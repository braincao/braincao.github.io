<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>左神刷题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="123456789title: 左神刷题date: 2018-09-21 17:32:47categories: 算法刷题tags:    - 左神刷题source: mac mdimg source: csdn——如果有图的话就在csdn上编辑，再同步至mac上update date: 2020-02-15 15:22:16  此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetco">
<meta property="og:type" content="article">
<meta property="og:title" content="左神刷题">
<meta property="og:url" content="https://braincao.gitee.io/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="123456789title: 左神刷题date: 2018-09-21 17:32:47categories: 算法刷题tags:    - 左神刷题source: mac mdimg source: csdn——如果有图的话就在csdn上编辑，再同步至mac上update date: 2020-02-15 15:22:16  此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetco">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200215151042325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200215151327162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2020021515145692.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20200215151658115.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70">
<meta property="article:published_time" content="2020-02-15T05:16:31.775Z">
<meta property="article:modified_time" content="2020-02-15T07:22:40.992Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20200215151042325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70">
  
    <link rel="alternate" href="/hexoblog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/hexoblog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexoblog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexoblog/">Home</a>
        
          <a class="main-nav-link" href="/hexoblog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/hexoblog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://braincao.gitee.io/hexoblog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-左神刷题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/" class="article-date">
  <time datetime="2020-02-15T05:16:31.775Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      左神刷题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: 左神刷题</span><br><span class="line">date: 2018-09-21 17:32:47</span><br><span class="line">categories: 算法刷题</span><br><span class="line">tags:</span><br><span class="line">    - 左神刷题</span><br><span class="line"></span><br><span class="line">source: mac md</span><br><span class="line">img source: csdn——如果有图的话就在csdn上编辑，再同步至mac上</span><br><span class="line">update date: 2020-02-15 15:22:16</span><br></pre></td></tr></table></figure>

<p>此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetcode题目，尽量都留存了最优解，部分简单的题目没有进行总结。</p>
<a id="more"></a>

<h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">题目</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="#1">按照左右半区的方式重新组合单链表</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="#2">用递归函数和栈操作逆序栈</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="#3">猫狗队列</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="#4">用一个栈来实现另一个栈的排序</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="#5">汉诺塔问题</a></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a href="#6">构造数组的MaxTree</a></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="#7">最大子矩阵(直方图-栈)</a></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a href="#8">找两个排序数组的中位数</a></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="#9">删除链表中的节点(两道)</a></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="#10">找到/删除链表的中间节点(两道)</a></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="#11">删除链表a/b处的节点</a></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a href="#12">判断一个链表是否为回文结构</a></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="#13">将单链表按某值划分成左边小，中间相等，右边大</a></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="#14">单链表的归并排序</a></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="#15">单链表的快速排序</a></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="#16">单链表的选择排序</a></td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="#17">两个链表生成相加链表</a></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="#18">删除单链表的重复节点(三道)</a></td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="#19">向有序的环形单链表中插入新节点</a></td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="#20">打印二叉树的边界节点</a></td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="#21">编辑距离</a></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="#22">找出数组中左边比他小右边比他大的所有元素</a></td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="#23">判断二叉树为BST(二叉搜索树)</a></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="#24">Replace Words(字典树应用)</a></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="#25">BFS/DFS思想</a></td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="#26">BFS相关题目(1道)</a></td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="#27">DFS相关题目(4道)</a></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="#28">图的几种最短路算法(4道)</a></td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="#29">Word Ladder(2道)(SPFA最短路算法应用)</a></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="#30">字符串匹配(kmp算法)</a></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="#31">两数相除(转为减法)</a></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="#32">sqrt(x)</a></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="#33">乱序的数组中找到最长的递增子序列</a></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="#34">蓄水池问题</a></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="#35">满足指定sum条件的长度最小的子数组</a></td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="#36">最大值减去最小值小于或等于num的子数组数量</a></td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="#37">几道未整理的</a></td>
</tr>
</tbody></table>
<h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p>
<h2 id="1-按照左右半区的方式重新组合单链表"><a href="#1-按照左右半区的方式重新组合单链表" class="headerlink" title="1.按照左右半区的方式重新组合单链表"></a>1.按照左右半区的方式重新组合单链表</h2><p>《左神》86、牛客网有编程挑战题</p>
<p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 </span><br><span class="line">1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p>
<p>思路：遍历两遍链表，先找到左半区的最后一个节点，再左右半区重新拼接链表。时间O(N)，空间O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">relocateList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span> || head.next.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//哨兵</span></span><br><span class="line">    guard.next = head;</span><br><span class="line">    ListNode left = guard.next;<span class="comment">//左半区</span></span><br><span class="line">    ListNode right;<span class="comment">//左半区的最后一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.遍历一遍链表，找到左半区的最后一个节点</span></span><br><span class="line">    ListNode fast = guard;</span><br><span class="line">    ListNode low = guard;</span><br><span class="line">    <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;<span class="comment">//fast走两步，low走一步</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        low = low.next;</span><br><span class="line">    &#125;</span><br><span class="line">    right = low;<span class="comment">//找到了左半区的最后一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.再左右半区重新拼接链表</span></span><br><span class="line">    ListNode rightCopy = right;<span class="comment">//缓存左半区的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(left!=rightCopy)&#123;</span><br><span class="line">        <span class="comment">//1.剥离当前节点</span></span><br><span class="line">        ListNode temp = right.next;</span><br><span class="line">        right.next = temp.next;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.拼接左右半区节点</span></span><br><span class="line">        temp.next = left.next;</span><br><span class="line">        left.next = temp;</span><br><span class="line">        left = left.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="2"></a></p>
<h2 id="2-用递归函数和栈操作逆序栈"><a href="#2-用递归函数和栈操作逆序栈" class="headerlink" title="2.用递归函数和栈操作逆序栈"></a>2.用递归函数和栈操作逆序栈</h2><p>《左神》8</p>
<p>题目：一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函数来实现，而不能用另外的数据结构。</p>
<p>思路：两个递归函数搞定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">//用递归函数和栈操作逆序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//逆序栈元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseStackRecursively</span><span class="params">(Stack&lt;Integer&gt; stack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> bottom = getAndDelBottom(stack);</span><br><span class="line">        reverseStackRecursively(stack);</span><br><span class="line">        stack.push(bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除并返回栈底元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndDelBottom</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curData = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> curData;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> last = getAndDelBottom(stack);</span><br><span class="line">            stack.push(curData);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="3"></a></p>
<h2 id="3-猫狗队列"><a href="#3-猫狗队列" class="headerlink" title="3.猫狗队列"></a>3.猫狗队列</h2><p>《左神》10</p>
<p>题目：实现一种狗猫队列的结构，要求如下：</p>
<p>（1）用户可以调用add方法将cat类或dog类的实例放入队列中；</p>
<p>（2）用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出；</p>
<p>（3）用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出；</p>
<p>（4）用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出；</p>
<p>（5）用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例；</p>
<p>（6）用户可以调用isDogEmpty方法，检查队列中是否还有dog类的实例；</p>
<p>（7）用户可以调用isCatEmpty方法，检查队列中是否还有cat类的实例。</p>
<p>思路：新定义带时间戳的Pet类(PetEnterQue)，然后用两个队列(dogQue\catQue)结合时间戳来定义新类(dogCatQue)，猫狗队列就是这个类的一个实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 猫狗队列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPetType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"dog"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"cat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//新定义一个带时间戳的Pet类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PetEnterQue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count; <span class="comment">//时间戳</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PetEnterQue</span><span class="params">(Pet pet, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pet = pet;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pet;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//这个类的实例就是一个猫狗队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dogCatQue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQue&gt; dogQue;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PetEnterQue&gt; catQue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">dogCatQue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dogQue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        catQue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Pet pet)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pet.getPetType().equals(<span class="string">"dog"</span>))&#123;</span><br><span class="line">            dogQue.offer(<span class="keyword">new</span> PetEnterQue(pet, count++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            catQue.offer(<span class="keyword">new</span> PetEnterQue(pet, count++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollDog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dogQue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dogQue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollCat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(catQue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> catQue.poll().getPet();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">pollAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dogQue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!catQue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> catQue.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(catQue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dogQue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> dogQue.poll().getPet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//比较时间戳，将早进队列的Pet出队</span></span><br><span class="line">            <span class="keyword">return</span> dogQue.peek().getCount()&gt;catQue.peek().getCount()? catQue.poll().getPet() :dogQue.poll().getPet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQue.isEmpty() &amp;&amp; catQue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDogEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dogQue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCatEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catQue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="4"></a></p>
<h2 id="4-用一个栈来实现另一个栈的排序"><a href="#4-用一个栈来实现另一个栈的排序" class="headerlink" title="4.用一个栈来实现另一个栈的排序"></a>4.用一个栈来实现另一个栈的排序</h2><p>《左神》13</p>
<p>题目：在一个栈中元素的类型为整型，现在想将该栈从栈顶到栈底按从大到小的顺序排序，只许申请一个栈，除此之外，可以申请其他变量，但是不能申请额外的数据结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个栈来实现另一个栈的排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortStackByStack</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; help = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = stack.pop();</span><br><span class="line">        <span class="keyword">while</span>(!help.isEmpty() &amp;&amp; temp&gt;help.peek())&#123;</span><br><span class="line">            stack.push(help.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        help.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!help.isEmpty())&#123;</span><br><span class="line">        stack.push(help.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(<span class="number">4</span>);</span><br><span class="line">    stack.push(<span class="number">3</span>);</span><br><span class="line">    stack.push(<span class="number">76</span>);</span><br><span class="line">    stack.push(<span class="number">5</span>);</span><br><span class="line">    stack.push(<span class="number">8</span>);</span><br><span class="line">    stack.push(<span class="number">9</span>);</span><br><span class="line">    System.out.println(stack);</span><br><span class="line">    sortStackByStack(stack);</span><br><span class="line">    System.out.println(stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="5"></a></p>
<h2 id="5-汉诺塔问题-两道"><a href="#5-汉诺塔问题-两道" class="headerlink" title="5.汉诺塔问题(两道)"></a>5.汉诺塔问题(两道)</h2><h3 id="1-正常汉诺塔：可以直接从左移到右，不需经过中间"><a href="#1-正常汉诺塔：可以直接从左移到右，不需经过中间" class="headerlink" title="1.正常汉诺塔：可以直接从左移到右，不需经过中间"></a>1.正常汉诺塔：可以直接从左移到右，不需经过中间</h3><p><strong>法一递归(常用这个)：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//汉诺塔tower of hanoi问题。法一:递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">towerOfHanoi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    move(<span class="string">"left"</span>, <span class="string">"right"</span>, <span class="string">"mid"</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(String start, String end, String buffer, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"from "</span> + start + <span class="string">" to "</span> + end);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    move(start, buffer, end, n-<span class="number">1</span>); <span class="comment">//将1-n-1移动到buffer，即缓冲区</span></span><br><span class="line">    System.out.println(<span class="string">"from "</span> + start + <span class="string">" to "</span> + end); <span class="comment">//将n移动到目标柱子上</span></span><br><span class="line">    move(buffer, end, start, n-<span class="number">1</span>); <span class="comment">// 将1-n-1移动到目标柱子上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    towerOfHanoi(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//out:</span></span><br><span class="line">    <span class="comment">//from left to right</span></span><br><span class="line">    <span class="comment">//from left to mid</span></span><br><span class="line">    <span class="comment">//from right to mid</span></span><br><span class="line">    <span class="comment">//from left to right</span></span><br><span class="line">    <span class="comment">//from mid to left</span></span><br><span class="line">    <span class="comment">//from mid to right</span></span><br><span class="line">    <span class="comment">//from left to right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二用栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiStack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack hanoi = <span class="keyword">new</span> Stack();</span><br><span class="line">        hanoi.push(<span class="keyword">new</span> Problem(<span class="number">4</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>));</span><br><span class="line">        Problem myProblem = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!hanoi.isEmpty() &amp;&amp; (myProblem = (Problem) hanoi.pop()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myProblem.n == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(myProblem.A+<span class="string">"-&gt;"</span>+myProblem.C);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hanoi.push(<span class="keyword">new</span> Problem(myProblem.n-<span class="number">1</span>, myProblem.B, myProblem.A, myProblem.C));</span><br><span class="line">                hanoi.push(<span class="keyword">new</span> Problem(<span class="number">1</span>, myProblem.A, myProblem.B, myProblem.C));</span><br><span class="line">                hanoi.push(<span class="keyword">new</span> Problem(myProblem.n-<span class="number">1</span>, myProblem.A, myProblem.C, myProblem.B));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> A, B, C;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Problem</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.A = A;</span><br><span class="line">        <span class="keyword">this</span>.B = B;</span><br><span class="line">        <span class="keyword">this</span>.C = C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-特殊汉诺塔：不可以直接从左移到右，必须经过中间"><a href="#2-特殊汉诺塔：不可以直接从左移到右，必须经过中间" class="headerlink" title="2.特殊汉诺塔：不可以直接从左移到右，必须经过中间"></a>2.特殊汉诺塔：不可以直接从左移到右，必须经过中间</h3><p>《左神》14</p>
<p>法一递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：递归。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hanoiProblem1</span><span class="params">(<span class="keyword">int</span> num, String left, String mid, String right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> process(num, left, mid, right, left, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> num, String left, String mid, String right, String from, String to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(from.equals(mid) || to.equals(mid))&#123;</span><br><span class="line">            System.out.println(<span class="string">"move 1 from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"move 1 from "</span> + from + <span class="string">" to mid"</span>);</span><br><span class="line">            System.out.println(<span class="string">"move 1 from mid to "</span> + to);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(from.equals(mid) || to.equals(mid))&#123;</span><br><span class="line">            String another = (from.equals(left)||to.equals(left))? right : left;</span><br><span class="line">            <span class="keyword">int</span> step1 = process(num-<span class="number">1</span>, left, mid, right, from, another);</span><br><span class="line">            System.out.println(<span class="string">"move "</span> + num + <span class="string">" from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">            <span class="keyword">int</span> step2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> step3 = process(num-<span class="number">1</span>, left, mid, right, another, to);</span><br><span class="line">            <span class="keyword">return</span> step1 + step2 + step3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> step1 = process(num-<span class="number">1</span>, left, mid, right, from, to);</span><br><span class="line">            <span class="keyword">int</span> step2 = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"move "</span> + num + <span class="string">" from "</span> + from + <span class="string">" to mid"</span>);</span><br><span class="line">            <span class="keyword">int</span> step3 = process(num-<span class="number">1</span>, left, mid, right, to, from);</span><br><span class="line">            <span class="keyword">int</span> step4 = <span class="number">1</span>;</span><br><span class="line">            System.out.println(<span class="string">"move "</span> + num + <span class="string">" from mid to "</span> + to);</span><br><span class="line">            <span class="keyword">int</span> step5 = process(num-<span class="number">1</span>, left, mid, right, from, to);</span><br><span class="line">            <span class="keyword">return</span> step1 + step2 + step3 + step4 + step5;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：栈。</p>
<p>非递归的方法核心思想：</p>
<p>1.由于必须经过中间，把三个柱子想成三个栈，每次操作栈顶的一个元素，只有四个动作L-&gt;M、M-&gt;L、M-&gt;R、R-&gt;M</p>
<p>2.最优步骤时，每次四个动作只有一个动作能同时满足3、4两个原则，因为满足3、4时直接进行该步骤即可，直到最终第三个栈元素都移过去结束</p>
<p>3.每次移动元素时，栈顶元素小压大</p>
<p>4.每次移动元素时，与上一次移动操作不可互逆(那就是重复无意义的操作)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">enum</span> Action&#123;</span><br><span class="line">    No, LToM, MToL, RToM, MToR</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span></span>&#123;</span><br><span class="line">    <span class="comment">//法二：栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hanoiProblem2</span><span class="params">(<span class="keyword">int</span> num, String left, String mid, String right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; ls = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; ms = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; rs = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ls.push(Integer.MAX_VALUE);</span><br><span class="line">        ms.push(Integer.MAX_VALUE);</span><br><span class="line">        rs.push(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=num; i&gt;=<span class="number">1</span>; i--)&#123;</span><br><span class="line">            ls.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        Action[] record = &#123;Action.No&#125;;<span class="comment">//record[0]存储上一次操作</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rs.size()!=num+<span class="number">1</span>)&#123;</span><br><span class="line">            res += fstack_To_tStack(record, Action.LToM, Action.MToL, ls, ms, left, mid);</span><br><span class="line">            res += fstack_To_tStack(record, Action.MToL, Action.LToM, ms, ls, mid, left);</span><br><span class="line">            res += fstack_To_tStack(record, Action.RToM, Action.MToR, rs, ms, right, mid);</span><br><span class="line">            res += fstack_To_tStack(record, Action.MToR, Action.RToM, ms, rs, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fstack_To_tStack</span><span class="params">(Action[] record, Action nowAct, Action nowActReverse, Stack&lt;Integer&gt;fstack, Stack&lt;Integer&gt;tstack, String from, String to)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(record[<span class="number">0</span>]!=nowActReverse &amp;&amp; fstack.peek()&lt;tstack.peek())&#123;<span class="comment">//和上次操作不互逆 且 栈顶满足小压大，即为当前应该走的一步</span></span><br><span class="line">            tstack.push(fstack.pop());</span><br><span class="line">            System.out.println(<span class="string">"move "</span> + tstack.peek() + <span class="string">" from "</span> + from + <span class="string">" to "</span> + to);</span><br><span class="line">            record[<span class="number">0</span>] = nowAct;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(hanoiProblem1(2,"left", "mid", "right"));//法一:递归</span></span><br><span class="line">        System.out.println(hanoiProblem2(<span class="number">2</span>,<span class="string">"left"</span>, <span class="string">"mid"</span>, <span class="string">"right"</span>));<span class="comment">//法二:栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="6"></a></p>
<h2 id="6-构造数组的MaxTree"><a href="#6-构造数组的MaxTree" class="headerlink" title="6.构造数组的MaxTree"></a>6.构造数组的MaxTree</h2><p>leetcode 654、《左神》22</p>
<p>题目：对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree。MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。</p>
<p>思路：现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。</p>
<p>核心转化为了怎么找到左边/右边第一个比它大的数呢？用栈，递减序列即可。</p>
<p>以找每个数左边第一个比他大的数为例，从左到右遍历每个数，栈中保持递减序列，新来的数不停的Pop出栈顶直到栈顶比新数大或没有数。以[3,1,2]为例，首先3入栈，接下来1比3小，无需pop出3，1入栈，并且确定了1往左第一个比他大的数为3。接下来2比1大，1出栈，2比3小，2入栈。并且确定了2往左第一个比他大的数为3。用同样的方法可以求得每个数往右第一个比他大的数。时间复杂度O(n)，空间复杂度也是O(n)为最优解法。</p>
<p><strong>本题最巧妙的一点是如何找某数的左边最近的比它大的值和右边最近的比它大的值。取左右两边的较小的数作为该数的父节点。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造数组的MaxTree。核心:如何找某数的左边最近的比它大的值和右边最近的比它大的值(辅助栈和数组)。取左右两边的较小的数作为该数的父节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">makeMaxTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(arr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] lmax = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//存储找出某数的左边最近的比它大的值的索引</span></span><br><span class="line">        <span class="keyword">int</span>[] rmax = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//存储找出某数的右边最近的比它大的值的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i)&#123;<span class="comment">//从左往右遍历，找出某数的左边最近的比它大的值。栈递减序列</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            lmax[i] = !stack.isEmpty() ? stack.peek() : -<span class="number">1</span>;<span class="comment">//左边最近的比它大的值，如果左边没有比它大的，则为-1</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();<span class="comment">//清空栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;<span class="comment">//从右往左遍历，找出某数的右边最近的比它大的值。栈递减序列</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            rmax[i] = !stack.isEmpty() ? stack.peek() : -<span class="number">1</span>;<span class="comment">//左边最近的比它大的值，如果左边没有比它大的，则为-1</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个数组(左边首个最大、右边首个最大)存储好了，取较小的节点作为父节点，开始构建maxTree</span></span><br><span class="line">        Node[] nodes = <span class="keyword">new</span> Node[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodes.length; ++i)&#123;</span><br><span class="line">            nodes[i] = <span class="keyword">new</span> Node(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lmax[i]==-<span class="number">1</span> &amp;&amp; rmax[i]==-<span class="number">1</span>)&#123;</span><br><span class="line">                head = nodes[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(lmax[i]==-<span class="number">1</span> &amp;&amp; rmax[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[rmax[i]].left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes[rmax[i]].left = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nodes[rmax[i]].right = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rmax[i]==-<span class="number">1</span> &amp;&amp; lmax[i]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[lmax[i]].right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes[lmax[i]].right = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nodes[lmax[i]].left = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[lmax[i]]&lt;arr[rmax[i]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[lmax[i]].right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes[lmax[i]].right = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nodes[lmax[i]].left = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[lmax[i]]&gt;arr[rmax[i]])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[rmax[i]].left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    nodes[rmax[i]].left = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    nodes[rmax[i]].right = nodes[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        System.out.println(makeMaxTree(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="7"></a></p>
<h2 id="7-最大子矩阵-2道-直方图-单调栈"><a href="#7-最大子矩阵-2道-直方图-单调栈" class="headerlink" title="7.最大子矩阵(2道)(直方图-单调栈)"></a>7.最大子矩阵(2道)(直方图-单调栈)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Largest Rectangle in Histogram(直方图面积)--leetcode 84</span><br><span class="line">2.Maximal Rectangle(最大子矩阵大小)--leetcode85、《左神》26</span><br></pre></td></tr></table></figure>

<h3 id="1-Largest-Rectangle-in-Histogram-直方图面积"><a href="#1-Largest-Rectangle-in-Histogram-直方图面积" class="headerlink" title="1.Largest Rectangle in Histogram(直方图面积)"></a>1.Largest Rectangle in Histogram(直方图面积)</h3><p>leetcode 84</p>
<p>题目：Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. out: 10</p>
<p>思路：<strong>辅助单调栈，递增存储</strong>。遍历原直方图数组，递增往栈里存储，如果遇到比栈顶小的元素时，循环栈顶弹出并计算resMax，直到继续递增存储。时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heights==<span class="keyword">null</span> || heights.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(heights.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断</span></span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()])&#123;<span class="comment">//每次遇到比栈顶小的元素时，对栈进行判断</span></span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            resMax = Math.max(resMax, (i-k-<span class="number">1</span>)*heights[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);<span class="comment">//递增存储</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;<span class="comment">//考虑[1,2,3]的情况，栈一直递增存储，最后必须要清空栈</span></span><br><span class="line">        <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">        resMax = Math.max(resMax, (heights.length-k-<span class="number">1</span>)*heights[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Maximal-Rectangle-最大子矩阵大小"><a href="#2-Maximal-Rectangle-最大子矩阵大小" class="headerlink" title="2.Maximal Rectangle(最大子矩阵大小)"></a>2.Maximal Rectangle(最大子矩阵大小)</h3><p>leetcode85、《左神》26</p>
<p>题目：Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line">Return 6.</span><br></pre></td></tr></table></figure>
<p>思路：一行一行进行，对矩阵每一行为底的直方图数组求解直方图最大面积，直方图最大面积：用单调递增栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//以矩阵每一行为底的直方图数组，最后一个元素temp[n]要为0，便于求解直方图面积</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;<span class="comment">//一行一行处理直方图的最大面积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;<span class="comment">//每一行先更新直方图</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                temp[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, largeArea(temp)); <span class="comment">//直方图最大面积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求一行的直方图最大面积--单调递增栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largeArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heights.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断</span></span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;heights.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()])&#123;<span class="comment">//每次遇到比栈顶小的元素时，对栈进行判断</span></span><br><span class="line">            <span class="keyword">int</span> j = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> k = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            resMax = Math.max(resMax, (i-k-<span class="number">1</span>)*heights[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);<span class="comment">//递增存储</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="8"></a></p>
<h2 id="8-找两个排序数组的中位数"><a href="#8-找两个排序数组的中位数" class="headerlink" title="8.找两个排序数组的中位数"></a>8.找两个排序数组的中位数</h2><p>leetcode 4</p>
<p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Median of Two Sorted Arrays找两个排序数组的中位数。思路：二分法，核心是注意怎么二分和边界条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">    <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * (getKth(nums1,<span class="number">0</span>,n-<span class="number">1</span>,nums2,<span class="number">0</span>,m-<span class="number">1</span>,left) + getKth(nums1,<span class="number">0</span>,n-<span class="number">1</span>,nums2,<span class="number">0</span>,m-<span class="number">1</span>,right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)&#123;</span><br><span class="line">        <span class="keyword">return</span> getKth(nums2,start2,end2,nums1,start1,end1,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</span><br><span class="line">    <span class="keyword">int</span> s1 = Math.min(start1 + k/<span class="number">2</span> - <span class="number">1</span>, start1 + len1 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> s2 = Math.min(start2 + k/<span class="number">2</span> - <span class="number">1</span>, start2 + len2 - <span class="number">1</span>);<span class="comment">//两个数组的k/2位置上的数，如果数组长度小于k/2，直接比len-1上的数</span></span><br><span class="line">    <span class="keyword">if</span>(nums1[s1] &lt; nums2[s2])&#123;<span class="comment">//nums1数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2</span></span><br><span class="line">        <span class="keyword">return</span> getKth(nums1,s1+<span class="number">1</span>,end1,nums2,start2,end2,k-Math.min(k/<span class="number">2</span>,len1));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//nums2数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2</span></span><br><span class="line">        <span class="keyword">return</span> getKth(nums1,start1,end1,nums2,s2+<span class="number">1</span>,end2,k-Math.min(k/<span class="number">2</span>,len2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="9"></a></p>
<h2 id="9-删除链表中的节点-两道"><a href="#9-删除链表中的节点-两道" class="headerlink" title="9. 删除链表中的节点(两道)"></a>9. 删除链表中的节点(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.删除某个链表中指定的（非末尾）节点--leetcode237、《左神》83</span><br><span class="line">2.删除链表中等于给定值 val 的所有节点--leetcode203</span><br></pre></td></tr></table></figure>

<h3 id="1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"><a href="#1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。" class="headerlink" title="1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"></a>1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。</h3><p>leetcode237、《左神》83</p>
<p>思路：后一个节点的val覆盖当前节点，删除后一个节点即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-删除链表中等于给定值-val-的所有节点"><a href="#2-删除链表中等于给定值-val-的所有节点" class="headerlink" title="2.删除链表中等于给定值 val 的所有节点"></a>2.删除链表中等于给定值 val 的所有节点</h3><p>leetcode203、《左神》73</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>思路：遍历链表删除即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode resHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//哨兵</span></span><br><span class="line">    resHead.next = head;</span><br><span class="line">    ListNode p = resHead;</span><br><span class="line">    ListNode cur = p.next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val==val)&#123;</span><br><span class="line">            p.next = cur.next;<span class="comment">//这种删除思想特别好</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> resHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="10"></a></p>
<h2 id="10-找到-删除链表的中间节点-两道"><a href="#10-找到-删除链表的中间节点-两道" class="headerlink" title="10.找到/删除链表的中间节点(两道)"></a>10.找到/删除链表的中间节点(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.找到链表的中间节点--leetcode 876</span><br><span class="line">2.删除链表的中间节点--《左神》38</span><br></pre></td></tr></table></figure>

<h3 id="1-找到链表的中间节点"><a href="#1-找到链表的中间节点" class="headerlink" title="1.找到链表的中间节点"></a>1.找到链表的中间节点</h3><p>leetcode 876</p>
<p>题目：Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3. </span><br><span class="line"></span><br><span class="line">[1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br></pre></td></tr></table></figure>

<p>思路：两个指快慢指针走即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode right = head;</span><br><span class="line">    ListNode left = head;</span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span> &amp;&amp; right.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right.next==<span class="keyword">null</span> ? left : left.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-删除链表的中间节点"><a href="#2-删除链表的中间节点" class="headerlink" title="2.删除链表的中间节点"></a>2.删除链表的中间节点</h3><p>《左神》38.</p>
<p>题目：删除一个链表的中间节点，当链表只有一个节点的时候或者head节点为空的时候返回head，当链表有两个节点的时候删除第一个节点，当链表有三个节点的时候删除第二个节点，当链表有四个节点的时候删除第二个节点，当链表有五个节点的时候删除第三个节点…</p>
<p>思路：一个链表长度每增加二，要删除的节点就后移一个节点，要删除一个节点需要知道它的前一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表中间节点。思路：两个快慢指针走即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeMidNode</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;<span class="comment">//空节点或只有一个节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head.next.next==<span class="keyword">null</span>)&#123;<span class="comment">//两个节点，删除第一个节点</span></span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode right = head.next.next;</span><br><span class="line">    ListNode left = head;<span class="comment">//要删除节点的上一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span> &amp;&amp; right.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    left.next = left.next.next;<span class="comment">//删除中间节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="11"></a></p>
<h2 id="11-删除链表a-b处的节点"><a href="#11-删除链表a-b处的节点" class="headerlink" title="11.删除链表a/b处的节点"></a>11.删除链表a/b处的节点</h2><p>《左神》38.</p>
<p>题目：给两个整数a，b(a&lt;=b)，实现删除链表a/b处节点的函数。若r=0，不删除；其他r的值向上取整，比如r在范围(2/5,3/5]中，取3，删除第三个节点。</p>
<p>思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表a/b处的节点。思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">removeByRatio</span><span class="params">(ListNode head, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span> || b==<span class="number">0</span> || a==b || head==<span class="keyword">null</span>)&#123;<span class="comment">//不删除任何节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.遍历链表，得其长度len</span></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.计算a/b处是第k个节点</span></span><br><span class="line">    <span class="keyword">int</span> k = (<span class="keyword">int</span>)Math.ceil( ((<span class="keyword">double</span>)a/b)*len );</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">0</span>)&#123;<span class="comment">//a/b为负数，不删除节点</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.删除第k个节点</span></span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    p = head;<span class="comment">//从头遍历</span></span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">2</span>)&#123;<span class="comment">//走到第k-1处</span></span><br><span class="line">        p = p.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = p.next.next;<span class="comment">//删除第k个节点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="12"></a></p>
<h2 id="12-判断一个链表是否为回文结构"><a href="#12-判断一个链表是否为回文结构" class="headerlink" title="12.判断一个链表是否为回文结构"></a>12.判断一个链表是否为回文结构</h2><p>《左神》48、leetcode234</p>
<p>题目：判断一个链表是否为回文链表(1\121\1221)，要求时间o(n)，空间o(1)</p>
<p>思路：由于要求时间o(n)，空间o(1)，感觉必须要动链表了。1.先找到中间节点，2.然后右半边逆序，3.然后分别从头部和中间开始比较元素是否相等即可。时间o(n)，空间o(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个链表是否为回文结构。思路：1.两个快慢指针先找到中间节点，2.然后右半边链表逆序，3.再从头遍历比较元素是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.两个快慢指针先找到中间节点</span></span><br><span class="line">    ListNode left = head;</span><br><span class="line">    ListNode right = head;</span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span> &amp;&amp; right.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.现将left后边的链表逆序</span></span><br><span class="line">    ListNode cur = left.next;</span><br><span class="line">    ListNode temp = cur;</span><br><span class="line">    cur = cur.next;</span><br><span class="line">    temp.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        temp.next = left.next;</span><br><span class="line">        left.next = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.从头遍历比较元素是否相等</span></span><br><span class="line">    right = left.next;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;<span class="comment">//遇到元素不等，不是回文结构，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    head.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    head.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    head.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    head.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    head.next.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    System.out.println(isPalindrome(head));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="13"></a></p>
<h2 id="13-将单向链表按某值划分成左边小，中间相等，右边大"><a href="#13-将单向链表按某值划分成左边小，中间相等，右边大" class="headerlink" title="13.将单向链表按某值划分成左边小，中间相等，右边大"></a>13.将单向链表按某值划分成左边小，中间相等，右边大</h2><p>《左神》52.</p>
<p>题目：给定一个单向链表的头结点head,节点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的节点，中间部分都是值等于privot的节点，右部分都是大于privot的节点。<br>例如:链表9-0-4-5-1，pivot=3。<br>调整后是1-0-4-9-5，也可以是0-1-9-5-4。 </p>
<p>思路：解法一：我们可以利用数组额外空间，利用数组partition排序来实现。时间o(n) 空间o(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​1. 先遍历一遍链表，得到链表长度。</span><br><span class="line">​2. 建立一个链表数组。</span><br><span class="line">​3. 利用三向快排的划分</span><br><span class="line">​4. 调整数组中的next值。</span><br></pre></td></tr></table></figure>

<p>解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可。时间o(n) 空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//解法一：我们可以利用数组额外空间来实现</span></span><br><span class="line">    <span class="comment">//时间o(n) 空间o(n)</span></span><br><span class="line">    <span class="comment">//1. 先遍历一遍链表，得到链表长度。</span></span><br><span class="line">    <span class="comment">//2. 建立一个链表数组。</span></span><br><span class="line">    <span class="comment">//3. 利用三向快排的划分</span></span><br><span class="line">    <span class="comment">//4. 调整数组中的next值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition1</span><span class="params">(Node head, <span class="keyword">int</span> privot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.遍历链表得到长度。</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.建立一个链表数组。</span></span><br><span class="line">        Node[] arr = <span class="keyword">new</span> Node[len];</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            arr[i] = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.数组partition排序</span></span><br><span class="line">        paitition(arr, <span class="number">0</span>, len-<span class="number">1</span>, privot);</span><br><span class="line">        <span class="comment">//4.重新连接数组的node</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">            arr[i].next = arr[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[len-<span class="number">1</span>].next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">paitition</span><span class="params">(Node[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> privot)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意的这里的partition保持了数组原来的顺序</span></span><br><span class="line">        <span class="keyword">int</span> small = left;</span><br><span class="line">        <span class="keyword">int</span> big = right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right&amp;&amp;i&lt;=big; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i].val&lt;privot)&#123;</span><br><span class="line">                swap(arr, i, small++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i].val&gt;privot)&#123;</span><br><span class="line">                swap(arr, i, big--);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(big&lt;right)&#123;</span><br><span class="line">            swap(arr, big++, right--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可</span></span><br><span class="line">    <span class="comment">//时间o(n) 空间o(1)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">listPartition2</span><span class="params">(Node head, <span class="keyword">int</span> privot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node small = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node smallCopy = small;</span><br><span class="line">        Node equal = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node equalCopy = equal;</span><br><span class="line">        Node big = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        Node bigCopy = big;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;<span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;privot)&#123;</span><br><span class="line">                Node temp = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">                small.next = temp;</span><br><span class="line">                small = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p.val == privot)&#123;</span><br><span class="line">                Node temp = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">                equal.next = temp;</span><br><span class="line">                equal = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Node temp = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                temp.next = <span class="keyword">null</span>;</span><br><span class="line">                big.next = temp;</span><br><span class="line">                big = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        small.next = equalCopy.next;</span><br><span class="line">        equal.next = bigCopy.next;</span><br><span class="line">        <span class="keyword">return</span> smallCopy.next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">        Node p = head;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        show(head);</span><br><span class="line"><span class="comment">//        head = listPartition1(head, 3);</span></span><br><span class="line">        head = listPartition2(head, <span class="number">3</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        show(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.print(head.val + <span class="string">" "</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Node temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out: 9 0 3 4 5 1 </span></span><br><span class="line">	   <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">9</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><a name="14"></a></p>
<h2 id="14-单链表的归并排序"><a href="#14-单链表的归并排序" class="headerlink" title="14.单链表的归并排序"></a>14.单链表的归并排序</h2><p>leetcode148</p>
<p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>思路：归并排序应该是单链表排序最好的方法了，时间o(nlogn)，空间o(1)。分而治之，先找到中间节点，拆分成两个链表，merge</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode left = head;</span><br><span class="line">    ListNode right = head;</span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span> &amp;&amp; right.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    right = left.next;</span><br><span class="line">    left.next = <span class="keyword">null</span>;<span class="comment">//将链表从中间节点拆分，分离成两个链表</span></span><br><span class="line">    left = sortList(head);</span><br><span class="line">    right = sortList(right);</span><br><span class="line">    <span class="keyword">return</span> merge(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = guard;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        p.next = temp;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(head.val + <span class="string">" "</span>);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    head.next = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    head.next.next = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    head.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    head.next.next.next.next = <span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">    show(head);</span><br><span class="line">    show(sortList(head));</span><br><span class="line">    <span class="comment">//out:1 2 5 4 7</span></span><br><span class="line">    <span class="comment">//    1 2 4 5 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="15"></a></p>
<h2 id="15-单链表的快速排序"><a href="#15-单链表的快速排序" class="headerlink" title="15.单链表的快速排序"></a>15.单链表的快速排序</h2><p>leetcode148</p>
<p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>

<p>思路：partition思想，用三个指针来控制，pBase指针指向枢纽值结点，pleft指针指向当前最后一个比枢纽值小的结点，pright结点用于遍历，将遇到的比pBase小的结点的值交换到前面去。<br>​<br><img src="https://img-blog.csdnimg.cn/20200215151042325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="ListquickSort"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的快排</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    <span class="keyword">while</span>(tail.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    quickSortList(head, tail);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSortList</span><span class="params">(ListNode head, ListNode tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==tail || head==<span class="keyword">null</span> || tail==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode pBase = head; <span class="comment">//基准key节点</span></span><br><span class="line">    ListNode pSmall = head; <span class="comment">//此节点之前的节点都是比pBase小的</span></span><br><span class="line">    ListNode cur = head.next; <span class="comment">//遍历节点</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=tail.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val&lt;pBase.val)&#123;</span><br><span class="line">            pSmall = pSmall.next;</span><br><span class="line">            swap(pSmall, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(pBase, pSmall);</span><br><span class="line">    quickSortList(head, pSmall);</span><br><span class="line">    quickSortList(pSmall.next, tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode a, ListNode b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a.val;</span><br><span class="line">    a.val = b.val;</span><br><span class="line">    b.val = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="16"></a></p>
<h2 id="16-单链表的选择排序"><a href="#16-单链表的选择排序" class="headerlink" title="16.单链表的选择排序"></a>16.单链表的选择排序</h2><p>《左神》79、和88题(单链表快排)一起看</p>
<p>题目：单链表的选择排序</p>
<p>思想：时间o(n^2)，空间o(1)，正常的选择排序思想，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，接入到排序好的链表部分，这里注意节点的断开与接入的指针变量操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的选择排序。时间o(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">selectSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode resHeadCopy = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//哨兵，最终返回resHeadCopy.next</span></span><br><span class="line">    ListNode resHead = resHeadCopy; <span class="comment">//存储排序链表的最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(head.next!=<span class="keyword">null</span>)&#123;<span class="comment">//选择排序，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，连接到resHead后</span></span><br><span class="line">        ListNode minTemp = head;</span><br><span class="line">        ListNode minPre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head.next;<span class="comment">//遍历剩下链表</span></span><br><span class="line">        ListNode curPre = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;<span class="comment">//每次都从剩下链表头结点遍历，找剩下链表中最小节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur.val&lt;minTemp.val)&#123;</span><br><span class="line">                minTemp = cur;</span><br><span class="line">                minPre = curPre;</span><br><span class="line">            &#125;</span><br><span class="line">            curPre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = minTemp;<span class="comment">//这是找到的min节点</span></span><br><span class="line">        <span class="keyword">if</span>(temp==head)&#123;<span class="comment">//如果min节点是头结点</span></span><br><span class="line">            head = head.next;<span class="comment">//断开min节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            minPre.next = minPre.next.next; <span class="comment">//断开min节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;<span class="comment">//断开min节点</span></span><br><span class="line">        resHead.next = temp;<span class="comment">//min节点连入排序链表尾</span></span><br><span class="line">        resHead = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    resHead.next = head; <span class="comment">//链表剩下最后一个节点接入</span></span><br><span class="line">    <span class="keyword">return</span> resHeadCopy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="17"></a></p>
<h2 id="17-两个链表生成相加链表"><a href="#17-两个链表生成相加链表" class="headerlink" title="17.两个链表生成相加链表"></a>17.两个链表生成相加链表</h2><p>《左神》59、leetcode 2</p>
<p>题目：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<p>思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位，注意如果最后还有进位，别忘了再生成一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个链表生成相加链表。思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = guard;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">int</span> sum;<span class="comment">//每两个节点的和</span></span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span> &amp;&amp; l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum = l1.val + l2.val + cnt;</span><br><span class="line">        cnt = sum/<span class="number">10</span>;</span><br><span class="line">        p.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum = l1.val + cnt;</span><br><span class="line">        cnt = sum/<span class="number">10</span>;</span><br><span class="line">        p.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum = l2.val + cnt;</span><br><span class="line">        cnt = sum/<span class="number">10</span>;</span><br><span class="line">        p.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">        p = p.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt!=<span class="number">0</span>)&#123;<span class="comment">//如果还有进位，则再创建一个节点</span></span><br><span class="line">        p.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="18"></a></p>
<h2 id="18-删除单链表的重复节点-三道"><a href="#18-删除单链表的重复节点-三道" class="headerlink" title="18.删除单链表的重复节点(三道)"></a>18.删除单链表的重复节点(三道)</h2><h3 id="1-链表有序，保留一个"><a href="#1-链表有序，保留一个" class="headerlink" title="1.链表有序，保留一个"></a>1.链表有序，保留一个</h3><p>leetcode 83</p>
<p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<p>思路：时间o(n)，空间o(1)，遍历删除即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode cur = head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.val==cur.val)&#123;</span><br><span class="line">            p.next = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            p = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-链表有序，不保留"><a href="#2-链表有序，不保留" class="headerlink" title="2.链表有序，不保留"></a>2.链表有序，不保留</h2><p>leetcode 82</p>
<p>题目：Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>

<p>思路：定义一个哨兵，定义一个前驱指针和一个现指针，每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//哨兵</span></span><br><span class="line">    guard.next = head;</span><br><span class="line">    </span><br><span class="line">    ListNode pre = guard;<span class="comment">//前驱指针</span></span><br><span class="line">    ListNode cur = guard.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.next.val==cur.val)&#123;<span class="comment">//有重复，要准备删除了</span></span><br><span class="line">            <span class="keyword">int</span> temp = cur.val;<span class="comment">//缓存要删除的val</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; cur.val==temp)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-链表无序"><a href="#3-链表无序" class="headerlink" title="3.链表无序"></a>3.链表无序</h3><p>《左神》71</p>
<p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<p>思路：哈希set。时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteDuplicate</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//哈希表</span></span><br><span class="line">    ListNode p = head;</span><br><span class="line">    ListNode cur = head.next;</span><br><span class="line">    set.add(p.val);</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(cur.val))&#123;</span><br><span class="line">            p.next = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            set.add(cur.val);</span><br><span class="line">            p = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="19"></a></p>
<h2 id="19-向有序的环形单链表中插入新节点"><a href="#19-向有序的环形单链表中插入新节点" class="headerlink" title="19.向有序的环形单链表中插入新节点"></a>19.向有序的环形单链表中插入新节点</h2><p>《左神》82</p>
<p>题目：一个环形单链表从头节点 head 开始不降序，同时由最后的节点指回头节点。给定这样的一个环形单链表的头节点 head 和 一个整数 num ，请生成节点值为 num 的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p>
<p>思路：直接从头结点遍历插入即可，时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环形有序链表中插入新节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">insertNum</span><span class="params">(ListNode head, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    ListNode newNode = <span class="keyword">new</span> ListNode(num);</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        newNode.next = newNode;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= head.val)&#123;<span class="comment">//如果要插入到头结点之前</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next!=head)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        newNode.next = head;</span><br><span class="line">        cur.next = newNode;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val&gt;=num)&#123;</span><br><span class="line">                newNode.next = cur.next;</span><br><span class="line">                cur.next = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="20"></a></p>
<h2 id="20-打印二叉树的边界节点"><a href="#20-打印二叉树的边界节点" class="headerlink" title="20.打印二叉树的边界节点"></a>20.打印二叉树的边界节点</h2><p>《左神》95、 leetcode545(会员)</p>
<p>题目：给定一颗二叉树的头结点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.头节点为边界节点</span><br><span class="line">2.叶结点为边界节点</span><br><span class="line">3.如果节点在其所在的层中是最左边或最右边，那么也是边界节点</span><br></pre></td></tr></table></figure>

<p><a name="21"></a></p>
<h2 id="21-编辑距离"><a href="#21-编辑距离" class="headerlink" title="21.编辑距离"></a>21.编辑距离</h2><p>leetcode 72</p>
<p>题目：Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Insert a character</span><br><span class="line">Delete a character</span><br><span class="line">Replace a characte</span><br></pre></td></tr></table></figure>

<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (remove &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (remove &#39;e&#39;)</span><br><span class="line">	</span><br><span class="line">Input: word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">intention -&gt; inention (remove &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (insert &#39;u&#39;)</span><br></pre></td></tr></table></figure>

<p>思路：DP问题。维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。</p>
<p>转移方程：当word1[i]==word2[j]时，dp[i][j] = dp[i-1][j-1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if word1[i-1]&#x3D;&#x3D;word2[j-1]：</span><br><span class="line">	dp[i][j] &#x3D; dp[i - 1][j - 1]</span><br><span class="line">else: </span><br><span class="line">	dp[i][j] &#x3D; min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 &#x2F;&#x2F;替换、删除、插入</span><br></pre></td></tr></table></figure>

<p>代码：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(word1==<span class="keyword">null</span> || word2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> len2 = word2.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len2; ++i)&#123;<span class="comment">//第一行</span></span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=len1; ++i)&#123;<span class="comment">//第一列</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len1; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len2; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>) == word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = Math.min(a,b);</span><br><span class="line">    <span class="keyword">return</span> Math.min(temp,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="22"></a></p>
<h2 id="22-找出数组中左边比他小右边比他大的所有元素"><a href="#22-找出数组中左边比他小右边比他大的所有元素" class="headerlink" title="22.找出数组中左边比他小右边比他大的所有元素"></a>22.找出数组中左边比他小右边比他大的所有元素</h2><p>题目：给定一个不重复的数组，找出所有符合条件的元素：该元素左边都比它小，右边都比它大。e.g. [1,2,3,4,5]–&gt;out:[1,2,3,4,5]所有元素都满足。时间要求o(n)</p>
<p>思路：<strong>辅助一个o(n)数组temp[]，遍历两次数组即可</strong>。第一次从后往前记录temp[]，temp[i]表示从结尾到i时最小的数，第二次遍历从前往后，tempMax存从头到i时最大的数，如果nums[i]比tempMax大且比temp[i]小则nums[i]符合条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出数组中左边比他小右边比他大的所有元素。思路：辅助o(n)的temp[]，遍历两遍数组即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">findEleBigLeftSmallRight</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;<span class="comment">//只有一个节点时直接返回该节点，无需比较</span></span><br><span class="line">        res.add(numbers[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.从后往前遍历，存最小的数</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//辅助数组</span></span><br><span class="line">    temp[len-<span class="number">1</span>] = numbers[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        temp[i] = numbers[i]&lt;temp[i+<span class="number">1</span>] ? numbers[i] : temp[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从前往后遍历，找符合条件的数</span></span><br><span class="line">    <span class="keyword">int</span> tempMax = Integer.MIN_VALUE;<span class="comment">//存最大的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i]&gt;tempMax &amp;&amp; numbers[i]&lt;temp[i+<span class="number">1</span>])&#123;</span><br><span class="line">            res.add(numbers[i]);<span class="comment">//符合条件</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i]&gt;tempMax)&#123;</span><br><span class="line">            tempMax = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numbers[len-<span class="number">1</span>]&gt;tempMax)&#123;<span class="comment">//最后一个数</span></span><br><span class="line">        res.add(numbers[len-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="23"></a></p>
<h2 id="23-判断二叉树为BST-二叉搜索树"><a href="#23-判断二叉树为BST-二叉搜索树" class="headerlink" title="23.判断二叉树为BST(二叉搜索树)"></a>23.判断二叉树为BST(二叉搜索树)</h2><p>leetcode 98</p>
<p>题目：判断二叉树为BST(二叉搜索树)</p>
<p>思路：中序遍历判断且使用全局变量记录前继节点的值</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long last = Long.MIN_VALUE;<span class="comment">//全局变量记录前继节点的值</span></span><br><span class="line"><span class="comment">//中序遍历判断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(!isValidBST(root.left))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.val&lt;=last)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    last = Long.valueOf(root.val);</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="24"></a></p>
<h2 id="24-Replace-Words-字典树应用"><a href="#24-Replace-Words-字典树应用" class="headerlink" title="24.Replace Words(字典树应用)"></a>24.Replace Words(字典树应用)</h2><p>leetcode 648</p>
<p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p>
<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p>
<p>You need to output the sentence after the replacement.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</span><br><span class="line">sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">Output: &quot;the cat was rat by the bat&quot;</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">The input will only have lower-case letters.</span><br><span class="line">1 &lt;&#x3D; dict words number &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; sentence words number &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; root length &lt;&#x3D; 100</span><br><span class="line">1 &lt;&#x3D; sentence words length &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<p>题目大意：给定一个字典，里面是词根root，给定一句话，如果这句话的单词前缀是字典中词根，则将单词用词根替换，如果有多个词根，找最短的词根替换，最后返回替换好的话</p>
<p>思路1(不可取)：暴力替换。将这句话split成words[]单词组，将每个单词从前往后字符组的依次与hash字典中的词根比较，如果出现就替换。时间o(nk),n这句话，k字典，空间辅助hash o(k)。时间效率很低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(dict);</span><br><span class="line">    String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;words[i].length(); ++j)&#123;</span><br><span class="line">            String root = words[i].substring(<span class="number">0</span>,j);</span><br><span class="line">            <span class="keyword">if</span>(set.contains(root))&#123;</span><br><span class="line">                words[i] = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(words[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2(可取，但还是不够好)：不暴力替换，采用了字典树的思想。1.字典的roots词根用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组;2.将这句话split成words[]单词组，遍历words单词数组，一个单词一个单词的在字典树中替换，最后返回替换好的话。时间o(n)，空间o(k),n是原句子，k是字典</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：字典树思想。将字典中的词根按照首字母构建字典</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HashSet[] set = <span class="keyword">new</span> HashSet[<span class="number">26</span>];<span class="comment">//字典树，用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组</span></span><br><span class="line">    String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构建字典树,26个字母开头索引</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dict.size(); ++i)&#123;</span><br><span class="line">        String word = dict.get(i);</span><br><span class="line">        <span class="keyword">int</span> wordIndex =  word.charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(set[wordIndex]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            set[wordIndex] = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        set[wordIndex].add(word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.遍历words单词数组，一个单词一个单词的在字典树中替换</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> wordIndex = words[i].charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(set[wordIndex]==<span class="keyword">null</span>)&#123;<span class="comment">//这个单词在字典树中没有首字母索引，即也没有词根对应，continue</span></span><br><span class="line">            sb.append(words[i] + <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;String&gt; iterator = set[wordIndex].iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">            String root = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (words[i].startsWith(root) &amp;&amp; root.length() &lt; words[i].length()) &#123;<span class="comment">//找最短的词根替换</span></span><br><span class="line">                words[i] = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(words[i] + <span class="string">" "</span>);<span class="comment">//替换好的单词加入到新话中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路3(高效字典树，棒):思路2只是很简单用首字母进行索引实现字典树，但还是不够，应该使用字典树(也叫前缀树)实现高效查询。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">boolean</span> isComplete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思路：构建字典树。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sentence==<span class="keyword">null</span> || sentence.length()&lt;<span class="number">2</span> || dict==<span class="keyword">null</span> || dict.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sentence;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.遍历字典中的词根，构建字典树</span></span><br><span class="line">        TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'c'</span>);<span class="comment">//字典树的根节点</span></span><br><span class="line">        <span class="keyword">for</span>(String dictWord: dict)&#123;<span class="comment">//遍历字典中的词根</span></span><br><span class="line">            <span class="keyword">char</span>[] chs = dictWord.toCharArray();</span><br><span class="line">            TrieNode temp = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c: chs)&#123;<span class="comment">//对每个词根进行字典树构建</span></span><br><span class="line">                <span class="keyword">if</span>(temp.children[c-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.children[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.children[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            temp.isComplete = <span class="keyword">true</span>;<span class="comment">//一个词根构建完，标记位置为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.遍历原话的words[]单词数组，对每个单词进行字典树替换</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;<span class="comment">//遍历原单词数组words[]</span></span><br><span class="line">            TrieNode temp = root;</span><br><span class="line">            StringBuilder tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">boolean</span> can_change = <span class="keyword">false</span>;<span class="comment">//是否找到一个可以替换的词根</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch: words[i].toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp.children[ch-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;<span class="comment">//当前字符在字典树中没有索引</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tempSb.append(ch);</span><br><span class="line">                temp = temp.children[ch-<span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span>(temp.isComplete==<span class="keyword">true</span>)&#123;<span class="comment">//找到了当前单词对应的一个词根</span></span><br><span class="line">                    can_change = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(can_change)&#123;<span class="comment">//将单词替换成词根</span></span><br><span class="line">                sb.append(tempSb.toString() + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//没有对应的词根，单词不变</span></span><br><span class="line">                sb.append(words[i] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="25"></a></p>
<h2 id="25-BFS-DFS思想"><a href="#25-BFS-DFS思想" class="headerlink" title="25.BFS/DFS思想"></a>25.BFS/DFS思想</h2><p>参考：<a href="https://www.cnblogs.com/developerY/p/3323264.html" target="_blank" rel="noopener">LeoYang<br>Coding and learning<br>BFS和DFS详解以及java实现</a></p>
<p>总的来说，BFS多用于寻找最短路径的问题，DFS多用于快速发现底部节点。</p>
<h3 id="BFS广度优先搜索-遍历"><a href="#BFS广度优先搜索-遍历" class="headerlink" title="BFS广度优先搜索/遍历"></a>BFS广度优先搜索/遍历</h3><p>BFS主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对A再加1，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问），而对于连通图来说，每个顶点都会被访问。加上每个顶点的邻接链表都会被遍历，因此<strong>BFS的时间复杂度是O（V+E</strong>），其中V是顶点个数，E是边数，也就是所有邻接表中的元素个数。</p>
<h3 id="DFS深度优先搜索-遍历"><a href="#DFS深度优先搜索-遍历" class="headerlink" title="DFS深度优先搜索/遍历"></a>DFS深度优先搜索/遍历</h3><p>DFS深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。</p>
<p><a name="26"></a></p>
<h2 id="26-BFS相关题目-1道"><a href="#26-BFS相关题目-1道" class="headerlink" title="26.BFS相关题目(1道)"></a>26.BFS相关题目(1道)</h2><h3 id="BFS相关题目-1-01-Matrix"><a href="#BFS相关题目-1-01-Matrix" class="headerlink" title="BFS相关题目_1.01 Matrix"></a>BFS相关题目_1.01 Matrix</h3><p>leetcode 542</p>
<p>题目：Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Example 1: </span><br><span class="line">Input:</span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">0 0 0</span><br><span class="line"></span><br><span class="line">Example 2: </span><br><span class="line">Input:</span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 1 1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">0 0 0</span><br><span class="line">0 1 0</span><br><span class="line">1 2 1</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">The number of elements of the given matrix will not exceed 10,000.</span><br><span class="line">There are at least one 0 in the given matrix.</span><br><span class="line">The cells are adjacent in only four directions: up, down, left and right.</span><br></pre></td></tr></table></figure>

<p>思路：BFS。这道题给了我们一个只有0和1的矩阵，让我们求每一个1到离其最近的0的距离，其实也就是求一个距离场，而求距离场那么BFS将是不二之选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.首先遍历一次矩阵，将值为0的点都存入queue，将值为1的点换成MAX_VALUE;</span><br><span class="line">2.对队列中的每一个0进行BFS上下左右搜索:从queue中取出一个数字，遍历其周围四个点，如果越界或者周围点的值小于等于当前值加1，则直接跳过;否则将周围点的值更新为当前值加1，然后把周围点的坐标加入queue</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.把原矩阵中1换成MAX_VALUE; 2.把0全部放进队列</span></span><br><span class="line">    Queue&lt;Pair&lt;Integer,Integer&gt; &gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair&lt;&gt;(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                matrix[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.对队列中的每一个0进行BFS上下左右搜索</span></span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//上下左右</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Pair&lt;Integer, Integer&gt; origin = queue.poll();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = origin.getKey() + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = origin.getValue() + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=m || y&lt;<span class="number">0</span> || y&gt;=n || matrix[x][y]&lt;=( matrix[origin.getKey()][origin.getValue()]+<span class="number">1</span> ) )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            matrix[x][y] = matrix[origin.getKey()][origin.getValue()]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            queue.offer(<span class="keyword">new</span> Pair&lt;&gt;(x, y));<span class="comment">//BFS入队别忘了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="27"></a></p>
<h2 id="27-DFS相关题目-4道"><a href="#27-DFS相关题目-4道" class="headerlink" title="27.DFS相关题目(4道)"></a>27.DFS相关题目(4道)</h2><h3 id="DFS相关题目-1-Number-of-Islands"><a href="#DFS相关题目-1-Number-of-Islands" class="headerlink" title="DFS相关题目_1.Number of Islands"></a>DFS相关题目_1.Number of Islands</h3><p>leetcode 200</p>
<p>题目：Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<p>思路：找岛屿的个数。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索，计数器加1</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)&#123;<span class="comment">//找到一个岛屿</span></span><br><span class="line">                dfs(grid, m, n, i, j);<span class="comment">//对该岛屿进行dfs搜索土地，并将岛屿的全部土地变为'0'已访问</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || grid[i][j]==<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">'0'</span>;<span class="comment">//标记为已访问</span></span><br><span class="line">    dfs(grid, m , n, i-<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, m , n, i+<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, m , n, i, j-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, m , n, i, j+<span class="number">1</span>);<span class="comment">//上下左右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS相关题目-2-Max-Area-of-Island"><a href="#DFS相关题目-2-Max-Area-of-Island" class="headerlink" title="DFS相关题目_2.Max Area of Island"></a>DFS相关题目_2.Max Area of Island</h3><p>leetcode 695</p>
<p>题目：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> </span><br><span class="line"> Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.(斜着的不算)</span><br></pre></td></tr></table></figure>

<p>思路：在很多岛屿中，返回最大岛屿面积。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索并计算面积。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;<span class="comment">//找到一个岛屿</span></span><br><span class="line">                <span class="keyword">int</span>[] tempMax = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;<span class="comment">//计算当前岛屿的面积</span></span><br><span class="line">                dfs(grid, m, n, i, j, tempMax);<span class="comment">//对该岛屿进行dfs搜索土地并计算面积，并将岛屿的全部土地变为'0'已访问</span></span><br><span class="line">                resMax = Math.max(resMax, tempMax[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[] tempMax)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;<span class="comment">//标记为已访问</span></span><br><span class="line">    tempMax[<span class="number">0</span>]++;</span><br><span class="line">    dfs(grid, m , n, i-<span class="number">1</span>, j, tempMax);</span><br><span class="line">    dfs(grid, m , n, i+<span class="number">1</span>, j, tempMax);</span><br><span class="line">    dfs(grid, m , n, i, j-<span class="number">1</span>, tempMax);</span><br><span class="line">    dfs(grid, m , n, i, j+<span class="number">1</span>, tempMax);<span class="comment">//上下左右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS相关题目-3-Island-Perimeter"><a href="#DFS相关题目-3-Island-Perimeter" class="headerlink" title="DFS相关题目_3.Island Perimeter"></a>DFS相关题目_3.Island Perimeter</h3><p>leetcode 463</p>
<p>题目大意：二维地图，每个单元格的长度为1的方形。1代表陆地，0代表水，上、下、左、右四个方向的单元格相连，求出相连陆地单元格的周长。 </p>
<p>思路：图中只有唯一一个岛屿,不用dfs，直接遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可。</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求图中唯一岛屿的周长。思路：//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可</span></span><br><span class="line"><span class="comment">//对岛屿的一个节点计算周长的规律:周围相邻有0/1/2/3/4的节点的话，对应的周长分别为4/3/3/2/1/0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resPrm = <span class="number">0</span>;<span class="comment">//该岛屿的周长</span></span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;<span class="comment">//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][j]==<span class="number">1</span>)&#123;<span class="comment">//上：有相邻的一个节点</span></span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span>&lt;m &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="number">1</span>)&#123;<span class="comment">//下：有相邻的一个节点</span></span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[i][j-<span class="number">1</span>]==<span class="number">1</span>)&#123;<span class="comment">//左：有相邻的一个节点</span></span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span>&lt;n &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="number">1</span>)&#123;<span class="comment">//右：有相邻的一个节点</span></span><br><span class="line">                    temp--;</span><br><span class="line">                &#125;</span><br><span class="line">                resPrm += temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resPrm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS相关题目-4-Surrounded-Regions"><a href="#DFS相关题目-4-Surrounded-Regions" class="headerlink" title="DFS相关题目_4.Surrounded Regions"></a>DFS相关题目_4.Surrounded Regions</h3><p>leetcode 130</p>
<p>题目：这道题的意思是将所有被X包围的O都变为X(边缘的不算)</p>
<p>思路：1.从图的4个边界出发DFS找O的土地，全部换成*;2.遍历图中剩下的节点，将O换成X，将*换成O</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length==<span class="number">0</span> || board[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//1.从图的4个边界出发DFS找O的土地，全部换成*</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        dfsSolve(board, m, n, <span class="number">0</span>, i);<span class="comment">//上边界</span></span><br><span class="line">        dfsSolve(board, m, n, m-<span class="number">1</span>, i);<span class="comment">//下边界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        dfsSolve(board, m, n, i, <span class="number">0</span>);<span class="comment">//左边界</span></span><br><span class="line">        dfsSolve(board, m, n, i, n-<span class="number">1</span>);<span class="comment">//右边界</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.遍历图中剩下的节点，将O换成X，将*换成O</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==<span class="string">'*'</span>)&#123;</span><br><span class="line">                board[i][j]=<span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span>)&#123;</span><br><span class="line">                board[i][j]=<span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从图的4个边界出发DFS找O的土地，访问过的换成*</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfsSolve</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=m || j&lt;<span class="number">0</span> || j&gt;=n || grid[i][j]==<span class="string">'X'</span> || grid[i][j]==<span class="string">'*'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">'*'</span>;<span class="comment">//把边界O换成*</span></span><br><span class="line">    dfsSolve(grid, m, n, i+<span class="number">1</span>, j);<span class="comment">//上</span></span><br><span class="line">    dfsSolve(grid, m, n, i-<span class="number">1</span>, j);<span class="comment">//下</span></span><br><span class="line">    dfsSolve(grid, m, n, i, j-<span class="number">1</span>);<span class="comment">//左</span></span><br><span class="line">    dfsSolve(grid, m, n, i, j+<span class="number">1</span>);<span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="28"></a></p>
<h2 id="28-图的几种最短路算法-4道"><a href="#28-图的几种最短路算法-4道" class="headerlink" title="28.图的几种最短路算法(4道)"></a>28.图的几种最短路算法(4道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.单源最短路径_1.Dijkstra算法</span><br><span class="line">2.单源最短路径_2.Bellman-Ford算法</span><br><span class="line">3.单源最短路径_3.SPFA算法</span><br><span class="line">4.多源最短路径_Floyd-Warshall算法</span><br></pre></td></tr></table></figure>

<h3 id="1-单源最短路径-1-Dijkstra算法"><a href="#1-单源最短路径-1-Dijkstra算法" class="headerlink" title="1.单源最短路径_1.Dijkstra算法"></a>1.单源最短路径_1.Dijkstra算法</h3><p>普通实现的时间复杂度为O(V2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O(E+VlogV)</p>
<p>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s</p>
<p>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p>
<p>图片截图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200215151327162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="dijkstra.png)"></p>
<p>自己跑过的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: Dijkstra</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: braincao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/9 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Dijkstra最短路径算法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> N = Integer.MAX_VALUE - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] Graph = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, N, N, N, N, N, N&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, N, N, N, N&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, N, <span class="number">1</span>, <span class="number">7</span>, N, N, N&#125;,</span><br><span class="line">            &#123;N, <span class="number">7</span>, N, <span class="number">0</span>, <span class="number">2</span>, N, <span class="number">3</span>, N, N&#125;,</span><br><span class="line">            &#123;N, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, N&#125;,</span><br><span class="line">            &#123;N, N, <span class="number">7</span>, N, <span class="number">3</span>, <span class="number">0</span>, N, <span class="number">5</span>, N&#125;,</span><br><span class="line">            &#123;N, N, N, <span class="number">3</span>, <span class="number">6</span>, N, <span class="number">0</span>, <span class="number">2</span>, <span class="number">7</span>&#125;,</span><br><span class="line">            &#123;N, N, N, N, <span class="number">9</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;N, N, N, N, N, N, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        dijkstra(<span class="number">0</span>, Graph);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dijkstra最短路径。</span></span><br><span class="line"><span class="comment">     * 即图中"节点vs"到其它各个节点的最短路径。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vs    起始节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Graph 图</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> vs, <span class="keyword">int</span>[][] Graph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> NUM = Graph.length;<span class="comment">//图中节点的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] prenode = <span class="keyword">new</span> <span class="keyword">int</span>[NUM];<span class="comment">//前驱节点数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] mindist = <span class="keyword">new</span> <span class="keyword">int</span>[NUM];<span class="comment">// 最短距离数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] find = <span class="keyword">new</span> <span class="keyword">boolean</span>[NUM];<span class="comment">// 该节点是否已经找到最短路径，即已经确定节点的集合，初始里面只有vs节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> vnear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;<span class="comment">//初始化</span></span><br><span class="line">            prenode[i] = i;</span><br><span class="line">            mindist[i] = Graph[vs][i];</span><br><span class="line">            find[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        find[vs] = <span class="keyword">true</span>;<span class="comment">//节点自己到自己的最短路径能找到</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; NUM; v++) &#123;<span class="comment">//循环NUM-1次</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次循环找一个距离vs最近的节点vnear和最短距离min</span></span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; NUM; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!find[j] &amp;&amp; mindist[j] &lt; min) &#123;</span><br><span class="line">                    min = mindist[j];</span><br><span class="line">                    vnear = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            find[vnear] = <span class="keyword">true</span>;<span class="comment">//vnear节点已经确定，访问标记</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据vnear修正vs到其他所有节点的前驱节点及距离，即松弛操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; NUM; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!find[k] &amp;&amp; (min + Graph[vnear][k]) &lt; mindist[k]) &#123;</span><br><span class="line">                    prenode[k] = vnear;</span><br><span class="line">                    mindist[k] = min + Graph[vnear][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"v"</span> + vs + <span class="string">"...v"</span> + prenode[i] + <span class="string">"-&gt;v"</span> + i + <span class="string">", s="</span> + mindist[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">v0...v0-&gt;v0, s=<span class="number">0</span></span><br><span class="line">v0...v1-&gt;v1, s=<span class="number">1</span></span><br><span class="line">v0...v1-&gt;v2, s=<span class="number">4</span></span><br><span class="line">v0...v2-&gt;v3, s=-<span class="number">2147483647</span></span><br><span class="line">v0...v3-&gt;v4, s=-<span class="number">2147483645</span></span><br><span class="line">v0...v7-&gt;v5, s=-<span class="number">2147483642</span></span><br><span class="line">v0...v2-&gt;v6, s=-<span class="number">2147483647</span></span><br><span class="line">v0...v2-&gt;v7, s=-<span class="number">2147483647</span></span><br><span class="line">v0...v2-&gt;v8, s=-<span class="number">2147483647</span></span><br></pre></td></tr></table></figure>

<h3 id="2-单源最短路径-2-Bellman-Ford算法"><a href="#2-单源最短路径-2-Bellman-Ford算法" class="headerlink" title="2.单源最短路径_2.Bellman-Ford算法"></a>2.单源最短路径_2.Bellman-Ford算法</h3><p>时间o(VE),比dijkstra慢</p>
<p>Bellman-Ford 算法描述：</p>
<p>1.创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；<br>计算最短路径，执行 V - 1 次遍历，每次遍历中，依赖所有边进行松弛操作；</p>
<p>2.松弛操作：对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；</p>
<p>3.检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</p>
<p>自己跑过的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: Dijkstra</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: braincao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/9 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Bellman-Ford最短路径算法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start; <span class="comment">//有向边的起点</span></span><br><span class="line">    <span class="keyword">int</span> end;   <span class="comment">//有向边的终点</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//边的权重</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bellman</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">9999</span>;<span class="comment">//不可达边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: 图结构、源节点的下标(0~节点个数-1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//图结构中的节点数目、边集合</span></span><br><span class="line">        <span class="keyword">int</span> nodenum = graph.length;</span><br><span class="line">        Set&lt;Edge&gt; edge = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//边集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.根据graph的图结构给edge[]边数组赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nodenum; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]!=N &amp;&amp; graph[i][j]!=<span class="number">0</span>)&#123;<span class="comment">//有边的话就赋值，最终有edgeIndex条边</span></span><br><span class="line">                    Edge tempEdge = <span class="keyword">new</span> Edge();</span><br><span class="line">                    tempEdge.start = i;</span><br><span class="line">                    tempEdge.end = j;</span><br><span class="line">                    tempEdge.weight = graph[i][j];</span><br><span class="line">                    edge.add(tempEdge);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.为dist最短路径数组初始化赋值</span></span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; i++)&#123;</span><br><span class="line">            dist[i]=graph[source][i];</span><br><span class="line">        &#125;</span><br><span class="line">        dist[source]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.循环nodenum-1次,每次都遍历所有边，进行松弛操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum-<span class="number">1</span>; i++)<span class="comment">//循环nodenum-1次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Edge edgeTemp: edge)&#123;<span class="comment">//每次都遍历所有边，进行松弛操作</span></span><br><span class="line">                <span class="keyword">int</span> start = edgeTemp.start;</span><br><span class="line">                <span class="keyword">int</span> end = edgeTemp.end;</span><br><span class="line">                <span class="keyword">int</span> weight = edgeTemp.weight;</span><br><span class="line">                <span class="keyword">if</span>(dist[end]&gt;dist[start]+weight)&#123;<span class="comment">//松弛操作</span></span><br><span class="line">                    dist[end]=dist[start]+weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.判断是否存在负回路</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//是否存在回路</span></span><br><span class="line">        <span class="keyword">for</span> (Edge edgeTemp: edge)&#123;</span><br><span class="line">            <span class="keyword">if</span>( dist[edgeTemp.end] &gt; dist[edgeTemp.start]+edgeTemp.weight )</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//不存在负回路的话打印dist最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodenum;i++)</span><br><span class="line">                System.out.println(dist[i]);<span class="comment">//打印源节点到每个节点的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Bellman bellman = <span class="keyword">new</span> Bellman();</span><br><span class="line">        <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                                    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, N&#125;,</span><br><span class="line">                                    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, N&#125;,</span><br><span class="line">                                    &#123;N, <span class="number">7</span>, N, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        bellman.Bellman_Ford(graph, <span class="number">2</span>);<span class="comment">//节点0、1、2、3，现求节点2的单源最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单源最短路径-3-SPFA算法"><a href="#3-单源最短路径-3-SPFA算法" class="headerlink" title="3.单源最短路径_3.SPFA算法"></a>3.单源最短路径_3.SPFA算法</h3><p>SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。</p>
<p>很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)。</p>
<p>但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。</p>
<p>实现方法：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。</p>
<p>此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。</p>
<p>图结构为邻接矩阵的spfa代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: SPFA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: braincao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/9 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SPFA最短路径算法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPFA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">9999</span>;<span class="comment">//不可达边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] spfa(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nodenum = graph.length;</span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];<span class="comment">//最短路径数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nodenum];<span class="comment">//访问标记位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nodenum; i++)&#123;</span><br><span class="line">            dist[i] = Integer.MAX_VALUE;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum]; <span class="comment">//记录每个节点遍历过的次数，用于检测负向环</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//辅助队列</span></span><br><span class="line">        <span class="keyword">int</span> path[] = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];         <span class="comment">//记录最短路的路径</span></span><br><span class="line"></span><br><span class="line">        dist[source] = <span class="number">0</span>;     <span class="comment">//source顶点到自身距离为0</span></span><br><span class="line">        used[source] = <span class="keyword">true</span>;    <span class="comment">//表示source顶点进入数组队</span></span><br><span class="line">        num[source] = <span class="number">1</span>;       <span class="comment">//表示source顶点已被遍历一次</span></span><br><span class="line">        queue.add(source);      <span class="comment">//source顶点入队</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//是否存在回路</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();   <span class="comment">//获取队头</span></span><br><span class="line">            used[u] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; nodenum; ++v) &#123;<span class="comment">//对每一个u的相邻节点进行松弛操作</span></span><br><span class="line">                <span class="keyword">if</span> (graph[u][v] != N) &#123;<span class="comment">////u与v直接邻接</span></span><br><span class="line">                    <span class="keyword">if</span> (dist[v] &gt; dist[u] + graph[u][v]) &#123;</span><br><span class="line">                        dist[v] = dist[u] + graph[u][v];</span><br><span class="line">                        path[v] = u;</span><br><span class="line">                        <span class="keyword">if</span> (!used[v]) &#123;<span class="comment">//如果v没有访问过，入队</span></span><br><span class="line">                            queue.offer(v);</span><br><span class="line">                            used[v] = <span class="keyword">true</span>;</span><br><span class="line">                            num[v]++;</span><br><span class="line">                            <span class="keyword">if</span> (num[v] &gt;= nodenum) &#123;<span class="comment">//遍历次数大于等于节点数，存在负向环,break</span></span><br><span class="line">                                flag = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;<span class="comment">//存在负向环,break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//不存在负回路的话打印dist最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodenum;i++)</span><br><span class="line">                System.out.println(dist[i]);<span class="comment">//打印源节点到每个节点的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                                    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, N&#125;,</span><br><span class="line">                                    &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, N&#125;,</span><br><span class="line">                                    &#123;N, <span class="number">7</span>, N, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dist = spfa(graph, <span class="number">2</span>);<span class="comment">//节点0、1、2、3，现求节点2的单源最短路径</span></span><br><span class="line">        System.out.println(Arrays.toString(dist));<span class="comment">//out:[4, 3, 0, 10]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图结构为邻接链表的spfa代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@FileName</span>: SPFA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: braincao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/1/9 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: SPFA最短路径算法实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPFA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">9999</span>;<span class="comment">//不可达边的权值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 单源最短路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] spfa(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> source)&#123;</span><br><span class="line">        <span class="comment">//1.邻接矩阵转成邻接表</span></span><br><span class="line">        <span class="keyword">int</span> nodenum = graph.length;</span><br><span class="line">        List[] vex = <span class="keyword">new</span> List[nodenum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; ++i)&#123;</span><br><span class="line">            vex[i] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nodenum; ++j)&#123;<span class="comment">//假设给定的图是无向图</span></span><br><span class="line">                <span class="keyword">if</span>(graph[i][j]!=N)&#123;</span><br><span class="line">                    vex[i].add(j);</span><br><span class="line">                    vex[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.spfa</span></span><br><span class="line">        <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];<span class="comment">//最短路径数组,初始化为MAX_VALUE</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; ++i)&#123;</span><br><span class="line">            dist[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[nodenum];<span class="comment">//访问标记位</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//辅助队列</span></span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];<span class="comment">//记录每个节点遍历过的次数，用于检测负向环</span></span><br><span class="line">        queue.offer(source);<span class="comment">//source顶点入队</span></span><br><span class="line">        dist[source] = <span class="number">0</span>;<span class="comment">//source顶点到自身距离为0</span></span><br><span class="line">        num[source] = <span class="number">1</span>;<span class="comment">//表示source顶点已被遍历一次</span></span><br><span class="line">        used[source] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//是否存在负向环</span></span><br><span class="line">        <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[nodenum];<span class="comment">//记录最短路径，初始化上一个节点都为source</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nodenum; ++i)&#123;</span><br><span class="line">            path[i] = source;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> u = queue.poll();<span class="comment">//获取队头</span></span><br><span class="line">            used[u] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vex[u].size(); ++i)&#123;<span class="comment">//对u的每个相邻节点v进行松弛操作</span></span><br><span class="line">                <span class="keyword">int</span> v = (<span class="keyword">int</span>)vex[u].get(i);</span><br><span class="line">                <span class="keyword">if</span>( dist[v]&gt;dist[u]+graph[u][v] )&#123;</span><br><span class="line">                    dist[v] = dist[u]+graph[u][v];</span><br><span class="line">                    path[v] = u;</span><br><span class="line">                    <span class="keyword">if</span>(!used[v])&#123;<span class="comment">//如果v没有访问过，入队</span></span><br><span class="line">                        queue.offer(v);</span><br><span class="line">                        num[v]++;</span><br><span class="line">                        used[v] = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(num[v]&gt;=nodenum)&#123;<span class="comment">//遍历次数大于等于节点数，存在负向环,break</span></span><br><span class="line">                            flag = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;<span class="comment">//存在负向环,break</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;<span class="comment">//不存在负回路的话打印dist最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nodenum;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"source:"</span>+source+<span class="string">"...pass:"</span>+path[i]+<span class="string">"--&gt;dest:"</span>+i+<span class="string">",distance:"</span>+dist[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] graph = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, N&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, N&#125;,</span><br><span class="line">                &#123;N, <span class="number">7</span>, N, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dist = spfa(graph, <span class="number">2</span>);<span class="comment">//节点0、1、2、3，现求节点2的单源最短路径</span></span><br><span class="line">        System.out.println(Arrays.toString(dist));</span><br><span class="line">        <span class="comment">//out:</span></span><br><span class="line">        <span class="comment">//source:2...pass:1--&gt;dest:0,distance:4</span></span><br><span class="line">        <span class="comment">//source:2...pass:2--&gt;dest:1,distance:3</span></span><br><span class="line">        <span class="comment">//source:2...pass:2--&gt;dest:2,distance:0</span></span><br><span class="line">        <span class="comment">//source:2...pass:1--&gt;dest:3,distance:10</span></span><br><span class="line">        <span class="comment">//[4, 3, 0, 10]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-多源最短路径-Floyd-Warshall算法"><a href="#4-多源最短路径-Floyd-Warshall算法" class="headerlink" title="4.多源最短路径_Floyd-Warshall算法"></a>4.多源最短路径_Floyd-Warshall算法</h3><p>时间o(V^3)</p>
<p>最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。</p>
<p>核心代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)  </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)  </span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)  </span><br><span class="line">			<span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])  </span><br><span class="line">				e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>

<p><a name="29"></a></p>
<h2 id="29-Word-Ladder-2道-SPFA最短路算法应用"><a href="#29-Word-Ladder-2道-SPFA最短路算法应用" class="headerlink" title="29.Word Ladder(2道)(SPFA最短路算法应用)"></a>29.Word Ladder(2道)(SPFA最短路算法应用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Word Ladder--leetcode 127</span><br><span class="line">Word Ladder2--leetcode 126</span><br></pre></td></tr></table></figure>

<h3 id="1-Word-Ladder"><a href="#1-Word-Ladder" class="headerlink" title="1.Word Ladder"></a>1.Word Ladder</h3><p>leetcode 127</p>
<p>题目：Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Only one letter can be changed at a time.</span><br><span class="line">2.Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Return 0 if there is no such transformation sequence.</span><br><span class="line">All words have the same length.</span><br><span class="line">All words contain only lowercase alphabetic characters.</span><br><span class="line">You may assume no duplicates in the word list.</span><br><span class="line">You may assume beginWord and endWord are non-empty and are not the same.</span><br></pre></td></tr></table></figure>

<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>

<p>题目大意: </p>
<p>思路：最短路径问题。1.构造图结构(邻接表); 2.用SPFA最短路算法求beginWord到endWord的最短改变次数</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Word Ladder找出beginWord到endWord的最小改变次数。</span></span><br><span class="line"><span class="comment">//思路：最短路问题。1.构图; 2.用SPFA最短路算法求beginWord到endWord的最短改变次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(diff(beginWord, endWord)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.构造图的邻接表</span></span><br><span class="line">    <span class="keyword">int</span> size = wordList.size();</span><br><span class="line">    List[] edge = <span class="keyword">new</span> List[size+<span class="number">2</span>];<span class="comment">//size装beginWord，size+1装endWord</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge.length; ++i)&#123;</span><br><span class="line">        edge[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> can_arrive = <span class="keyword">false</span>;<span class="comment">//从beginWord到endWord是否能顺利改变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;size; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(diff(wordList.get(i), wordList.get(j)) == <span class="number">1</span>)&#123;<span class="comment">//这两个单词可以转变，图中有边</span></span><br><span class="line">                edge[i].add(j);</span><br><span class="line">                edge[j].add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(diff(beginWord, wordList.get(i))==<span class="number">1</span>)&#123;<span class="comment">//字典中的当前单词与beginWord可以改变，图中有边</span></span><br><span class="line">            edge[size].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = diff(endWord, wordList.get(i));</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;<span class="comment">//字典中的当前单词与endWord可以改变，图中有边</span></span><br><span class="line">            edge[i].add(size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>)&#123;<span class="comment">//字典中包含endWord，can_arrive</span></span><br><span class="line">            can_arrive = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(can_arrive==<span class="keyword">false</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径</span></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[size+<span class="number">2</span>];<span class="comment">//求edge[size]节点的单源最短路径数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size+<span class="number">2</span>; i++)&#123;</span><br><span class="line">        dist[i] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[size] = <span class="number">1</span>;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(size);<span class="comment">//起始节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> queFirstNode = queue.poll();   <span class="comment">//获取队头</span></span><br><span class="line">        <span class="keyword">int</span> dest = dist[queFirstNode];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[queFirstNode].size(); ++i)&#123;<span class="comment">//遍历queFirstNode为起点的每条边</span></span><br><span class="line">            <span class="comment">//当队头的节点等于边edgeTemp的起点时,进行松弛操作</span></span><br><span class="line">            <span class="keyword">int</span> temp = (<span class="keyword">int</span>)edge[queFirstNode].get(i);</span><br><span class="line">            <span class="keyword">if</span>( dist[temp] &gt; dest+<span class="number">1</span> ) &#123;</span><br><span class="line">                dist[temp] = dest+<span class="number">1</span>;</span><br><span class="line">                queue.add(temp);</span><br><span class="line">                <span class="keyword">if</span>(temp == size+<span class="number">1</span>) &#123;<span class="comment">//该节点是终点，即改变成功</span></span><br><span class="line">                    <span class="keyword">return</span> dist[temp];<span class="comment">//从起点(size)到终点(size+1)的最短距离</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//判断两个字符串不同的字符个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diff</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word1.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(word1.charAt(i)!=word2.charAt(i))&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Word-Ladder2"><a href="#2-Word-Ladder2" class="headerlink" title="2.Word Ladder2"></a>2.Word Ladder2</h3><p>leetcode 126</p>
<p>题目：题目与上面同，只是结果应该返回所有转换的路径而不是最短的路径长度</p>
<p>思路：还是构造邻接链表+SPFA最短路径算法，当找到终点时用<strong>dfs</strong>从终点节点反推找出所有不同的最短路径即可。</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord &#x3D; &quot;hit&quot;,</span><br><span class="line">endWord &#x3D; &quot;cog&quot;,</span><br><span class="line">wordList &#x3D; [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],</span><br><span class="line">  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span>[] dist;</span><br><span class="line">    List[] edge;</span><br><span class="line">    String a;</span><br><span class="line">    String b;<span class="comment">//这些变量弄成全局是为了dfs函数中使用</span></span><br><span class="line">    List&lt;String&gt; wl;</span><br><span class="line">    ArrayList&lt;String&gt; tempPath = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        a = beginWord;</span><br><span class="line">        b = endWord;</span><br><span class="line">        wl = wordList;</span><br><span class="line"></span><br><span class="line">        size = wordList.size();</span><br><span class="line">        <span class="comment">//1.构造图的邻接表</span></span><br><span class="line">        edge = <span class="keyword">new</span> List[size+<span class="number">2</span>];<span class="comment">//size装beginWord，size+1装endWord</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge.length; ++i)&#123;</span><br><span class="line">            edge[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> can_arrive = <span class="keyword">false</span>;<span class="comment">//从beginWord到endWord是否能顺利改变</span></span><br><span class="line">        <span class="keyword">if</span>(diff(beginWord, endWord)==<span class="number">1</span>)&#123;</span><br><span class="line">            edge[size].add(size+<span class="number">1</span>);</span><br><span class="line">            edge[size+<span class="number">1</span>].add(size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;size; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(diff(wordList.get(i), wordList.get(j)) == <span class="number">1</span>)&#123;<span class="comment">//这两个单词可以转变，图中有边</span></span><br><span class="line">                    edge[i].add(j);</span><br><span class="line">                    edge[j].add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(diff(beginWord, wordList.get(i))==<span class="number">1</span>)&#123;<span class="comment">//字典中的当前单词与beginWord可以改变，图中有边</span></span><br><span class="line">                edge[size].add(i);</span><br><span class="line">                edge[i].add(size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = diff(endWord, wordList.get(i));</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>)&#123;<span class="comment">//字典中的当前单词与endWord可以改变，图中有边</span></span><br><span class="line">                edge[i].add(size+<span class="number">1</span>);</span><br><span class="line">                edge[size+<span class="number">1</span>].add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>)&#123;<span class="comment">//字典中包含endWord，can_arrive</span></span><br><span class="line">                can_arrive = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!can_arrive)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径</span></span><br><span class="line">        dist = <span class="keyword">new</span> <span class="keyword">int</span>[size+<span class="number">2</span>];<span class="comment">//求edge[size]节点的单源最短路径数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;size+<span class="number">2</span>; i++)&#123;</span><br><span class="line">            dist[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[size] = <span class="number">1</span>;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(size);<span class="comment">//起始节点入队</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queFirstNode = queue.poll();   <span class="comment">//获取队头</span></span><br><span class="line">            <span class="keyword">int</span> dest = dist[queFirstNode];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[queFirstNode].size(); ++i)&#123;<span class="comment">//遍历queFirstNode为起点的每条边</span></span><br><span class="line">                <span class="comment">//当队头的节点等于边edgeTemp的起点时,进行松弛操作</span></span><br><span class="line">                <span class="keyword">int</span> temp = (<span class="keyword">int</span>)edge[queFirstNode].get(i);</span><br><span class="line">                <span class="keyword">if</span>( dist[temp] &gt; dest+<span class="number">1</span> ) &#123;</span><br><span class="line">                    dist[temp] = dest+<span class="number">1</span>;</span><br><span class="line">                    queue.add(temp);</span><br><span class="line">                    <span class="keyword">if</span>(temp == size+<span class="number">1</span>) &#123;<span class="comment">//该节点是终点，即改变成功,用dfs从终点返回回去找路径</span></span><br><span class="line">                        dfs(temp);</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==size)&#123;<span class="comment">//起点</span></span><br><span class="line">            tempPath.add(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==size+<span class="number">1</span>)&#123;<span class="comment">//终点</span></span><br><span class="line">            tempPath.add(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tempPath.add(wl.get(p));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dist[p]==<span class="number">1</span>)&#123;<span class="comment">//递归出口，如果递归到了起点，说明一条路径已经找到了</span></span><br><span class="line">            ArrayList&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(tempPath);</span><br><span class="line">            Collections.reverse(temp);</span><br><span class="line">            res.add(temp);</span><br><span class="line">            <span class="keyword">if</span> (!tempPath.isEmpty())&#123;</span><br><span class="line">                tempPath.remove(tempPath.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//往回走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;edge[p].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> dest = (<span class="keyword">int</span>)edge[p].get(i);</span><br><span class="line">            <span class="keyword">if</span>(dist[dest]+<span class="number">1</span> == dist[p])&#123;</span><br><span class="line">                dfs(dest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tempPath.isEmpty())&#123;</span><br><span class="line">            tempPath.remove(tempPath.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断两个字符串不同的字符个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diff</span><span class="params">(String word1, String word2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;word1.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word1.charAt(i)!=word2.charAt(i))&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        String beginWord = <span class="string">"hit"</span>;</span><br><span class="line">        String endWord = <span class="string">"cog"</span>;</span><br><span class="line">        String[] wordList = <span class="keyword">new</span> String[]&#123;<span class="string">"hot"</span>,<span class="string">"dot"</span>,<span class="string">"dog"</span>,<span class="string">"lot"</span>,<span class="string">"log"</span>,<span class="string">"cog"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(s.findLadders(beginWord, endWord, Arrays.asList(wordList)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//out:[[hit, hot, dot, dog, cog], [hit, hot, lot, log, cog]]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="30"></a></p>
<h2 id="30-字符串匹配-kmp算法"><a href="#30-字符串匹配-kmp算法" class="headerlink" title="30.字符串匹配(kmp算法)"></a>30.字符串匹配(kmp算法)</h2><p>leetcode 28</p>
<p>题目：Implement strStr().</p>
<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>

<p>思路：kmp算法。求模式串的next数组，然后进行字符串匹配即可。不用kmp算法之前的时间o(mn),m字符串，n模式串，用kmp算法之后的时候是o(m+n)。下面重点讲解kmp中的next数组怎么求。</p>
<p>如果不写代码的话，kmp的next非常好求，就是考研时候的那个套路，如”ABAD”–&gt;next:[-1,0,0,1]，有了next数组，拿模式串j和字符串i依次进行匹配即可，如果不等，则i不动，对应模式串跳转到next[j]继续匹配，如果next[j]==-1，则i也+1即可</p>
<p>代码实现next数组的过程强推油管<a href="https://www.youtube.com/watch?v=GTJr8OvyEVQ" target="_blank" rel="noopener">(KMP) Pattern Matching</a>，下面是自己的总结。</p>
<p>核心就是代码求kmp的next数组如”ABAD”–&gt;next:[-1,0,0,1],见下面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(needle==<span class="keyword">null</span> || needle.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(haystack==<span class="keyword">null</span> || haystack.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(needle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( j==-<span class="number">1</span> || haystack.charAt(i)==needle.charAt(j) )</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( j==needle.length() )&#123;<span class="comment">//匹配成功，返回needle出现的位置</span></span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String needle)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[needle.length()];</span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;needle.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span> || needle.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;needle.length())&#123;</span><br><span class="line">                next[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="31"></a></p>
<h2 id="31-两数相除-转为减法"><a href="#31-两数相除-转为减法" class="headerlink" title="31.两数相除(转为减法)"></a>31.两数相除(转为减法)</h2><p>leetcode 29</p>
<p>题目：除法运算，但是不能使用/、%、*（除数不会为0）。</p>
<p>思路：将除法转化为减法，但是单纯的做减法计算次数太粗暴，故采用除数扩大（左移），商随之扩大（左移）的思想，同时要考虑正负两边的最大绝对值是不一样的。最简单的方法是用long去处理。另外一个边界条件需要单独处理：<code>-2147483648/-1= 2147483647</code></p>
<p>把除数表示为：dividend = 2^i * divisor + 2^(i-1) * divisor + … + 2^0 * divisor。这样一来，我们所求的商就是各系数之和了，而每个系数都可以通过移位操作获得。</p>
<p>分两步走：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）获得i的值；</span><br><span class="line">2）将各系数求和。</span><br><span class="line">显然每步都是logN的复杂度。</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除法转换为减法。具体思路:除数左移几次，商左移几次。dividend=2^i*divisor+2^(i-1)*divisor+...+2^0*divisor.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dividend == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isPositive = (dividend&gt;<span class="number">0</span> &amp;&amp; divisor&gt;<span class="number">0</span>) || (dividend&lt;<span class="number">0</span> &amp;&amp; divisor&lt;<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> res = divideDetail( Math.abs((<span class="keyword">long</span>)dividend), Math.abs((<span class="keyword">long</span>)divisor) );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isPositive &amp;&amp; res&gt;Integer.MAX_VALUE)&#123;<span class="comment">//溢出特例必须处理-2147483648/-1= 2147483647</span></span><br><span class="line">        res = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> isPositive ? (<span class="keyword">int</span>)res : -(<span class="keyword">int</span>)res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">divideDetail</span><span class="params">(<span class="keyword">long</span> dividend, <span class="keyword">long</span> divisor)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.除数左移, 获取i值</span></span><br><span class="line">    <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(dividend &gt;= (divisor&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">        divisor &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.商左移cnt次，获取多项式系数和，即商系数相加</span></span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dividend&gt;=divisor)&#123;</span><br><span class="line">            res += (<span class="number">1L</span>&lt;&lt;i);</span><br><span class="line">            dividend -= divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        divisor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="32"></a></p>
<h2 id="32-sqrt-x"><a href="#32-sqrt-x" class="headerlink" title="32.sqrt(x)"></a>32.sqrt(x)</h2><p>leetcode 69</p>
<p>题目：Implement int sqrt(int x).求x的平方根。</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>思路1：二分法。定义一个最小精度，用二分法逼近即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> right = x;</span><br><span class="line">    <span class="keyword">double</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid==x || right-mid&lt;<span class="number">1e-9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&gt;x)&#123;<span class="comment">//因为是double类型所以乘法比除法好，也不会溢出</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid*mid&lt;x)&#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路1的改进：因为题目中所求是int类型，所以不需要double类型去逼近，用int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分法的改进</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = x;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x/mid==mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x/mid&lt;mid)&#123;<span class="comment">//因为是int类型所以除法比乘法好，这样也可以避免溢出</span></span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x/mid&gt;mid)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;<span class="comment">//while跳出循环时，right &lt; left，应该返回right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：牛顿法。对x的平方根的值一个猜想y。通过执行一个简单的操作去得到一个更好的猜测：只需要求出y和x/y的平均值（它更接近实际的平方根值）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//牛顿法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> k=<span class="number">1.0</span>； <span class="comment">//当然猜想的数拿来主义会更快k=0x5f3759df;</span></span><br><span class="line">    <span class="keyword">while</span>(Math.abs(k*k-x)&gt;<span class="number">0.0001</span>) &#123;<span class="comment">//精度不能太高，否则太慢</span></span><br><span class="line">        k=(k+x/k)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="33"></a></p>
<h2 id="33-乱序的数组中找到最长的递增子序列"><a href="#33-乱序的数组中找到最长的递增子序列" class="headerlink" title="33.乱序的数组中找到最长的递增子序列"></a>33.乱序的数组中找到最长的递增子序列</h2><p>leetcode 300</p>
<p>题目：Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</span><br></pre></td></tr></table></figure>

<p>思路1(可取，但不够好)：DP问题。时间o(n^2)</p>
<p>设长度为N的数组为{a0，a1, a2, …an-1)，则假定以aj结尾的数组序列的最长递增子序列长度为L(j)，<strong>则L(j)={ max(L(i))+1, i&lt;j且a[i]&lt;a[j] }</strong>。也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。</p>
<p>例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长递增子序列。思路1：一维DP，时间o(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] longest = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">        longest[i] = <span class="number">1</span>; <span class="comment">//初始化都为1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[j] = &#123;max(L(i))+1&#125;, 如果i&lt;j且a[i]&lt;a[j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;len; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;j; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&gt;nums[i] &amp;&amp; longest[j]&lt;longest[i]+<span class="number">1</span>)&#123; <span class="comment">//注意longest[j]&lt;longest[i]+1这个条件，不能省略。</span></span><br><span class="line">                longest[j] = longest[i] + <span class="number">1</span>; <span class="comment">//计算以arr[j]结尾的序列的最长递增子序列长度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再遍历一遍dp[]数组，取最大的</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (longest[j] &gt; max) max = longest[j];  <span class="comment">//从longest[j]中找出最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2(更好)：二分。假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。</p>
<p>下面一步一步试着找出它。</p>
<p>我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br>此外，我们用一个变量Len来记录现在最长算到多少了</p>
<p>首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p>
<p>然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1</p>
<p>接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2</p>
<p>再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p>
<p>继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p>
<p>第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p>
<p>第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p>
<p>第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p>
<p>最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p>
<p>于是我们知道了LIS的长度为5。</p>
<p>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p>
<p>然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)<del>~</del>于是算法的时间复杂度就降低到了O(NlogN)～！</p>
<p>代码如下（代码中的数组B从位置0开始存数据）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最长递增子序列。思路2：辅助数组存储有序数列，时间o(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">        <span class="comment">//二分查找，查找不到的话就返回负数,负数从1开始。[1,2,3](索引是0，1，2/找不到的索引是1,2,3) 找num=1.5 返回-2</span></span><br><span class="line">        <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) i = -i-<span class="number">1</span>;</span><br><span class="line">        dp[i] = num;</span><br><span class="line">        <span class="keyword">if</span>(len == i) len ++;<span class="comment">//不是更新的值，而是实实在在的扩张递增序列了，所以len++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="34"></a></p>
<h2 id="34-蓄水池问题"><a href="#34-蓄水池问题" class="headerlink" title="34.蓄水池问题"></a>34.蓄水池问题</h2><p>leetcode 42</p>
<p><img src="https://img-blog.csdnimg.cn/2020021515145692.png" alt="蓄水池.jpg"></p>
<p>题目：Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p>思路：两头双指针往中间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蓄水池问题。思路：两头双指针往中间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftmax = <span class="number">0</span>;<span class="comment">//左边最大的板子</span></span><br><span class="line">    <span class="keyword">int</span> rightmax = <span class="number">0</span>;<span class="comment">//右边最大的板子</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a &lt;= b)&#123;</span><br><span class="line">        leftmax = Math.max(height[a], leftmax);<span class="comment">//每次都更新下左右两边最大的板子</span></span><br><span class="line">        rightmax = Math.max(height[b], rightmax);</span><br><span class="line">        <span class="keyword">if</span>(leftmax &lt; rightmax)&#123;<span class="comment">//左边比右边的板子小，右边能挡住，因此看左边的短板</span></span><br><span class="line">            sum += leftmax - height[a];</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += rightmax - height[b];</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="35"></a></p>
<h2 id="35-满足指定sum条件的长度最小的子数组"><a href="#35-满足指定sum条件的长度最小的子数组" class="headerlink" title="35.满足指定sum条件的长度最小的子数组"></a>35.满足指定sum条件的长度最小的子数组</h2><p>leetcode 209 Minimum Size Subarray Sum</p>
<p>题目：Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>Example: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: the subarray [4,3] has the minimal length under the problem constraint.</span><br></pre></td></tr></table></figure>

<p>思路：遍历一遍数组，两个指针变量i,j控制窗口动态变化，时间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resMin = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[i];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt; s)&#123;<span class="comment">//和不够，j++，扩大窗口</span></span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=nums.length)&#123;<span class="comment">//循环出口</span></span><br><span class="line">                <span class="keyword">return</span> resMin==Integer.MAX_VALUE ? <span class="number">0</span> : resMin;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        resMin = Math.min(resMin, j-i+<span class="number">1</span>);<span class="comment">//更新最小窗口长度</span></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= s)&#123;<span class="comment">//和够了，i++，缩小窗口</span></span><br><span class="line">            resMin = Math.min(resMin, j-i+<span class="number">1</span>);<span class="comment">////更新最小窗口长度</span></span><br><span class="line">            sum -= nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="36"></a></p>
<h2 id="36-最大值减去最小值小于或等于num的子数组数量"><a href="#36-最大值减去最小值小于或等于num的子数组数量" class="headerlink" title="36.最大值减去最小值小于或等于num的子数组数量"></a>36.最大值减去最小值小于或等于num的子数组数量</h2><p>《左神》31</p>
<p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p>
<p>思路：数组长度n，时间o(n),空间o(n)</p>
<p>1、生成两个队列qmax和qmin. 两个指针i,j，标定数组边界</p>
<p>2、令j不断向右移动（j++）,表示arr[i..j]一直向右扩大，并不断更新qmax和qmin结构，保证qmax和qmin始终维持动态窗口最大值和最小值的更新结构。直到j不满足向右扩张条件时，以arr[i]为左边界且满足条件的子数组(子数组长度&gt;=2)个数为j-i</p>
<p>3、当进行完步骤2，令i向右移动一个位置并对qmax和qmin做出相应的更新做出相应的更新。 </p>
<p>4、根据步骤2，步骤3，依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量分别有多少，累加起来起来的数量就是最终的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大值减去最小值小于或等于num的子数组数量(子数组长度大于1)。思路：两个队列qmax和qmin. 两个指针i,j</span></span><br><span class="line"><span class="comment">//依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//辅助i/j两个指针</span></span><br><span class="line">    Deque&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//辅助两个双端队列记录当前子数组的最大/小值</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;arr.length)&#123;<span class="comment">//j不断往右扩</span></span><br><span class="line">            <span class="keyword">while</span>(!qmax.isEmpty() &amp;&amp; arr[j]&gt;=arr[qmax.peekLast()])&#123;<span class="comment">//注意这里必须有=</span></span><br><span class="line">                qmax.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            qmax.offerLast(j);</span><br><span class="line">            <span class="keyword">while</span>(!qmin.isEmpty() &amp;&amp; arr[j]&lt;=arr[qmin.peekLast()])&#123;</span><br><span class="line">                qmin.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            qmin.offerLast(j);</span><br><span class="line">            <span class="keyword">if</span>(!qmax.isEmpty()&amp;&amp;!qmin.isEmpty() &amp;&amp; arr[qmax.peekFirst()]-arr[qmin.peekFirst()] &lt;= num)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//当j不满足继续向右扩的条件时，break并计算当前以arr[i]为底的子数组的个数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        res += j-i;<span class="comment">//计算当前以arr[i]为底的子数组的个数</span></span><br><span class="line">        <span class="keyword">if</span>(!qmax.isEmpty() &amp;&amp; qmax.peekFirst()&lt;i)&#123;<span class="comment">//将队列窗口之外的元素索引弹出(i之前的都不要了)</span></span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!qmin.isEmpty() &amp;&amp; qmin.peekFirst()&lt;i)&#123;</span><br><span class="line">            qmin.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(getNum(nums,<span class="number">1</span>));<span class="comment">//out:4  [1,2][2,3][3,4][4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="37"></a></p>
<h2 id="37-几道未整理的"><a href="#37-几道未整理的" class="headerlink" title="37.几道未整理的"></a>37.几道未整理的</h2><p>###1.有序数组合并###</p>
<p>####问题：</p>
<p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。<br>给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</p>
<p>####思路：</p>
<p>这道题很简单，就是一个归并的过程。和归并排序里面的归并函数做法基本一样，但需要注意的是，这道题是把数组B加入到数组A里。我们需要从后往前比较、加入，这样防止覆盖掉数组A前面的有用部分。过程大致为我们每次从两个列表后面元素选取较大的一个，放入A最后，直到某一个列表到达头部，再将另一个剩下部分逆序取出。时间复杂度O（n+m），空间O（1）。</p>
<p>####代码：</p>
<pre><code>class A
{
    public int[] mergeAB(int[] a, int[] b, int n, int m)
    {
        int pa = n - 1;
        int pb = m - 1;
        int p = m + n - 1;
        do
        {
            if(pa==-1)
                for(int i=p; i&gt;=0; i--)
                    a[i] = b[pb--];

            else if(pb==-1)
                return a;
            else
                a[p--] = (a[pa]&gt;b[pb])?a[pa--]:b[pb--];
        }while(p!=0);
    return a;
    }
}

public class Example
{
    public static void main(String[] args)
    {
        A cc = new A();
        int[] a = {1,3,5,7,11, 0, 0, 0, 0, 0};
        int[] b = {2,4,6,8,12};
        int[] c = new int[5];
        c = cc.mergeAB(a, b, 5, 5);
        for(int i: c)
            System.out.print(i + &quot; &quot;);
    }
}
//output:1 2 3 4 5 6 7 8 11 12</code></pre><p>###2.三色排序</p>
<p>####问题：</p>
<p>有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。<br>给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。<br>测试样例：<br>[0,1,1,0,2,2],6<br>返回：[0,0,1,1,2,2]</p>
<p>####思路：</p>
<p>这是一个经典的荷兰国旗问题，处理过程和快排的划分过程相似，可以参考快排的划分技巧。时间复杂度O（n），空间O（1）。过程为：</p>
<p>遍历数组之前，在数组左端设立“0区”，初始大小0，在数组右端设立“2区”，初始大小0。遍历数组，如果是1，直接跳到下一个；如果是0，把当前元素与“0区”后一位交换，“0区”大小+1，遍历下一个元素；遇到2，把当前元素与“2区”前一位交换，“2区”大小+1，由于“2区”元素并没有遍历过，所以不跳到后一个位置，继续遍历该位置元素。</p>
<p>####代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeColor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sortThreeColor(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">int</span> i=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=n;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                swap(A,++i,k++); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[k]==<span class="number">2</span>)&#123;</span><br><span class="line">                swap(A,--j,k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=A[a];</span><br><span class="line">        A[a]=A[b];</span><br><span class="line">        A[b]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实拿到这个问题我最先想到的是用计数排序处理，只要三个桶，几乎可以认为是原地的，简单多了。但这里明确说要用交换，而不是计数。在在线课程下面的评论区里，有小伙伴提出和我一样的疑问，老师的回答是:</p>
<blockquote>
<p>如果数组里面放的不是int，long这种类型，而是具体一个一个实例呢？你还能压缩在一起吗？比如数组里面放的是“人”这个类的实例，每个实例有一个“身高”的数据项，请把小于160放左边，160~170放中间，170以上放右边。荷兰国旗问题重点介绍的是一种处理数组的技巧。这种技巧从快排中来，掌握了可以解决很多类似的问题。我并不是在强调这么做才对，只是一种技巧而已。</p>
</blockquote>
<p>###3.最短子数组问题</p>
<p>####问题：</p>
<p>对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。<br>给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。<br>测试样例：<br>[1,4,6,5,9,10],6<br>返回：2</p>
<p>####思路：<br>拿到这道题，我最直接的想法就是先排序，再比较排序后的数组有变化的位置，位置有变化的元素里的最左的一个到最右的一个，这之间的数组就是题目要求的需要排序的最短子数组。这种方法需要额外空间复杂度O（n），用来保存排序后的数组（或者保存原数组各元素下标情况，这取决于具体实现）。时间复杂度O（nlogn）。</p>
<p>由上面的这个思路，我们可以想到，其实只要知道，需要调整的元素里最右的元素和最左的元素的位置，就可以得到需要排序的最短子数组的长度。我们知道，如果是有序数组，一定是越往右，数值越大，越往左，数值越小，不满足这个条件的元素，那么就是需要调整的元素。于是可以想到下面的这种处理方法。它可以做到时间复杂度O（n），额外空间复杂度O（1）。处理过程大致为：</p>
<p>先向右遍历，记住遍历过的元素中的最大值max。如果遍历的当前元素i的值A[i]小于max，说明i是需要向左调整的，记住它。向右遍历，只记录需要向左调整的元素的最右的一个，记为R。<br>再从右至左遍历一次，这次记住遍历过的元素中的最小值min。同理，如果遍历的当前元素i的值A[i]大于min，说明i是需要向右调整的，记住它。遍历过程只记录要调整的最左的一个元素，记为L。A[l]~A[R]就是需要排序的最短子数组，它的长度是R-L+1.</p>
<p>####代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubsequence</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = A[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = A[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> l = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//从左至右遍历，记录最右的当前值小于最大值情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;=max)</span><br><span class="line">            max = A[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从右至左遍历，记录最左的当前值大于最小值情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n-<span class="number">2</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[j]&lt;min)</span><br><span class="line">            min = A[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l-r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###4.有序矩阵查找</p>
<p>####问题：</p>
<p>现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。<br>给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。</p>
<p>测试样例：</p>
<p>[[1,2,3],[4,5,6],[7,8,9]],3,3,10</p>
<p>返回：false</p>
<p>####思路：</p>
<p>这道题可以做到时间复杂度O（m+n），额外空间复杂度O（1）。用下面这个矩阵举例说明。</p>
<p><img src="https://img-blog.csdnimg.cn/20200215151658115.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="matrix0.jpg"></p>
<p>我们从右上角或左下角作为起始位置开始遍历。这么做是因为矩阵行列都是有序的，右上角是行最小，列最大，左下角相反。我们这里选择从右上角开始，假设待查值是3。当前值是5，如果待查值比当前值大，那么往下走一步，因为我们知道这一行当前位置是最大的，左面所有元素都小于该值，就不用考虑；如果待查值更小，那么往左走一步，理由同上；如果相等，返回true。待查值3&lt;当前值5，往左走一步，当前值变成2。重复上面过程，当前值=4。3&lt;4,所以再往左走，现在待查值3=当前值3，返回true。如果直到越界都没找到，则返回false。</p>
<p>####代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">findX</span><span class="params">(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, j=m-<span class="number">1</span>; (i!=n)&amp;&amp;(j!=-<span class="number">1</span>); ) <span class="comment">//起始位置(i,j)从矩阵右上角开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;mat[i][j]) <span class="comment">//目标值大于矩阵元素，向下走</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; mat[i][j])  <span class="comment">//目标值小于矩阵元素，向左走</span></span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == mat[i][j])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://braincao.gitee.io/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/" data-id="ck6nmgv7z0001z30qd1hy7z2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/hexoblog/2020/02/15/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">剑指offer刷题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexoblog/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexoblog/2020/02/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/">左神刷题</a>
          </li>
        
          <li>
            <a href="/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/">剑指offer刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexoblog/" class="mobile-nav-link">Home</a>
  
    <a href="/hexoblog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/hexoblog/fancybox/jquery.fancybox.css">

  
<script src="/hexoblog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/hexoblog/js/script.js"></script>




  </div>
</body>
</html>