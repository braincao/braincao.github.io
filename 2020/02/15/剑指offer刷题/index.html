<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>剑指offer刷题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1234567title: 剑指offer刷题date: 2018-09-21 17:32:47categories: 算法刷题tags:    - 剑指offer刷题source: mac mdupdate: 2020-02-15 13:15:50  此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer刷题">
<meta property="og:url" content="https://braincao.gitee.io/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1234567title: 剑指offer刷题date: 2018-09-21 17:32:47categories: 算法刷题tags:    - 剑指offer刷题source: mac mdupdate: 2020-02-15 13:15:50  此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-02-15T03:37:32.203Z">
<meta property="article:modified_time" content="2020-02-15T05:15:53.345Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/hexoblog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/hexoblog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/hexoblog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/hexoblog/">Home</a>
        
          <a class="main-nav-link" href="/hexoblog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/hexoblog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://braincao.gitee.io/hexoblog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-剑指offer刷题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/" class="article-date">
  <time datetime="2020-02-15T03:37:32.203Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      剑指offer刷题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: 剑指offer刷题</span><br><span class="line">date: 2018-09-21 17:32:47</span><br><span class="line">categories: 算法刷题</span><br><span class="line">tags:</span><br><span class="line">    - 剑指offer刷题</span><br><span class="line">source: mac md</span><br><span class="line">update: 2020-02-15 13:15:50</span><br></pre></td></tr></table></figure>

<p>此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑指offer专题oj，可在上面进行练习验证。</p>
<a id="more"></a>

<h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">题目</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="#1">找出数组中重复的数字</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="#2">不修改数组找出重复的数字</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="#3">0~n-1中缺失的数字(2道)</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="#4">数组中数字出现的次数(3道)</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="#5">数组中出现次数超过一半的数字</a></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a href="#6">数组中出现次数超过1/3的数字</a></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="#7">统计指定数字在排序数组中出现的次数</a></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a href="#8">二维数组中的查找</a></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="#9">替换空格</a></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="#10">Replace Words–字典树</a></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="#11">Find And Replace in String</a></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a href="#12">从尾到头打印链表</a></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="#13">反转链表(三道)</a></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="#14">重建二叉树</a></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="#15">二叉树的下一个节点</a></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="#16">Populating Next Right Pointers in Each Node</a></td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="#717">Populating Next Right Pointers in Each Node II</a></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="#18">两个栈实现队列</a></td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="#19">两个队列实现栈</a></td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="#20">斐波那契数列(三道)</a></td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="#21">斐波那契数列变种_medium难度(两道)</a></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="#22">Additive Number</a></td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="#23">旋转数组的最小数字(三道)</a></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="#24">矩阵中的路径</a></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="#25">机器人的运动范围</a></td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="#26">Unique Paths(两道)</a></td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="#27">剪绳子</a></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="#28">不用加减乘除做加法(位运算)</a></td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="#29">Two Sum</a></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="#30">二进制中1的个数</a></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="#31">数值的整数次方</a></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="#32">打印从1到最大的n位数</a></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="#33">删除链表中重复的节点(两道)</a></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="#34">正则表达式匹配</a></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="#35">表示数值的字符串</a></td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="#36">调整数组顺序使奇数位于偶数前面(3道)</a></td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="#37">链表中倒数第k个结点(两道)</a></td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="#38">判断链表是否有环(两道)</a></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="#39">两个单链表相交的第一个公共节点(2道)</a></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="#40">合并两个排序的链表</a></td>
</tr>
<tr>
<td align="center">41</td>
<td align="center"><a href="#41">树的子结构</a></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="#42">二叉树的翻转(镜像)与对称(2道)</a></td>
</tr>
<tr>
<td align="center">43</td>
<td align="center"><a href="#43">顺时针打印矩阵</a></td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="#44">包含min函数的栈</a></td>
</tr>
<tr>
<td align="center">45</td>
<td align="center"><a href="#45">栈的压入、弹出序列</a></td>
</tr>
<tr>
<td align="center">46</td>
<td align="center"><a href="#46">二叉树的层序遍历(3道)</a></td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="#47">递归与非递归实现二叉树前序、中序、后序遍历</a></td>
</tr>
<tr>
<td align="center">48</td>
<td align="center"><a href="#48">判断数组是否为二叉搜索树的后续遍历序列</a></td>
</tr>
<tr>
<td align="center">49</td>
<td align="center"><a href="#49">二叉树中和为某一值的路径</a></td>
</tr>
<tr>
<td align="center">50</td>
<td align="center"><a href="#50">复杂链表的复制</a></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="#51">二叉搜索树与双向链表(两道)</a></td>
</tr>
<tr>
<td align="center">52</td>
<td align="center"><a href="#52">序列化二叉树</a></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="#53">全排列问题(五道)</a></td>
</tr>
<tr>
<td align="center">54</td>
<td align="center"><a href="#54">打印出给定字符串中字符的所有组合</a></td>
</tr>
<tr>
<td align="center">55</td>
<td align="center"><a href="#55">大/小根堆–优先队列实现(两道)</a></td>
</tr>
<tr>
<td align="center">56</td>
<td align="center"><a href="#56">数据流中的中位数</a></td>
</tr>
<tr>
<td align="center">57</td>
<td align="center"><a href="#57">数组中最大连续子序列的和</a></td>
</tr>
<tr>
<td align="center">58</td>
<td align="center"><a href="#58">1到n整数中1出现的次数</a></td>
</tr>
<tr>
<td align="center">59</td>
<td align="center"><a href="#59">正整数序列中的第n个数字</a></td>
</tr>
<tr>
<td align="center">60</td>
<td align="center"><a href="#60">把数组排成最小的数</a></td>
</tr>
<tr>
<td align="center">61</td>
<td align="center"><a href="#61">求把一个数字翻译成不同字符串的个数(DP)</a></td>
</tr>
<tr>
<td align="center">62</td>
<td align="center"><a href="#62">礼物的最大价值</a></td>
</tr>
<tr>
<td align="center">63</td>
<td align="center"><a href="#63">最长不含重复的子字符串长度</a></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center"><a href="#64">丑数(两道)</a></td>
</tr>
<tr>
<td align="center">65</td>
<td align="center"><a href="#65">第一个只出现一次的字符</a></td>
</tr>
<tr>
<td align="center">66</td>
<td align="center"><a href="#66">归并排序相关(3道)</a></td>
</tr>
<tr>
<td align="center">67</td>
<td align="center"><a href="#67">二叉搜索树的第k小节点(中序遍历)</a></td>
</tr>
<tr>
<td align="center">68</td>
<td align="center"><a href="#68">二叉树的深度(两道)</a></td>
</tr>
<tr>
<td align="center">69</td>
<td align="center"><a href="#69">数组中和为s的数字(四道)</a></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center"><a href="#70">翻转字符串(两道)</a></td>
</tr>
<tr>
<td align="center">71</td>
<td align="center"><a href="#71">滑动窗口的最大值(双端队列)</a></td>
</tr>
<tr>
<td align="center">72</td>
<td align="center"><a href="#72">打印n个骰子所有可能的点数和及概率</a></td>
</tr>
<tr>
<td align="center">73</td>
<td align="center"><a href="#73">扑克牌中的顺子(2道)</a></td>
</tr>
<tr>
<td align="center">74</td>
<td align="center"><a href="#74">圆圈中剩下的数(约瑟夫环问题)</a></td>
</tr>
<tr>
<td align="center">75</td>
<td align="center"><a href="#75">股票的最大利润问题(四道)</a></td>
</tr>
<tr>
<td align="center">76</td>
<td align="center"><a href="#76">求1+2+3+…+n(不用if而用或短路的方式结束递归)</a></td>
</tr>
<tr>
<td align="center">77</td>
<td align="center"><a href="#77">构建乘积数组</a></td>
</tr>
<tr>
<td align="center">78</td>
<td align="center"><a href="#78">普通二叉树中两个节点的最低公共祖先</a></td>
</tr>
<tr>
<td align="center">79</td>
<td align="center"><a href="#79">把字符串转换成整数</a></td>
</tr>
</tbody></table>
<h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p>
<h2 id="1-找出数组中重复的数字"><a href="#1-找出数组中重复的数字" class="headerlink" title="1.找出数组中重复的数字"></a>1.找出数组中重复的数字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LeetCode 217：Contains Duplicate </span><br><span class="line">LeetCode 219：Contains Duplicate II </span><br><span class="line">LeetCode 220：Contains Duplicate III </span><br><span class="line">LeetCode 287：Find the Duplicate Number</span><br></pre></td></tr></table></figure>

<h3 id="1-《剑指offer》p39、leetcode-287"><a href="#1-《剑指offer》p39、leetcode-287" class="headerlink" title="1.《剑指offer》p39、leetcode 287"></a>1.《剑指offer》p39、leetcode 287</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>思路：交换法、映射。数组不重复的情形是array[i]=i。遍历数组元素，元素值为m时，与array[m]的值作对比，如果相同则重复了，返回即可，否则二者交换，继续比较，直到遍历完数组。时间o(n)，空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i]!=i)&#123;<span class="comment">//注意这里是while</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[numbers[i]]==numbers[i])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    swap(numbers, i, numbers[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-LeetCode-217：Contains-Duplicate"><a href="#2-LeetCode-217：Contains-Duplicate" class="headerlink" title="2.LeetCode 217：Contains Duplicate"></a>2.LeetCode 217：Contains Duplicate</h3><p>题目：Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>1）将数组排序，判断前后两个元素是否一样，如果一样则返回true，否则返回false； </p>
<p>2）方法（1）对数组进行排序，改变了数组元素的位置；若要求不能修改数组元素，可以创建一个辅助HashSet，判断HashSet中是否已经存在该元素，存在则返回true，否则返回false，并将其加入在HashSet中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：排序(改变了位置,时间o(nlogn)，空间o(1))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i+<span class="number">1</span>]==nums[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//法二：hashSet(不改变位置，时间o(n),空间o(n))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.add(num))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-LeetCode-219：Contains-Duplicate-II"><a href="#3-LeetCode-219：Contains-Duplicate-II" class="headerlink" title="3.LeetCode 219：Contains Duplicate II"></a>3.LeetCode 219：Contains Duplicate II</h3><p>题目：给定一个数组nums和一个整数k，是否存在两个不相等的整数 i 和 j，使得nums[i] == nums[j]，并且i和j之间的距离最多为k。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1], k &#x3D; 3</span><br><span class="line">Output: true</span><br><span class="line">	</span><br><span class="line">Input: nums &#x3D; [1,0,1,1], k &#x3D; 1</span><br><span class="line">Output: true</span><br><span class="line">	</span><br><span class="line">Input: nums &#x3D; [1,2,3,1,2,3], k &#x3D; 2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<p>思路：辅助map存储数组元素值-元素索引，遍历数组即可，时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//值-索引</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i]))&lt;=k)&#123;<span class="comment">//找到重复</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(nums[i], i);<span class="comment">//更新键值对</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-LeetCode-220：Contains-Duplicate-III"><a href="#4-LeetCode-220：Contains-Duplicate-III" class="headerlink" title="4.LeetCode 220：Contains Duplicate III"></a>4.LeetCode 220：Contains Duplicate III</h3><p>题目：给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。</p>
<p>思路：维持一个大小为k的窗口，由左向右在nums中移动。对于nums[i]，只要查找其之前的元素中是否存在大小范围在[nums[i] - t,nums[i] + t]的元素，如果存在就返回true。还要注意整数的溢出问题，Long</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。</span></span><br><span class="line"><span class="comment">//思路：treeset滑窗保存有序元素</span></span><br><span class="line"><span class="comment">//treeset.ceiling--返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null</span></span><br><span class="line"><span class="comment">//treeset.floor--返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeSet&lt;Long&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k)&#123;<span class="comment">//超过滑窗k，删除treeset中的一个元素</span></span><br><span class="line">            treeSet.remove((<span class="keyword">long</span>)nums[i-k-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Long left = treeSet.ceiling((<span class="keyword">long</span>)nums[i]-t);</span><br><span class="line">        Long right = treeSet.floor((<span class="keyword">long</span>)nums[i]+t);</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span> &amp;&amp; right&gt;=left)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treeSet.add((<span class="keyword">long</span>)nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="2"></a></p>
<h2 id="2-不修改数组找出重复的数字"><a href="#2-不修改数组找出重复的数字" class="headerlink" title="2.不修改数组找出重复的数字"></a>2.不修改数组找出重复的数字</h2><p>《剑指offer》p41. </p>
<p>题目：在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。</p>
<p>第一种思路：与题目1思路相似，利用哈希表，创建一个相同长度的辅助数组，将数组元素存在对应辅助数组下标处，很容易发现重复的数字。辅助空间O(n)</p>
<p>思路：二分查找。若有重复出现，则数字的个数会大于区间的长度，O(nlogn)、O(1)。</p>
<p>详细思路：如果数组中有重复的数，那么n+1个0~n范围内的数中，一定有几个数的个数大于1。那么，我们可以利用这个思路解决该问题。</p>
<p>我们把从1<del>n的数字从中间的数字m分为两部分，前面一半为1</del>m，后面一半为m+1<del>n。如果1</del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，反之，如果大于m，那么这一半的区间一定包含重复的数字；如果小于m，另一半m+1~n的区间里一定包含重复的数字。接下来，我们可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p>
<p>由于如果1<del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，我们可以逐步减少m，然后判断1</del>m之间是否有重复的数，即，我们可以令m=m-1，然后再计算1<del>m的数字的数目是否等于m，如果等于m，再令m=m-1，如果大于m，则说明1</del>m的区间有重复的数，如果小于m，则说明m+1~n有重复的数，不断重复此过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FileName: Hello</span></span><br><span class="line"><span class="comment"> * Author:   braincao</span></span><br><span class="line"><span class="comment"> * Date:     2018/8/29 15:21</span></span><br><span class="line"><span class="comment"> * Description: 《剑指offer》P41.不修改数组找出重复的数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        System.out.println(getDuplication(c,<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDuplication</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = count(array, length, left, mid);</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; (mid - left + <span class="number">1</span>)) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]&gt;=start &amp;&amp; array[i]&lt;=end)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="3"></a></p>
<h2 id="3-0-n-1中缺失的数字-2道"><a href="#3-0-n-1中缺失的数字-2道" class="headerlink" title="3.0~n-1中缺失的数字(2道)"></a>3.0~n-1中缺失的数字(2道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0~n-1中缺失的数字(数组有序)--《剑指offer》p266</span><br><span class="line">0~n-1中缺失的数字(数组无序)--leetcode 268</span><br></pre></td></tr></table></figure>

<h3 id="1-0-n-1中缺失的数字-数组有序"><a href="#1-0-n-1中缺失的数字-数组有序" class="headerlink" title="1.0~n-1中缺失的数字(数组有序)"></a>1.0~n-1中缺失的数字(数组有序)</h3><p>《剑指offer》p266</p>
<p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0<del>n-1之内。在范围0</del>n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>思路：排序数组，问题转换成找出第一个下标与值不等的那个下标对应的数，显然是二分查找，时间o(logn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0~n-1中缺失的数字(数组有序)。思路：利用二分查找查找第一个nums[i]!=i的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLostNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]==mid)&#123;<span class="comment">//nums[i]==i说明该元素与下标相符，往右边找</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]!=mid) &#123;<span class="comment">//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素</span></span><br><span class="line">            <span class="keyword">if</span>(mid==left || (mid&gt;left&amp;&amp;arr[mid-<span class="number">1</span>]==mid-<span class="number">1</span>) )&#123;<span class="comment">//该元素左边元素与下标相符，说明该元素是第一个不符的</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//往左边找</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr.length;<span class="comment">//之前的都相符，说明缺失的数字在最右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//0~9一共10个数，数组长度为9，缺失的数字为6</span></span><br><span class="line">    System.out.println(findLostNumber(nums));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-0-n-1中缺失的数字-数组无序"><a href="#2-0-n-1中缺失的数字-数组无序" class="headerlink" title="2.0~n-1中缺失的数字(数组无序)"></a>2.0~n-1中缺失的数字(数组无序)</h3><p>leetcode 268</p>
<p>题目：Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br><span class="line">	</span><br><span class="line">Input: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure>

<p>这道题的几种思路如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 二分查找(not good)</span><br><span class="line">把数组排序，用二分查找来找到缺失值。时间o(nlogn)</span><br><span class="line">	</span><br><span class="line">1. 累加(good)</span><br><span class="line">计算1+2+...+n. 用和值减去数组中数的和值，最后的差就是我们要的结果。这个过程中要防止溢出。</span><br><span class="line">	</span><br><span class="line">3. 异或(best)</span><br><span class="line">异或运算有一个性质，x^y^y&#x3D;x. 结果与x和y的顺序无关。我们把0～n与数组中的数都异或到一起，那么最后的结果就是缺失的那个数。</span><br></pre></td></tr></table></figure>

<p>法一(不好)：先排序，再利用二分查找找第一个下标不符的元素，时间o(nlogn)，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);<span class="comment">//先排序</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==mid)&#123;<span class="comment">//nums[i]==i说明该元素与下标相符，往右边找</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]!=mid) &#123;<span class="comment">//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素</span></span><br><span class="line">            <span class="keyword">if</span>(mid==left || (mid&gt;left&amp;&amp;nums[mid-<span class="number">1</span>]==mid-<span class="number">1</span>) )&#123;<span class="comment">//该元素左边元素与下标相符，说明该元素是第一个不符的</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//往左边找</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums.length;<span class="comment">//之前的都相符，说明缺失的数字在最右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二忽略</p>
<p>法三(更好)：<strong>异或性质。0～n与数组中的数都异或到一起，最后的结果即为所求的缺失数字</strong>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        res ^= i;</span><br><span class="line">        res ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res^nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="4"></a></p>
<h2 id="4-数组中数字出现的次数-3道"><a href="#4-数组中数字出现的次数-3道" class="headerlink" title="4.数组中数字出现的次数(3道)"></a>4.数组中数字出现的次数(3道)</h2><p>《剑指offer》p275、leetcode 260、leetcode 136、leetcode 137、leetcode 540</p>
<p>题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。</p>
<p>思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求</p>
<p>题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。</p>
<p>思路2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">​1.所有数字异或;</span><br><span class="line">​2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);</span><br><span class="line">​3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)</span><br></pre></td></tr></table></figure>

<p>题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字</p>
<p>思路3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.这里不能用异或了，但是还是考虑位运算思路;</span><br><span class="line">2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除,则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1</span><br><span class="line">3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。</span></span><br><span class="line"><span class="comment"> * 思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment"> * 思路2：1.所有数字异或;</span></span><br><span class="line"><span class="comment"> *       2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);</span></span><br><span class="line"><span class="comment"> *       3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字</span></span><br><span class="line"><span class="comment"> * 思路3：1.这里不能用异或了，但是还是考虑位运算思路;</span></span><br><span class="line"><span class="comment"> *       2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，</span></span><br><span class="line"><span class="comment"> *         则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1</span></span><br><span class="line"><span class="comment"> *       3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//题目1：找出唯一一个一个出现了一次的数字--&gt;所有数字异或</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSingleNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            res ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目2：找出这两个只出现一次的数字--&gt;</span></span><br><span class="line"><span class="comment">     * 1.所有数字异或;</span></span><br><span class="line"><span class="comment">     * 2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);</span></span><br><span class="line"><span class="comment">     * 3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findSingleNumber2(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempRes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;<span class="comment">//1.将数组所有数字异或</span></span><br><span class="line">            tempRes ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">1</span>;<span class="comment">//2.找出tempRes从右往左首个1出现在第k位</span></span><br><span class="line">        <span class="keyword">while</span>(tempRes!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((tempRes&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123; <span class="comment">//出现了首个1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//还没出现首个1</span></span><br><span class="line">                k++;</span><br><span class="line">                tempRes = tempRes&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> groupOne = <span class="number">0</span>;<span class="comment">//3.将原数组数字分组，并在每个组中找出只出现一个的数字</span></span><br><span class="line">        <span class="keyword">int</span> groupTwo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (i&gt;&gt;(k-<span class="number">1</span>)) &amp; <span class="number">1</span>; <span class="comment">//该数的第k位是bit</span></span><br><span class="line">            <span class="keyword">if</span>(bit==<span class="number">1</span>)&#123;</span><br><span class="line">                groupOne ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                groupTwo ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;groupOne, groupTwo&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目3：找出这两个只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字--&gt;</span></span><br><span class="line"><span class="comment">     * 1.这里不能用异或了，但是还是考虑位运算思路;</span></span><br><span class="line"><span class="comment">     * 2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，</span></span><br><span class="line"><span class="comment">     *   则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1</span></span><br><span class="line"><span class="comment">     * 3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findSingleNumber3</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] bits = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>]; <span class="comment">//int类型4字节，32位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> number: arr)&#123;<span class="comment">//将数组中所有数字的二进制表示的每一位都加起来，每一位的和存在bits数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)&#123; <span class="comment">//从个位到第32位依次相加存储</span></span><br><span class="line">                bits[i] += (number&gt;&gt;i)&amp;<span class="number">1</span>; <span class="comment">//数字number的第i位上的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i) &#123; <span class="comment">//把bits每一位上的数%3，如果为0，则所求的数该位也为0，否则为1</span></span><br><span class="line">            res += ((bits[i]%<span class="number">3</span>)&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//找出一个出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">//找出两次出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span>[] arr3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>&#125;; <span class="comment">//找出两次出现一次的数字</span></span><br><span class="line">        System.out.println(findSingleNumber(arr));<span class="comment">//找出一个出现一次的数字。out:3</span></span><br><span class="line">        System.out.println(findSingleNumber2(arr2)[<span class="number">0</span>] + <span class="string">" "</span> + findSingleNumber2(arr2)[<span class="number">1</span>]);<span class="comment">//找出两次出现一次的数字。out:3,4</span></span><br><span class="line">        System.out.println(findSingleNumber3(arr3));<span class="comment">//找出这两个只出现一次的数字，其他都出现三次。out:5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="5"></a></p>
<h2 id="5-数组中出现次数超过一半的数字"><a href="#5-数组中出现次数超过一半的数字" class="headerlink" title="5.数组中出现次数超过一半的数字"></a>5.数组中出现次数超过一半的数字</h2><p>《剑指offer》p205、leetcode 169</p>
<p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>思路：</p>
<p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p>
<p>法二_更简单高效的方法：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p>
<p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> middle = len/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = partition(array, left, right, left);</span><br><span class="line">    <span class="keyword">while</span>(index != middle)&#123;<span class="comment">//如果不是中位数</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; middle)&#123;<span class="comment">//说明中位数在index的右边</span></span><br><span class="line">            left = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(array, left, right, left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; middle)&#123;<span class="comment">//说明中位数在index的左边</span></span><br><span class="line">            right = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(array, left, right, left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在array[index]是中位数了</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(check(array, array[index]))&#123;<span class="comment">//检查array[index]是否真的出现次数超过一半，不超过返回0</span></span><br><span class="line">        res = array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> pivotIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[pivotIndex];</span><br><span class="line">    swap(arr, pivotIndex, right);</span><br><span class="line">    <span class="keyword">int</span> storeIndex = left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left; i&lt;=right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">            swap(arr, i, storeIndex);</span><br><span class="line">            storeIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, storeIndex, right);</span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span></span>&#123;<span class="comment">//经过算法后求出的数，再次进行检查看看是否真的超过一半，不符合条件res=0</span></span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == key)&#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times &gt; (arr.length/<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(array.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> num = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]==num)&#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            times--;</span><br><span class="line">            <span class="keyword">if</span>(times==<span class="number">0</span>)&#123;</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">                num = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(times&gt;<span class="number">1</span>)&#123;<span class="comment">//一定是</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(times==<span class="number">1</span>)&#123;<span class="comment">//有可能不是，再重新检查该数出现次数是否超过数组长度一半，不超过返回0</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]==num)&#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt; (array.length)/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(MoreThanHalfNum_Solution(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="6"></a></p>
<h2 id="6-数组中出现次数超过1-3的数字"><a href="#6-数组中出现次数超过1-3的数字" class="headerlink" title="6.数组中出现次数超过1/3的数字"></a>6.数组中出现次数超过1/3的数字</h2><p>leetcode 229</p>
<p>题目：Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space.</p>
<p>给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br><span class="line">	</span><br><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<p>思路：每次从nums中拿出3个不一样的数作为一组，肯定会出现两种情况。一，nums被取空了，那么nums中每个数出现次数最多占总次数的1/3，不存在超过1/3的数字；二，还有剩余，这个情况就复杂了，有可能剩余多个，但是……但是，<strong>最多只可能剩余两种数</strong>。 为什么？ 3个不同的数凑一组才能删掉，所以不可能删掉超过1/3的数。所以超过1/3的数肯定被剩下来，但是，<strong>剩下来的俩数并不一定都是超过1/3的</strong>，这点额外注意。 很容易举个例子， 比如</p>
<p><code>1 1 1 1 1 2 2 3 3 4 4 5--最后剩1,4--&gt;只有1是结果</code></p>
<p>我们把原问题转换为如何快速高效的从数组中每次去掉3个不同的数，最后把剩下的两个不同的数保存起来，重新遍历数组判断即可。</p>
<p>代码实现：用a,b表示两种不同的数，用计数器cnta,cntb表示a,b不同的数出现的次数来计数，在遍历数组的过程中计数抵消，看他们俩最终还剩下多少个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)</span></span><br><span class="line"><span class="comment">//思路：遍历数组，每次抵消三个不同的数，最后剩下的2个数重新遍历数组判断。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> b = nums[<span class="number">0</span>];<span class="comment">//a,b存两种不同的数</span></span><br><span class="line">    <span class="keyword">int</span> cnta = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cntb = <span class="number">0</span>;<span class="comment">//cnta,cntb对a,b两种不同的数出现次数的计数，当计数为0时，重置a/b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;<span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">if</span>(a==num)&#123;</span><br><span class="line">            cnta++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==num)&#123;</span><br><span class="line">            cntb++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnta==<span class="number">0</span>)&#123;<span class="comment">//a的计数为0，重置a</span></span><br><span class="line">            a = num;</span><br><span class="line">            cnta = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cntb==<span class="number">0</span>)&#123;<span class="comment">//b的计数为0，重置b</span></span><br><span class="line">            b = num;</span><br><span class="line">            cntb = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnta--;</span><br><span class="line">        cntb--;<span class="comment">//当前的num和a,b都不同，则一起抵消</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnta = <span class="number">0</span>;</span><br><span class="line">    cntb = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最后剩下的有a,b,重新遍历数组查看是否次数超过1/3</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num: nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==a)&#123;</span><br><span class="line">            cnta++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num==b)&#123;</span><br><span class="line">            cntb++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnta&gt;(nums.length)/<span class="number">3</span>)&#123;</span><br><span class="line">            res.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cntb&gt;(nums.length)/<span class="number">3</span>)&#123;</span><br><span class="line">        res.add(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="7"></a></p>
<h2 id="7-统计指定数字在排序数组中出现的次数"><a href="#7-统计指定数字在排序数组中出现的次数" class="headerlink" title="7.统计指定数字在排序数组中出现的次数"></a>7.统计指定数字在排序数组中出现的次数</h2><p>《剑指offer》p263、leetcode 34</p>
<p>题目：统计一个数字在排序数组中出现的次数。</p>
<p>思路：</p>
<p>因为数组排序，很明显要用二分查找。</p>
<p>法一(不可取)，最差时间o(n)。先二分查找k在数组array中的索引，然后从该索引处向左向右外扩，找出所有相等的数。</p>
<p>法二(更好的方法)：充分利用二分查找直接找到第一个k和最后一个k，二者索引相减即为出现的个数。时间o(logn)</p>
<p>什么时候是第一个k：找到的k的前面一个元素如果不等于k，则此时是第一个k</p>
<p>什么时候是最后一个k：找到的k的后面一个元素如果不等于k，则此时是第一个k</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计指定数字在排序数组中出现的次数。思路：充分利用二分查找第一个k和最后一个k的位置，两者的区间长度即为所求次数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找左边第一个k的位置</span></span><br><span class="line">    <span class="keyword">int</span> left = getFirst(array, k);</span><br><span class="line">    <span class="keyword">int</span> right = getLast(array, k);</span><br><span class="line">    <span class="keyword">if</span>(left==-<span class="number">1</span> || right==-<span class="number">1</span>)&#123;<span class="comment">//数组中没有k</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">return</span> right-left+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找第一个k的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (mid&gt;left&amp;&amp;nums[mid-<span class="number">1</span>]!=k) || mid==left)&#123;<span class="comment">//找到第一个k</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//不是第一个k，继续往左边找</span></span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)&#123;<span class="comment">//k在右边</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//k在左边</span></span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//没找到k，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找最后一个k的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==k)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (mid&lt;right&amp;&amp;nums[mid+<span class="number">1</span>]!=k) || mid==right)&#123;<span class="comment">//找到最后一个k</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//不是最后一个k，继续往右边找</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;k)&#123;<span class="comment">//k在右边</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//k在左边</span></span><br><span class="line">            right = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//没找到k，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">11</span>&#125;;<span class="comment">//out:7</span></span><br><span class="line">    System.out.println(GetNumberOfK(nums, <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="8"></a></p>
<h2 id="8-二维数组中的查找"><a href="#8-二维数组中的查找" class="headerlink" title="8.二维数组中的查找"></a>8.二维数组中的查找</h2><p>《剑指offer》p44、leetcode74</p>
<p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路：从二维数组右上角开始查找，因为从右上角/左下角开始比较的话若不相等可以删除不符合条件的一行或者一列</p>
<p>以右上角为例，若相等则返回true；若target比右上角大，说明目标在其下面，则删除所在行；若target比右上角小，说明目标在其左侧，则删除所在列</p>
<p>以左上角为例，若target比左上角大，则不能缩小范围，因为右侧和下侧的元素都比左上角，右下角同理，pass！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(array[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = array[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i][j] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;array[i][j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="9"></a></p>
<h2 id="9-替换空格"><a href="#9-替换空格" class="headerlink" title="9.替换空格"></a>9.替换空格</h2><p>《剑指offer》p51</p>
<p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>思路：先遍历字符串计算空格出现次数，然后设置新数组大小，从后往前遍历数组，替换空格。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newLen = str.length() + cnt*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span>[] newStr = <span class="keyword">new</span> <span class="keyword">char</span>[newLen];</span><br><span class="line">        <span class="keyword">int</span> i = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = newLen-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">                newStr[j--] = <span class="string">'0'</span>;</span><br><span class="line">                newStr[j--] = <span class="string">'2'</span>;</span><br><span class="line">                newStr[j--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                newStr[j--] = str.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(newStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="10"></a></p>
<h2 id="10-Replace-Words–字典树"><a href="#10-Replace-Words–字典树" class="headerlink" title="10.Replace Words–字典树"></a>10.Replace Words–字典树</h2><p>LeetCode 648. Replace Words 字典树练习</p>
<p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p>
<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with theroot forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p>
<p>You need to output the sentence after the replacement.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: dict &#x3D; [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]</span><br><span class="line">sentence &#x3D; &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">Output: &quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure>

<p>题意：用字典中存在的前缀代替句子中的单词，若有多个前缀可以表示单词，则选择最短的一个<br>​<br>暴力思路：1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根(换长度最小的那个); 2.将words数组重新组成sentence返回即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根</span></span><br><span class="line">        String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(String root: dict)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[i].startsWith(root) &amp;&amp; root.length()&lt;min)&#123;</span><br><span class="line">                    words[i] = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//2.将words数组重新组成sentence返回即可</span></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">            res.append(words[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化思路(字典树):这道题给了我们一个前缀字典，又给了一个句子，让我们将句子中较长的单词换成其前缀(如果在前缀字典中存在的话)。我们对于句子中的一个长单词如何找前缀呢，是不是可以根据第一个字母来快速定位呢，比如cattle这个单词的首字母是c，那么我们在前缀字典中找所有开头是c的前缀，为了方便查找，我们<strong>将首字母相同的前缀都放到同一个数组中，总共需要26个数组</strong>，所以我们可以定义一个二维数组来装这些前缀。还有，我们希望短前缀在长前缀的前面，因为题目中要求用最短的前缀来替换单词，所以我们可以<strong>先按单词的长度来给所有的前缀排序</strong>，然后再依次加入对应的数组中，这样就可以保证短的前缀在前面。</p>
<p>提交显示暴力思路50ms，优化思路19ms，优化的还不错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceWords</span><span class="params">(List&lt;String&gt; dict, String sentence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.roots数组按长度排序</span></span><br><span class="line">    Collections.sort(dict);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.构建字典树，采用HashMap，用首字母索引，首字母相同的前缀都放到同一个数组中，总共需要26个数组</span></span><br><span class="line">    Map&lt;Integer, ArrayList&lt;String&gt;&gt; wordTree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dict.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> wordIndex =  dict.get(i).charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!wordTree.containsKey(wordIndex))&#123;</span><br><span class="line">            wordTree.put(wordIndex, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        wordTree.get(wordIndex).add(dict.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//3.将sentencesplit(" ")分成words单词数组，每个单词通过字典树进行前缀判断，有词根的换成词根</span></span><br><span class="line">    String[] words = sentence.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> wordIndex = words[i].charAt(<span class="number">0</span>)-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(wordTree.containsKey(wordIndex))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;wordTree.get(wordIndex).size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[i].startsWith(wordTree.get(wordIndex).get(j)))&#123;</span><br><span class="line">                    words[i] = wordTree.get(wordIndex).get(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//4.将words数组重新组成sentence返回即可</span></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">        res.append(words[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="11"></a></p>
<h2 id="11-Find-And-Replace-in-String"><a href="#11-Find-And-Replace-in-String" class="headerlink" title="11.Find And Replace in String"></a>11.Find And Replace in String</h2><p>LeetCode 833. Find And Replace in String</p>
<p>题目：To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;abcd&quot;, indexes &#x3D; [0,2], sources &#x3D; [&quot;a&quot;,&quot;cd&quot;], targets &#x3D; [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeebffff&quot;</span><br><span class="line">Explanation: &quot;a&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;.</span><br><span class="line">&quot;cd&quot; starts at index 2 in S, so it&#39;s replaced by &quot;ffff&quot;.</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;abcd&quot;, indexes &#x3D; [0,2], sources &#x3D; [&quot;ab&quot;,&quot;ec&quot;], targets &#x3D; [&quot;eee&quot;,&quot;ffff&quot;]</span><br><span class="line">Output: &quot;eeecd&quot;</span><br><span class="line">Explanation: &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. </span><br><span class="line">&quot;ec&quot; doesn&#39;t starts at index 2 in the original S, so we do nothing.</span><br></pre></td></tr></table></figure>

<p>题目大意：给了原始的字符串S，给出了要开始替换的位置indexes，判断S在indexes的位置向后是否能匹配sources中对应位置的元素，如果相等，则把S的该部分替换成targets对应的部分。</p>
<p>思路：</p>
<p>不可能直接对S进行替换操作的，因为那样直接改变了S的值和长度，影响以后的匹配操作。</p>
<p>而应该将原字符串S按照indexs拆分成几段子字符串，然后分别进行替换，最终拼接返回即可。同时应该从右往左处理原字符串，替换用replaceFirst()</p>
<p>将indexes按逆序排序，然后对S从右往左依次查找可替换的单词，如果出现在指定位置，则替换。由于indexes排序后，会变化，因此需要用map结构保存原来的索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">findReplaceString</span><span class="params">(String S, <span class="keyword">int</span>[] indexes, String[] sources, String[] targets)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S==<span class="keyword">null</span> || S.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于indexes排序后，会变化，因此需要用map结构保存原来的索引。</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key:index[i] value:i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;indexes.length; ++i)&#123;</span><br><span class="line">        map.put(indexes[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将indexes按排序</span></span><br><span class="line">    Arrays.sort(indexes);</span><br><span class="line">    <span class="comment">//将原字符串S按照indexs拆分成几段子字符串，然后分别进行判断</span></span><br><span class="line">    String[] words = <span class="keyword">new</span> String[indexes.length+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//字符串从右往左处理，同时index也从最大到最小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=indexes.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        String last;<span class="comment">//当前需要处理的子字符串，判断是否需要替换</span></span><br><span class="line">        <span class="keyword">if</span>(i==indexes.length-<span class="number">1</span>)&#123;</span><br><span class="line">            last = S.substring(indexes[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last = S.substring(indexes[i], indexes[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tempIndex = map.get(indexes[i]); <span class="comment">//当前字符串对应的index</span></span><br><span class="line">        <span class="keyword">if</span>(last.startsWith(sources[tempIndex]))&#123;</span><br><span class="line">            words[i+<span class="number">1</span>] = last.replaceFirst(sources[tempIndex],targets[tempIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            words[i+<span class="number">1</span>] = last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    words[<span class="number">0</span>] = S.substring(<span class="number">0</span>,indexes[<span class="number">0</span>]).replaceFirst(sources[<span class="number">0</span>],targets[<span class="number">0</span>]);<span class="comment">//最前面的字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将替换完的words数组拼接成最终的字符串</span></span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;words.length; ++i)&#123;</span><br><span class="line">        res.append(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="12"></a></p>
<h2 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12.从尾到头打印链表"></a>12.从尾到头打印链表</h2><p>《剑指offer》p58.</p>
<p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p>思路：</p>
<p>法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可</p>
<p>法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可</p>
<p>法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可</p>
<p>法四：递归实现，从头遍历链表，但是递归实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ListNode p = listNode;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.add(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead2</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = listNode;</span><br><span class="line">    ListNode cur = p.next;</span><br><span class="line">    p.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode temp = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        temp.next = p;</span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.add(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead3</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode p = listNode;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(p.val);</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        res.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//法四：递归实现，从头遍历链表，但是递归实现</span></span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead4</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        printListFromTailToHead4(listNode.next);</span><br><span class="line">        res.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="13"></a></p>
<h2 id="13-反转链表-三道"><a href="#13-反转链表-三道" class="headerlink" title="13.反转链表(三道)"></a>13.反转链表(三道)</h2><h3 id="1-反转全部链表"><a href="#1-反转全部链表" class="headerlink" title="1.反转全部链表"></a>1.反转全部链表</h3><p>《剑指offer》p142、《左神》p40、leetcode206</p>
<p>题目：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>思路：头插法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head;</span><br><span class="line">        head = head.next;</span><br><span class="line">        newHead.next = <span class="keyword">null</span>; <span class="comment">//这步别忘了</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tempNode = head;</span><br><span class="line">            <span class="comment">//原链表继续遍历下一个</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="comment">//头插法</span></span><br><span class="line">            tempNode.next = newHead;</span><br><span class="line">            newHead = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-反转部分链表"><a href="#2-反转部分链表" class="headerlink" title="2.反转部分链表"></a>2.反转部分链表</h3><p>《左神》p42、leetcode92</p>
<p>题目：这道题目规定了要进行反转的位置区间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m &#x3D; 2, n &#x3D; 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>思路：我们要先<strong>添加一个哨兵</strong>，指向head节点（最后返回头指针的next即可）；然后一直往后访问，一直到要反转的节点的前一位停下来。</p>
<p>我们要<strong>记录下两个节点的位置</strong>：开始反转位置的节点的前一位、开始反转位置的节点。因为在反转后，开始反转的节点的前一个节点的next指针要指向反转的最后一个节点，开始反转的节点的next要指向反转的最后一个节点的后一个节点。</p>
<p>然后<strong>进行与上面一题同样的反转即可</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || m&gt;=n || m&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.哨兵，这样不用考虑m==1从头反转的问题，都转化成从中间反转</span></span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    guard.next = head;</span><br><span class="line">    ListNode p = guard;</span><br><span class="line">    <span class="comment">//2..将p移到要反转部分的前一个节点，移动次数为m-1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;<span class="comment">//如果遍历完链表都没有加到m，则不需要反转</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p.next==<span class="keyword">null</span> || p.next.next==<span class="keyword">null</span>)&#123;<span class="comment">//需要反转的部分为空或者只有一个节点，则不需要反转</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.保存反转部分的前一个节点</span></span><br><span class="line">    ListNode pre = p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.反转部分链表(头插法)</span></span><br><span class="line">    p = p.next;</span><br><span class="line">    ListNode cur = p.next;</span><br><span class="line">    p.next=<span class="keyword">null</span>;</span><br><span class="line">    ListNode last = p;<span class="comment">//保存反转部分的最后一个节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m; i&lt;n; ++i)&#123;</span><br><span class="line">        ListNode temp = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        temp.next = p;</span><br><span class="line">        p = temp;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.拼接反转部分前，反转部分，反转部分后的链表</span></span><br><span class="line">    last.next = cur;</span><br><span class="line">    pre.next = p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-分组翻转链表"><a href="#3-分组翻转链表" class="headerlink" title="3.分组翻转链表"></a>3.分组翻转链表</h3><p>leetcode 25 Reverse Nodes in k-Group、《左神》68</p>
<p>题目：将链表的每k个节点逆序。给定一个单链表的头结点head，实现一个调整单链表的函数，使得每k个节点之间逆序，如果最后不管k个节点一组，则不调整最后几个节点。</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">For k &#x3D; 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line">For k &#x3D; 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<p>思路：先遍历一次链表记录长度，然后分组进行翻转即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || k&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.遍历一遍链表记录链表长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.分组翻转链表</span></span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//哨兵</span></span><br><span class="line">    guard.next = head;</span><br><span class="line">    ListNode pre = guard;<span class="comment">//缓存翻转后的尾节点指针</span></span><br><span class="line">    ListNode cur = guard.next;<span class="comment">//哨兵</span></span><br><span class="line">    ListNode last = cur;<span class="comment">//缓存翻转后的尾节点指针</span></span><br><span class="line">    <span class="keyword">while</span>(len&gt;=k)&#123;<span class="comment">//翻转这么多次</span></span><br><span class="line">        len -= k;</span><br><span class="line">        <span class="keyword">int</span> tempK = k;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tempK!=<span class="number">0</span>)&#123;<span class="comment">//每次翻转k个节点</span></span><br><span class="line">            ListNode temp = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            temp.next = pre.next;<span class="comment">//头插法</span></span><br><span class="line">            pre.next = temp;</span><br><span class="line">            tempK--;</span><br><span class="line">        &#125;</span><br><span class="line">        last.next = cur;<span class="comment">//翻转后的链表尾部连接到需要反转部分的下一个节点</span></span><br><span class="line">        pre = last;</span><br><span class="line">        last = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="14"></a></p>
<h2 id="14-根据前序-中序遍历数组来重建二叉树"><a href="#14-根据前序-中序遍历数组来重建二叉树" class="headerlink" title="14.根据前序+中序遍历数组来重建二叉树"></a>14.根据前序+中序遍历数组来重建二叉树</h2><p>《剑指offer》p62、leetcode105</p>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>思路：在函数recon中，先根据前序遍历数组的第一个数字创建根节点，之后在中序遍历数组中找到根节点的位置，这样就能确定左、右子树节点的数量。在前序遍历和中序遍历数组中划分了左、右子树节点的值之后，就可以递归地调用函数recon去分别构建它的左、右子树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder==<span class="keyword">null</span> || preorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recon(preorder, <span class="number">0</span>, preorder.length-<span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归重建二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recon</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart&gt;preEnd || inStart&gt;inEnd)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preStart]);<span class="comment">//前序遍历第一个节点为根节点</span></span><br><span class="line">        <span class="keyword">int</span> rootIndex = findRootIndex(inorder, inStart, inEnd, root.val);<span class="comment">//前序遍历的根节点在中序遍历数组的位置索引</span></span><br><span class="line">        <span class="keyword">int</span> leftCnt = rootIndex-inStart;<span class="comment">//左子树节点的个数</span></span><br><span class="line">        root.left = recon(preorder, preStart+<span class="number">1</span>, preStart+leftCnt, inorder, inStart, rootIndex-<span class="number">1</span>);</span><br><span class="line">        root.right = recon(preorder, preStart+leftCnt+<span class="number">1</span>, preEnd, inorder, rootIndex+<span class="number">1</span>, inEnd);</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//找到根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRootIndex</span><span class="params">(<span class="keyword">int</span>[] order, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(order[i]==root)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="15"></a></p>
<h2 id="15-二叉树的下一个节点"><a href="#15-二叉树的下一个节点" class="headerlink" title="15.二叉树的下一个节点"></a>15.二叉树的下一个节点</h2><p>《剑指offer》p65.</p>
<p>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p>思路：这个节点可以分为三种情况<br>​    </p>
<blockquote>
<p>1.该节点有右子树：下一个节点就是它的右子树中最左子节点</p>
<p>2.该节点没有右子树且是父节点的左子节点：下一个节点就是它的父节点</p>
<p>3.该节点没有右子树且是父节点的右子节点：沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode next = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该节点有右子树，返回其右子树中最左的子节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span>(pNode.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该节点没有右子树</span></span><br><span class="line">        <span class="keyword">while</span>(pNode.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//该节点是父节点的左子节点，返回父节点</span></span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left== pNode)&#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该节点是父节点的右子节点，沿着指向父节点的指针一直向上遍历，</span></span><br><span class="line">            <span class="comment">// 直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点</span></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第3中情况下一直向上遍历到根节点，则没有要找的下一个节点，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="16"></a></p>
<h2 id="16-Populating-Next-Right-Pointers-in-Each-Node"><a href="#16-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="16.Populating Next Right Pointers in Each Node"></a>16.Populating Next Right Pointers in Each Node</h2><p>leetcode 116.</p>
<p>题目：Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>题目大意：将满二叉树每个节点的next指针赋值，每个节点的next指针指向同一层的下一个节点，要求空间复杂度是O(1)。本题的前提是给定的二叉树是满二叉树，即所有的叶子节点都在同一层。举例如下</p>
<p>原始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4  5  6  7</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">4-&gt;5-&gt;6-&gt;7 -&gt; NULL</span><br></pre></td></tr></table></figure>

<p>思路：如果有下一层的话，为下一层的子节点的next指针赋值。每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器，并且不用递归，循环层即可完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeLinkNode pRoot = root;</span><br><span class="line">    TreeLinkNode guard = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);<span class="comment">//哨兵，指向下一层的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>)&#123;<span class="comment">//层的循环</span></span><br><span class="line">        guard.next=<span class="keyword">null</span>;<span class="comment">//哨兵，指向下一层的第一个节点</span></span><br><span class="line">        TreeLinkNode cur = guard;</span><br><span class="line">        <span class="keyword">if</span>(pRoot.left!=<span class="keyword">null</span>) &#123;<span class="comment">//如果有下层的话</span></span><br><span class="line">            <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>)&#123;<span class="comment">//依次为下一层的每个节点next指针</span></span><br><span class="line">                cur.next = pRoot.left;</span><br><span class="line">                cur.next.next = pRoot.right;</span><br><span class="line">                cur = cur.next.next;</span><br><span class="line">                pRoot = pRoot.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pRoot = guard.next;<span class="comment">//进入下一层的第一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="17"></a></p>
<h2 id="17-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#17-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="17.Populating Next Right Pointers in Each Node II"></a>17.Populating Next Right Pointers in Each Node II</h2><p>leetcode 117.Populating Next Right Pointers in Each Node</p>
<p>题目：本题要求和上面一样，不同的是这里给定的二叉树不一定是满二叉树。You may only use constant extra space</p>
<p>原始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2    3</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4   5    7</span><br></pre></td></tr></table></figure>

<p>变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1 -&gt; NULL</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  2 -&gt; 3 -&gt; NULL</span><br><span class="line"> &#x2F; \    \</span><br><span class="line">4-&gt; 5 -&gt; 7 -&gt; NULL</span><br></pre></td></tr></table></figure>

<p>思路：因为可能不是满二叉树而是任意二叉树，所以下一层的第一个节点需要手动寻找，我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeLinkNode pRoot = root;</span><br><span class="line">    <span class="comment">//我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个哨兵，代表第一个节点</span></span><br><span class="line">    TreeLinkNode guard = <span class="keyword">new</span> TreeLinkNode(<span class="number">0</span>);<span class="comment">//哨兵，指向下一层的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        guard.next=<span class="keyword">null</span>;<span class="comment">//哨兵，指向下一层的第一个节点</span></span><br><span class="line">        TreeLinkNode cur = guard;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(pRoot!=<span class="keyword">null</span>)&#123;<span class="comment">//依次为下一层的节点next指针赋值</span></span><br><span class="line">            <span class="keyword">if</span>(pRoot.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = pRoot.left;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pRoot.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                cur.next = pRoot.right;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pRoot = pRoot.next;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        pRoot = guard.next;<span class="comment">//进入下一层(下一层的root从下一层的第一个节点guard.next开始)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="18"></a></p>
<h2 id="18-两个栈实现队列"><a href="#18-两个栈实现队列" class="headerlink" title="18.两个栈实现队列"></a>18.两个栈实现队列</h2><p>《剑指offer》p68、leetcode232、《左神》5</p>
<p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="19"></a></p>
<h2 id="19-两个队列实现栈"><a href="#19-两个队列实现栈" class="headerlink" title="19.两个队列实现栈"></a>19.两个队列实现栈</h2><p>《剑指offer》p71、leetcode225</p>
<p>题目：两个队列实现栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; que1;</span><br><span class="line">    Queue&lt;Integer&gt; que2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        que2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que1.isEmpty())&#123;</span><br><span class="line">            que1.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            que2.offer(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = que1.poll();</span><br><span class="line">            <span class="keyword">if</span>(que1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                que2.offer(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = que2.poll();</span><br><span class="line">            <span class="keyword">if</span>(que2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                que1.offer(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = que1.poll();</span><br><span class="line">            que2.offer(temp);</span><br><span class="line">            <span class="keyword">if</span>(que1.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span>(!que2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = que2.poll();</span><br><span class="line">            que1.offer(temp);</span><br><span class="line">            <span class="keyword">if</span>(que2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty() &amp;&amp; que2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="20"></a></p>
<h2 id="20-斐波那契数列-三道"><a href="#20-斐波那契数列-三道" class="headerlink" title="20.斐波那契数列(三道)"></a>20.斐波那契数列(三道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列--《剑指offer》p75 </span><br><span class="line">青蛙跳台阶--《剑指offer》p77、leetcode 70</span><br><span class="line">变态跳台阶--牛客网</span><br></pre></td></tr></table></figure>

<h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h3><p>《剑指offer》p75</p>
<p>题目：大家都知道斐波那契数列f(n)=f(n-1)+f(n-2)，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p>
<p>思路：动态规划问题。解法：自上而下递归分析，自下而上循环实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = n1+n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-青蛙跳台阶"><a href="#2-青蛙跳台阶" class="headerlink" title="2.青蛙跳台阶"></a>2.青蛙跳台阶</h3><p>《剑指offer》p77、leetcode 70</p>
<p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p>
<p>思路：就是斐波那切数列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=target; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-变态跳台阶"><a href="#3-变态跳台阶" class="headerlink" title="3.变态跳台阶"></a>3.变态跳台阶</h3><p>牛客网上的</p>
<p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>思路：动态规划分析：f(n)=f(n-1)+f(n-2)+…f(1)+1，因此需要数组来缓存之前的值，但其实不需要数组，直接用变量来缓存即可，即f(n)=之前的和+1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(target==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sumTemp = <span class="number">3</span>;<span class="comment">//缓存之前的和</span></span><br><span class="line">    <span class="keyword">int</span> resTemp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;=target; ++i)&#123;</span><br><span class="line">        resTemp = sumTemp+<span class="number">1</span>;<span class="comment">//当前的结果值</span></span><br><span class="line">        sumTemp += resTemp; <span class="comment">//把当前的结果值加到缓存和中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="21"></a></p>
<h2 id="21-斐波那契数列变种-两道"><a href="#21-斐波那契数列变种-两道" class="headerlink" title="21.斐波那契数列变种(两道)"></a>21.斐波那契数列变种(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Length of Longest Fibonacci Subsequence--leetcode 873 </span><br><span class="line">Split Array into Fibonacci Sequence--leetcode842</span><br></pre></td></tr></table></figure>

<h3 id="1-Length-of-Longest-Fibonacci-Subsequence"><a href="#1-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="1.Length of Longest Fibonacci Subsequence"></a>1.Length of Longest Fibonacci Subsequence</h3><p>leetcode 873</p>
<p>题目：给定一个严格递增的正整数数组形成序列 A ，找到A中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>
<p>子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7,8]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">The longest subsequence that is fibonacci-like: [1,2,3,5,8].</span><br></pre></td></tr></table></figure>

<p>思路：动态规划问题。二维dp问题。</p>
<p>使用一维DP解决不了这个问题，因为一维DP只保存了到某个为止的最长斐波那契数列，但是新的数字到来之后能不能满足之前的费布拉奇数列是未知的。所以使用二维DP。</p>
<p>dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。</p>
<p>核心方程：dp[j][k]=dp[i][j]+1</p>
<p>条件是 A[i] + A[j] = A[k]</p>
<p>这个算法的时间复杂度是O(n^2)，空间复杂度是O(n^2).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维dp问题。dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。</span></span><br><span class="line"><span class="comment">//核心方程：dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = A.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][m];<span class="comment">//dp[i][j]表示以A[i]、A[j]结尾的斐波那契数列长度，初始化为2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;m; ++j)&#123;</span><br><span class="line">            dp[i][j] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//map存放A[]数组便于下面查找。key:a[i], value:i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; ++i)&#123;</span><br><span class="line">        map.put(A[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=j+<span class="number">1</span>; k&lt;m; ++k)&#123;</span><br><span class="line">            <span class="keyword">int</span> a_i = A[k]-A[j];</span><br><span class="line">            <span class="keyword">if</span>(a_i&lt;A[j] &amp;&amp; map.containsKey(a_i))&#123;</span><br><span class="line">                dp[j][k] = Math.max(dp[j][k], dp[map.get(a_i)][j]+<span class="number">1</span>);</span><br><span class="line">                res = Math.max(res, dp[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Split-Array-into-Fibonacci-Sequence"><a href="#2-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="2.Split Array into Fibonacci Sequence"></a>2.Split Array into Fibonacci Sequence</h3><p>leetcode 842、与leetcode 306类似</p>
<p>题目：给出了一个有0-9数字组成的纯数字字符串。判断能否组成斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。最终要返回的是任何一个组合即可。</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;123456579&quot;</span><br><span class="line">Output: [123,456,579]</span><br></pre></td></tr></table></figure>

<p>思路:回溯法。本题和下面的刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p>
<p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p>
<p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p>
<p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p>
<p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p>
<p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p>
<p>本题需要把斐波那契数列的各个数字存起来，同时还要注意要防止int溢出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = S.length();</span><br><span class="line">    List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(L-<span class="number">1</span>)/<span class="number">2</span>; ++i)&#123;<span class="comment">//第一个数的长度为[1,(L-1)/2]</span></span><br><span class="line">        String s1 = S.substring(<span class="number">0</span>,i);<span class="comment">//第一个数</span></span><br><span class="line">        <span class="keyword">if</span>(S.startsWith(<span class="string">"0"</span>) &amp;&amp; s1.length()&gt;<span class="number">1</span>)&#123;<span class="comment">//第一个数长度超过2起始位不能为0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long num1 = Long.valueOf(s1);</span><br><span class="line">        <span class="keyword">if</span>(num1&gt;Integer.MAX_VALUE)&#123;<span class="comment">//防止int溢出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=L-<span class="number">1</span>&amp;&amp;(L-j)&gt;=(j-i)&amp;&amp;(L-j)&gt;=i; ++j)&#123;<span class="comment">//第三个数大于等于第一、第二个数</span></span><br><span class="line">            String s2 = S.substring(i,j);<span class="comment">//第二个数</span></span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i)==<span class="string">'0'</span> &amp;&amp; s2.length()&gt;<span class="number">1</span>)&#123;<span class="comment">//第二个数长度超过2起始位不能为0</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Long num2 = Long.valueOf(s2);</span><br><span class="line">            <span class="keyword">if</span>(num2&gt;Integer.MAX_VALUE)&#123;<span class="comment">//防止int溢出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span>(isValid(S.substring(j), num1, num2, res))&#123;<span class="comment">//进行斐波那契判断</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res.clear();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String S, <span class="keyword">long</span> num1, <span class="keyword">long</span> num2, List&lt;Integer&gt; temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.equals(<span class="string">""</span>))&#123;<span class="comment">//递归结束</span></span><br><span class="line">        temp.add((<span class="keyword">int</span>) num1);</span><br><span class="line">        temp.add((<span class="keyword">int</span>) num2);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;Integer.MAX_VALUE)&#123;<span class="comment">//防止int溢出</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String sumStr = <span class="string">""</span> + sum;</span><br><span class="line">    <span class="keyword">if</span>(sumStr.length()&gt;<span class="number">1</span> &amp;&amp; S.startsWith(<span class="string">"0"</span>))&#123;<span class="comment">//如果和的长度大于1，则起始位不能是0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//剪枝，回溯点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(S.startsWith(sumStr))&#123;</span><br><span class="line">        temp.add((<span class="keyword">int</span>) num1);</span><br><span class="line">        <span class="keyword">return</span> isValid(S.substring(sumStr.length()), num2, sum, temp);<span class="comment">//递归判断</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        temp.clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="22"></a></p>
<h2 id="22-Additive-Number"><a href="#22-Additive-Number" class="headerlink" title="22.Additive Number"></a>22.Additive Number</h2><p>leetcode 306</p>
<p>题目：给出了一个有0-9数字组成的纯数字字符串。判断它能不能组成所谓的“加法数字”，即斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。</p>
<p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;112358&quot;</span><br><span class="line">Output: true </span><br><span class="line">Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. </span><br><span class="line">1 + 1 &#x3D; 2, 1 + 2 &#x3D; 3, 2 + 3 &#x3D; 5, 3 + 5 &#x3D; 8</span><br><span class="line">	</span><br><span class="line">Input: &quot;199100199&quot;</span><br><span class="line">Output: true </span><br><span class="line">Explanation: The additive sequence is: 1, 99, 100, 199.</span><br><span class="line">1 + 99 &#x3D; 100, 99 + 100 &#x3D; 199</span><br></pre></td></tr></table></figure>

<p>思路:回溯法。刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p>
<p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p>
<p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p>
<p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p>
<p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p>
<p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯法问题。关键在于确定前两个数即可。</span></span><br><span class="line"><span class="comment">//三个数的长度: 第一个数,[0,i)，长度为i；第二个数,[i,j)长度为j-i; 第三个数(和):[j,L-1],长度L-j</span></span><br><span class="line"><span class="comment">//三个数的长度最长的范围：第一个数长度上限:x=(L-1)/2; 第二个数长度下限：y=x，第三个数长度下限: y</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = num.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(L-<span class="number">1</span>)/<span class="number">2</span>; ++i)&#123;<span class="comment">//i从1起，第一个数长度至少为1</span></span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(num.startsWith(<span class="string">"0"</span>) &amp;&amp; i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//第一个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环</span></span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=L-<span class="number">1</span> &amp;&amp; (L-j)&gt;=i &amp;&amp; (L-j)&gt;=(j-i); ++j)&#123;<span class="comment">//第三个数长度不小于第一个数，第三个数长度不小于第二个数</span></span><br><span class="line">            <span class="keyword">if</span>(num.charAt(i)==<span class="string">'0'</span> &amp;&amp; j-i&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//第二个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环</span></span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">long</span> num1 = Long.valueOf(num.substring(<span class="number">0</span>, i));<span class="comment">//第一个数</span></span><br><span class="line">            <span class="keyword">long</span> num2 = Long.valueOf(num.substring(i, j));<span class="comment">//第二个数</span></span><br><span class="line">	</span><br><span class="line">            <span class="keyword">if</span>(isAdditive(num.substring(j), num1, num2))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//找到满足斐波那契条件的一个划分序列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAdditive</span><span class="params">(String num, <span class="keyword">long</span> num1, <span class="keyword">long</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num.equals(<span class="string">""</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//递归结束，回溯点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> sum = num1+num2;</span><br><span class="line">    String sumStr = <span class="string">""</span> + sum;</span><br><span class="line">    <span class="keyword">int</span> sumLen = sumStr.length();</span><br><span class="line">    <span class="keyword">if</span>(sumLen&gt;<span class="number">1</span> &amp;&amp; num.startsWith(<span class="string">"0"</span>))&#123;<span class="comment">//如果和的长度大于1，则起始位不能是0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//剪枝，回溯点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num.startsWith(sumStr))&#123;<span class="comment">//如果和在字符串中，则进行下一次递归</span></span><br><span class="line">        <span class="keyword">return</span> isAdditive(num.substring(sumLen), num2, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String num = <span class="string">"123"</span>;</span><br><span class="line">    System.out.println(isAdditiveNumber(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="23"></a></p>
<h2 id="23-旋转数组的最小数字-三道"><a href="#23-旋转数组的最小数字-三道" class="headerlink" title="23.旋转数组的最小数字(三道)"></a>23.旋转数组的最小数字(三道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》p82</span><br><span class="line">Find Minimum in Rotated Sorted Array--leetcode153</span><br><span class="line">Find Minimum in Rotated Sorted Array 2--leetcode154</span><br></pre></td></tr></table></figure>

<h3 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="1.旋转数组的最小数字"></a>1.旋转数组的最小数字</h3><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>普通二分查找思路：顺序解法o(n)，从头到尾遍历数组一次，我们就能找出最小的数字。但本题部分排序，排序的题优先考虑二分查找，因此采用二分查找的双指针的思路，o(logn)。</p>
<p><strong>两个指针代表两大阵营</strong>(原数组/旋转的那部分数组)，最终会相邻，第二个指针指向的刚好是最小的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里是部分排序的数组，考虑二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;<span class="comment">//二分查找</span></span><br><span class="line">        <span class="comment">//结束条件：两个指针最终会相邻，代表两大阵营(原数组/旋转的那部分数组)，第二个指针指向的刚好是最小的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>==right)&#123;<span class="comment">//结束条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[right]&lt;nums[<span class="number">0</span>])&#123;<span class="comment">//也可能存在原数组没旋转的情况</span></span><br><span class="line">                <span class="keyword">return</span> nums[right];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//特殊情况，当left、right、mid对应的三个数相等时，无法判断最小的数位于哪一边，因此要顺序查找</span></span><br><span class="line">        <span class="keyword">if</span>(array[mid]==array[left]&amp;&amp;array[mid]==array[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> search(array,left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[mid]&gt;=array[left])&#123;<span class="comment">//最小值在右半边</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;=array[right])&#123;<span class="comment">//最小值在左半边</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[left];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=left+<span class="number">1</span>; i&lt;=right; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;array[i-<span class="number">1</span>])&#123;<span class="comment">//顺序查找，注意这里也不是完全遍历，而是第一个比之前小的数就是所求</span></span><br><span class="line">            <span class="keyword">return</span> array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>牛客网答案区很干练的二分查找思路：(仅供参考一般想不到，还是用上面自己想的即可)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">采用二分法解答这个问题，</span><br><span class="line">mid &#x3D; low + (high - low)&#x2F;2</span><br><span class="line">需要考虑三种情况：</span><br><span class="line">(1)array[mid] &gt; array[high]:</span><br><span class="line">出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。</span><br><span class="line">low &#x3D; mid + 1</span><br><span class="line">(2)array[mid] &#x3D;&#x3D; array[high]:</span><br><span class="line">出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边</span><br><span class="line">还是右边,这时只好一个一个试 ，</span><br><span class="line">high &#x3D; high - 1</span><br><span class="line">(3)array[mid] &lt; array[high]:</span><br><span class="line">出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左</span><br><span class="line">边。因为右边必然都是递增的。</span><br><span class="line">high &#x3D; mid</span><br><span class="line">注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字</span><br><span class="line">比如 array &#x3D; [4,6]</span><br><span class="line">array[low] &#x3D; 4 ;array[mid] &#x3D; 4 ; array[high] &#x3D; 6 ;</span><br><span class="line">如果high &#x3D; mid - 1，就会产生错误， 因此high &#x3D; mid</span><br><span class="line">但情形(1)中low &#x3D; mid + 1就不会错误</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = array.length - <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;        </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Find-Minimum-in-Rotated-Sorted-Array-2"><a href="#2-Find-Minimum-in-Rotated-Sorted-Array-2" class="headerlink" title="2.Find Minimum in Rotated Sorted Array 2"></a>2.Find Minimum in Rotated Sorted Array 2</h3><p>leetcode154</p>
<p>题目：和153一样，这里新增数组可以有重复数字，如[1,3,3,3]</p>
<p>思路：思路还是一样，就是需要考虑重复的问题，改动如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//left、right代表原数组、旋转数组两大阵营，结束条件是相邻</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left+<span class="number">1</span>==right)&#123;<span class="comment">//结束条件</span></span><br><span class="line">            <span class="keyword">if</span>(nums[right]&lt;nums[<span class="number">0</span>])&#123;<span class="comment">//也可能存在原数组没旋转的情况</span></span><br><span class="line">                <span class="keyword">return</span> nums[right];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==nums[left]&amp;&amp; nums[mid]==nums[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> search(nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;=nums[left])&#123;<span class="comment">//在右半边</span></span><br><span class="line">            left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;=nums[right])&#123;<span class="comment">//在左半边</span></span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; ++i)&#123;</span><br><span class="line">        min = Math.min(min, array[i]);<span class="comment">//顺序查找，注意这里必须完全全部遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="24"></a></p>
<h2 id="24-矩阵中的路径"><a href="#24-矩阵中的路径" class="headerlink" title="24.矩阵中的路径"></a>24.矩阵中的路径</h2><p>《剑指offer》p89、leetcode 79</p>
<p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b c e</span><br><span class="line">s f c s</span><br><span class="line">a d e e</span><br></pre></td></tr></table></figure>

<p>思路：二维矩阵中路径查找问题通常用回溯法。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法可以看成蛮力法的升级版。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(matrix==<span class="keyword">null</span> || matrix.length&lt;str.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//路径查找中，不能重复进入相同的格子，因此需要设置标记矩阵，初始为false</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;rows; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;cols; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">            <span class="keyword">if</span>(matrix[index]==str[<span class="number">0</span>])&#123;<span class="comment">//如果第一个字符匹配，则开始回溯法匹配路径</span></span><br><span class="line">                <span class="keyword">if</span>(isPath(matrix,rows,cols,i,j,str,<span class="number">0</span>, visited))&#123;<span class="comment">//匹配成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] str, <span class="keyword">int</span> strIndex, <span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strIndex==str.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//查找完成，找到路径的结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = i*cols+j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || visited[index]==<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//查找到边界外或已经访问过，false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(matrix[index]==str[strIndex])&#123;<span class="comment">//如果当前字符匹配，则开始回溯法匹配路径</span></span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//上下左右回溯法查找</span></span><br><span class="line">        <span class="keyword">if</span>(isPath(matrix,rows,cols,i-<span class="number">1</span>,j,str,strIndex+<span class="number">1</span>, visited)</span><br><span class="line">                ||isPath(matrix,rows,cols,i+<span class="number">1</span>,j,str,strIndex+<span class="number">1</span>,visited)</span><br><span class="line">                ||isPath(matrix,rows,cols,i,j-<span class="number">1</span>,str,strIndex+<span class="number">1</span>,visited)</span><br><span class="line">                ||isPath(matrix,rows,cols,i,j+<span class="number">1</span>,str,strIndex+<span class="number">1</span>,visited))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[index] = <span class="keyword">false</span>;<span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>leetcode79的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(board==<span class="keyword">null</span> || board.length==<span class="number">0</span> || word==<span class="keyword">null</span> || word.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> m = board.length;</span><br><span class="line">    <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>((m*n)&lt;word.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];<span class="comment">//避免重复访问的标记数组，初始为false</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j]==word.charAt(<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPath(board, m, n, i, j, word, <span class="number">0</span>, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPath</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> strIndex, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strIndex==word.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//查找完成，结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n || visited[i][j]==<span class="keyword">true</span> || board[i][j]!=word.charAt(strIndex))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//剪枝，错误条件:访问越界或已经访问过或当前字符不匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(isPath(board, m, n, i-<span class="number">1</span>, j, word, strIndex+<span class="number">1</span>, visited)||</span><br><span class="line">            isPath(board, m, n, i+<span class="number">1</span>, j, word, strIndex+<span class="number">1</span>, visited)||</span><br><span class="line">            isPath(board, m, n, i, j-<span class="number">1</span>, word, strIndex+<span class="number">1</span>, visited)||</span><br><span class="line">            isPath(board, m, n, i, j+<span class="number">1</span>, word, strIndex+<span class="number">1</span>, visited))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    visited[i][j] = <span class="keyword">false</span>;<span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="25"></a></p>
<h2 id="25-机器人的运动范围"><a href="#25-机器人的运动范围" class="headerlink" title="25.机器人的运动范围"></a>25.机器人的运动范围</h2><p>《剑指offer》p92.</p>
<p>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：通常物体或人在二维矩阵运动这类问题够可以用回溯法解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;;<span class="comment">//最多可到达的格子数，存成数组便于参数传递修改</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];<span class="comment">//记录访问过的标记位数组，初始化为false</span></span><br><span class="line">    <span class="keyword">return</span> isPath(rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited, res, threshold);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//回溯法矩阵路径查找，返回能到达格子的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">isPath</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[] res, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=rows || j&gt;=cols || visited[i][j]==<span class="keyword">true</span> || (digitSum(i)+digitSum(j))&gt;k)&#123;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>];<span class="comment">//剪枝的结束条件:访问越界或已经访问过或行列数位和大于k</span></span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">    res[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">int</span> resTemp;</span><br><span class="line">    resTemp = Math.max(isPath(rows,cols,i-<span class="number">1</span>,j,visited,res,k), res[<span class="number">0</span>]);</span><br><span class="line">    resTemp = Math.max(isPath(rows,cols,i+<span class="number">1</span>,j,visited,res,k), resTemp);</span><br><span class="line">    resTemp = Math.max(isPath(rows,cols,i,j-<span class="number">1</span>,visited,res,k), resTemp);</span><br><span class="line">    resTemp = Math.max(isPath(rows,cols,i,j+<span class="number">1</span>,visited,res,k), resTemp);</span><br><span class="line">    <span class="keyword">return</span> resTemp;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//一个数字的数位和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">        sum += (num%<span class="number">10</span>);</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="26"></a></p>
<h2 id="26-Unique-Paths-两道"><a href="#26-Unique-Paths-两道" class="headerlink" title="26.Unique Paths(两道)"></a>26.Unique Paths(两道)</h2><h3 id="1-Unique-Paths"><a href="#1-Unique-Paths" class="headerlink" title="1.Unique Paths"></a>1.Unique Paths</h3><p>leetcode 62 Unique Paths</p>
<p>题目：给定m*n的矩阵，机器人从左上走到右下，每次只能向右或向下，How many possible unique paths are there?</p>
<p>思路：dp问题，dp[i][j]表示走至当前格子时的unique paths数。</p>
<p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p>
<p>dp问题，自上而下分析上述方程，自下而上循环解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//dp[i][j]表示走至当前格子时的unique paths数</span></span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//第一行的dp[0][j]=1</span></span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;<span class="comment">//每行的第一个dp[i][0]=dp[i-1][0]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;<span class="comment">//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化:</strong>上述方法时间o(m<em>n)、空间o(m</em>n)，其实只用o(n)的空间即可，对每行来说只缓存上一行的dp即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[j]缓存上一行的unique paths数，初始第一行的dp[j]=1</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; ++j)&#123;<span class="comment">//直接从第1列开始就行了，第0列不用考虑</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//初始第一行的dp[j]=1</span></span><br><span class="line">                dp[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[j] = dp[j-<span class="number">1</span>] + dp[j];<span class="comment">//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Unique-Paths-2"><a href="#2-Unique-Paths-2" class="headerlink" title="2.Unique Paths 2"></a>2.Unique Paths 2</h3><p>leetcode 63 Unique Paths 2</p>
<p>题目：和Unique Paths一样，左上到右下，每次只能向右或者向下，但是新增了障碍物条件，Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>思路：还是一样的。dp问题，用了优化后思路，dp[j]缓存上一行的unique paths数</p>
<p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p>
<p>dp问题，自上而下分析上述方程，自下而上循环解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;<span class="comment">//如果起始点是障碍物</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//dp[j]缓存上一行的unique paths数</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//初始第一行的dp[j]=1</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[j] = dp[j-<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;<span class="comment">//有障碍物，此路不通</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//其他行</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;<span class="comment">//有障碍物，此路不通</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="27"></a></p>
<h2 id="27-剪绳子"><a href="#27-剪绳子" class="headerlink" title="27.剪绳子"></a>27.剪绳子</h2><p>《剑指offer》p96.</p>
<p>题目：给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]* k[1] * … *k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：</p>
<blockquote>
<p>问题是求最优解；</p>
<p>整体的问题的最优解是依赖各个子问题的最优解；</p>
<p>子问题之间还有互相重叠的更小的子问题；</p>
<p>为避免子问题的重复计算，我们存储子问题的最优解。从上往下分析问题，从下往上求解问题。</p>
</blockquote>
<p>上面的几个条件可以看出，属于动态规划问题。</p>
<p>dp方程：<code>f(n) = max(f(i)*f(n-i))</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    res[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    res[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=(i/<span class="number">2</span>); ++j)&#123;</span><br><span class="line">            res[i] = Math.max(res[j]*res[i-j], res[i]);<span class="comment">//f(n)=max(f(i)*f(n-i))</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="28"></a></p>
<h2 id="28-不用加减乘除做加法"><a href="#28-不用加减乘除做加法" class="headerlink" title="28.不用加减乘除做加法"></a>28.不用加减乘除做加法</h2><p>牛客网、leetcode 371</p>
<p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>思路：首先看十进制是如何做的： 5+7=12，三步走 </p>
<blockquote>
<p>第一步：相加各位的值，不算进位，得到2。 </p>
</blockquote>
<blockquote>
<p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p>
</blockquote>
<blockquote>
<p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p>
</blockquote>
<p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p>
<blockquote>
<p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p>
</blockquote>
<blockquote>
<p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p>
</blockquote>
<blockquote>
<p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 </p>
</blockquote>
<p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(num2!=<span class="number">0</span>)&#123;</span><br><span class="line">        temp = num1^num2;<span class="comment">//加</span></span><br><span class="line">        num2 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;<span class="comment">//进位</span></span><br><span class="line">        num1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="29"></a></p>
<h2 id="29-Two-Sum"><a href="#29-Two-Sum" class="headerlink" title="29.Two Sum"></a>29.Two Sum</h2><p>leetcode 1</p>
<p>题目：给定数组(非有序)和target，找到nums[i]+nums[j]==target的i、j，假定给定条件一定会有一个解</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line">	</span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>

<p>思路1：暴力解法，时间o(n2)，空间o(1)–38ms</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>( (nums[i] + nums[j]) == target )&#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                res[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：只遍历一次数组，辅助map，temp=target-nums[i],看map中是否有temp，有则返回两者索引即可，没有将当前nums[i]存入map，继续遍历。时间o(n)，空间o(n)–5ms</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key:nums[i]; value:i</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = target-nums[i];</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(temp))&#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="30"></a></p>
<h2 id="30-二进制中1的个数"><a href="#30-二进制中1的个数" class="headerlink" title="30.二进制中1的个数"></a>30.二进制中1的个数</h2><p>《剑指offer》p100、leetcode191 Number of 1 Bits</p>
<p>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>本题超级技巧：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong></p>
<p>思路：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>，通过这个小技巧，我们只要循环判断n=n&amp;(n-1)是否为0，即可统计1的个数。整数中有多少个1，则循环多少次。</p>
<p>有了这个思路，可以轻松解以下相关题目。位运算相关题目</p>
<p>用一条语句判断一个整数是不是2的整数次方。</p>
<p><code>if(n&amp;(n-1)==0) return true;</code></p>
<p>输入两个整数m,n,计算需要改变m的二进制表示中的多少位才能得到n？<br>​<br>​<code>int x=m^n; return NumberOf1(x);</code></p>
<p>解法一：从尾部到最高位(0到32位)，依次找1。不好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">//从尾部到最高位(0到32位)，依次找1</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = Integer.toBinaryString(n).length();<span class="comment">//返回二进制的位数，这样不用暴力的写32位了</span></span><br><span class="line">    <span class="keyword">while</span>(cnt!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;temp)==temp)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>。每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        n=(n-<span class="number">1</span>)&amp;n; <span class="comment">//每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)</span></span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="31"></a></p>
<h2 id="31-数值的整数次方"><a href="#31-数值的整数次方" class="headerlink" title="31.数值的整数次方"></a>31.数值的整数次方</h2><p>《剑指offer》p110、leetcode 50</p>
<p>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>思路：记得考虑base==0与exponent&lt;0的情况。解法三更为优化，递归实现将exponent二分下去减少乘法运算次数。判断一个整数为奇数偶数，这里把%运算换成位运算，效率更高（二进制最低位如果为1则为奇数，为0则为偶数）。</p>
<p><strong>超级知识点</strong>：注意MIN_VALUE取反的情况。在JDK中，整型类型是有范围的 -2147483648～2147483647（-2^31-2^31-1），最大值为Integer.MAX_VALUE，即2147483647，最小值为Integer.MIN_VALUE -2147483648。</p>
<p>Integer.MIN_VALUE取反或者取绝对值呢仍为Integer.MIN_VALUE，因为绝对值2147483648超过Integer.MAX_VALUE 2147483647。</p>
<p><strong>因此有如下重要结论：</strong><br>​<br>​    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE<br>​    Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</p>
<p>解法一：无耻解法2333</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.pow(base, exponent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：逐个base相乘即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE</span></span><br><span class="line">    <span class="comment">//Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</span></span><br><span class="line">    <span class="keyword">if</span>(exponent==Integer.MIN_VALUE)&#123;</span><br><span class="line">        exponent = exponent + <span class="number">2</span>;<span class="comment">//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不ååå行，必须为偶数参与二分)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        positive = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exponent = Math.abs(exponent);</span><br><span class="line">    <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">        exponent--;</span><br><span class="line">        res*=base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positive?res:(<span class="number">1</span>/res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法三，效率更高：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a^n = a^(n/2)*a^(n/2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;<span class="comment">//exponent正负的标记位</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE</span></span><br><span class="line">    <span class="comment">//Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</span></span><br><span class="line">    <span class="keyword">if</span>(exponent==Integer.MIN_VALUE)&#123;</span><br><span class="line">        exponent = exponent + <span class="number">2</span>;<span class="comment">//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不行，必须为偶数参与二分)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        positive = <span class="keyword">false</span>;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(exponent!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;<span class="comment">//exponent是奇数</span></span><br><span class="line">            res*=base;</span><br><span class="line">            exponent--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//exponent是偶数，二分，减少乘法次数，效率更高</span></span><br><span class="line">            base*=base;</span><br><span class="line">            exponent/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> positive?res:(<span class="number">1</span>/res);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(Power(<span class="number">2</span>, -<span class="number">2147483648</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="32"></a></p>
<h2 id="32-打印从1到最大的n位数"><a href="#32-打印从1到最大的n位数" class="headerlink" title="32.打印从1到最大的n位数"></a>32.打印从1到最大的n位数</h2><p>《剑指offer》p114</p>
<p>题目：打印从1到最大的n位数（本题是大数问题，当n位数很多时，只能用其他的数据结构来存储我们的非常大的数字）</p>
<p>思路：使用数组，采用数字全排列的方法。如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。当然打印的时候，我们应该不输出左边的0</p>
<p>解法一：递归实现全排列，顺序打印（代码比较简单，但可能会栈溢出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        printOneToNBit(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印从1到最大的n位数，就是一个n个数的全排列，用递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOneToNBit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] number = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//n位的数组存放数字的全排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line">            number[<span class="number">0</span>] = i;</span><br><span class="line">            OneToNBit(number, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归实现数字全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OneToNBit</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//递归结束条件，已经完成一个数字全排列，打印出来</span></span><br><span class="line">        <span class="keyword">if</span>(index == n-<span class="number">1</span>)&#123;</span><br><span class="line">            printNumber(number);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)&#123;</span><br><span class="line">            number[index] = i;</span><br><span class="line">            OneToNBit(number, n, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印一个数组排列，左边的0都不输出</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">int</span>[] number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> notFirst = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;number.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                notFirst = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(notFirst)&#123;</span><br><span class="line">                System.out.print(number[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：字符串存数字，采用循环，不断加1。这个思路在两个数相加（大数问题）等题目中可以用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印从1到最大的n位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOneToNBit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//大数问题，用字符串来存数字</span></span><br><span class="line">    StringBuilder num = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        num.append(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!addOne(num))&#123;</span><br><span class="line">        printNum(num);<span class="comment">//字符串每次加1，然后打印,直到n位的最大数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//字符串每次加1，然后打印,直到n位的最大数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addOne</span><span class="params">(StringBuilder num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//前一位的进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=num.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = num.charAt(i)-<span class="string">'0'</span>+cnt;<span class="comment">//第i位上的数字</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(i==num.length()-<span class="number">1</span>)&#123;<span class="comment">//个位加1</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">10</span>)&#123;<span class="comment">//如果有进位，操作如下</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;<span class="comment">//如果当前是最高位且有进位，说明已经到达是最大数，return true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num.setCharAt(i, <span class="string">'0'</span>);<span class="comment">//进位后当前位为0</span></span><br><span class="line">            cnt = <span class="number">1</span>;<span class="comment">//进位1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//如果没进位</span></span><br><span class="line">            num.setCharAt(i, (<span class="keyword">char</span>)(<span class="string">'0'</span>+temp));</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//没有进位了，跳出循环即可</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//打印数字，左边的0不打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(StringBuilder num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> leftCnt = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = num.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="string">'0'</span>) &#123;</span><br><span class="line">            leftCnt = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!leftCnt)&#123;</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    printOneToNBit(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="33"></a></p>
<h2 id="33-删除链表中重复的节点-两道"><a href="#33-删除链表中重复的节点-两道" class="headerlink" title="33.删除链表中重复的节点(两道)"></a>33.删除链表中重复的节点(两道)</h2><pre><code>1.Remove Duplicates from Sorted List((保留一个重复节点)---leetcode83
2.Remove Duplicates from Sorted List 2(不保留重复节点)---《剑指offer》p122、leetcode82</code></pre><h3 id="1-Remove-Duplicates-from-Sorted-List"><a href="#1-Remove-Duplicates-from-Sorted-List" class="headerlink" title="1.Remove Duplicates from Sorted List"></a>1.Remove Duplicates from Sorted List</h3><p>leetcode 83</p>
<p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点保留一个，返回链表头指针。</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next.val==cur.val)&#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Remove-Duplicates-from-Sorted-List-II"><a href="#2-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="2.Remove Duplicates from Sorted List II"></a>2.Remove Duplicates from Sorted List II</h3><p>《剑指offer》p122、leetcode82</p>
<p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>思路：</p>
<blockquote>
<p>1.需要两个指针，一个指向前一个节点pre，另一个指向当前节点p。如果遇到相等的节点，p向后移动，pre不动，存下此时相等数值tempVal方便后面的比较，直到遇到p和p.next不相等，pre就可以指向当前的p。</p>
<p>2.注意：链表开头可能就开始有重复的节点，所以设置一个哨兵guard(0)，</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链表为空或只有一个节点，返回pHead</span></span><br><span class="line">    <span class="keyword">if</span>(pHead==<span class="keyword">null</span> || pHead.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置哨兵</span></span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    guard.next = pHead;</span><br><span class="line">    </span><br><span class="line">    ListNode pre = guard;<span class="comment">//重复节点的前一个节点</span></span><br><span class="line">    ListNode cur = guard.next; <span class="comment">//用于遍历的节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.next.val==cur.val)&#123;<span class="comment">//后一节点==当前节点</span></span><br><span class="line">            <span class="keyword">int</span> temp = cur.val;<span class="comment">//存储重复的值，用于后边比较</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; cur.val==temp)&#123;<span class="comment">//如果重复</span></span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//后一节点!=当前节点</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="34"></a></p>
<h2 id="34-正则表达式匹配"><a href="#34-正则表达式匹配" class="headerlink" title="34.正则表达式匹配"></a>34.正则表达式匹配</h2><p>《剑指offer》p124、leetcode 10</p>
<p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。*表示前面字符0~无穷个，.表示任意一个字符。要求全部，匹配，不是部分匹配。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>思路：二维DP问题。这道题的核心是分析’<em>‘，DP[i][j]代表计算str[:i]与patten[:j]匹不匹配.最终要得到的结果就是dp[s.length()][p.length()]，转移方程如下(时间复杂度O(m\</em>n)，空间复杂度O(n)):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i - 1][j - 1], 如果s[i] &#x3D;&#x3D; p[j] || p[j] &#x3D;&#x3D; &#39;.&#39;</span><br><span class="line"></span><br><span class="line">&#x3D;dp[i][j - 2], 如果s[i] !&#x3D; p[j] &amp;&amp; p[j] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; s[i] !&#x3D; p[j - 1](只能匹配0次)</span><br><span class="line"></span><br><span class="line">&#x3D;dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j], 如果s[i] !&#x3D; p[j] &amp;&amp; p[j] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; s[i] &#x3D;&#x3D; p[j - 1](匹配0\1\多次)</span><br><span class="line"></span><br><span class="line">返回：</span><br><span class="line">dp[s.length()][p.length()]</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正则匹配. *。思路：二维DP。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.charAt(i) == <span class="string">'*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) != p.charAt(j-<span class="number">1</span>) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>)&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] || dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] str = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] pattern = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'*'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] str2 = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>,<span class="string">'b'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>[] pattern2 = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'.'</span>,<span class="string">'*'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line">    String s = <span class="string">"ab"</span>;</span><br><span class="line">    String p = <span class="string">".*c"</span>;<span class="comment">//这对测试用例解决了一个大bug，很好</span></span><br><span class="line"></span><br><span class="line">    System.out.println(isMatch(s,p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="35"></a></p>
<h2 id="35-表示数值的字符串"><a href="#35-表示数值的字符串" class="headerlink" title="35.表示数值的字符串"></a>35.表示数值的字符串</h2><p>《剑指offer》p127、leetcode 65</p>
<p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>思路：+A.Be+C，对字符串分别判断A、B、C部分是否存在且是否正确，都正确则返回true。注意边界条件：</p>
<p>1.整数部分判断，整数部分可以没有，但没有则必须：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有小数部分，小数点+小数部分--&gt;  -.123正确, -.错误 </span><br><span class="line">没有小数点，也没有小数部分--&gt;  -正确</span><br></pre></td></tr></table></figure>

<p>2.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)</p>
<p>3.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//+A.Be+C</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//1.正负号判断</span></span><br><span class="line">        <span class="keyword">if</span>(str[index]==<span class="string">'+'</span> || str[index]==<span class="string">'-'</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//2.整数部分判断(整数部分可以没有 但没有则必须要有小数部分，-.123正确, -.错误)</span></span><br><span class="line">        <span class="keyword">boolean</span> num = <span class="keyword">false</span>;<span class="comment">//是否有整数部分</span></span><br><span class="line">        <span class="keyword">int</span> indexTemp = readNum(str, index);</span><br><span class="line">        <span class="keyword">if</span>(indexTemp&gt;index)&#123;<span class="comment">//有整数部分</span></span><br><span class="line">            num = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = indexTemp;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//3.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;str.length &amp;&amp; str[index]==<span class="string">'.'</span>)&#123;</span><br><span class="line">            index++;</span><br><span class="line">            indexTemp = readNum(str, index);</span><br><span class="line">            <span class="keyword">if</span>(!num &amp;&amp; indexTemp==index)&#123;<span class="comment">//小数部分前面如果没有整数则必须要有小数部分</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = indexTemp;</span><br><span class="line">            num = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//4.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;str.length &amp;&amp; (str[index]==<span class="string">'e'</span>||str[index]==<span class="string">'E'</span>) )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!num)&#123;<span class="comment">//e部分前面没有数字，false (e9错误)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index==str.length)&#123;<span class="comment">//有e但没有后面的整数部分，false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[index]==<span class="string">'+'</span> || str[index]==<span class="string">'-'</span>)&#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            indexTemp = readNum(str, index);</span><br><span class="line">            <span class="keyword">if</span>(indexTemp==index)&#123;<span class="comment">//有e但没有后面的整数部分，false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index = indexTemp;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(index!=str.length)&#123;<span class="comment">//如果都判断完了，字符串还有字符，false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//遍历读取数字部分，返回不是数字的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readNum</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;str.length)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = str[index]-<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;<span class="number">0</span> || temp&gt;<span class="number">9</span>)&#123;<span class="comment">//不是数字</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//是数字</span></span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">".5"</span>;<span class="comment">//Expected:true</span></span><br><span class="line">        String s2 = <span class="string">"."</span>;<span class="comment">//Expected:false</span></span><br><span class="line">        String s = <span class="string">"100."</span>;<span class="comment">//Expected:true</span></span><br><span class="line">        String s4 = <span class="string">"-"</span>;<span class="comment">//Expected:true</span></span><br><span class="line">        System.out.println(isNumeric(s4.trim().toCharArray()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="36"></a></p>
<h2 id="36-调整数组顺序使奇数位于偶数前面-3道"><a href="#36-调整数组顺序使奇数位于偶数前面-3道" class="headerlink" title="36.调整数组顺序使奇数位于偶数前面(3道)"></a>36.调整数组顺序使奇数位于偶数前面(3道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》p129(需要保持顺序不变)</span><br><span class="line">leetcode 905(不用保持顺序)</span><br><span class="line">leetcode 328(调整链表的奇偶顺序)</span><br></pre></td></tr></table></figure>

<h3 id="《剑指offer》p129-需要保持顺序不变"><a href="#《剑指offer》p129-需要保持顺序不变" class="headerlink" title="《剑指offer》p129(需要保持顺序不变)"></a>《剑指offer》p129(需要保持顺序不变)</h3><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>思路：遍历一遍数组，记下奇数偶数个数；建立新数组temp后，再遍历一遍原数组，奇数偶数分开放到新数组temp中；将新数组temp的值赋给原数组array。时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cntOdd = <span class="number">0</span>;<span class="comment">//记录奇数个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i: array)&#123;<span class="comment">//遍历一遍数组，记下奇数偶数个数</span></span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            cntOdd++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> oddIndex = <span class="number">0</span>;<span class="comment">//奇数index</span></span><br><span class="line">    <span class="keyword">int</span> evenIndex = cntOdd;<span class="comment">//偶数index</span></span><br><span class="line">    <span class="keyword">int</span>[] tempArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; ++i)&#123;<span class="comment">//再遍历一遍数组，奇数偶数分开放到新数组temp中</span></span><br><span class="line">        <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)== <span class="number">1</span>)&#123;</span><br><span class="line">            tempArray[oddIndex++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tempArray[evenIndex++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; ++i)&#123;<span class="comment">//再遍历一遍数组，将新数组temp的值赋给原数组array</span></span><br><span class="line">        array[i] = tempArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sort-Array-By-Parity"><a href="#Sort-Array-By-Parity" class="headerlink" title="Sort Array By Parity"></a>Sort Array By Parity</h3><p>leetcode 905</p>
<p>题目：偶数在前，奇数在后，不用保持顺序</p>
<p>Example :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure>

<p>思路：既然不用保持顺序，那么就不用空间o(n)的辅助了，思路：遍历一遍数组，两个指针变量，partition思想</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偶数在前，奇数在后，不用保持顺序。思路：遍历一遍数组，两个指针变量，partition思想</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> storeEven = <span class="number">0</span>;<span class="comment">//遍历一遍数组，把偶数放在前面。storeEven左边都是偶数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((A[i]&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">            swap(A, storeEven++, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[i];</span><br><span class="line">    A[i] = A[j];</span><br><span class="line">    A[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h3><p>leetcode 328</p>
<p>题目：Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>题目大意：奇数号节点在前，偶数号节点在后，同时要求时间o(n)，空间o(1)</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>Example 2:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</span><br><span class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>思路：拆分成两个链表，奇数号链表、偶数号链表，最后再合成即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span> || head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//奇数号链表</span></span><br><span class="line">    ListNode oddHead = head;</span><br><span class="line">    ListNode oddP = oddHead;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//偶数号链表</span></span><br><span class="line">    ListNode evenHead = head.next;</span><br><span class="line">    ListNode evenP = evenHead;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历并拆分原链表</span></span><br><span class="line">    ListNode cur = oddP.next.next;</span><br><span class="line">    oddP.next = <span class="keyword">null</span>;</span><br><span class="line">    evenP.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; cur.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//奇数号节点</span></span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        oddP.next = temp;</span><br><span class="line">        oddP = oddP.next;</span><br><span class="line">        oddP.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//偶数号节点</span></span><br><span class="line">        temp = cur;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        evenP.next = temp;</span><br><span class="line">        evenP = evenP.next;</span><br><span class="line">        evenP.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;<span class="comment">//如果还剩一个奇数号节点</span></span><br><span class="line">        oddP.next = cur;</span><br><span class="line">        oddP = oddP.next;</span><br><span class="line">        oddP.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//连接奇偶两个链表</span></span><br><span class="line">    oddP.next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> oddHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="37"></a></p>
<h2 id="37-链表中倒数第k个结点-两道"><a href="#37-链表中倒数第k个结点-两道" class="headerlink" title="37.链表中倒数第k个结点(两道)"></a>37.链表中倒数第k个结点(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》p134--返回倒数第k个结点</span><br><span class="line">《左神》p35&#x3D;&#x3D;leetcode19--删除倒数第k个结点</span><br></pre></td></tr></table></figure>

<h3 id="1-返回倒数第k个结点"><a href="#1-返回倒数第k个结点" class="headerlink" title="1.返回倒数第k个结点"></a>1.返回倒数第k个结点</h3><p>《剑指offer》p134</p>
<p>题目：输入一个链表，输出该链表中倒数第k个结点。</p>
<p>思路：双指针，遍历一遍链表即可。时间o(n),空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode right = head;<span class="comment">//先出发，走k-1个节点</span></span><br><span class="line">    ListNode left = head;<span class="comment">//后出发，直到right.next为null时left即为所求</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.right先走k-1个节点</span></span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">1</span>)&#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//链表的节点数都不够k个，更没有倒数第k个节点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.left、right一起走，直到right.next==null</span></span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-删除倒数第k个节点"><a href="#2-删除倒数第k个节点" class="headerlink" title="2.删除倒数第k个节点"></a>2.删除倒数第k个节点</h3><p>《左神》35==leetcode19，思路差不多，删除时应该首先遍历到倒数第k+1个节点，且需要设置哨兵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除倒数第n个节点，则需要找到倒数第n+1个节点，需要设置哨兵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1.设置哨兵</span></span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    guard.next = head;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.找到倒数第n+1个节点</span></span><br><span class="line">    ListNode right = guard;<span class="comment">//先出发，走n-1个节点</span></span><br><span class="line">    ListNode left = guard;<span class="comment">//后出发，直到right.next为null时left即为所求</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//1.right先走n个节点</span></span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        right = right.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.left、right一起走，直到right.next==null，此时left指向倒数第n+1个节点</span></span><br><span class="line">    <span class="keyword">while</span>(right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        left = left.next;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//3.删除倒数第k个节点</span></span><br><span class="line">    left.next = left.next.next;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="38"></a></p>
<h2 id="38-判断链表是否有环-两道"><a href="#38-判断链表是否有环-两道" class="headerlink" title="38.判断链表是否有环(两道)"></a>38.判断链表是否有环(两道)</h2><h3 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1.判断链表是否有环"></a>1.判断链表是否有环</h3><p>leetcode 141</p>
<p>题目：Given a linked list, determine if it has a cycle in it.</p>
<p>思路：每次fast走两步，low走一步，如果两者相遇则有环，如果遇到null则无环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</span></span><br><span class="line">    ListNode right = head;<span class="comment">//走两步</span></span><br><span class="line">    ListNode left = head;<span class="comment">//走一步</span></span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="keyword">null</span> &amp;&amp; right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">        <span class="keyword">if</span>(right==left)&#123;<span class="comment">//如果相遇，则有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-判断链表是否有环，有则返回环的入口结点"><a href="#2-判断链表是否有环，有则返回环的入口结点" class="headerlink" title="2.判断链表是否有环，有则返回环的入口结点"></a>2.判断链表是否有环，有则返回环的入口结点</h3><p>《剑指offer》p139、leetcode 142</p>
<p>题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>思路：</p>
<blockquote>
<p>1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</p>
<p>如果有环：前后指针相遇的地方一定在环中，此时遍历这个环计算环的节点数k，之后从头遍历链表，前指针比后指针多走k步，前后指针再次相遇时即为为环的入口节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</span></span><br><span class="line">    ListNode right = pHead;<span class="comment">//走两步</span></span><br><span class="line">    ListNode left = pHead;<span class="comment">//走一步</span></span><br><span class="line">    <span class="keyword">boolean</span> haveCycle = <span class="keyword">false</span>; <span class="comment">//是否有环</span></span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="keyword">null</span> &amp;&amp; right.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right = right.next.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">        <span class="keyword">if</span>(right==left)&#123;<span class="comment">//如果相遇，则有环</span></span><br><span class="line">            haveCycle = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!haveCycle)&#123;<span class="comment">//如果没环，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.有环，找出环的入口节点。</span></span><br><span class="line">    <span class="comment">//  思路：2.1遍历环计算环中节点个数k个；</span></span><br><span class="line">    <span class="comment">//       2.2从头遍历链表，两个指针，一个先走k，两个一起走直到相遇即为入口节点</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.1遍历环计算环中节点个数k个</span></span><br><span class="line">    <span class="keyword">int</span> cycleNum = <span class="number">1</span>; <span class="comment">//环中节点个数</span></span><br><span class="line">    <span class="keyword">while</span>(right.next!=left)&#123;</span><br><span class="line">        cycleNum++;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.2从头遍历链表，两个指针，一个先走cycleNum-1个节点，两个一起走直到相遇时left即为入口节点</span></span><br><span class="line">    right = pHead;</span><br><span class="line">    left = pHead;</span><br><span class="line">    <span class="keyword">while</span>(cycleNum!=<span class="number">1</span>)&#123;<span class="comment">//right先走cycleNum-1个节点</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        cycleNum--;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(right.next!=left)&#123;<span class="comment">//right、left两个一起走，直到相遇时的left节点即为所求</span></span><br><span class="line">        right = right.next;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="39"></a></p>
<h2 id="39-两个单链表相交的第一个公共节点-2道"><a href="#39-两个单链表相交的第一个公共节点-2道" class="headerlink" title="39.两个单链表相交的第一个公共节点(2道)"></a>39.两个单链表相交的第一个公共节点(2道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个链表的第一个公共节点(无环)--《剑指offer》p253、leetcode 160</span><br><span class="line">两个链表的第一个公共节点(可能有环，需自己判断)--《左神》62，掌握这一道题就够了</span><br></pre></td></tr></table></figure>

<h3 id="1-两个链表的第一个公共节点-无环"><a href="#1-两个链表的第一个公共节点-无环" class="headerlink" title="1.两个链表的第一个公共节点(无环)"></a>1.两个链表的第一个公共节点(无环)</h3><p>《剑指offer》p253、leetcode 160</p>
<p>题目：输入两个链表，链表无环，找出它们的第一个公共结点。如果不相交返回null</p>
<p>思路：</p>
<p>法一：因为要从两个链表的尾部往前一一判断，因此需要借助两个栈的辅助。java栈的实现可以用LinkedList。时间o(m+n)，空间o(m+n)</p>
<p>法二(更简单的办法)：链表长度差。首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到第一个相同的结点就是他们的第一个公共结点。时间o(m+n)，空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回两个无环链表相交的第一个节点，如果不相交返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">FindFirstNoCycleCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head1==<span class="keyword">null</span> || head2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.计算两个链表的长度</span></span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">    ListNode p1 = head1;</span><br><span class="line">    ListNode p2 = head2;</span><br><span class="line">    <span class="keyword">while</span>(p1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        len1++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        len2++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p1!=p2)&#123;<span class="comment">//两个链表的最后一个节点不相同，说明不相交</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.计算长度差k，让长链表先走k步</span></span><br><span class="line">    ListNode longList = len1&gt;=len2?head1:head2;</span><br><span class="line">    ListNode shortList = longList==head1?head2:head1;</span><br><span class="line">    <span class="keyword">int</span> k = Math.abs(len1-len2);</span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">        longList = longList.next;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.两个链表一起走，直到找到相交的第一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(longList!=<span class="keyword">null</span> &amp;&amp; shortList!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(longList==shortList)&#123;</span><br><span class="line">            <span class="keyword">return</span> longList;</span><br><span class="line">        &#125;</span><br><span class="line">        longList = longList.next;</span><br><span class="line">        shortList = shortList.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不相交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-两个链表的第一个公共节点-可能有环，需自己判断"><a href="#2-两个链表的第一个公共节点-可能有环，需自己判断" class="headerlink" title="2.两个链表的第一个公共节点(可能有环，需自己判断)"></a>2.两个链表的第一个公共节点(可能有环，需自己判断)</h3><p>《左神》62，掌握这一道题就够了</p>
<p>题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null</p>
<p>思路：</p>
<p>1.判断两个链表是否有环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.1 若一个链表有环，另一个链表无环，则不可能相交，返回null</span><br><span class="line">1.2 都无环则判断两个无环链表的第一个公共节点，没有返回null</span><br></pre></td></tr></table></figure>

<p>2.若有环，判断两个有环链表的第一个公共节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.1找两个有环链表的入口节点p1&#x2F;p2，若p1&#x3D;&#x3D;p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)</span><br><span class="line">	</span><br><span class="line">2.2若p1!&#x3D;p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">    ListNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null</span></span><br><span class="line"><span class="comment">     * 思路：</span></span><br><span class="line"><span class="comment">     *   1.判断两个链表是否有环，都无环则判断两个无环链表的第一个公共节点，没有返回null</span></span><br><span class="line"><span class="comment">     *   2.判断两个有环链表的第一个公共节点。</span></span><br><span class="line"><span class="comment">     *     2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)</span></span><br><span class="line"><span class="comment">     *     2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head1==<span class="keyword">null</span> || head2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        ListNode beginNodeOfCycle1 = hasCycle(head1);<span class="comment">//链表head1是否有环，无环返回null，有环返回入口节点</span></span><br><span class="line">        ListNode beginNodeOfCycle2 = hasCycle(head2);<span class="comment">//链表head2是否有环，无环返回null，有环返回入口节点</span></span><br><span class="line">        <span class="comment">//1.两个链表都无环，判断两个无环链表的第一个公共节点，没有返回null</span></span><br><span class="line">        <span class="keyword">if</span> (beginNodeOfCycle1==<span class="keyword">null</span> &amp;&amp; beginNodeOfCycle2==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> noCycleCommonNode(head1, head2);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//2.两个链表都有环</span></span><br><span class="line">        <span class="keyword">if</span> (beginNodeOfCycle1!=<span class="keyword">null</span> &amp;&amp; beginNodeOfCycle2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1beginNodeOfCycle1==beginNodeOfCycle2,交点在发生在环前,与无环链表公共节点求法类似(长度差，分别先后走找交点)</span></span><br><span class="line">            <span class="keyword">if</span>(beginNodeOfCycle1==beginNodeOfCycle2)&#123;</span><br><span class="line">                ListNode p1 = head1;</span><br><span class="line">                ListNode p2 = head2;</span><br><span class="line">                <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(p1!=beginNodeOfCycle1)&#123;</span><br><span class="line">                    len1++;</span><br><span class="line">                    p1 = p1.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(p2!=beginNodeOfCycle2)&#123;</span><br><span class="line">                    len2++;</span><br><span class="line">                    p2 = p2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode longHead = len1&gt;=len2 ? head1 : head2;</span><br><span class="line">                ListNode shortHead = longHead==head1 ? head2 : head1;</span><br><span class="line">                <span class="keyword">int</span> k = Math.abs(len1-len2);</span><br><span class="line">	</span><br><span class="line">                <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;<span class="comment">//长链表先走k步</span></span><br><span class="line">                    longHead = longHead.next;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(longHead!=beginNodeOfCycle1 &amp;&amp; shortHead!=beginNodeOfCycle2)&#123;<span class="comment">//两个链表一起走</span></span><br><span class="line">                    <span class="keyword">if</span>(longHead==shortHead)&#123;<span class="comment">//找到公共节点</span></span><br><span class="line">                        <span class="keyword">return</span> longHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    longHead = longHead.next;</span><br><span class="line">                    shortHead = shortHead.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.2beginNodeOfCycle11=beginNodeOfCycle2,交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(beginNodeOfCycle1.next!=beginNodeOfCycle1)&#123;</span><br><span class="line">                    beginNodeOfCycle1 = beginNodeOfCycle1.next;</span><br><span class="line">                    <span class="keyword">if</span>(beginNodeOfCycle1==beginNodeOfCycle2)&#123;<span class="comment">//环中找到了第一个公共节点，返回</span></span><br><span class="line">                        <span class="keyword">return</span> beginNodeOfCycle1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//环中没有公共节点，即两个有环链表独立不相交的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//一个链表有环，一个链表无环，返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断一个链表是否有环，没环返回null，如果有环返回入口节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">hasCycle</span><span class="params">(ListNode pHead)</span></span>&#123;</span><br><span class="line">        ListNode p1 = pHead;<span class="comment">//每次走两步</span></span><br><span class="line">        ListNode p2 = pHead;<span class="comment">//每次走一步</span></span><br><span class="line">        <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(p2.next!=<span class="keyword">null</span> &amp;&amp; p1.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            p2 = p2.next.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            <span class="keyword">if</span>(p1==p2)&#123;</span><br><span class="line">                hasCycle = <span class="keyword">true</span>;<span class="comment">//两个指针相遇则有环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hasCycle)&#123;<span class="comment">//链表有环，返回入口节点</span></span><br><span class="line">            <span class="comment">//1.计算环的节点个数</span></span><br><span class="line">            ListNode temp = p1;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(p1.next!=temp)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//2.right指针从链表头先走k步</span></span><br><span class="line">            ListNode right = pHead;</span><br><span class="line">            ListNode left = pHead;</span><br><span class="line">            <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">                right = right.next;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//3.left从头和right一起走，直到相遇</span></span><br><span class="line">            <span class="keyword">while</span>(left!=right)&#123;</span><br><span class="line">                left = left.next;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;<span class="comment">//找到入口节点并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//链表无环，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断两个无环链表的第一个公共节点，没有则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">noCycleCommonNode</span><span class="params">(ListNode head1, ListNode head2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//长度差，一个先走k步，然后同时走，看是否有公共节点</span></span><br><span class="line">        <span class="keyword">if</span>(head1==<span class="keyword">null</span> || head2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = head1;</span><br><span class="line">        ListNode p2 = head2;</span><br><span class="line">        <span class="keyword">int</span> len1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len2++;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p1!=p2)&#123;<span class="comment">//两个链表的最后一个节点不等，则没有公共节点，返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        ListNode longHead = len1&gt;=len2 ? head1 : head2;</span><br><span class="line">        ListNode shortHead = longHead==head1 ? head2 : head1;</span><br><span class="line">        <span class="keyword">int</span> k = Math.abs(len1-len2);</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;<span class="comment">//长链表先走k步</span></span><br><span class="line">            longHead = longHead.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span>(longHead!=<span class="keyword">null</span> &amp;&amp; shortHead!=<span class="keyword">null</span>)&#123;<span class="comment">//两个链表一起走</span></span><br><span class="line">            <span class="keyword">if</span>(longHead==shortHead)&#123;<span class="comment">//找到公共节点</span></span><br><span class="line">                <span class="keyword">return</span> longHead;</span><br><span class="line">            &#125;</span><br><span class="line">            longHead = longHead.next;</span><br><span class="line">            shortHead = shortHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有公共节点，返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="40"></a></p>
<h2 id="40-合并两个排序的链表"><a href="#40-合并两个排序的链表" class="headerlink" title="40.合并两个排序的链表"></a>40.合并两个排序的链表</h2><p>《剑指offer》p145、leetcode21、《左神》84</p>
<p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>思路：正常的遍历两个链表结点，每次将较小的节点插到新链表的尾部即可。设置哨兵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序的链表，设置一个哨兵</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = guard;</span><br><span class="line">    ListNode temp;</span><br><span class="line">    <span class="keyword">while</span>(list1!=<span class="keyword">null</span> &amp;&amp; list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;=list2.val)&#123;</span><br><span class="line">            temp = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">null</span>;</span><br><span class="line">        p.next = temp;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(list1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = list1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(list2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p.next = list2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> guard.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="41"></a></p>
<h2 id="41-树的子结构"><a href="#41-树的子结构" class="headerlink" title="41.树的子结构"></a>41.树的子结构</h2><p>《剑指offer》p148、leetcode 572</p>
<p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>思路：分为两步。第一步，先序遍历树A，在树A中找到和树B的根节点值相同的节点R；第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">     TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">     TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//两个二叉树A、B，判断B是否是A的子结构。思路：先序遍历A，找到与B的根节点相同的节点，判断子结构是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSame(root1, root2))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSame(root1.left, root2.left) &amp;&amp; isSame(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="42"></a></p>
<h2 id="42-二叉树的翻转-镜像-与对称-2道"><a href="#42-二叉树的翻转-镜像-与对称-2道" class="headerlink" title="42.二叉树的翻转(镜像)与对称(2道)"></a>42.二叉树的翻转(镜像)与对称(2道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》p157--二叉树的翻转(转换成镜像二叉树)</span><br><span class="line">leetcode 101、《剑指offer》p159--判断二叉树是否是对称</span><br></pre></td></tr></table></figure>

<h3 id="1-二叉树的翻转-镜像"><a href="#1-二叉树的翻转-镜像" class="headerlink" title="1.二叉树的翻转(镜像)"></a>1.二叉树的翻转(镜像)</h3><p>《剑指offer》p157</p>
<p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>思路：前序遍历树的每一个结点，对每个节点的左右子树互换，递归下去即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作给定的二叉树，将其变换为源二叉树的镜像。思路：左右子树互换，递归下去即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    </span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-对称的二叉树"><a href="#2-对称的二叉树" class="headerlink" title="2.对称的二叉树"></a>2.对称的二叉树</h3><p>《剑指offer》p159、leetcode 101 </p>
<p>题目：判断一颗二叉树是不是对称的</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<p>思路：根左右与根右左的递归判断即可。</p>
<p>从根开始，先判断其左右孩子，如果都不存在则为true</p>
<p>如果只有一个为空或者两个指向的val值不同则为false</p>
<p>当根的左右孩子节点相同时，再判断其左孩子的左孩子和右孩子的右孩子、左孩子的右孩子和右孩子的左孩子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一颗二叉树是不是对称的。思路：根左右与根右左的递归判断即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pRoot.left==<span class="keyword">null</span> &amp;&amp; pRoot.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pRoot.left!=<span class="keyword">null</span> &amp;&amp; pRoot.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricalDetail(pRoot.left, pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricalDetail</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span> &amp;&amp; root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val==root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricalDetail(root1.left, root2.right) &amp;&amp; isSymmetricalDetail(root1.right, root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="43"></a></p>
<h2 id="43-顺时针打印矩阵"><a href="#43-顺时针打印矩阵" class="headerlink" title="43.顺时针打印矩阵"></a>43.顺时针打印矩阵</h2><p>《剑指offer》p161、leetcode 54 spiral Matrix(螺旋矩阵)</p>
<p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>思路：先定义好打印一圈的函数，然后根据矩阵大小确定需要打印几圈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//顺时针打印矩阵。思路：先定义打印一圈的函数，再确定打印几圈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">int</span> startI = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startJ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> endI = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> endJ = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cycleNum = (<span class="keyword">int</span>)Math.ceil((<span class="keyword">double</span>)Math.min(m,n)/<span class="number">2</span>);<span class="comment">//一共打印cycleNum圈</span></span><br><span class="line">	</span><br><span class="line">        <span class="keyword">while</span>(cycleNum!=<span class="number">0</span>)&#123;<span class="comment">//循环打印cycleNum圈</span></span><br><span class="line">            printOneCycle(matrix, startI, startJ, endI, endJ, res);</span><br><span class="line">            startI++;</span><br><span class="line">            startJ++;</span><br><span class="line">            endI--;</span><br><span class="line">            endJ--;</span><br><span class="line">            cycleNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义打印一圈的函数。限定一圈的边界需要两个参数，圈的左上角元素和右下角元素的坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOneCycle</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> startI, <span class="keyword">int</span> startJ, <span class="keyword">int</span> endI, <span class="keyword">int</span> endJ, ArrayList&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.打印圈的上边，每圈都有</span></span><br><span class="line">        <span class="keyword">int</span> temp = startJ;</span><br><span class="line">        <span class="keyword">while</span>(temp&lt;=endJ) &#123;</span><br><span class="line">            res.add(matrix[startI][temp]);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.打印圈的右边，必须两行以上</span></span><br><span class="line">        temp = startI+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(endI&gt;startI &amp;&amp; temp&lt;=endI)&#123;</span><br><span class="line">            res.add(matrix[temp][endJ]);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.打印圈的下边，必须两行以上、两列以上</span></span><br><span class="line">        temp = endJ-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(endI&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;=startJ)&#123;</span><br><span class="line">            res.add(matrix[endI][temp]);</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.打印圈的左边，必须三行以上、两列以上</span></span><br><span class="line">        temp = endI - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(endI-<span class="number">1</span>&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;startI)&#123;</span><br><span class="line">            res.add(matrix[temp][startJ]);</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        System.out.println(printMatrix(matrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="44"></a></p>
<h2 id="44-包含min函数的栈"><a href="#44-包含min函数的栈" class="headerlink" title="44.包含min函数的栈"></a>44.包含min函数的栈</h2><p>《剑指offer》p165、leetcode155</p>
<p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））</p>
<p>思路：如果只用一个元素保存最小的元素，那么当最小的元素被弹出后，就没有办法得到剩余元素中最下的元素。因此引入辅助栈，每次将最小元素（之前的最小元素和新压入的元素两者的较小者）都保存起来放到辅助栈里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    Stack&lt;Integer&gt; stk = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minStk = <span class="keyword">new</span> Stack&lt;&gt;(); <span class="comment">//辅助栈，每次push时都压入当前最小值（node与minStk栈顶元素中的较小者）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stk.push(node);</span><br><span class="line">        <span class="keyword">if</span>(minStk.empty() || node &lt; minStk.peek())&#123;</span><br><span class="line">            minStk.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            minStk.push(minStk.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        minStk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStk.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="45"></a></p>
<h2 id="45-栈的压入、弹出序列"><a href="#45-栈的压入、弹出序列" class="headerlink" title="45.栈的压入、弹出序列"></a>45.栈的压入、弹出序列</h2><p>《剑指offer》p168、leetcode 946</p>
<p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>思路：借助一个辅助栈来模拟入栈弹栈过程。每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环（直到出栈序列遍历完返回true）；如果不等：入栈后面的数字（直到入栈序列遍历完还没找到则false）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环；如果不等：入栈后面的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = pushA.length;</span><br><span class="line">    <span class="keyword">int</span> pushAIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> popAIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(popAIndex&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty() || popA[popAIndex]!=stack.peek())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pushAIndex==len)&#123; <span class="comment">//直到入栈序列遍历完还没找到则false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(pushA[pushAIndex]);</span><br><span class="line">            pushAIndex++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                popAIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//直到出栈序列遍历完返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="46"></a></p>
<h2 id="46-二叉树的层序遍历-3道"><a href="#46-二叉树的层序遍历-3道" class="headerlink" title="46.二叉树的层序遍历(3道)"></a>46.二叉树的层序遍历(3道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二叉树的层序遍历--《剑指offer》p171</span><br><span class="line">二叉树的层序遍历，按行打印--《剑指offer》p174、leetcode 102、leetcode107</span><br><span class="line">二叉树的层序遍历，之字形按行打印--《剑指offer》p176、leetcode 103</span><br></pre></td></tr></table></figure>

<h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h3><p>《剑指offer》p171</p>
<p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路：借助队列实现层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历。思路：辅助队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        res.add(temp.val);</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-二叉树的层序遍历，按行打印"><a href="#2-二叉树的层序遍历，按行打印" class="headerlink" title="2.二叉树的层序遍历，按行打印"></a>2.二叉树的层序遍历，按行打印</h3><p>《剑指offer》p174、leetcode 102、leetcode107</p>
<p>题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCnt</span></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(pRoot);</span><br><span class="line">    <span class="keyword">int</span> curCnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextCnt = <span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; resTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        resTemp.add(temp.val);</span><br><span class="line">        curCnt--;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.left);</span><br><span class="line">            nextCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.right);</span><br><span class="line">            nextCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(curCnt==<span class="number">0</span>)&#123;</span><br><span class="line">            res.add(resTemp);</span><br><span class="line">            resTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curCnt = nextCnt;</span><br><span class="line">            nextCnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-二叉树的层序遍历，之字形按行打印"><a href="#3-二叉树的层序遍历，之字形按行打印" class="headerlink" title="3.二叉树的层序遍历，之字形按行打印"></a>3.二叉树的层序遍历，之字形按行打印</h3><p>《剑指offer》p176、leetcode 103</p>
<p>题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数；且辅助奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCnt</span></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(pRoot);</span><br><span class="line">    <span class="keyword">int</span> curCnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextCnt = <span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; resTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> odd = <span class="keyword">true</span>; <span class="comment">//奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode temp = queue.poll();</span><br><span class="line">        resTemp.add(temp.val);</span><br><span class="line">        curCnt--;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(temp.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.left);</span><br><span class="line">            nextCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(temp.right);</span><br><span class="line">            nextCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(curCnt==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!odd)&#123;<span class="comment">//当前行是偶数行，从右往左，reverse下</span></span><br><span class="line">                Collections.reverse(resTemp);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(resTemp);</span><br><span class="line">            resTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curCnt = nextCnt;</span><br><span class="line">            nextCnt = <span class="number">0</span>;</span><br><span class="line">            odd = !odd;<span class="comment">//下一行的奇偶是!odd</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="47"></a></p>
<h2 id="47-递归与非递归实现二叉树前序、中序、后序遍历"><a href="#47-递归与非递归实现二叉树前序、中序、后序遍历" class="headerlink" title="47.递归与非递归实现二叉树前序、中序、后序遍历"></a>47.递归与非递归实现二叉树前序、中序、后序遍历</h2><p>《左神》88、 leetcode144、94、145</p>
<p>题目：递归与非递归实现二叉树前序、中序、后序遍历</p>
<h3 id="1-前序："><a href="#1-前序：" class="headerlink" title="1.前序："></a>1.前序：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现前序遍历</span></span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	res.add(root.val);</span><br><span class="line">	<span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		res = preorderTraversal(root.left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		res = preorderTraversal(root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//非递归实现前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//定义栈</span></span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(temp.val);<span class="comment">//压栈之前先访问</span></span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = stack.pop().right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现中序遍历</span></span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = inorderTraversal(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = inorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="comment">//非递归实现中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = stack.pop();</span><br><span class="line">            res.add(temp.val);</span><br><span class="line">            temp = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<h3 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现后序遍历</span></span><br><span class="line">ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = postorderTraversal(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = postorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//非递归实现后序遍历。思路：1.根右左压栈，利用中间栈output来存储逆后序遍历的结果 + 2.最后再一起输出即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//定义栈,存根节点</span></span><br><span class="line">    Stack&lt;TreeNode&gt; output = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//还需要一个辅助栈来存储逆后序遍历的结果</span></span><br><span class="line">    TreeNode temp = root;</span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            output.push(temp);</span><br><span class="line">            temp = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp = stack.pop().left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!output.isEmpty())&#123;</span><br><span class="line">        res.add(output.pop().val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="48"></a></p>
<h2 id="48-判断数组是否为二叉搜索树的后续遍历序列"><a href="#48-判断数组是否为二叉搜索树的后续遍历序列" class="headerlink" title="48.判断数组是否为二叉搜索树的后续遍历序列"></a>48.判断数组是否为二叉搜索树的后续遍历序列</h2><p>《剑指offer》p179.</p>
<p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p>思路：后序遍历序列是左右根，所以先取数组中最后一个数，作为根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.找根</span><br><span class="line">2.找根左右的左右分界线(从左往右第一个比根大的即为右)</span><br><span class="line">3.右可以没有，如果有右，则右中不含比根小的，否则false</span><br><span class="line">4.递归判断下去</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果,假设输入的数组的任意两个数字都互不相同。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> *   1.找根</span></span><br><span class="line"><span class="comment"> *   2.找根左右的左右分界线(从左往右第一个比根大的即为➡右)</span></span><br><span class="line"><span class="comment"> *   3.右可以没有，如果有右，则右中不含比根小的，否则false</span></span><br><span class="line"><span class="comment"> *   4.递归判断下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">​        <span class="keyword">if</span>(sequence==<span class="keyword">null</span> || sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">​            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span>(sequence.length==<span class="number">1</span>)&#123;</span><br><span class="line">​            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">return</span> VerifySquenceOfBSTDetail(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBSTDetail</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">​        <span class="keyword">if</span>(start&gt;end)&#123;</span><br><span class="line">​            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">​            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="comment">//1.找根</span></span><br><span class="line">​        <span class="keyword">int</span> root = sequence[end];</span><br><span class="line">​</span><br><span class="line">​        <span class="comment">//2.找左右分界线</span></span><br><span class="line">​        <span class="keyword">int</span> rightIndex = start;</span><br><span class="line">​        <span class="keyword">int</span> temp = start;</span><br><span class="line">​        <span class="keyword">while</span>(temp&lt;end)&#123;</span><br><span class="line">​            <span class="keyword">if</span>(sequence[temp]&gt;root)&#123;<span class="comment">//第一个比root大的节点即为右</span></span><br><span class="line">​                rightIndex = temp;</span><br><span class="line">​                <span class="keyword">break</span>;</span><br><span class="line">​            &#125;</span><br><span class="line">​            temp++;</span><br><span class="line">​        &#125;</span><br><span class="line">​        <span class="keyword">if</span>(temp==end)&#123;<span class="comment">//只有左，没有右，则递归判断左即可</span></span><br><span class="line">​            <span class="keyword">return</span> VerifySquenceOfBSTDetail(sequence, start, end-<span class="number">1</span>);</span><br><span class="line">​        &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="comment">//3.有右，则右中不能含比根小的，否则返回false</span></span><br><span class="line">    temp = rightIndex;</span><br><span class="line">    <span class="keyword">while</span>(temp&lt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence[temp]&lt;root)&#123;<span class="comment">//右中含比根小的，返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.递归判断左、右序列即可</span></span><br><span class="line">    <span class="keyword">if</span>(rightIndex==start)&#123;<span class="comment">//只有左，没有右，递归判断右即可</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBSTDetail(sequence, rightIndex, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//有左有右</span></span><br><span class="line">        <span class="keyword">return</span> VerifySquenceOfBSTDetail(sequence, start, rightIndex-<span class="number">1</span>) &amp;&amp; VerifySquenceOfBSTDetail(sequence, rightIndex, end-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="49"></a></p>
<h2 id="49-二叉树中和为指定值的路径-2道"><a href="#49-二叉树中和为指定值的路径-2道" class="headerlink" title="49.二叉树中和为指定值的路径(2道)"></a>49.二叉树中和为指定值的路径(2道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leetcode 112--二叉树中和为指定值的一条路径</span><br><span class="line">《剑指offer》p182、leetcode 113--二叉树中和为指定值的所有路径(回溯法)</span><br></pre></td></tr></table></figure>

<h3 id="1-Path-Sum"><a href="#1-Path-Sum" class="headerlink" title="1.Path Sum"></a>1.Path Sum</h3><p>leetcode 112</p>
<p>题目：二叉树中和为指定值的一条路径。</p>
<p>思路：正常递归遍历即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出二叉树中结点值的和为输入整数的满足条件的一条路径。</span></span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; sum==<span class="number">0</span>)&#123;<span class="comment">//当前节点为叶节点且路径和==sum，true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left,sum) || hasPathSum(root.right, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Path-Sum-2"><a href="#2-Path-Sum-2" class="headerlink" title="2.Path Sum 2"></a>2.Path Sum 2</h3><p>《剑指offer》p182、leetcode 113</p>
<p>题目：二叉树中和为指定值的所有路径。输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p>思路：回溯法。遍历树每一条到叶子节点的路径，找寻符合条件的路径。到叶子节点如果还没有找到路径，就要回退到父节点继续寻找，依次类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印出二叉树中结点值的和为输入整数的满足条件的所有路径。思路：递归+回溯法</span></span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放所有路径</span></span><br><span class="line">ArrayList&lt;Integer&gt; tempPath = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放当前路径</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    target -= root.val;</span><br><span class="line">    tempPath.add(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; target==<span class="number">0</span>)&#123;<span class="comment">//当前节点是叶节点且路径和==target，满足条件</span></span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempPath));</span><br><span class="line">    &#125;</span><br><span class="line">    FindPath(root.left, target);</span><br><span class="line">    FindPath(root.right, target);</span><br><span class="line">    tempPath.remove(tempPath.size()-<span class="number">1</span>);<span class="comment">//回溯点</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="50"></a></p>
<h2 id="50-复杂链表的复制"><a href="#50-复杂链表的复制" class="headerlink" title="50.复杂链表的复制"></a>50.复杂链表的复制</h2><p>《剑指offer》p187、《左神》56、leetcode138</p>
<p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>思路：分而治之，复杂问题分成小问题一一解决。时间o(n) 空间o(1)<br>1、遍历链表并复制结点，复制的结点在相应节点之后：a-&gt;b-&gt;c-&gt;d-&gt;e为a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’-&gt;d-&gt;d’-&gt;e-&gt;e’<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> label;</span><br><span class="line">    <span class="keyword">public</span> RandomListNode next, random;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.label = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        RandomListNode p = head;</span><br><span class="line">        <span class="comment">//1.遍历链表，复制节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode newNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">            newNode.next = p.next;</span><br><span class="line">            p.next = newNode;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//2.遍历链表，复制random指针</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.random!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                p.next.random = p.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.拆分链表，将复制链表拆出来</span></span><br><span class="line">        p = pHead;</span><br><span class="line">        RandomListNode newHead = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);<span class="comment">//新链表的哨兵</span></span><br><span class="line">        RandomListNode newP = newHead;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            RandomListNode temp = p.next;</span><br><span class="line">            p.next = p.next.next;</span><br><span class="line">            temp.next = <span class="keyword">null</span>;</span><br><span class="line">            newP.next = temp;</span><br><span class="line">            newP = newP.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="51"></a></p>
<h2 id="51-二叉搜索树与双向链表-两道"><a href="#51-二叉搜索树与双向链表-两道" class="headerlink" title="51.二叉搜索树与双向链表(两道)"></a>51.二叉搜索树与双向链表(两道)</h2><h3 id="1-二叉搜索树转双向链表"><a href="#1-二叉搜索树转双向链表" class="headerlink" title="1.二叉搜索树转双向链表"></a>1.二叉搜索树转双向链表</h3><p>《剑指offer》p191、leetcode426、《左神》74</p>
<p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：中序遍历+记录有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序，因此需要辅助保存当前链表最后一个节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode lastPointer = <span class="keyword">null</span>;<span class="comment">//当前有序双向链表的最后一个节点</span></span><br><span class="line">        lastPointer = ConvertDetail(lastPointer, root);</span><br><span class="line">        <span class="keyword">while</span>(lastPointer.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastPointer = lastPointer.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPointer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历，返回当前有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序的了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">ConvertDetail</span><span class="params">(TreeNode lastPointer, TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> lastPointer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastPointer = ConvertDetail(lastPointer, root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = lastPointer;</span><br><span class="line">        <span class="keyword">if</span>(lastPointer!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastPointer.right = root;</span><br><span class="line">        &#125;</span><br><span class="line">        lastPointer = root;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            lastPointer = ConvertDetail(lastPointer, root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastPointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-有序数组转平衡二叉树"><a href="#2-有序数组转平衡二叉树" class="headerlink" title="2.有序数组转平衡二叉树"></a>2.有序数组转平衡二叉树</h3><p>leetcode 108</p>
<p>题目：Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>思路：数组中间的数做root，递归二分即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序数组转成平衡二叉树。思路：数组中间的数做root，递归二分即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArrayToBSTDetail(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBSTDetail</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&lt;<span class="number">0</span> || end&gt;=nums.length || start&gt;end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    </span><br><span class="line">    root.left = sortedArrayToBSTDetail(nums, start, mid-<span class="number">1</span>);</span><br><span class="line">    root.right = sortedArrayToBSTDetail(nums, mid+<span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="52"></a></p>
<h2 id="52-序列化二叉树"><a href="#52-序列化二叉树" class="headerlink" title="52.序列化二叉树"></a>52.序列化二叉树</h2><p>《剑指offer》p194、leetcode 297(序列化反序列化二叉树）、leetcode 449(序列化反序列化平衡二叉树)</p>
<p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>思路：序列化：前序遍历，遇到子节点为空用”$”代替；反序列化：按照前序遍历序列化的顺序进行反推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请实现两个函数，分别用来序列化和反序列化二叉树</span></span><br><span class="line"><span class="comment">//1.序列化：前序遍历，遇到空节点为空用"null"代替</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    serializeDetail(root, res);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样分开的话，递归的时候不用保存全局变量res，防止二叉树太深导致的递归栈溢出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializeDetail</span><span class="params">(TreeNode root, StringBuilder res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        res.append(<span class="string">"null,"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(root.val + <span class="string">","</span>);</span><br><span class="line">    serializeDetail(root.left, res);</span><br><span class="line">    serializeDetail(root.right, res);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2.反序列化：按照前序遍历序列化的顺序进行反推,将String转成ArrayList&lt;String&gt;方便删除同时节省空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] str = data.split(<span class="string">","</span>);</span><br><span class="line">    ArrayList&lt;String&gt; strr = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(str));</span><br><span class="line">    <span class="keyword">return</span> deserializeDetail(strr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeDetail</span><span class="params">(ArrayList&lt;String&gt; strr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(strr.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String temp = strr.get(<span class="number">0</span>);</span><br><span class="line">    strr.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(temp.equals(<span class="string">"null"</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(temp));</span><br><span class="line">    root.left = deserializeDetail(strr);</span><br><span class="line">    root.right = deserializeDetail(strr);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="53"></a></p>
<h2 id="53-全排列-组合问题-五道"><a href="#53-全排列-组合问题-五道" class="headerlink" title="53.全排列/组合问题(五道)"></a>53.全排列/组合问题(五道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.字符串的全排列(abc,acb...)--《剑指offer》p197</span><br><span class="line">2.无重复数字的全排列--leetcode 46</span><br><span class="line">3.有重复数字的全排列--leetcode 47</span><br><span class="line">4.八皇后问题--《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)</span><br><span class="line">5.字符串s1的全排列是否在s2字符串中--leetcode 567</span><br></pre></td></tr></table></figure>

<h3 id="1-字符串的全排列"><a href="#1-字符串的全排列" class="headerlink" title="1.字符串的全排列"></a>1.字符串的全排列</h3><p>《剑指offer》p197</p>
<p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>例如输入字符串abc，则打印由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。注意aac aac只能有一个，需要过滤重复</p>
<p>思路：递归。我们求整个字符串的排列，可以看成两步：首先求出所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的全排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    PermutationDetail(res, str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">    Collections.sort(res);<span class="comment">//最后排序一下，按字典序输出</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PermutationDetail</span><span class="params">(ArrayList&lt;String&gt; res, <span class="keyword">char</span>[] str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==str.length)&#123;<span class="comment">//递归出口</span></span><br><span class="line">        String temp = String.valueOf(str);</span><br><span class="line">        <span class="keyword">if</span>(!res.contains(temp))&#123;<span class="comment">//过滤重复</span></span><br><span class="line">            res.add(String.valueOf(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;str.length; ++i)&#123;</span><br><span class="line">        swap(str, i, index);<span class="comment">//每次递归将index位置字符与后面所有字符进行分别交换</span></span><br><span class="line">        PermutationDetail(res, str, index+<span class="number">1</span>);<span class="comment">//当前位置交换后进行下一位上的排列递归</span></span><br><span class="line">        swap(str, i, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp = str[i];</span><br><span class="line">    str[i] = str[j];</span><br><span class="line">    str[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-无重复数字的全排列"><a href="#2-无重复数字的全排列" class="headerlink" title="2.无重复数字的全排列"></a>2.无重复数字的全排列</h3><p>leetcode 46</p>
<p>题目：和字符串的全排列一样，换汤不换药。给定一个无重复数字的序列，返回这些数所能排列出所有序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字的全排列</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    permuteDetail(res, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permuteDetail</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.length)&#123;<span class="comment">//递归出口</span></span><br><span class="line">        Integer[] temp = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp[i]= nums[i];<span class="comment">//int-&gt;Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(Arrays.asList(temp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        swap(nums, i, index);<span class="comment">//每次递归将index位置字符与后面所有字符进行分别交换</span></span><br><span class="line">        permuteDetail(res, nums, index+<span class="number">1</span>);<span class="comment">//当前位置交换后进行下一位上的排列递归</span></span><br><span class="line">        swap(nums, i, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-有重复数字的全排列"><a href="#3-有重复数字的全排列" class="headerlink" title="3.有重复数字的全排列"></a>3.有重复数字的全排列</h3><p>leetcode 47</p>
<p>题目：给定一个有重复数字的序列，返回这些数所能排列出所有序列。注意需要把重复的全排列给过滤掉</p>
<p>思路：有重复的数字的全排列。为了过滤重复，对于同一个值，只交换一次，否则跳过。为了保证这一点，辅助<strong>hash表</strong>来过滤重复的元素，如果重复则跳过不交换即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有重复数组的全排列。需要过滤重复，思路：用hash即可，不用排序</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    permuteUniqueDetail(res, nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">permuteUniqueDetail</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.length)&#123;<span class="comment">//递归出口</span></span><br><span class="line">        Integer[] itg = <span class="keyword">new</span> Integer[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;<span class="comment">//int-&gt;Integer</span></span><br><span class="line">            itg[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; temp = Arrays.asList(itg);</span><br><span class="line">        res.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; used = <span class="keyword">new</span> HashSet&lt;&gt;();<span class="comment">//hashSet记录已经访问过的数，避免重复排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(used.add(nums[i]))&#123;<span class="comment">//对于同一个值，只交换一次，否则跳过。</span></span><br><span class="line">            swap(nums, index, i);</span><br><span class="line">            permuteUniqueDetail(res, nums, index+<span class="number">1</span>);</span><br><span class="line">            swap(nums, index, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-八皇后问题"><a href="#4-八皇后问题" class="headerlink" title="4.八皇后问题"></a>4.八皇后问题</h3><p>《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)</p>
<p>题目：在n*n的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角斜线上。下图中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请求出总共有多少种摆法或者输出八皇后摆法。</p>
<p>思路：八皇后问题(不能同一行、列、对角线)。<strong>思路：转化为数字的全排列问题。总体思路: 0-n全排列的总数 - check(全排列出现同时在对角线上的)。</strong></p>
<p>详细思路：八个皇后的任意两个不能处在同一行，那么这肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把ColumnIndex的八个数字分别用0-7初始化，接下来我们要做的事情就是对数组ColumnIndex做全排列。由于我们是用不同的数字初始化数组中的数字，因此任意两个皇后肯定不同列。我们只需要判断得到的每一个排列对应的八个皇后是不是在同一对角斜线上，也就是数组的两个下标i和j，是不是i-j==ColumnIndex[i]-Column[j]或者j-i==ColumnIndex[i]-ColumnIndex[j]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//八皇后问题(不能同一行、列、对角线)。思路：转化为数字的全排列问题：76548321-&gt;皇后分别在：第一行的7，第二行的6...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//将八皇后问题转成不重复数字全排列问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;<span class="comment">//0-n个数字全排列之前初始化</span></span><br><span class="line">        nums[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    solveNQueensDetail(res, nums, <span class="number">0</span>);<span class="comment">//全排列并且判断是否满足八皇后，满足的排列存入结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//全排列并判断是否满足八皇后(不能出现在同一对角线)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solveNQueensDetail</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.length)&#123;<span class="comment">//递归出口</span></span><br><span class="line">        <span class="keyword">if</span>(!check(nums))&#123;<span class="comment">//不满足八皇后(同一对角线)</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;<span class="comment">//将八皇后排列转成输出格式--&gt;..Q.</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">int</span> cnt = nums[i];</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(ct&lt;cnt)&#123;</span><br><span class="line">                sb.append(<span class="string">"."</span>);</span><br><span class="line">                ct++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"Q"</span>);</span><br><span class="line">            ct++;</span><br><span class="line">            <span class="keyword">while</span>(ct&lt;nums.length)&#123;</span><br><span class="line">                sb.append(<span class="string">"."</span>);</span><br><span class="line">                ct++;</span><br><span class="line">            &#125;</span><br><span class="line">            tempList.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tempList);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        swap(nums, index, i);</span><br><span class="line">        solveNQueensDetail(res, nums, index+<span class="number">1</span>);</span><br><span class="line">        swap(nums, index, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否同一对角线</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;<span class="comment">//检查一种排列是否出现在同一对角线，是则不是八皇后排列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;nums.length; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>( Math.abs(i-j)==Math.abs(nums[i]-nums[j]) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-字符串s1的全排列是否在s2字符串中"><a href="#5-字符串s1的全排列是否在s2字符串中" class="headerlink" title="5.字符串s1的全排列是否在s2字符串中"></a>5.字符串s1的全排列是否在s2字符串中</h3><p>leetcode 567 Permutation in String</p>
<p>题目：Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:s1 &#x3D; &quot;ab&quot; s2 &#x3D; &quot;eidbaooo&quot;</span><br><span class="line">Output:True</span><br><span class="line">Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>方法1：最简单最暴力的方法其实就是找到s1的所有<strong>全排列</strong>，然后在s2中查找是否这些全排列字符串在s2中。但是这种方法<strong>耗时太大，会导致超时</strong>。</p>
<p>方法2：<strong>滑动窗口</strong><br>其实不需要找到s1的全排列，因为我们只需要考虑s2中是否包含s1中同样个数的字符，并且这些字符是连在一起的就行了。因此，我们可以使用一个滑动窗口，在s2上滑动。在这个滑动窗口中的字符及其个数是否刚好等于s1中的字符及其个数，此外滑动窗口保证了这些字符是连在一起的。</p>
<p>具体思路：辅助两个map键值对来模拟滑动窗口中的字符情况，由于都是小写字母，不用map，直接用int[26]来模拟map即可</p>
<p>注意：判断两个数组是否相等<code>Arrays.equals(int[] num1, int[] num2);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1==<span class="keyword">null</span> || s1.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s2==<span class="keyword">null</span> || s2.length()==<span class="number">0</span> || s1.length()&gt;s2.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] map1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//s1的字符键值对</span></span><br><span class="line">    <span class="keyword">int</span>[] map2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//s2上滑动窗口的字符键值对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length(); ++i)&#123;<span class="comment">//记录s1的字符map</span></span><br><span class="line">        map1[s1.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s2.length(); ++i)&#123;<span class="comment">//遍历s2，滑动窗口</span></span><br><span class="line">        map2[s2.charAt(i)-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">if</span>((i+<span class="number">1</span>)&gt;=s1.length())&#123;<span class="comment">//滑动窗口</span></span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(map1, map2))&#123;<span class="comment">//如果两个map包含的字符一样，则找到了s2中的s1的全排列</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//否则，滑动窗口map2删除最左边的元素</span></span><br><span class="line">                map2[s2.charAt(i-s1.length()+<span class="number">1</span>)-<span class="string">'a'</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="54"></a></p>
<h2 id="54-打印出给定字符串中字符的所有组合"><a href="#54-打印出给定字符串中字符的所有组合" class="headerlink" title="54.打印出给定字符串中字符的所有组合"></a>54.打印出给定字符串中字符的所有组合</h2><p>题目：”abc”-&gt;打印a,b,c,ab,ac,bc,abc</p>
<p>思路：在字符串位置的index到chs.length()-1中找number个数，组合成字符串放在list中，每次递归到chs[index]字符时，都有两种选择：</p>
<p>1.放进组合，在begin+1到chs.length()-1中找number-1个数；</p>
<p>2.不放进组合，在begin+1到chs.length()-1中找number个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(<span class="keyword">char</span>[] chs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(chs==<span class="keyword">null</span> || chs.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(chs.length==<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(chs[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Character&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=chs.length; ++i)&#123;<span class="comment">//组合数字的个数[1~chs.length]</span></span><br><span class="line">        combineDetail(chs, i, <span class="number">0</span>, tempList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从index开始找combineNum个数字的组合，并打印</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">combineDetail</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> combineNum, <span class="keyword">int</span> index, List&lt;Character&gt; tempList)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(combineNum==<span class="number">0</span>)&#123; <span class="comment">//找到一种number个字符的组合，将list-&gt;String打印出来并回溯</span></span><br><span class="line">        System.out.println(tempList.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index==chs.length)&#123;<span class="comment">//递归出口: 找完number个字符的所有组合，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前位置的数字放进组合，则往后需要找combineNum-1个数</span></span><br><span class="line">    tempList.add(chs[index]);</span><br><span class="line">    combineDetail(chs, combineNum-<span class="number">1</span>, index+<span class="number">1</span>, tempList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前位置的数字不放进组合，则往后需要找combineNum个数</span></span><br><span class="line">    tempList.remove(Character.valueOf(chs[index]));<span class="comment">//回溯</span></span><br><span class="line">    combineDetail(chs, combineNum, index+<span class="number">1</span>, tempList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] nums = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">    combine(nums);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">out:</span><br><span class="line"></span><br><span class="line">[a]</span><br><span class="line">[b]</span><br><span class="line">[c]</span><br><span class="line">[a, b]</span><br><span class="line">[a, c]</span><br><span class="line">[b, c]</span><br><span class="line">[a, b, c]</span><br></pre></td></tr></table></figure>

<p><a name="55"></a></p>
<h2 id="55-大-小根堆–优先队列实现-两道"><a href="#55-大-小根堆–优先队列实现-两道" class="headerlink" title="55.大/小根堆–优先队列实现(两道)"></a>55.大/小根堆–优先队列实现(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找出数组中最小的k个数(优先队列大根堆)--《剑指offer》p209</span><br><span class="line">找出数组中第k大的数(优先队列小根堆)--leetcode 215</span><br></pre></td></tr></table></figure>

<p>注：java优先队列默认小根堆</p>
<h3 id="1-找出数组中最小的k个数-优先队列大根堆"><a href="#1-找出数组中最小的k个数-优先队列大根堆" class="headerlink" title="1.找出数组中最小的k个数(优先队列大根堆)"></a>1.找出数组中最小的k个数(优先队列大根堆)</h3><p>《剑指offer》p209</p>
<p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>思路：辅助一个k长的优先队列大根堆，遍历数组的同时每次用大根堆替换k长容器的值(适合海量不能修改数组的数据)—&gt;o(nlogk)。<strong>大根堆的实现用优先队列大根堆</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出数组中最小的k个数(优先队列大根堆)。思路：用优先队列的大根堆。时间o(nlogk)，空间o(k)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input==<span class="keyword">null</span> || input.length==<span class="number">0</span> || k&lt;<span class="number">1</span> || k&gt;input.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于java默认小根堆，所以定义一个k长的大根堆</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">            queue.offer(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.peek()&gt;input[i])&#123;<span class="comment">//把大的数都出堆，留下最小的k个数</span></span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(queue);<span class="comment">//treeSet-&gt;ArrayList&lt;Integer&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-找出数组中第k大的数-优先队列小根堆"><a href="#2-找出数组中第k大的数-优先队列小根堆" class="headerlink" title="2.找出数组中第k大的数(优先队列小根堆)"></a>2.找出数组中第k大的数(优先队列小根堆)</h3><p>leetcode 215 Kth Largest Element in an Array</p>
<p>题目：Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>Example 1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p>思路：辅助用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回数组中第k大的数,k总是有效的。思路：用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();<span class="comment">//默认小根堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">            queue.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.peek()&lt;nums[i])&#123;<span class="comment">//注意这里要比较一下，不满足就不用出堆</span></span><br><span class="line">                queue.poll();</span><br><span class="line">                queue.offer(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="56"></a></p>
<h2 id="56-数据流中的中位数"><a href="#56-数据流中的中位数" class="headerlink" title="56.数据流中的中位数"></a>56.数据流中的中位数</h2><p>《剑指offer》p209、leetcode 295</p>
<p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p>思路：对于数据流，对应的就是在线算法了，一道很经典的题目就是在1亿个数中找到最大的前100个数，这是一道堆应用题，找最大的前100个数，那么我们就创建一个大小为100的最小化堆，每来一个元素就与堆顶元素比较，因为堆顶元素是目前前100大数中的最小数，前来的元素如果比该元素大，那么就把原来的堆顶替换掉。那么对于这一道题呢？如果单纯的把所有元素放到一个数组里，每次查找中位数最快也要O(n)，综合下来是O(n^2)的复杂度。<br>我们可以利用上面例子中的想法：动态查找考虑堆，中位数左边的数比它小，右边的数比它大。故用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器，因为要找中位数所以也要保证两边容器的数据个数差不超过1。</p>
<p>java堆的实现用优先队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//左边的大根堆，存比中位数小的数</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; bigHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2-o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//右边的小根堆，存比中位数大的数</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; smallHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//优先放左边的大根堆，左边的大根堆与右边的小根堆的size只能差1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( bigHeap.size()==smallHeap.size() )&#123;<span class="comment">//放左边大根堆</span></span><br><span class="line">            <span class="keyword">if</span>(!smallHeap.isEmpty() &amp;&amp; smallHeap.peek()&lt;num) &#123;<span class="comment">//如果num比右边的小根堆的peek大，应该交换下放到右边</span></span><br><span class="line">                bigHeap.offer(smallHeap.poll());</span><br><span class="line">                smallHeap.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                bigHeap.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( bigHeap.size()&gt;smallHeap.size() )&#123;<span class="comment">//放右边小根堆</span></span><br><span class="line">            <span class="keyword">if</span>(bigHeap.peek()&gt;num)&#123;<span class="comment">//如果num比左边的大根堆的peek小，应该交换下放到左边</span></span><br><span class="line">                smallHeap.offer(bigHeap.poll());</span><br><span class="line">                bigHeap.offer(num);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                smallHeap.offer(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( bigHeap.size()&gt;smallHeap.size() )&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)bigHeap.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  ((<span class="keyword">double</span>)bigHeap.peek() + (<span class="keyword">double</span>)smallHeap.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">            s.Insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s.GetMedian());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="57"></a></p>
<h2 id="57-数组中最大连续子序列的和"><a href="#57-数组中最大连续子序列的和" class="headerlink" title="57.数组中最大连续子序列的和"></a>57.数组中最大连续子序列的和</h2><p>《剑指offer》p218、leetcode 53</p>
<p>题目：给一个数组，返回它的最大连续子序列的和</p>
<p>思路：</p>
<p>法一：动态规划。DP[i]表示以i结尾的数组，目前最大连续子序列的和是DP[i]。递推公式：DP[i] = max{DP[i-1] + A[i],A[i]}</p>
<p>法二：更高效。动态规划需要额外数组存，所以本题改进不用额外的空间，直接<strong>辅助两个变量遍历一遍数组即可</strong>。两个变量：tempMax记录数组中每一段和大于0的连续子数组，整个数组有很多个这样的tempMax；最后的resultMax是这些tempMax最大的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有负数的数组中，连续子序列的最大和为多少。思路：辅助两个变量，resMax,tempMax，当tempMax&lt;=0时，tempMax=0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> resMax = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> tempMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; ++i)&#123;</span><br><span class="line">        tempMax += array[i];</span><br><span class="line">        resMax = Math.max(resMax, tempMax);</span><br><span class="line">        <span class="keyword">if</span>(tempMax&lt;=<span class="number">0</span>)&#123;<span class="comment">//当tempMax&lt;=0，那当前这段连续子数组就不要了，tempMax重置为0</span></span><br><span class="line">            tempMax = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="58"></a></p>
<h2 id="58-1到n整数中1出现的次数"><a href="#58-1到n整数中1出现的次数" class="headerlink" title="58.1到n整数中1出现的次数"></a>58.1到n整数中1出现的次数</h2><p>《剑指offer》p221、leetcode 233</p>
<p>题目：求1 到 n 中1出现的次数。e.g.1~13的整数中1出现的次数：1、10、11、12、13因此共出现5次</p>
<p>思路：按位进行讨论计算。对数字的每一位单独拿出讨论，按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可。</p>
<p><strong>计算规则：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">​若weight为0，则1出现次数为round*base</span><br><span class="line">若weight为1，则1出现次数为round*base+former+1</span><br><span class="line">​若weight大于1，则1出现次数为round*base+base</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>详细请参考<a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">从1到n整数中1出现的次数：O(logn)算法</a></p>
<p>​```java<br>//求出1到n出现1的次数。思路：按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可<br>public static int NumberOf1Between1AndN_Solution(int n) {<br>    int res = 0;</p>
<pre><code>int round = n;
int weight;
int former;
int base = 1;
while(round!=0){
    weight = round%10;
    round /= 10;
    former = n%base;
    res += round*base;//res += weight*base

    if(weight==1){//res += former + 1
        res += former + 1;
    }
    else if(weight&gt;1){//res += base
        res += base;
    }
    base *= 10;
}

return res;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;a name&#x3D;&quot;59&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line">## 59.正整数序列中的第n个数字 </span><br><span class="line"></span><br><span class="line">《剑指offer》p221、leetcode 400</span><br><span class="line"></span><br><span class="line">题目：在整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...中找到第 n个数字，n是正数且在32为整形范围内(n &lt; 231)。e.g.第5位是5，第13位是1</span><br><span class="line"></span><br><span class="line">思路：一位数0-9数字在序列中占10位，两位数10-99数字在序列中占2*90&#x3D;180位，三位数100-999有3*900&#x3D;2700位。当n&#x3D;1001时，n-10-180&#x3D;811&gt;0 &amp;&amp; n-10-180-2700&lt;0，且811&#x3D;3*270+1，说明第n位在三位数的100之后第270个数字即370的中间一位，即7。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;正整数序列中的第n个数字。思路：</span><br><span class="line">public static int findNthDigit(int n) &#123;</span><br><span class="line">    if(n&lt;10)&#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    int digitLen &#x3D; 2; &#x2F;&#x2F;当前区间的位数，如：10~99的2</span><br><span class="line">    int start &#x3D; 10; &#x2F;&#x2F;当前区间的起始数，如：10~99的10</span><br><span class="line">    int base &#x3D; 90; &#x2F;&#x2F;当前区间的所有位数，如10~99的90</span><br><span class="line">    n -&#x3D; 9;</span><br><span class="line">    while(n!&#x3D;0)&#123;</span><br><span class="line">        int objectNum &#x3D; (int)Math.ceil((double)n&#x2F;digitLen) + start -1;&#x2F;&#x2F;定位到了目标数字</span><br><span class="line">        if(objectNum&lt;(start*10))&#123;&#x2F;&#x2F;目标数字就在当前区间,这样判断是为了防止int溢出</span><br><span class="line">            int loc &#x3D; n%digitLen; &#x2F;&#x2F;定位到目标数字的第几位，从左往右</span><br><span class="line">            if(loc&#x3D;&#x3D;0)&#123;</span><br><span class="line">                loc &#x3D; digitLen-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                loc &#x3D; loc-1;</span><br><span class="line">            &#125;</span><br><span class="line">            String num &#x3D; String.valueOf(objectNum);</span><br><span class="line">            return num.charAt(loc)-&#39;0&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;&#x2F;&#x2F;目标数字在下一个区间</span><br><span class="line">            n -&#x3D; (base*digitLen);</span><br><span class="line">            digitLen++;</span><br><span class="line">            start *&#x3D; 10;</span><br><span class="line">            base *&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="60"></a></p>
<h2 id="60-把数组排成最小的数"><a href="#60-把数组排成最小的数" class="headerlink" title="60.把数组排成最小的数"></a>60.把数组排成最小的数</h2><p>《剑指offer》p227、leetcode 179</p>
<p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>注意：</p>
<p>我们要判断一个数字的最高位上的数字，故最方便的方法是：数字转成字符串。</p>
<p>且数字拼接过程很可能大数溢出int类型，更要用字符串拼接比较</p>
<p>思路：</p>
<p><strong>1.先把数组中的整数转换成字符串，2.然后用compareTo中定义比较规则，3.并根据该规则调用库函数sort()排序，4.最后把排序后数字字符串依次打印出来即为所求最小的数字。时间复杂度就是排序的时间复杂度o(nlogn)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把数组排成最小的数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.int[] --&gt; String[]</span></span><br><span class="line">    String[] strings = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; ++i)&#123;</span><br><span class="line">        strings[i] = numbers[i]+<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.定义字符串排序的比较规则</span></span><br><span class="line">    Comparator&lt;String&gt; com = <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            String s1 = o1 + o2;</span><br><span class="line">            String s2 = o2 + o1;</span><br><span class="line">            <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.对String[]排序</span></span><br><span class="line">    Arrays.sort(strings, com);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.拼接字符串</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strings.length; ++i)&#123;</span><br><span class="line">        sb.append(strings[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sb.charAt(<span class="number">0</span>)==<span class="string">'0'</span>)&#123;<span class="comment">//"0000"--&gt;"0"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="61"></a></p>
<h2 id="61-求把一个数字翻译成不同字符串的个数-DP"><a href="#61-求把一个数字翻译成不同字符串的个数-DP" class="headerlink" title="61.求把一个数字翻译成不同字符串的个数(DP)"></a>61.求把一个数字翻译成不同字符串的个数(DP)</h2><p>《剑指offer》p231、leetcode 91</p>
<p>题目: 求把数字翻译成字符串的个数。0-&gt;a,1-&gt;b…11-&gt;l,25-&gt;z。求一个数字有多少种不同的翻译方法。e.g.258-&gt;2,58、25,8</p>
<p>题目分析：这道题要求解码方法，跟之前那道 Climbing Stairs 爬梯子问题 非常的相似，但是还有一些其他的限制条件，比如说一位数时不能为0，两位数不能大于26，其十位上的数也不能为0，除去这些限制条件，跟爬梯子基本没啥区别，也勉强算特殊的斐波那契数列，当然需要用动态规划DP来解。</p>
<p>思路：DP问题。f(i)为第i位开始到最右边结束的数字的翻译个数。–&gt;动态规划题，解题分析步骤如下。</p>
<p><strong>1.从左往右DP分析</strong>：定义f(i)为从i至字符串s最右边结束的不同字符串的个数，因此所求为f(0)。<strong>f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)</strong></p>
<p><strong>2.详细的DP方程：</strong> f(i) = </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0,   s[i]&#x3D;&#x3D;‘0’</span><br><span class="line">f(i+2),   s[i+1]&#x3D;&#x3D;‘0’ &amp;&amp; (s[i]&#x3D;&#x3D;‘1’ || s[i]&#x3D;&#x3D;‘2’)</span><br><span class="line">0,   s[i+1]&#x3D;&#x3D;‘0’ &amp;&amp; (else)</span><br><span class="line">f(i+1)+f(i+2),   s[i+1]!&#x3D;&#39;0&#39; &amp;&amp; s[i]&#x3D;&#x3D;‘1’ || （s[i]&#x3D;&#x3D;‘2’ &amp;&amp; s[i+1]-‘0’&lt;&#x3D;6)</span><br><span class="line">f(i+1),     s[i+1]!&#x3D;&#39;0&#39; &amp;&amp; (else)</span><br></pre></td></tr></table></figure>

<p>且递归结束条件为:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;&#x3D;s.length  return 1;</span><br><span class="line">s[i]&#x3D;&#x3D;&#39;0&#39;  return 0;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.从右往左循环实现</strong> 递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题</p>
<p>代码一：按dp方程直接翻译的递归代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求把一个数字翻译成不同字符串的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numDecodingsDetail(s.toCharArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从右往左，每次递归表示从String s中的index至最右边字符串结束，可翻译成不同字符串的个数</span></span><br><span class="line"><span class="comment">//f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodingsDetail</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;chs.length &amp;&amp; chs[index]==<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;chs.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chs[index+<span class="number">1</span>]==<span class="string">'0'</span>)&#123;<span class="comment">//后一个为0，必须与后一个连成字母，不满足为0</span></span><br><span class="line">            <span class="keyword">if</span>(chs[index]==<span class="string">'1'</span> || chs[index]==<span class="string">'2'</span>)&#123;<span class="comment">//与后一个连成字母</span></span><br><span class="line">                <span class="keyword">return</span> numDecodingsDetail(chs,index+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//匹配错误，返回0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//后一个不为0，可以不与后一个连成字母，同时如果连成字母需要判断</span></span><br><span class="line">            <span class="keyword">if</span>(chs[index]==<span class="string">'1'</span> || (chs[index]==<span class="string">'2'</span> &amp;&amp; chs[index+<span class="number">1</span>]&lt;=<span class="string">'6'</span>))&#123;<span class="comment">//自成一派+与后一个连成字母</span></span><br><span class="line">                <span class="keyword">return</span> numDecodingsDetail(chs, index+<span class="number">1</span>) + numDecodingsDetail(chs,index+<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//不能与后一个连成字母，只能自成一派</span></span><br><span class="line">                <span class="keyword">return</span> numDecodingsDetail(chs, index+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//index==chs.length 递归结束</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">代码二：递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题（这个代码是按照剑指offer的题目来的，A-<span class="number">0</span>,Z-<span class="number">25</span>）</span><br><span class="line"></span><br><span class="line"><span class="comment">//求把一个数字翻译成不同字符串的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.把数字每一位拆分，存到数组中</span></span><br><span class="line">    <span class="keyword">char</span>[] chs = s.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.从右往左，res[]存放动态规划循环计算的每一个f(i)结果，最后要返回的是res[0]</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[chs.length];</span><br><span class="line">    <span class="comment">//每次计算f(i)时的临时计数器</span></span><br><span class="line">    <span class="keyword">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=chs.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;<span class="comment">//从右往左循环计算</span></span><br><span class="line">        <span class="keyword">if</span>(i==chs.length-<span class="number">1</span>) &#123;</span><br><span class="line">            tempCount = <span class="number">1</span>; <span class="comment">//如果是最右边的数字时，初始化翻译个数=1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//f(i) = f(i+1)</span></span><br><span class="line">            tempCount = res[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//f(i) = f(i+1) + g(i,i+1)*f(i+2)</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;chs.length-<span class="number">1</span>)&#123;<span class="comment">//判断后一个字母的情况</span></span><br><span class="line">            <span class="keyword">int</span> temp = Integer.parseInt(<span class="string">""</span>+chs[i]+chs[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=<span class="number">10</span> &amp;&amp; temp&lt;=<span class="number">25</span>)&#123;<span class="comment">//可以连成字母</span></span><br><span class="line">                <span class="keyword">if</span>((i+<span class="number">2</span>)&lt;chs.length)&#123;</span><br><span class="line">                    tempCount += res[i+<span class="number">2</span>];<span class="comment">//f(i+1)+f(i+2)</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    tempCount += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = tempCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="62"></a></p>
<h2 id="62-礼物的最大价值"><a href="#62-礼物的最大价值" class="headerlink" title="62.礼物的最大价值"></a>62.礼物的最大价值</h2><p>《剑指offer》p233、leetcode 64</p>
<p>题目：礼物的最大价值。</p>
<p>在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。</p>
<p>从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。</p>
<p>例如，对于如下棋盘：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1*  10  3  8</span><br><span class="line">12*  2  9  6</span><br><span class="line">5*  *7  4  11</span><br><span class="line">3  7*  16*  5*</span><br></pre></td></tr></table></figure>

<p>res = 1+12+5+7+7+16+5 = 53</p>
<p>思路：</p>
<p>典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)</p>
<p>递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</p>
<p>循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 题目：礼物的最大价值。</span></span><br><span class="line"><span class="comment"> * 在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。</span></span><br><span class="line"><span class="comment"> * 从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。</span></span><br><span class="line"><span class="comment"> * 例如，对于如下棋盘：</span></span><br><span class="line"><span class="comment"> *      1*    10   3    8</span></span><br><span class="line"><span class="comment">        12*   2    9    6</span></span><br><span class="line"><span class="comment">        5*    *7    4    11</span></span><br><span class="line"><span class="comment">        3    7*    16*   5*</span></span><br><span class="line"><span class="comment">    res = 1+12+5+7+7+16+5 = 53</span></span><br><span class="line"><span class="comment"> 思路：</span></span><br><span class="line"><span class="comment">    典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)</span></span><br><span class="line"><span class="comment">    递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</span></span><br><span class="line"><span class="comment">    循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] gift = &#123;&#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">12</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">6</span>&#125;,&#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">11</span>&#125;,&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        System.out.println(maxValue(gift, <span class="number">4</span>, <span class="number">4</span>)); <span class="comment">//out:53</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] gift, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Description</span>: m*n大小的棋盘gift[][]</span></span><br><span class="line"><span class="comment">         * 递归分析f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</span></span><br><span class="line"><span class="comment">         * 循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(gift==<span class="keyword">null</span> || m&lt;=<span class="number">0</span> || n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] maxValue = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123; <span class="comment">//从左上往右下进行循环计算</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((i-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    temp = Math.max(temp, maxValue[i-<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>((j-<span class="number">1</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    temp = Math.max(temp, maxValue[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                maxValue[i][j] = temp + gift[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化改进空间复杂度，使用一维数组<br>•题目中可知，坐标(i,j)的最大礼物价值仅仅取决于坐标为(i-1,j)和(i,j-1)两个格子；<br>•因此第i-2行以上的最大价值没有必要保存下来。<br>•使用一维数组保存，数组的长度为gift的列数：(0…j-1)保存的是(i,0)…(i,j-1)的最大价值；(j…cols-1)保存的是(i-1,j)…(i-1,cols-1)的最大价值。即：数组前j个数字分别是当前第i行前j个格子的maxvule,而之后的数字分别保存前面第i-1行n-j个格子的maxVlue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//leetcode 64 Minimum Path Sum的代码，一样的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> || grid[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length;</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//辅助一维数组，数组的长度为grid的列数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;<span class="comment">//第一行</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;<span class="comment">//第一列</span></span><br><span class="line">                    min[j] = grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    min[j] = grid[i][j] + min[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//后面几行</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;<span class="comment">//第一列</span></span><br><span class="line">                    min[j] = min[j] + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    min[j] = Math.min(min[j-<span class="number">1</span>], min[j]) + grid[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="63"></a></p>
<h2 id="63-最长不含重复字符的子字符串长度"><a href="#63-最长不含重复字符的子字符串长度" class="headerlink" title="63.最长不含重复字符的子字符串长度"></a>63.最长不含重复字符的子字符串长度</h2><p>《剑指offer》p236、leetcode 3</p>
<p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p>
<p>思路：</p>
<p>不重复子串可能有多个，而最长不重复子串长度只有一个唯一的值。</p>
<p><strong>遍历一遍字符串，同时借助辅助hashMap</strong>记录字符是否出现及上一次出现的位置。时间o(n)，空间o(n)</p>
<p>三个变量：</p>
<p>int resMax = 0; //记录最长的不重复字符子串的长度</p>
<p>int tempMax = 0; //记录当前不重复字符子串的长度</p>
<p>int startIndex = 0; //记录当前不重复字符子串的开始位置，初始化为0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Longest Substring Without Repeating Characters最长不含重复字符的子字符串长度</span></span><br><span class="line"><span class="comment">//思路：遍历一遍字符串，辅助hashMap存字符是否出现过或上一次出现的位置。时间o(n), 空间o(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>;<span class="comment">//最终返回的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> tempMax = <span class="number">0</span>;<span class="comment">//当前的最大长度</span></span><br><span class="line">    <span class="keyword">int</span> startIndex = <span class="number">0</span>;<span class="comment">//当前最大长度的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.辅助hashMap存字符是否出现过或上一次出现的位置</span></span><br><span class="line">    HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.遍历一遍字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">        <span class="comment">//如果字符没出现过或字符上一次出现的位置在startIndex的前面，那么当前字符有效，计算更新相应长度即可</span></span><br><span class="line">        <span class="keyword">if</span>(!hashMap.containsKey(temp) || hashMap.get(temp)&lt;startIndex)&#123;</span><br><span class="line">            tempMax = i-startIndex+<span class="number">1</span>;</span><br><span class="line">            resMax = Math.max(tempMax, resMax);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前字符重复了</span></span><br><span class="line">            startIndex = hashMap.get(temp)+<span class="number">1</span>; <span class="comment">//下次的startIndex为重复字符上一次出现位置的下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        hashMap.put(temp, i);<span class="comment">//不管重复与否，都要更新字符出现的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="64"></a></p>
<h2 id="64-丑数-两道"><a href="#64-丑数-两道" class="headerlink" title="64.丑数(两道)"></a>64.丑数(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断一个数是否为丑数--leetcode 263</span><br><span class="line">求第N个丑数是几--《剑指offer》p240</span><br></pre></td></tr></table></figure>

<h3 id="1-判断一个数是否为丑数"><a href="#1-判断一个数是否为丑数" class="headerlink" title="1.判断一个数是否为丑数"></a>1.判断一个数是否为丑数</h3><p>leetcode 263</p>
<p>题目：给定一个数，判断是否为丑数(丑数定义:只含因子2、3、5的正数，1也算丑数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 &#x3D; 2 × 3</span><br></pre></td></tr></table></figure>

<p>思路：就正常判断因子即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个数是否为丑数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">3</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(num%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        num /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-求第N个丑数是几"><a href="#2-求第N个丑数是几" class="headerlink" title="2.求第N个丑数是几"></a>2.求第N个丑数是几</h3><p>《剑指offer》p240</p>
<p>题目：把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>思路：</p>
<p>空间换时间。丑数一定是丑数<em>2/</em>3/*5得来的，直接用数组存下1到index的丑数</p>
<p>关键是怎么保证每一个丑数的大小顺序的–&gt;三个变量：index2、index3、index5</p>
<p>每次该放下一个丑数时，三个变量分别记录了当前可以<em>2/</em>3/*5的最小的丑数位置</p>
<p>每次分别对这三个位置上的丑数<em>2</em>3*5后找出最小的一个，即为当前的丑数，之后更新三个变量即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//丑数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index+<span class="number">1</span>];<span class="comment">//存1到index的丑数，返回res[index]</span></span><br><span class="line">    res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index3 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index5 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=index; ++i)&#123;</span><br><span class="line">        res[i] = min(res[index2]*<span class="number">2</span>, res[index3]*<span class="number">3</span>, res[index5]*<span class="number">5</span>);<span class="comment">//该放res[i]丑数了，找三个中最小的</span></span><br><span class="line">        <span class="keyword">while</span>(res[index2]*<span class="number">2</span>&lt;=res[i])&#123;<span class="comment">//更新三个变量</span></span><br><span class="line">            index2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res[index3]*<span class="number">3</span>&lt;=res[i])&#123;</span><br><span class="line">            index3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res[index5]*<span class="number">5</span>&lt;=res[i])&#123;</span><br><span class="line">            index5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a&lt;b ? a : b;</span><br><span class="line">    <span class="keyword">return</span> temp&lt;c ? temp : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="65"></a></p>
<h2 id="65-第一个只出现一次的字符"><a href="#65-第一个只出现一次的字符" class="headerlink" title="65.第一个只出现一次的字符"></a>65.第一个只出现一次的字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个只出现一次的字符(数组)--《剑指offer》p243、leetcode 387</span><br><span class="line">第一个只出现一次的字符(字符流)--《剑指offer》p247</span><br></pre></td></tr></table></figure>

<p>题目：给定数组或是输入一个字符流，返回第一个只出现一次的的字符位置。在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g.输入&quot;abaccdeff&quot; --&gt; 则输出&#39;b&#39;</span><br></pre></td></tr></table></figure>

<p>思路：不管是数组还是字符流，都用这个思路。<strong>遍历一遍str，辅助hashMap，value记录字符出现第一次的位置，若字符重复出现，则value记录-1。最后再遍历一遍hashMap，找除了-1之外的最小value即可所求</strong>。时间o(n)，空间o(256)</p>
<p>数据是数组的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给定数组的代码，字符流的情况一样的。思路：遍历一遍str，辅助hashMap记录字符出现的位置，再遍历一遍hashMap即可。时间o(n)，空间o(256)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Character, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key:字符，value:字符出现一次value为上次出现的位置，字符出现多次value存-1</span></span><br><span class="line">    <span class="comment">//1.遍历字符串,辅助hashMap记录字符出现的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length(); ++i)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!hashMap.containsKey(temp))&#123;<span class="comment">//字符只出现一次，存出现的位置</span></span><br><span class="line">            hashMap.put(temp,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//字符出现多次，存-1</span></span><br><span class="line">            hashMap.put(temp, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.遍历hashMap来找第一次只出现一次的字符</span></span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue()!=-<span class="number">1</span>)&#123;</span><br><span class="line">            res = Math.min(res, entry.getValue());<span class="comment">//找最小的只出现一次的字符位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res==Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">数据是字符流的代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] chIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//计数当前输入到第几个数了，初始为0</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        chIndex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];<span class="comment">//初始化哈希数组，每个字符都未出现，</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(chIndex[ch]==<span class="number">0</span>) &#123;<span class="comment">//之前未出现过，则更新值为当前位置，说明出现了第一次</span></span><br><span class="line">            chIndex[ch] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">//之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2</span></span><br><span class="line">            chIndex[ch] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = Integer.MAX_VALUE; <span class="comment">//记录最早出现一次字符的位置</span></span><br><span class="line">        <span class="keyword">char</span> resChar = <span class="string">'#'</span>; <span class="comment">//记录最早出现只出现一次的那个字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; ++i)&#123;<span class="comment">//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)</span></span><br><span class="line">            <span class="keyword">if</span>(chIndex[i]&gt;<span class="number">0</span> &amp;&amp; chIndex[i]&lt;minIndex)&#123;</span><br><span class="line">                minIndex = chIndex[i];</span><br><span class="line">                resChar = (<span class="keyword">char</span>)i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，本题中hashMap可以用256的数组，也可以用hashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> HashMap&lt;Character, Integer&gt; hashMap;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//计数当前输入到第几个数了，初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Insert one char from stringstream</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span>(!hashMap.containsKey(ch)) &#123;<span class="comment">//之前未出现过，则更新值为当前位置，说明出现了第一次</span></span><br><span class="line">        hashMap.put(ch, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">//之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2</span></span><br><span class="line">        hashMap.put(ch, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minIndex = Integer.MAX_VALUE; <span class="comment">//记录最早出现一次字符的位置</span></span><br><span class="line">    <span class="keyword">char</span> resChar = <span class="string">'#'</span>; <span class="comment">//记录最早出现只出现一次的那个字符</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet())&#123;<span class="comment">//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)</span></span><br><span class="line">        <span class="keyword">if</span>(entry.getValue()!=-<span class="number">1</span> &amp;&amp; entry.getValue()&lt;minIndex)&#123;</span><br><span class="line">            minIndex = entry.getValue();</span><br><span class="line">            resChar = entry.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="66"></a></p>
<h2 id="66-归并排序相关-3道"><a href="#66-归并排序相关-3道" class="headerlink" title="66.归并排序相关(3道)"></a>66.归并排序相关(3道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组的归并排序</span><br><span class="line">数组中的逆序对个数(2道)--《剑指offer》p249、leetcode 493</span><br><span class="line">单链表的归并排序--leetcode 148</span><br></pre></td></tr></table></figure>
<h3 id="1-数组的归并排序"><a href="#1-数组的归并排序" class="headerlink" title="1.数组的归并排序"></a>1.数组的归并排序</h3><p>经典的归并排序算法，时间o(nlog)，空间o(n)</p>
<p>来源<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序。思路：分而治之，先分后治,辅助数组temp[]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        mergeSortDetail(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//分</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortDetail</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;<span class="comment">//一个数字不用merge，只有两个以上才merge</span></span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            mergeSortDetail(nums, left, mid, temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            mergeSortDetail(nums, mid+<span class="number">1</span>, right, temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(nums, left, mid, right, temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//治</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempIndex = <span class="number">0</span>;<span class="comment">//temp数组的当前位置</span></span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">//左序列的索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>; <span class="comment">//右序列的索引</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;<span class="comment">//将左、右序列的元素有序的放进temp数组中</span></span><br><span class="line">            temp[tempIndex++] = nums[i]&lt;=nums[j] ? nums[i++] : nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[tempIndex++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右边剩余元素填充进temp中</span></span><br><span class="line">            temp[tempIndex++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到nums原数组中</span></span><br><span class="line">        tempIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            nums[left++] = temp[tempIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        mergeSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数组中的逆序对-2道"><a href="#2-数组中的逆序对-2道" class="headerlink" title="2.数组中的逆序对(2道)"></a>2.数组中的逆序对(2道)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">《剑指offer》p249</span><br><span class="line">Reverse Pairs--leetcode 493</span><br></pre></td></tr></table></figure>
<h4 id="2-1-求出数组中逆序对的个数"><a href="#2-1-求出数组中逆序对的个数" class="headerlink" title="2.1 求出数组中逆序对的个数"></a>2.1 求出数组中逆序对的个数</h4><p>《剑指offer》p249</p>
<p>思路：用归并排序思想，在归并排序的过程中计数逆序对。时间o(nlogn)，空间o(n)，稳定。先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数（也就是逆序数），这三个过程加起来就是整体的逆序数目了。</p>
<p>注意:归并排序merge过程中的<strong>从右往左排序的巧妙思想</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中逆序对的总数。思路：归并排序思想</span></span><br><span class="line"><span class="comment">// 先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">return</span> InversePairsDetail(array, <span class="number">0</span>, array.length-<span class="number">1</span>, temp)%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairsDetail</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        res += InversePairsDetail(array, left, mid, temp);<span class="comment">//左边的逆序数</span></span><br><span class="line">        res += InversePairsDetail(array, mid+<span class="number">1</span>, right, temp);<span class="comment">//右边的逆序数</span></span><br><span class="line">        res += merge(array, left, mid, right, temp);<span class="comment">//左边与右边的逆序数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = mid;<span class="comment">//左序列指针，从右往左</span></span><br><span class="line">    <span class="keyword">int</span> j = right;<span class="comment">//右序列指针，从右往左</span></span><br><span class="line">    <span class="keyword">int</span> tempIndex = right;<span class="comment">//临时数组指针，从右往左</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=left &amp;&amp; j&gt;mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&gt;array[j])&#123;<span class="comment">//是一个逆序对，且前面的比后面的大，又找到很多个逆序对</span></span><br><span class="line">            temp[tempIndex--] = array[i--];</span><br><span class="line">            res += (j-mid);<span class="comment">//又找到很多个逆序对</span></span><br><span class="line">            res %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[tempIndex--] = array[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=left)&#123;<span class="comment">//前面的数组还有</span></span><br><span class="line">        temp[tempIndex--] = array[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;mid)&#123;<span class="comment">//后面的数组还有</span></span><br><span class="line">        temp[tempIndex--] = array[j--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tempIndex = right; <span class="comment">//最后还是要完成排序</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        array[right--] = temp[tempIndex--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Reverse-Pairs"><a href="#2-2-Reverse-Pairs" class="headerlink" title="2.2 Reverse Pairs"></a>2.2 Reverse Pairs</h4><p>leetcode 493 </p>
<p>题目：和上面的逆序数有点不一样，Given an array nums, we call (i, j) an important reverse pair if i &lt; j and <strong>nums[i] &gt; 2*nums[j].</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,2,3,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>思路：还是逆序对的归并排序思想，只不过找逆序对的算法不同，因此简要修改判断即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中逆序对的总数。思路：归并排序思想</span></span><br><span class="line"><span class="comment">//先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">return</span> InversePairsDetail(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairsDetail</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        res += InversePairsDetail(array, left, mid, temp);<span class="comment">//左边排序，且计算左边的逆序对个数</span></span><br><span class="line">        res += InversePairsDetail(array, mid+<span class="number">1</span>, right, temp);<span class="comment">//右边排序，且计算右边的逆序对个数</span></span><br><span class="line">        <span class="comment">//merge左右两边排序前，计算左右两边的逆序对个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = mid+<span class="number">1</span>; i &lt;= mid &amp;&amp; j &lt;= right;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; (<span class="keyword">long</span>) array[j] * <span class="number">2</span>)&#123;<span class="comment">//long必须有</span></span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        merge(array, left, mid, right, temp);<span class="comment">//左右两边归并排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常的左右两边归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = mid;<span class="comment">//左序列指针，从右往左</span></span><br><span class="line">    <span class="keyword">int</span> j = right;<span class="comment">//右序列指针，从右往左</span></span><br><span class="line">    <span class="keyword">int</span> tempIndex = right;<span class="comment">//临时数组指针，从右往左</span></span><br><span class="line">    <span class="keyword">while</span>(i&gt;=left &amp;&amp; j&gt;mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&gt;array[j])&#123;</span><br><span class="line">            temp[tempIndex--] = array[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp[tempIndex--] = array[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=left)&#123;<span class="comment">//前面的数组还有</span></span><br><span class="line">        temp[tempIndex--] = array[i--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;mid)&#123;<span class="comment">//后面的数组还有</span></span><br><span class="line">        temp[tempIndex--] = array[j--];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tempIndex = right; <span class="comment">//最后还是要完成排序</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        array[right--] = temp[tempIndex--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单链表的归并排序"><a href="#3-单链表的归并排序" class="headerlink" title="3.单链表的归并排序"></a>3.单链表的归并排序</h3><p>leetcode 148 </p>
<p>见 <a href="#93.0">93.0单链表的归并排序</a></p>
<p><a name="67"></a></p>
<h2 id="67-二叉搜索树的第k小节点-中序遍历"><a href="#67-二叉搜索树的第k小节点-中序遍历" class="headerlink" title="67.二叉搜索树的第k小节点(中序遍历)"></a>67.二叉搜索树的第k小节点(中序遍历)</h2><p>《剑指offer》p269、leetcode 230</p>
<p>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<p>思路：中序遍历即可。时间o(n)，空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉搜索树中第k小节点。将k存到数组中便于修改传参，对二叉树中序遍历判断即可 </span></span><br><span class="line"><span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot==<span class="keyword">null</span> || k&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] ks = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    ks[<span class="number">0</span>] = k;</span><br><span class="line">    <span class="keyword">return</span> KthNodeDetail(pRoot, ks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">KthNodeDetail</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span>[] ks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRoot.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = KthNodeDetail(pRoot.left, ks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ks[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">if</span>(ks[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pRoot.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        res = KthNodeDetail(pRoot.right, ks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="68"></a></p>
<h2 id="68-二叉树的深度-两道"><a href="#68-二叉树的深度-两道" class="headerlink" title="68.二叉树的深度(两道)"></a>68.二叉树的深度(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求二叉树的深度--leetcode104</span><br><span class="line">判断是否为平衡二叉树--leetcode110</span><br></pre></td></tr></table></figure>
<h3 id="1-求二叉树的深度"><a href="#1-求二叉树的深度" class="headerlink" title="1.求二叉树的深度"></a>1.求二叉树的深度</h3><p>leetcode104、《剑指offer》p271</p>
<p>思路：递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max( treeDepth(head.left)+<span class="number">1</span>, treeDepth(head.right)+<span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-判断是否为平衡二叉树"><a href="#2-判断是否为平衡二叉树" class="headerlink" title="2.判断是否为平衡二叉树"></a>2.判断是否为平衡二叉树</h3><p>leetcode110、《剑指offer》p271</p>
<p>题目：给一个二叉树，判断是否为平衡二叉树</p>
<p>思路1：遍历树，对每一个节点进行判断是否满足平衡树的条件—&gt;递归重复判断计算，不可取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为平衡二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span>(Math.abs(left-right)&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2：后序遍历(左右根)，从下往上依次判断每个节点是否满足平衡二叉树的条件。这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算—&gt;可取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否为平衡二叉树。好的方法:后序遍历(左右根),从下往上依次判断每个节点是否满足平衡二叉树的条件。</span></span><br><span class="line"><span class="comment">// 这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right))&#123;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求二叉树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(getDepth(root.left), getDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="69"></a></p>
<h2 id="69-数组中和为s的数字-四道"><a href="#69-数组中和为s的数字-四道" class="headerlink" title="69.数组中和为s的数字(四道)"></a>69.数组中和为s的数字(四道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组中和为s的两个数字(有序数组)--《剑指offer》p280</span><br><span class="line">数组中和为s的两个数字(无序数组)--leetcode 1</span><br><span class="line">打印出和为s的所有连续正数序列--《剑指offer》p280	求和为s的所有连续正数序列的总数(转化为找因子的思想)--leetcode 829</span><br></pre></td></tr></table></figure>
<h3 id="1-数组中和为s的两个数字-有序数组"><a href="#1-数组中和为s的两个数字-有序数组" class="headerlink" title="1.数组中和为s的两个数字(有序数组)"></a>1.数组中和为s的两个数字(有序数组)</h3><p>《剑指offer》p280</p>
<p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>思路：从数组两端向中间扫，时间o(n)，空间o(1)，当然因为有序可以加一点二分的思想减少比较次数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> resMax = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//left、right往中间扫</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[mid]&gt;=sum)&#123;<span class="comment">//二分判断，需要往左边找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[left] + array[right];</span><br><span class="line">        <span class="keyword">if</span>(temp==sum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[left]*array[right]&lt;resMax)&#123;<span class="comment">//看是否乘积最小</span></span><br><span class="line">                resMax = array[left]*array[right];</span><br><span class="line">                <span class="keyword">if</span>(!res.isEmpty())&#123;</span><br><span class="line">                    res.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(array[left]);</span><br><span class="line">                res.add(array[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt; sum)&#123;<span class="comment">//左边的数++</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//右边的数--</span></span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-数组中和为s的两个数字-无序数组"><a href="#2-数组中和为s的两个数字-无序数组" class="headerlink" title="2.数组中和为s的两个数字(无序数组)"></a>2.数组中和为s的两个数字(无序数组)</h3><p>leetcode 1</p>
<p>题目：Given an array of integers(无序), return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>思路：因为数组无序，因此需要辅助map，时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-打印出和为s的所有连续正数序列"><a href="#3-打印出和为s的所有连续正数序列" class="headerlink" title="3.打印出和为s的所有连续正数序列"></a>3.打印出和为s的所有连续正数序列</h3><p>《剑指offer》p280、leetcode 829</p>
<p>输入一个整数s，打印出所有和为s的连续正数序列(至少含有两个数)</p>
<p>如：输入15，1+2+3+4+5=4+5+6=7+8=15，因此输出{1,2,3,4,5},{4,5,6},{7,8}三个序列</p>
<p>思路：</p>
<p>思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从递增数组中两个和为s的数得到启示，设置两个变量，一个记录当前序列的最小的数small，一个记录当前序列的最大的数big。</span><br><span class="line">初始化small&#x3D;0,big&#x3D;1</span><br><span class="line">若是当前的正数序列之和小于S，big++</span><br><span class="line">若是当前的正数序列之和大于S，small++</span><br><span class="line">因为和为s的序列至少包括两个数，所以small要小于等于s的一半</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和为s的连续整数序列</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> small = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> big = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> tempRes = small+big;<span class="comment">//当前序列的和</span></span><br><span class="line">    ArrayList&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//缓存当前序列</span></span><br><span class="line">    tempList.add(small);</span><br><span class="line">    tempList.add(big);</span><br><span class="line">    <span class="keyword">while</span>(small &lt;= sum/<span class="number">2</span>)&#123;<span class="comment">//至少两个数的和为sum，所以small不能超过sum的一半</span></span><br><span class="line">        <span class="keyword">if</span>(tempRes&lt;=sum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempRes==sum)&#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">            &#125;</span><br><span class="line">            big++;</span><br><span class="line">            tempRes += big;</span><br><span class="line">            tempList.add(big);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tempRes&gt;sum)&#123;</span><br><span class="line">            tempRes-=small;</span><br><span class="line">            tempList.remove((Object)small);</span><br><span class="line">            small++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-求和为s的所有连续正数序列的总数-转化为找因子的思想"><a href="#4-求和为s的所有连续正数序列的总数-转化为找因子的思想" class="headerlink" title="4.求和为s的所有连续正数序列的总数(转化为找因子的思想)"></a>4.求和为s的所有连续正数序列的总数(转化为找因子的思想)</h3><p>leetcode 829</p>
<p>题目：Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? 和为s的连续整数序列一共有多少种。和为s的连续整数序列一共有多少种，题目中N特别大，o(n)会超时，因此必须o(logn)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 5 &#x3D; 5 &#x3D; 2 + 3</span><br></pre></td></tr></table></figure>
<p>思路：变型求和公式转化问题，时间o(logn)，空间o(1)。</p>
<p>详细思路： 连续数列的求和公式–&gt;（n1+n2)*(n2-n1+1)=2*N，(n1&lt;n2)，其中(n1+n2)和(n2-n1+1)一定要是2*N的因子，因此<strong>转化成求2*N的因子的问题</strong>，将时间复杂度控制在了O(logn)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">consecutiveNumbersSum</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;<span class="comment">//一共有res种方法，本身也算一种，因此初始为1</span></span><br><span class="line">    <span class="keyword">int</span> target = <span class="number">2</span>*N;</span><br><span class="line">    <span class="keyword">int</span> index = (<span class="keyword">int</span>)Math.sqrt(target);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=index; ++i)&#123;<span class="comment">//从2遍历到index找target的因子，直接优化到了o(logn)</span></span><br><span class="line">        <span class="keyword">if</span>(target%i==<span class="number">0</span>)&#123;<span class="comment">//i是target的一个因子</span></span><br><span class="line">            <span class="comment">//两元一次方程解出n1、n2，注意n1&lt;n2</span></span><br><span class="line">            <span class="keyword">int</span> n2 = (i+target/i-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> n1 = target/i-n2;</span><br><span class="line">            <span class="keyword">if</span>(n1&lt;n2 &amp;&amp; (n1 + n2)*(n2 - n1 + <span class="number">1</span>)==target)&#123;<span class="comment">//找到一个从n1~n2的连续序列和为s</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="70"></a></p>
<h2 id="70-翻转字符串-两道"><a href="#70-翻转字符串-两道" class="headerlink" title="70.翻转字符串(两道)"></a>70.翻转字符串(两道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给定一句话，翻转这句话的单词顺序(单词不变)--《剑指offer》p284、leetcode 151</span><br><span class="line">左旋转字符串(abcXYZdef循环左移3位--&gt;XYZdefabc)--《剑指offer》p284</span><br></pre></td></tr></table></figure>
<h3 id="1-翻转一句话的单词顺序-单词不变"><a href="#1-翻转一句话的单词顺序-单词不变" class="headerlink" title="1.翻转一句话的单词顺序(单词不变)"></a>1.翻转一句话的单词顺序(单词不变)</h3><p>《剑指offer》p284、leetcode 151</p>
<p>题目：给定一句话，翻转这句话的单词顺序(单词不变)</p>
<p>思路：先split(“ “)成数组，再反着拼装即可。时间o(n)，空间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String[] strs = s.split(<span class="string">" "</span>);</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=strs.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs[i].equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(strs[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2.左旋转字符串"></a>2.左旋转字符串</h3><p>《剑指offer》p284</p>
<p>题目：左旋转字符串(abcXYZdef循环左移3位–&gt;XYZdefabc)</p>
<p>思路1(不可取): 用substring()函数拼接即可，当然substring()会依赖辅助空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> || str==<span class="keyword">null</span> || str.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.substring(n) + str.substring(<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2(可取): 当不能用substring()去依赖辅助空间时，直接在原字符串上修改。分成需要移位的左边和剩下右边的两部分，<strong>先将这两部分分别翻转，然后再整个翻转即可</strong>。时间o(n)，空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabc</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> || str==<span class="keyword">null</span> || str.length()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">    reverse(chs, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    reverse(chs, n, chs.length-<span class="number">1</span>);</span><br><span class="line">    reverse(chs,<span class="number">0</span>,chs.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> String.valueOf(chs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//翻转一个字符串：首尾向中间扫，字符互换即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = str[start];</span><br><span class="line">        str[start] = str[end];</span><br><span class="line">        str[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="71"></a></p>
<h2 id="71-滑动窗口最大值-双端队列"><a href="#71-滑动窗口最大值-双端队列" class="headerlink" title="71.滑动窗口最大值(双端队列)"></a>71.滑动窗口最大值(双端队列)</h2><p>《剑指offer》p288、《左神》19、leetcode239</p>
<p>题目：滑动窗口的最大值。给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。如{2,3,4,2,6,2,5,1}及滑动窗口的大小3，最大值分别为{4,4,6,6,6,5}</p>
<p>思路：双端队列。滑动窗口先进先出因此借助双端队列，使用队列保存数组的下标，从头遍历数组，根据如下规则进行入队、出队：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0. 如果队列为空，则当前数字入队列</span><br><span class="line">1. 如果当前数字大于队列尾，则删除队列尾，然后当前数字入队列</span><br><span class="line">2. 如果当前数字小于等于队列尾，则当前数字入队列</span><br><span class="line">3. 如果队列头超出滑动窗口范围，则删除队列头</span><br><span class="line">4. 这样能始终保证队头为当前的最大值</span><br><span class="line">5. 时间o(n)，空间o(k)</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;滑动窗口最大值--&gt;双端队列</span><br><span class="line">public static int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">    if(nums&#x3D;&#x3D;null || nums.length&#x3D;&#x3D;0 || k&lt;1 || k&gt;nums.length)&#123;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] res &#x3D; new int[nums.length-k+1];&#x2F;&#x2F;滑动窗口最大值</span><br><span class="line">    int resCnt &#x3D; 0;</span><br><span class="line">    Deque&lt;Integer&gt; deque &#x3D; new LinkedList&lt;&gt;();&#x2F;&#x2F;双端队列,存的不是数组元素，而是下标，便于判断滑动窗口位置</span><br><span class="line">    for (int i&#x3D;0; i&lt;nums.length; ++i)&#123;&#x2F;&#x2F;遍历数组</span><br><span class="line">        if(!deque.isEmpty() &amp;&amp; deque.getFirst()+k&#x3D;&#x3D;i)&#123;&#x2F;&#x2F;进行滑动窗口:双端队列的头部已经不在窗口中，头部出队</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        while(!deque.isEmpty() &amp;&amp; nums[i]&gt;nums[deque.getLast()])&#123;&#x2F;&#x2F;如果当前数比双端队列的尾部大，则一直pollLast，直到当前数比尾部小或相等</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line"></span><br><span class="line">        if(i+1&gt;&#x3D;k)&#123;&#x2F;&#x2F;存储当前窗口最大值</span><br><span class="line">            res[resCnt++] &#x3D; nums[deque.getFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="72"></a></p>
<h2 id="72-打印n个骰子所有可能的点数和及概率"><a href="#72-打印n个骰子所有可能的点数和及概率" class="headerlink" title="72.打印n个骰子所有可能的点数和及概率"></a>72.打印n个骰子所有可能的点数和及概率</h2><p>《剑指offer》p294.</p>
<p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s，输入n，打印出s的所有可能的值出现的概率。示例如下(n=2)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2个骰子，点数和为2出现的概率为: 0.027777777777777776</span><br><span class="line">2个骰子，点数和为3出现的概率为: 0.05555555555555555</span><br><span class="line">2个骰子，点数和为4出现的概率为: 0.08333333333333333</span><br><span class="line">2个骰子，点数和为5出现的概率为: 0.1111111111111111...</span><br></pre></td></tr></table></figure>

<p>递归思路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getsumcount</span><span class="params">(self, number, summ)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">1</span> <span class="keyword">or</span> summ &lt; number <span class="keyword">or</span> summ &gt; <span class="number">6</span> * number:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    resCount = <span class="number">0</span></span><br><span class="line">    resCount = self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-1</span>)+self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-2</span>)+self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-3</span>)+self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-4</span>)+self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-5</span>)+self.getsumcount(number<span class="number">-1</span>, summ<span class="number">-6</span>)</span><br><span class="line">    <span class="keyword">return</span> resCount</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">po</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    total = pow(<span class="number">6</span>, number)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(number, <span class="number">6</span>*number+<span class="number">1</span>):</span><br><span class="line">        res = self.getsumcount(number, i)</span><br><span class="line">        ratio = res/total</span><br><span class="line">        print(i, ratio)</span><br></pre></td></tr></table></figure>

<p>循环思路：<strong>先算所有出现的点数和及出现次数，再算概率(出现次数/6^number)。一个一个骰子往上加，辅助两个数组交替着存所有出现的点数和为n的出现次数，resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</strong></p>
<p>详细思路(可以不看了，初学看)：n个骰子的总点数，最小为n，最大为6n，n个骰子出现的所有点数排列的个数为6^n。我们先统计每一个点数和出现的次数，定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组的第s-n个元素里;然后把每一个点数和出现的次数除以6^n，就能求出每个点数和出现的概率。因此本题重点是统计每一个点数和出现的次数，不难发现这是一种递归的思路，自下而上循环实现,从1个骰子开始，每次加一个骰子计算。用两个数组来存储骰子点数和的每一种出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的综合，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</p>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n个骰子的所有出现的点数和及概率。思路：两个数组存所有出现的点数和及出现次数，再算概率。</span></span><br><span class="line"><span class="comment">//详细思路:一个一个骰子往上加，点数和为n的出现次数resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSumRatio</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.辅助两个数组并初始化</span></span><br><span class="line">    <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">6</span>*number+<span class="number">1</span>];<span class="comment">//定义两个数组，交换着统计number个骰子所有可能的点数和出现的次数，数组长度为6*n+1</span></span><br><span class="line">    <span class="keyword">int</span> resFlag = <span class="number">0</span>;<span class="comment">//交换数组的标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; ++i)&#123;<span class="comment">//当1个骰子时，初始化res数组</span></span><br><span class="line">        res[resFlag][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.交换着使用两个数组，统计number个骰子所有点数和出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=number; ++i)&#123;<span class="comment">//一个一个骰子往上加</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i; ++j)&#123;<span class="comment">//当有i个骰子时，[1,i)的点数和为0，全部清空</span></span><br><span class="line">            res[<span class="number">1</span>-resFlag][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;=<span class="number">6</span>*i; ++j)&#123;<span class="comment">//当有i个骰子时,给[i,6*i]赋值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=<span class="number">6</span>&amp;&amp;j&gt;k; ++k)&#123;</span><br><span class="line">                res[<span class="number">1</span>-resFlag][j] += res[resFlag][j-k];<span class="comment">//resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resFlag = <span class="number">1</span>-resFlag;<span class="comment">//交换数组，改变flag</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.计算并打印number个骰子所有可能的点数和及概率</span></span><br><span class="line">    <span class="keyword">double</span> totalCount = Math.pow(<span class="number">6</span>, number);<span class="comment">//number个骰子出现的不同情况的总次数为6^n次方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=number; i&lt;=<span class="number">6</span>*number; ++i)&#123;</span><br><span class="line">        <span class="keyword">double</span> ratio = (<span class="keyword">double</span>)res[resFlag][i]/totalCount;<span class="comment">//点数和为res[i]的概率</span></span><br><span class="line">        System.out.println(number + <span class="string">"个骰子，点数和为"</span> + i + <span class="string">"出现的概率为"</span> + ratio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    printSumRatio(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//out:</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为2出现的概率为0.027777777777777776</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为3出现的概率为0.05555555555555555</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为4出现的概率为0.08333333333333333</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为5出现的概率为0.1111111111111111</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为6出现的概率为0.1388888888888889</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为7出现的概率为0.16666666666666666</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为8出现的概率为0.1388888888888889</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为9出现的概率为0.1111111111111111</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为10出现的概率为0.08333333333333333</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为11出现的概率为0.05555555555555555</span></span><br><span class="line">    <span class="comment">//2个骰子，点数和为12出现的概率为0.027777777777777776</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="73"></a></p>
<h2 id="73-扑克牌中的顺子-2道"><a href="#73-扑克牌中的顺子-2道" class="headerlink" title="73.扑克牌中的顺子(2道)"></a>73.扑克牌中的顺子(2道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整个数组是否为一个顺子(同时有大小王)--《剑指offer》p298.</span><br><span class="line">整个数组分组后每组都要为顺子--leetcode 846</span><br></pre></td></tr></table></figure>
<h3 id="1-整个数组是否为一个顺子-同时有大小王"><a href="#1-整个数组是否为一个顺子-同时有大小王" class="headerlink" title="1.整个数组是否为一个顺子(同时有大小王)"></a>1.整个数组是否为一个顺子(同时有大小王)</h3><p>《剑指offer》p298.</p>
<p>题目：扑克牌中的顺子：从扑克牌中随机抽5张牌,判断是不是顺子(即这5张牌是不是连续的)。2-10为数字本身，A为1，J、Q、K 为11、12、13，大小王可以看成任意的数字(解题时可以看成0)。</p>
<p>思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0.定义长度为numbers的数组(这里不限于解决5张,判断numbers张牌是否为顺子);</span><br><span class="line">1.数组排序；</span><br><span class="line">2.统计数组中0的个数;</span><br><span class="line">3.统计排序后数组相邻数字间的空缺数(eg数字57间空缺1);</span><br><span class="line">4.2、3两步统计的0个数大于等于空缺数--&gt;顺子，否则不是顺子</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断扑克牌顺子(2张及以上连续),大小王0可以代表任意牌。思路：数组排序,记录大小王的个数，遍历数组判断是否为顺子即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length&gt;<span class="number">13</span> || numbers.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.数组排序</span></span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.记录大小王的个数并判断是否为顺子</span></span><br><span class="line">    <span class="keyword">int</span> superCnt = <span class="number">0</span>;<span class="comment">//记录大小王的个数</span></span><br><span class="line">    <span class="keyword">int</span> superCntCopy = <span class="number">0</span>;<span class="comment">//保存大小王个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i]==<span class="number">0</span>)&#123;<span class="comment">//是大小王</span></span><br><span class="line">            superCnt++;</span><br><span class="line">            superCntCopy++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]==numbers[i+<span class="number">1</span>])&#123;<span class="comment">//相等，即出现对儿，不是顺子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]+<span class="number">1</span>==numbers[i+<span class="number">1</span>])&#123;<span class="comment">//连续</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i]+<span class="number">1</span>!=numbers[i+<span class="number">1</span>])&#123;<span class="comment">//遇到不连续的牌，看看能不能凑个王</span></span><br><span class="line">            <span class="keyword">if</span>( (numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>) &lt;= superCnt )&#123;<span class="comment">//可以用王凑</span></span><br><span class="line">                superCnt -= (numbers[i+<span class="number">1</span>]-numbers[i]-<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不够王了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.王太多还剩下几张王，放在牌头与牌尾后还剩下王，则不是顺子</span></span><br><span class="line">    <span class="keyword">if</span>(superCnt&gt;<span class="number">0</span> &amp;&amp; superCnt&gt;(numbers[superCntCopy]-numbers[numbers.length-<span class="number">1</span>]+<span class="number">12</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-整个数组分组后每组都要为顺子"><a href="#2-整个数组分组后每组都要为顺子" class="headerlink" title="2.整个数组分组后每组都要为顺子"></a>2.整个数组分组后每组都要为顺子</h3><p>leetcode 846</p>
<p>题目：Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: hand &#x3D; [1,2,3,6,2,3,4,7,8], W &#x3D; 3</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Alice&#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</span><br></pre></td></tr></table></figure>

<p>思路：1.hand长度不能整除W，false;2.hand排序;3.由于[1,2,3],[2,3,4]也可以，需要<strong>辅助数组缓存访问标记</strong>用于后续判断;4.遍历数组一组一组进行判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNStraightHand</span><span class="params">(<span class="keyword">int</span>[] hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.hand长度不能整除W，false</span></span><br><span class="line">    <span class="keyword">if</span>(hand==<span class="keyword">null</span> || hand.length==<span class="number">0</span> || W&lt;<span class="number">1</span> || W&gt;hand.length || hand.length%W!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.hand排序</span></span><br><span class="line">    Arrays.sort(hand);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.辅助数组缓存访问标记用于后续判断</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[hand.length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.遍历数组一组一组进行判断</span></span><br><span class="line">    <span class="keyword">int</span> cnt = W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;hand.length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;<span class="comment">//如果没有被访问过之前，以此为新group的起始位置开始寻找一个group</span></span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> left = i;</span><br><span class="line">            <span class="keyword">int</span> right = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt!=<span class="number">1</span>)&#123;<span class="comment">//寻找一个group</span></span><br><span class="line">                <span class="keyword">if</span>(right&gt;=hand.length)&#123;<span class="comment">//找完了hand都没凑成一个group,false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!visited[right])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(hand[left]+<span class="number">1</span>&lt;hand[right])&#123;<span class="comment">//断层太大，不可能连续了，false</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(hand[left]+<span class="number">1</span>==hand[right])&#123;<span class="comment">//前后连续</span></span><br><span class="line">                        visited[right] = <span class="keyword">true</span>;</span><br><span class="line">                        left = right;</span><br><span class="line">                        cnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找完了一个group，重置cnt</span></span><br><span class="line">            cnt = W;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//找完了所有group，没有返回false说明都符合条件,true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="74"></a></p>
<h2 id="74-圆圈中剩下的数-约瑟夫环问题"><a href="#74-圆圈中剩下的数-约瑟夫环问题" class="headerlink" title="74.圆圈中剩下的数(约瑟夫环问题)"></a>74.圆圈中剩下的数(约瑟夫环问题)</h2><p>《剑指offer》p300、《左神》43、leetcode 292</p>
<p>题目：圆圈中最后剩下的数字。0,1…n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字，求出这个圆圈里剩下的最后一个数字。e.g n=5([0,1,2,3,4]),m=3,out:3</p>
<p>思路1：用<strong>双端队列</strong>模拟这个循环环的问题，每排除一个数需要m步运算，n个数就需要O(mn)，空间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆圈中剩下的数。思路:用双端队列模拟这个过程，时间o(nm),空间o(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.辅助o(n)双端队列</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        deque.offerLast(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.模拟弹出过程,直到双端队列中剩下一个数为止</span></span><br><span class="line">    <span class="keyword">int</span> cnt = m;</span><br><span class="line">    <span class="keyword">while</span>(deque.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;<span class="comment">//弹出一个数，重置cnt</span></span><br><span class="line">            deque.pollFirst();</span><br><span class="line">            cnt = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            deque.offerLast(deque.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deque.pollFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2(更好)：分析这个题的数学规律，直接求解:<code>f(n,m)=[(f(n-1,m)+m]%n</code>，时间o(n)，空间o(1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f(n,m)=[(f(n-1,m)+m]%n</span></span><br><span class="line"><span class="comment">//f(n,m)=0(n=1);f(n,m)=[(f(n-1,m)+m)%n](n&gt;1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">        res = (res+m)%i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="75"></a></p>
<h2 id="75-股票的最大利润问题-四道"><a href="#75-股票的最大利润问题-四道" class="headerlink" title="75.股票的最大利润问题(四道)"></a>75.股票的最大利润问题(四道)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">只允许买卖一次股票，求最大收益--《剑指offer》p304、leetcode 121</span><br><span class="line">允许多次买卖，求最大收益--《剑指offer》p304、leetcode 122</span><br><span class="line">只允许买卖两次股票，求最大收益--leetcode 123</span><br><span class="line">只允许买卖k次股票，求最大收益--leetcode 188</span><br></pre></td></tr></table></figure>
<h3 id="1-只允许买卖一次股票，求最大收益"><a href="#1-只允许买卖一次股票，求最大收益" class="headerlink" title="1.只允许买卖一次股票，求最大收益"></a>1.只允许买卖一次股票，求最大收益</h3><p>《剑指offer》p304</p>
<p>题目：只允许买卖一次股票，求最大收益</p>
<p>思路：以当前股票为基准，找到之前的最小值，用来更新最大利润。时间o(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//股票的最大利润，只允许买卖一次股票，求最大收益。思路:两个变量即可，每天都尝试卖一次，不断更新最大利润。时间o(n),空间o(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];<span class="comment">//存之前最小的股价</span></span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>; <span class="comment">//存最大的利润</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; ++i)&#123;<span class="comment">//遍历股价，每天都尝试卖一次，不断更新最大利润</span></span><br><span class="line">        resMax = Math.max(resMax, prices[i]-min);</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;min)&#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-允许多次买卖，求最大收益"><a href="#2-允许多次买卖，求最大收益" class="headerlink" title="2.允许多次买卖，求最大收益"></a>2.允许多次买卖，求最大收益</h3><p>《剑指offer》p304、leetcode 122</p>
<p>题目：允许多次买卖，求最大收益</p>
<p>思路：每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//股票的最大利润，允许多次买卖，求最大收益。思路:每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resMax = <span class="number">0</span>; <span class="comment">//存最大的利润</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;prices.length; ++i)&#123;<span class="comment">//遍历股价，每天都尝试卖一次，不断更新最大利润</span></span><br><span class="line">        <span class="keyword">int</span> temp = prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            resMax += temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-只允许买卖两次股票，求最大收益"><a href="#3-只允许买卖两次股票，求最大收益" class="headerlink" title="3.只允许买卖两次股票，求最大收益"></a>3.只允许买卖两次股票，求最大收益</h3><p>leetcode 123</p>
<p>题目：只允许买卖两次股票，求最大收益</p>
<p>思路：3、4两题可以用DP解决，但是这里用更巧妙的方法，直接看第4题即可，本题的解法就是第4题的k=2</p>
<h3 id="4-只允许买卖k次股票，求最大收益"><a href="#4-只允许买卖k次股票，求最大收益" class="headerlink" title="4.只允许买卖k次股票，求最大收益"></a>4.只允许买卖k次股票，求最大收益</h3><p>leetcode 188</p>
<p>题目：只允许买卖k次股票，求最大收益</p>
<p>思路：3、4两题都用二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k次买卖的最大股票收益。思路：二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);<span class="comment">//可以最多次买卖，求最大收益即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];<span class="comment">//tmpMax就是自己的钱包，就是当前的收益</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);<span class="comment">//卖</span></span><br><span class="line">            tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);<span class="comment">//买</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//允许多次买卖，把所有的收益都加起来即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="76"></a></p>
<h2 id="76-求1-2-3-…-n"><a href="#76-求1-2-3-…-n" class="headerlink" title="76.求1+2+3+…+n"></a>76.求1+2+3+…+n</h2><p>《剑指offer》p307.</p>
<p>题目：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>思路：递归。</p>
<p>这里可以通过递归的方式进行计算，<strong>但是很疑问的地方在于如何结束递归</strong><br>​<br>这里可以有多种的方式，基本方向是采用逻辑与或的方式来计算，</p>
<p><strong>用或运算通过n==0来短路，这样在n=0的时候不需要计算递归的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b = n==<span class="number">0</span> || (res=n+Sum_Solution(n-<span class="number">1</span>))&gt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="77"></a></p>
<h2 id="77-构建乘积数组"><a href="#77-构建乘积数组" class="headerlink" title="77.构建乘积数组"></a>77.构建乘积数组</h2><p>《剑指offer》p312、leetcode 238</p>
<p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],</p>
<p>其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<p>思路1(不可取)：如果没有不能使用除法的限制,可以用公式B[i]=A[0]*A[1]*…..*A[n-1]/A[i]表示,使用除法时要特别注意A[i]等于0的情况。时间o(n)，空间o(1)，但是这里不能用除法</p>
<p>思路2(不可取)：现在要求不能使用除法，一个直观的解法是用连乘n-1个数字得到B[i]，时间o(n^2)</p>
<p>思路3(可取)：辅助一个数组temp[]的思想(但这里就用B做辅助数组)，时间o(n),空间o(1)</p>
<p>1.先从后往前存储(temp[i]=A[i]*A[i+1]*…A[length-1])，此时先将B[]看成辅助数组temp[]</p>
<p>2.再从前往后计算(tempRes=A[0],B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]…)</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];<span class="comment">//存放结果，但从后往前计算时先将B看成辅助数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.1.先从后往前存储(temp[i]=A[i]*A[i+1]*...A[length-1])，此时先将B[]看成辅助数组</span></span><br><span class="line">    B[A.length-<span class="number">1</span>] = A[A.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.length-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        B[i] = B[i+<span class="number">1</span>] * A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.再从前往后计算(tempRes=1,B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]...)</span></span><br><span class="line">    <span class="keyword">int</span> tempRes = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.length-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        B[i] = tempRes * B[i+<span class="number">1</span>];</span><br><span class="line">        tempRes *= A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    B[A.length-<span class="number">1</span>] = tempRes;<span class="comment">//最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="78"></a></p>
<h2 id="78-普通二叉树中两个节点的最低公共祖先"><a href="#78-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="78.普通二叉树中两个节点的最低公共祖先"></a>78.普通二叉树中两个节点的最低公共祖先</h2><p>《剑指offer》p326、leetcode 236</p>
<p>题目：普通二叉树中两个节点的最低公共祖先</p>
<p>思路1(不可取)：从root开始寻找</p>
<p>如果当前节点的左子节点是两个节点的祖先(应该继续对左子节点判断)</p>
<p>如果当前节点的右子节点是两个节点的祖先(应该继续对右子节点判断)</p>
<p>当前结点不同时为两个结点的祖先(一边一个)，即为最低公共祖先</p>
<p>这种方法自上而下重复遍历，不太好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNode(root.left, p) &amp;&amp; hasNode(root.left, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasNode(root.right, p) &amp;&amp; hasNode(root.right, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//遍历以root为根的树，判断是否含有节点p</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNode</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == p) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasNode(root.left, p) || hasNode(root.right, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路2(可取)：遍历两次树，分别找出从root到两个节点的路径(用两个List存下来)，变成求两个list中的最后一个公共结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通二叉树中两个节点的最低公共祖先</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor2</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span> || p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;TreeNode&gt; arrayListP = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;TreeNode&gt; arrayListQ = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//两个List存路径</span></span><br><span class="line">    <span class="keyword">if</span>(!findPath(root,p,arrayListP) || !findPath(root,q,arrayListQ))&#123;<span class="comment">//没找到p、q</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;arrayListP.size() &amp;&amp; index&lt;arrayListQ.size())&#123;<span class="comment">//对两个路径list找最后一个公共节点</span></span><br><span class="line">        <span class="keyword">if</span>(arrayListP.get(index)!=arrayListQ.get(index))&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index==<span class="number">0</span> ? root: arrayListP.get(index-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历二叉树，找root到target节点的路径(路径存在res中)，如果没找到target返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findPath</span><span class="params">(TreeNode root, TreeNode target, ArrayList&lt;TreeNode&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(root);</span><br><span class="line">    <span class="keyword">if</span>(root==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (findPath(root.left, target, res) || findPath(root.right, target, res))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.remove(res.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="79"></a></p>
<h2 id="79-把字符串转换成整数"><a href="#79-把字符串转换成整数" class="headerlink" title="79.把字符串转换成整数"></a>79.把字符串转换成整数</h2><p>《剑指offer》p318、leetcode 8</p>
<p>题目：把字符串(包括数字字母符号,可以为空)转换成整数，不符合条件返回0。<br>即实现Integer.valueOf(string)的功能，要求不能使用字符串转换整数的库函数</p>
<p>思路：字符串转换成数组，res用long，从前往后遍历即可，本题核心是对以下情况的处理</p>
<p>要点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.字母判断</span><br><span class="line">2.溢出</span><br><span class="line">3.正负号</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] chs = str.trim().toCharArray();<span class="comment">//转换成数组</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive = <span class="keyword">true</span>;<span class="comment">//正负号</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(chs[index]==<span class="string">'+'</span> || chs[index]==<span class="string">'-'</span>)&#123;</span><br><span class="line">        isPositive = chs[index]==<span class="string">'-'</span> ? <span class="keyword">false</span> : <span class="keyword">true</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index&lt;chs.length)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = chs[index]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>||temp&gt;<span class="number">9</span>)&#123;<span class="comment">//是否是数字判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//这里在leetoce中应该为break，题目要求有一点点不一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        res = res*<span class="number">10L</span> + (<span class="keyword">long</span>)temp;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span>(isPositive==<span class="keyword">true</span>)&#123;<span class="comment">//溢出判断</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(res*(-<span class="number">1L</span>)&lt;Integer.MIN_VALUE)&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isPositive==<span class="keyword">true</span> ? (<span class="keyword">int</span>)res : (<span class="keyword">int</span>)res*(-<span class="number">1</span>);<span class="comment">//正负号判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="https://braincao.gitee.io/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/" data-id="ck6nmgv820002z30q0w17efds" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          左神刷题
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexoblog/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/hexoblog/2020/02/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/hexoblog/2020/02/15/%E5%B7%A6%E7%A5%9E%E5%88%B7%E9%A2%98/">左神刷题</a>
          </li>
        
          <li>
            <a href="/hexoblog/2020/02/15/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98/">剑指offer刷题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/hexoblog/" class="mobile-nav-link">Home</a>
  
    <a href="/hexoblog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/hexoblog/fancybox/jquery.fancybox.css">

  
<script src="/hexoblog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/hexoblog/js/script.js"></script>




  </div>
</body>
</html>