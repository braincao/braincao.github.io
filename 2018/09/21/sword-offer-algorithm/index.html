<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>剑指offer刷题 | Braincao&#39;s blog</title>
  <meta name="keywords" content=" 算法刷题 ">
  <meta name="description" content="剑指offer刷题 | Braincao&#39;s blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Brain Cao， 北邮8年，本科通信，研究生cs 已签阿里-蚂蚁金服，java技术栈 最近  搭建博客、个性化装修  自定义域名、博客备份  阿里云oss图床  迁移博客md，本周末结束  seo配置  联系方式 QQ : 491316377 邮箱 : 491316377@qq.com">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="https://braincao.cn/about/index.html">
<meta property="og:site_name" content="Braincao&#39;s blog">
<meta property="og:description" content="Brain Cao， 北邮8年，本科通信，研究生cs 已签阿里-蚂蚁金服，java技术栈 最近  搭建博客、个性化装修  自定义域名、博客备份  阿里云oss图床  迁移博客md，本周末结束  seo配置  联系方式 QQ : 491316377 邮箱 : 491316377@qq.com">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.braincao.cn/blogimg/1583405239.jpg">
<meta property="article:published_time" content="2020-02-15T18:03:30.000Z">
<meta property="article:modified_time" content="2020-03-06T15:55:50.345Z">
<meta property="article:author" content="Brain Cao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.braincao.cn/blogimg/1583405239.jpg">


<link rel="icon" href="/img/avatar.gif">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.2.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="true">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.gif" />
</a>
<div class="author">
    <span>Brain Cao</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/braincao" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="csdn" href="https://blog.csdn.net/pop_rain" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-csdn"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:491316377@qq.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
        
        <a title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=491316377&site=qq&menu=yes" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-qq"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(46)</small></div></li>
    
        
            
            <li><div data-rel="前端">前端<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="综合技术">综合技术<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="算法刷题">算法刷题<small>(8)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="技术之外"><i class="fold iconfont icon-right"></i>技术之外<small>(5)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="投资理财">投资理财<small>(3)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="计网">计网<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="java">java<small>(16)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
            <li><div data-rel="linux">linux<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="多线程">多线程<small>(1)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库">数据库<small>(4)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="python">python<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="spring">spring<small>(1)</small></div>
                
            </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  " target="_self"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="46">
<input type="hidden" id="yelog_site_word_count" value="142.2k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://www.oschina.net/">开源中国</a></li>
            
            <li><a target="_blank" href="http://ifeve.com/">并发编程网</a></li>
            
            <li><a target="_blank" href="https://www.cnblogs.com/">博客园</a></li>
            
            <li><a target="_blank" href="https://www.csdn.net/">csdn</a></li>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>

        <div class="title-list">
    <form onkeydown="if(event.keyCode === 13){return false;}">
        <input id="local-search-input" class="search" type="text" placeholder="以 in: 开头进行全文搜索" />
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color3">前端</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">博客</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">hexo</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">gitee</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">算法刷题</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">DFS</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">动态规划</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">投资理财</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">hosts</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">github</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">计网</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">leetcode</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">linux</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">职业管理</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">多线程</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">数据库</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">面经</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">python</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">排序算法</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">技术之外</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a id="top" class=""
           href="/2020/02/21/blog-index/"
           data-tag="博客"
           data-author="" >
            <span class="post-title" title="Braincao&#39;s Blog">Braincao&#39;s Blog</span>
            <span class="post-date" title="2020-02-21 01:37:19">2020/02/21</span>
        </a>
        
        <a  class="技术之外 投资理财 "
           href="/2020/03/05/fund-bank-screw/"
           data-tag="投资理财"
           data-author="" >
            <span class="post-title" title="《指数基金投资指南》学习笔记">《指数基金投资指南》学习笔记</span>
            <span class="post-date" title="2020-03-05 18:52:28">2020/03/05</span>
        </a>
        
        <a  class="综合技术 "
           href="/2020/02/29/oss-img-bed/"
           data-tag="博客"
           data-author="" >
            <span class="post-title" title="使用阿里云oss做博客图床">使用阿里云oss做博客图床</span>
            <span class="post-date" title="2020-02-29 12:22:43">2020/02/29</span>
        </a>
        
        <a  class="技术之外 "
           href="/2020/02/28/thinking-cognition/"
           data-tag="技术之外"
           data-author="" >
            <span class="post-title" title="思考认知">思考认知</span>
            <span class="post-date" title="2020-02-28 13:24:54">2020/02/28</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2020/02/27/normal-algorithms-summary/"
           data-tag="算法刷题"
           data-author="" >
            <span class="post-title" title="常用算法心得总结">常用算法心得总结</span>
            <span class="post-date" title="2020-02-27 18:13:44">2020/02/27</span>
        </a>
        
        <a  class="技术之外 "
           href="/2020/02/23/master-seek-job/"
           data-tag="职业管理"
           data-author="" >
            <span class="post-title" title="研二找工作过程总结">研二找工作过程总结</span>
            <span class="post-date" title="2020-02-23 12:54:10">2020/02/23</span>
        </a>
        
        <a  class="综合技术 "
           href="/2020/02/20/github-hosts/"
           data-tag="hosts,github"
           data-author="" >
            <span class="post-title" title="加速github访问速度">加速github访问速度</span>
            <span class="post-date" title="2020-02-20 23:24:11">2020/02/20</span>
        </a>
        
        <a  class="技术之外 投资理财 "
           href="/2020/01/20/fund-investment/"
           data-tag="投资理财"
           data-author="" >
            <span class="post-title" title="基金定投">基金定投</span>
            <span class="post-date" title="2020-01-20 10:30:31">2020/01/20</span>
        </a>
        
        <a  class="多线程 "
           href="/2019/10/01/multithread-programming-demo/"
           data-tag="多线程"
           data-author="" >
            <span class="post-title" title="多线程编程例子">多线程编程例子</span>
            <span class="post-date" title="2019-10-01 19:00:08">2019/10/01</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2019/10/01/postgraduate-interview-questions/"
           data-tag="算法刷题,面经"
           data-author="" >
            <span class="post-title" title="研二面试题目">研二面试题目</span>
            <span class="post-date" title="2019-10-01 12:03:55">2019/10/01</span>
        </a>
        
        <a  class="技术之外 投资理财 "
           href="/2019/05/08/financial-tips/"
           data-tag="投资理财"
           data-author="" >
            <span class="post-title" title="金融小知识">金融小知识</span>
            <span class="post-date" title="2019-05-08 09:43:21">2019/05/08</span>
        </a>
        
        <a  class="java "
           href="/2019/01/16/java-concurrency/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java并发">java并发</span>
            <span class="post-date" title="2019-01-16 22:08:05">2019/01/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-collection/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java集合">java集合</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-constant-pool/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="方法区与常量池">方法区与常量池</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-copy/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java深浅拷贝">java深浅拷贝</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-enum/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java枚举">java枚举</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-final/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="final关键字">final关键字</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-io/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java IO">java IO</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-jmm/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java内存模型JMM">java内存模型JMM</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-lamada/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="lamada表达式">lamada表达式</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-multi-thread/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java多线程">java多线程</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-parameter/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java参数...">java参数...</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-priority-queue/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java优先队列">java优先队列</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-reflection/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java反射">java反射</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-regular/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="java正则">java正则</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-throwable/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Java异常和处理详解">Java异常和处理详解</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/12/16/sort-algorithm/"
           data-tag="算法刷题,排序算法"
           data-author="" >
            <span class="post-title" title="十大经典排序算法总结">十大经典排序算法总结</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="spring "
           href="/2018/12/16/spring-filter/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="spring拦截器与过滤器的区别">spring拦截器与过滤器的区别</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="数据库 "
           href="/2018/12/16/sql-btree/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="B树系列详解">B树系列详解</span>
            <span class="post-date" title="2018-12-16 15:54:20">2018/12/16</span>
        </a>
        
        <a  class="java "
           href="/2018/12/16/java-md5-string/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="md5加密字符串">md5加密字符串</span>
            <span class="post-date" title="2018-12-16 13:45:57">2018/12/16</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/09/21/leetcode-algorithm-part1/"
           data-tag="算法刷题,leetcode"
           data-author="" >
            <span class="post-title" title="leetcode刷题-part1">leetcode刷题-part1</span>
            <span class="post-date" title="2018-09-21 17:32:47">2018/09/21</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/09/21/leftgod-algorithm/"
           data-tag="算法刷题"
           data-author="" >
            <span class="post-title" title="左神刷题">左神刷题</span>
            <span class="post-date" title="2018-09-21 17:32:47">2018/09/21</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/09/21/sword-offer-algorithm/"
           data-tag="算法刷题"
           data-author="" >
            <span class="post-title" title="剑指offer刷题">剑指offer刷题</span>
            <span class="post-date" title="2018-09-21 17:32:47">2018/09/21</span>
        </a>
        
        <a  class="linux "
           href="/2018/07/23/linux-orders/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="linux命令">linux命令</span>
            <span class="post-date" title="2018-07-23 23:31:32">2018/07/23</span>
        </a>
        
        <a  class="linux "
           href="/2018/07/23/linux-virtual/"
           data-tag="linux"
           data-author="" >
            <span class="post-title" title="ubuntu虚拟机共享文件夹">ubuntu虚拟机共享文件夹</span>
            <span class="post-date" title="2018-07-23 23:31:32">2018/07/23</span>
        </a>
        
        <a  class="python "
           href="/2018/07/19/python-mysql-connect/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="Python3连接MySQL">Python3连接MySQL</span>
            <span class="post-date" title="2018-07-19 19:13:39">2018/07/19</span>
        </a>
        
        <a  class="计网 "
           href="/2018/07/18/http-request/"
           data-tag="计网"
           data-author="" >
            <span class="post-title" title="http请求过程、方式">http请求过程、方式</span>
            <span class="post-date" title="2018-07-18 23:52:28">2018/07/18</span>
        </a>
        
        <a  class="python "
           href="/2018/07/18/python-shell/"
           data-tag="python"
           data-author="" >
            <span class="post-title" title="python中shell调用">python中shell调用</span>
            <span class="post-date" title="2018-07-18 22:28:30">2018/07/18</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/04/08/dfs-template/"
           data-tag="算法刷题,DFS"
           data-author="" >
            <span class="post-title" title="DFS模板">DFS模板</span>
            <span class="post-date" title="2018-04-08 16:03:01">2018/04/08</span>
        </a>
        
        <a  class="数据库 "
           href="/2018/04/08/mysql-key-index/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="数据库的主键外键索引">数据库的主键外键索引</span>
            <span class="post-date" title="2018-04-08 16:03:01">2018/04/08</span>
        </a>
        
        <a  class="数据库 "
           href="/2018/04/08/mysql-transaction/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="MySQL事务">MySQL事务</span>
            <span class="post-date" title="2018-04-08 16:03:01">2018/04/08</span>
        </a>
        
        <a  class="数据库 "
           href="/2018/04/08/sql-grammar/"
           data-tag="数据库"
           data-author="" >
            <span class="post-title" title="sql语法">sql语法</span>
            <span class="post-date" title="2018-04-08 16:03:01">2018/04/08</span>
        </a>
        
        <a  class="前端 "
           href="/2018/03/21/ajax/"
           data-tag="前端"
           data-author="" >
            <span class="post-title" title="ajax学习笔记">ajax学习笔记</span>
            <span class="post-date" title="2018-03-21 16:49:52">2018/03/21</span>
        </a>
        
        <a  class="算法刷题 "
           href="/2018/03/21/dynamic-programming/"
           data-tag="算法刷题,动态规划"
           data-author="" >
            <span class="post-title" title="动态规划">动态规划</span>
            <span class="post-date" title="2018-03-21 08:54:35">2018/03/21</span>
        </a>
        
        <a  class="综合技术 "
           href="/2018/02/22/build-hexo/"
           data-tag="博客,hexo,gitee"
           data-author="" >
            <span class="post-title" title="hexo博客系统搭建过程">hexo博客系统搭建过程</span>
            <span class="post-date" title="2018-02-22 19:29:01">2018/02/22</span>
        </a>
        
        <a  class="综合技术 "
           href="/2018/02/22/git-orders/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="git命令">git命令</span>
            <span class="post-date" title="2018-02-22 19:29:01">2018/02/22</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-sword-offer-algorithm" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">剑指offer刷题</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="算法刷题">算法刷题</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color5">算法刷题</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date">2018-09-21 17:32</time>
        
        
        更新时间:<time class="updated">2020-02-22 14:21</time>
        

    </div>
    <div class="article-meta">
        
        <span>字数:49.7k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、题目总览"><span class="toc-text">一、题目总览</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、题目及解答"><span class="toc-text">二、题目及解答</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-找出数组中重复的数字"><span class="toc-text">1.找出数组中重复的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-《剑指offer》p39、leetcode-287"><span class="toc-text">1.《剑指offer》p39、leetcode 287</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LeetCode-217：Contains-Duplicate"><span class="toc-text">2.LeetCode 217：Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LeetCode-219：Contains-Duplicate-II"><span class="toc-text">3.LeetCode 219：Contains Duplicate II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LeetCode-220：Contains-Duplicate-III"><span class="toc-text">4.LeetCode 220：Contains Duplicate III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-不修改数组找出重复的数字"><span class="toc-text">2.不修改数组找出重复的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-0-n-1中缺失的数字-2道"><span class="toc-text">3.0~n-1中缺失的数字(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-0-n-1中缺失的数字-数组有序"><span class="toc-text">1.0~n-1中缺失的数字(数组有序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-0-n-1中缺失的数字-数组无序"><span class="toc-text">2.0~n-1中缺失的数字(数组无序)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-数组中数字出现的次数-3道"><span class="toc-text">4.数组中数字出现的次数(3道)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-数组中出现次数超过一半的数字"><span class="toc-text">5.数组中出现次数超过一半的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-数组中出现次数超过1-3的数字"><span class="toc-text">6.数组中出现次数超过1&#x2F;3的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-统计指定数字在排序数组中出现的次数"><span class="toc-text">7.统计指定数字在排序数组中出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-二维数组中的查找"><span class="toc-text">8.二维数组中的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-替换空格"><span class="toc-text">9.替换空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Replace-Words–字典树"><span class="toc-text">10.Replace Words–字典树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Find-And-Replace-in-String"><span class="toc-text">11.Find And Replace in String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-从尾到头打印链表"><span class="toc-text">12.从尾到头打印链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-反转链表-三道"><span class="toc-text">13.反转链表(三道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-反转全部链表"><span class="toc-text">1.反转全部链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-反转部分链表"><span class="toc-text">2.反转部分链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-分组翻转链表"><span class="toc-text">3.分组翻转链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-根据前序-中序遍历数组来重建二叉树"><span class="toc-text">14.根据前序+中序遍历数组来重建二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-二叉树的下一个节点"><span class="toc-text">15.二叉树的下一个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Populating-Next-Right-Pointers-in-Each-Node"><span class="toc-text">16.Populating Next Right Pointers in Each Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="toc-text">17.Populating Next Right Pointers in Each Node II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-两个栈实现队列"><span class="toc-text">18.两个栈实现队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-两个队列实现栈"><span class="toc-text">19.两个队列实现栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-斐波那契数列-三道"><span class="toc-text">20.斐波那契数列(三道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-斐波那契数列"><span class="toc-text">1.斐波那契数列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-青蛙跳台阶"><span class="toc-text">2.青蛙跳台阶</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-变态跳台阶"><span class="toc-text">3.变态跳台阶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-斐波那契数列变种-两道"><span class="toc-text">21.斐波那契数列变种(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Length-of-Longest-Fibonacci-Subsequence"><span class="toc-text">1.Length of Longest Fibonacci Subsequence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Split-Array-into-Fibonacci-Sequence"><span class="toc-text">2.Split Array into Fibonacci Sequence</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Additive-Number"><span class="toc-text">22.Additive Number</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-旋转数组的最小数字-三道"><span class="toc-text">23.旋转数组的最小数字(三道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-旋转数组的最小数字"><span class="toc-text">1.旋转数组的最小数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Find-Minimum-in-Rotated-Sorted-Array-2"><span class="toc-text">2.Find Minimum in Rotated Sorted Array 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-矩阵中的路径"><span class="toc-text">24.矩阵中的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-机器人的运动范围"><span class="toc-text">25.机器人的运动范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-Unique-Paths-两道"><span class="toc-text">26.Unique Paths(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Unique-Paths"><span class="toc-text">1.Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Unique-Paths-2"><span class="toc-text">2.Unique Paths 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-剪绳子"><span class="toc-text">27.剪绳子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-不用加减乘除做加法"><span class="toc-text">28.不用加减乘除做加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-Two-Sum"><span class="toc-text">29.Two Sum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-二进制中1的个数"><span class="toc-text">30.二进制中1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-数值的整数次方"><span class="toc-text">31.数值的整数次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-打印从1到最大的n位数"><span class="toc-text">32.打印从1到最大的n位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-删除链表中重复的节点-两道"><span class="toc-text">33.删除链表中重复的节点(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Remove-Duplicates-from-Sorted-List"><span class="toc-text">1.Remove Duplicates from Sorted List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Remove-Duplicates-from-Sorted-List-II"><span class="toc-text">2.Remove Duplicates from Sorted List II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-正则表达式匹配"><span class="toc-text">34.正则表达式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-表示数值的字符串"><span class="toc-text">35.表示数值的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-调整数组顺序使奇数位于偶数前面-3道"><span class="toc-text">36.调整数组顺序使奇数位于偶数前面(3道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#《剑指offer》p129-需要保持顺序不变"><span class="toc-text">《剑指offer》p129(需要保持顺序不变)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sort-Array-By-Parity"><span class="toc-text">Sort Array By Parity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Odd-Even-Linked-List"><span class="toc-text">Odd Even Linked List</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-链表中倒数第k个结点-两道"><span class="toc-text">37.链表中倒数第k个结点(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-返回倒数第k个结点"><span class="toc-text">1.返回倒数第k个结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-删除倒数第k个节点"><span class="toc-text">2.删除倒数第k个节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-判断链表是否有环-两道"><span class="toc-text">38.判断链表是否有环(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-判断链表是否有环"><span class="toc-text">1.判断链表是否有环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-判断链表是否有环，有则返回环的入口结点"><span class="toc-text">2.判断链表是否有环，有则返回环的入口结点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-两个单链表相交的第一个公共节点-2道"><span class="toc-text">39.两个单链表相交的第一个公共节点(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-两个链表的第一个公共节点-无环"><span class="toc-text">1.两个链表的第一个公共节点(无环)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-两个链表的第一个公共节点-可能有环，需自己判断"><span class="toc-text">2.两个链表的第一个公共节点(可能有环，需自己判断)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-合并两个排序的链表"><span class="toc-text">40.合并两个排序的链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-树的子结构"><span class="toc-text">41.树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-二叉树的翻转-镜像-与对称-2道"><span class="toc-text">42.二叉树的翻转(镜像)与对称(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-二叉树的翻转-镜像"><span class="toc-text">1.二叉树的翻转(镜像)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-对称的二叉树"><span class="toc-text">2.对称的二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-顺时针打印矩阵"><span class="toc-text">43.顺时针打印矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-包含min函数的栈"><span class="toc-text">44.包含min函数的栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-栈的压入、弹出序列"><span class="toc-text">45.栈的压入、弹出序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-二叉树的层序遍历-3道"><span class="toc-text">46.二叉树的层序遍历(3道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-二叉树的层序遍历"><span class="toc-text">1.二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-二叉树的层序遍历，按行打印"><span class="toc-text">2.二叉树的层序遍历，按行打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-二叉树的层序遍历，之字形按行打印"><span class="toc-text">3.二叉树的层序遍历，之字形按行打印</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-递归与非递归实现二叉树前序、中序、后序遍历"><span class="toc-text">47.递归与非递归实现二叉树前序、中序、后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-前序："><span class="toc-text">1.前序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-中序"><span class="toc-text">2.中序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-后序"><span class="toc-text">3.后序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-判断数组是否为二叉搜索树的后续遍历序列"><span class="toc-text">48.判断数组是否为二叉搜索树的后续遍历序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-二叉树中和为指定值的路径-2道"><span class="toc-text">49.二叉树中和为指定值的路径(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Path-Sum"><span class="toc-text">1.Path Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Path-Sum-2"><span class="toc-text">2.Path Sum 2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-复杂链表的复制"><span class="toc-text">50.复杂链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-二叉搜索树与双向链表-两道"><span class="toc-text">51.二叉搜索树与双向链表(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-二叉搜索树转双向链表"><span class="toc-text">1.二叉搜索树转双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-有序数组转平衡二叉树"><span class="toc-text">2.有序数组转平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-序列化二叉树"><span class="toc-text">52.序列化二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-全排列-组合问题-五道"><span class="toc-text">53.全排列&#x2F;组合问题(五道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-字符串的全排列"><span class="toc-text">1.字符串的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-无重复数字的全排列"><span class="toc-text">2.无重复数字的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-有重复数字的全排列"><span class="toc-text">3.有重复数字的全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-八皇后问题"><span class="toc-text">4.八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-字符串s1的全排列是否在s2字符串中"><span class="toc-text">5.字符串s1的全排列是否在s2字符串中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-打印出给定字符串中字符的所有组合"><span class="toc-text">54.打印出给定字符串中字符的所有组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-大-小根堆–优先队列实现-两道"><span class="toc-text">55.大&#x2F;小根堆–优先队列实现(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-找出数组中最小的k个数-优先队列大根堆"><span class="toc-text">1.找出数组中最小的k个数(优先队列大根堆)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-找出数组中第k大的数-优先队列小根堆"><span class="toc-text">2.找出数组中第k大的数(优先队列小根堆)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-数据流中的中位数"><span class="toc-text">56.数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57-数组中最大连续子序列的和"><span class="toc-text">57.数组中最大连续子序列的和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58-1到n整数中1出现的次数"><span class="toc-text">58.1到n整数中1出现的次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59-正整数序列中的第n个数字"><span class="toc-text">59.正整数序列中的第n个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-把数组排成最小的数"><span class="toc-text">60.把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-求把一个数字翻译成不同字符串的个数-DP"><span class="toc-text">61.求把一个数字翻译成不同字符串的个数(DP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-礼物的最大价值"><span class="toc-text">62.礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-最长不含重复字符的子字符串长度"><span class="toc-text">63.最长不含重复字符的子字符串长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-丑数-两道"><span class="toc-text">64.丑数(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-判断一个数是否为丑数"><span class="toc-text">1.判断一个数是否为丑数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-求第N个丑数是几"><span class="toc-text">2.求第N个丑数是几</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65-第一个只出现一次的字符"><span class="toc-text">65.第一个只出现一次的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66-归并排序相关-3道"><span class="toc-text">66.归并排序相关(3道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数组的归并排序"><span class="toc-text">1.数组的归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-数组中的逆序对-2道"><span class="toc-text">2.数组中的逆序对(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-求出数组中逆序对的个数"><span class="toc-text">2.1 求出数组中逆序对的个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Reverse-Pairs"><span class="toc-text">2.2 Reverse Pairs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-单链表的归并排序"><span class="toc-text">3.单链表的归并排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67-二叉搜索树的第k小节点-中序遍历"><span class="toc-text">67.二叉搜索树的第k小节点(中序遍历)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68-二叉树的深度-两道"><span class="toc-text">68.二叉树的深度(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-求二叉树的深度"><span class="toc-text">1.求二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-判断是否为平衡二叉树"><span class="toc-text">2.判断是否为平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69-数组中和为s的数字-四道"><span class="toc-text">69.数组中和为s的数字(四道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数组中和为s的两个数字-有序数组"><span class="toc-text">1.数组中和为s的两个数字(有序数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-数组中和为s的两个数字-无序数组"><span class="toc-text">2.数组中和为s的两个数字(无序数组)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-打印出和为s的所有连续正数序列"><span class="toc-text">3.打印出和为s的所有连续正数序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-求和为s的所有连续正数序列的总数-转化为找因子的思想"><span class="toc-text">4.求和为s的所有连续正数序列的总数(转化为找因子的思想)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-翻转字符串-两道"><span class="toc-text">70.翻转字符串(两道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-翻转一句话的单词顺序-单词不变"><span class="toc-text">1.翻转一句话的单词顺序(单词不变)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-左旋转字符串"><span class="toc-text">2.左旋转字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-滑动窗口最大值-双端队列"><span class="toc-text">71.滑动窗口最大值(双端队列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-打印n个骰子所有可能的点数和及概率"><span class="toc-text">72.打印n个骰子所有可能的点数和及概率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-扑克牌中的顺子-2道"><span class="toc-text">73.扑克牌中的顺子(2道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-整个数组是否为一个顺子-同时有大小王"><span class="toc-text">1.整个数组是否为一个顺子(同时有大小王)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-整个数组分组后每组都要为顺子"><span class="toc-text">2.整个数组分组后每组都要为顺子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-圆圈中剩下的数-约瑟夫环问题"><span class="toc-text">74.圆圈中剩下的数(约瑟夫环问题)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-股票的最大利润问题-四道"><span class="toc-text">75.股票的最大利润问题(四道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-只允许买卖一次股票，求最大收益"><span class="toc-text">1.只允许买卖一次股票，求最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-允许多次买卖，求最大收益"><span class="toc-text">2.允许多次买卖，求最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-只允许买卖两次股票，求最大收益"><span class="toc-text">3.只允许买卖两次股票，求最大收益</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-只允许买卖k次股票，求最大收益"><span class="toc-text">4.只允许买卖k次股票，求最大收益</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-求1-2-3-…-n"><span class="toc-text">76.求1+2+3+…+n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#77-构建乘积数组"><span class="toc-text">77.构建乘积数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-普通二叉树中两个节点的最低公共祖先"><span class="toc-text">78.普通二叉树中两个节点的最低公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-把字符串转换成整数"><span class="toc-text">79.把字符串转换成整数</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑指offer专题oj，可在上面进行练习验证。</p>
<a id="more"></a>

<h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">题目</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center"><a href="#1">找出数组中重复的数字</a></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"><a href="#2">不修改数组找出重复的数字</a></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"><a href="#3">0~n-1中缺失的数字(2道)</a></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"><a href="#4">数组中数字出现的次数(3道)</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center"><a href="#5">数组中出现次数超过一半的数字</a></td>
</tr>
<tr>
<td align="center">6</td>
<td align="center"><a href="#6">数组中出现次数超过1/3的数字</a></td>
</tr>
<tr>
<td align="center">7</td>
<td align="center"><a href="#7">统计指定数字在排序数组中出现的次数</a></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center"><a href="#8">二维数组中的查找</a></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center"><a href="#9">替换空格</a></td>
</tr>
<tr>
<td align="center">10</td>
<td align="center"><a href="#10">Replace Words–字典树</a></td>
</tr>
<tr>
<td align="center">11</td>
<td align="center"><a href="#11">Find And Replace in String</a></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center"><a href="#12">从尾到头打印链表</a></td>
</tr>
<tr>
<td align="center">13</td>
<td align="center"><a href="#13">反转链表(三道)</a></td>
</tr>
<tr>
<td align="center">14</td>
<td align="center"><a href="#14">重建二叉树</a></td>
</tr>
<tr>
<td align="center">15</td>
<td align="center"><a href="#15">二叉树的下一个节点</a></td>
</tr>
<tr>
<td align="center">16</td>
<td align="center"><a href="#16">Populating Next Right Pointers in Each Node</a></td>
</tr>
<tr>
<td align="center">17</td>
<td align="center"><a href="#717">Populating Next Right Pointers in Each Node II</a></td>
</tr>
<tr>
<td align="center">18</td>
<td align="center"><a href="#18">两个栈实现队列</a></td>
</tr>
<tr>
<td align="center">19</td>
<td align="center"><a href="#19">两个队列实现栈</a></td>
</tr>
<tr>
<td align="center">20</td>
<td align="center"><a href="#20">斐波那契数列(三道)</a></td>
</tr>
<tr>
<td align="center">21</td>
<td align="center"><a href="#21">斐波那契数列变种_medium难度(两道)</a></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center"><a href="#22">Additive Number</a></td>
</tr>
<tr>
<td align="center">23</td>
<td align="center"><a href="#23">旋转数组的最小数字(三道)</a></td>
</tr>
<tr>
<td align="center">24</td>
<td align="center"><a href="#24">矩阵中的路径</a></td>
</tr>
<tr>
<td align="center">25</td>
<td align="center"><a href="#25">机器人的运动范围</a></td>
</tr>
<tr>
<td align="center">26</td>
<td align="center"><a href="#26">Unique Paths(两道)</a></td>
</tr>
<tr>
<td align="center">27</td>
<td align="center"><a href="#27">剪绳子</a></td>
</tr>
<tr>
<td align="center">28</td>
<td align="center"><a href="#28">不用加减乘除做加法(位运算)</a></td>
</tr>
<tr>
<td align="center">29</td>
<td align="center"><a href="#29">Two Sum</a></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center"><a href="#30">二进制中1的个数</a></td>
</tr>
<tr>
<td align="center">31</td>
<td align="center"><a href="#31">数值的整数次方</a></td>
</tr>
<tr>
<td align="center">32</td>
<td align="center"><a href="#32">打印从1到最大的n位数</a></td>
</tr>
<tr>
<td align="center">33</td>
<td align="center"><a href="#33">删除链表中重复的节点(两道)</a></td>
</tr>
<tr>
<td align="center">34</td>
<td align="center"><a href="#34">正则表达式匹配</a></td>
</tr>
<tr>
<td align="center">35</td>
<td align="center"><a href="#35">表示数值的字符串</a></td>
</tr>
<tr>
<td align="center">36</td>
<td align="center"><a href="#36">调整数组顺序使奇数位于偶数前面(3道)</a></td>
</tr>
<tr>
<td align="center">37</td>
<td align="center"><a href="#37">链表中倒数第k个结点(两道)</a></td>
</tr>
<tr>
<td align="center">38</td>
<td align="center"><a href="#38">判断链表是否有环(两道)</a></td>
</tr>
<tr>
<td align="center">39</td>
<td align="center"><a href="#39">两个单链表相交的第一个公共节点(2道)</a></td>
</tr>
<tr>
<td align="center">40</td>
<td align="center"><a href="#40">合并两个排序的链表</a></td>
</tr>
<tr>
<td align="center">41</td>
<td align="center"><a href="#41">树的子结构</a></td>
</tr>
<tr>
<td align="center">42</td>
<td align="center"><a href="#42">二叉树的翻转(镜像)与对称(2道)</a></td>
</tr>
<tr>
<td align="center">43</td>
<td align="center"><a href="#43">顺时针打印矩阵</a></td>
</tr>
<tr>
<td align="center">44</td>
<td align="center"><a href="#44">包含min函数的栈</a></td>
</tr>
<tr>
<td align="center">45</td>
<td align="center"><a href="#45">栈的压入、弹出序列</a></td>
</tr>
<tr>
<td align="center">46</td>
<td align="center"><a href="#46">二叉树的层序遍历(3道)</a></td>
</tr>
<tr>
<td align="center">47</td>
<td align="center"><a href="#47">递归与非递归实现二叉树前序、中序、后序遍历</a></td>
</tr>
<tr>
<td align="center">48</td>
<td align="center"><a href="#48">判断数组是否为二叉搜索树的后续遍历序列</a></td>
</tr>
<tr>
<td align="center">49</td>
<td align="center"><a href="#49">二叉树中和为某一值的路径</a></td>
</tr>
<tr>
<td align="center">50</td>
<td align="center"><a href="#50">复杂链表的复制</a></td>
</tr>
<tr>
<td align="center">51</td>
<td align="center"><a href="#51">二叉搜索树与双向链表(两道)</a></td>
</tr>
<tr>
<td align="center">52</td>
<td align="center"><a href="#52">序列化二叉树</a></td>
</tr>
<tr>
<td align="center">53</td>
<td align="center"><a href="#53">全排列问题(五道)</a></td>
</tr>
<tr>
<td align="center">54</td>
<td align="center"><a href="#54">打印出给定字符串中字符的所有组合</a></td>
</tr>
<tr>
<td align="center">55</td>
<td align="center"><a href="#55">大/小根堆–优先队列实现(两道)</a></td>
</tr>
<tr>
<td align="center">56</td>
<td align="center"><a href="#56">数据流中的中位数</a></td>
</tr>
<tr>
<td align="center">57</td>
<td align="center"><a href="#57">数组中最大连续子序列的和</a></td>
</tr>
<tr>
<td align="center">58</td>
<td align="center"><a href="#58">1到n整数中1出现的次数</a></td>
</tr>
<tr>
<td align="center">59</td>
<td align="center"><a href="#59">正整数序列中的第n个数字</a></td>
</tr>
<tr>
<td align="center">60</td>
<td align="center"><a href="#60">把数组排成最小的数</a></td>
</tr>
<tr>
<td align="center">61</td>
<td align="center"><a href="#61">求把一个数字翻译成不同字符串的个数(DP)</a></td>
</tr>
<tr>
<td align="center">62</td>
<td align="center"><a href="#62">礼物的最大价值</a></td>
</tr>
<tr>
<td align="center">63</td>
<td align="center"><a href="#63">最长不含重复的子字符串长度</a></td>
</tr>
<tr>
<td align="center">64</td>
<td align="center"><a href="#64">丑数(两道)</a></td>
</tr>
<tr>
<td align="center">65</td>
<td align="center"><a href="#65">第一个只出现一次的字符</a></td>
</tr>
<tr>
<td align="center">66</td>
<td align="center"><a href="#66">归并排序相关(3道)</a></td>
</tr>
<tr>
<td align="center">67</td>
<td align="center"><a href="#67">二叉搜索树的第k小节点(中序遍历)</a></td>
</tr>
<tr>
<td align="center">68</td>
<td align="center"><a href="#68">二叉树的深度(两道)</a></td>
</tr>
<tr>
<td align="center">69</td>
<td align="center"><a href="#69">数组中和为s的数字(四道)</a></td>
</tr>
<tr>
<td align="center">70</td>
<td align="center"><a href="#70">翻转字符串(两道)</a></td>
</tr>
<tr>
<td align="center">71</td>
<td align="center"><a href="#71">滑动窗口的最大值(双端队列)</a></td>
</tr>
<tr>
<td align="center">72</td>
<td align="center"><a href="#72">打印n个骰子所有可能的点数和及概率</a></td>
</tr>
<tr>
<td align="center">73</td>
<td align="center"><a href="#73">扑克牌中的顺子(2道)</a></td>
</tr>
<tr>
<td align="center">74</td>
<td align="center"><a href="#74">圆圈中剩下的数(约瑟夫环问题)</a></td>
</tr>
<tr>
<td align="center">75</td>
<td align="center"><a href="#75">股票的最大利润问题(四道)</a></td>
</tr>
<tr>
<td align="center">76</td>
<td align="center"><a href="#76">求1+2+3+…+n(不用if而用或短路的方式结束递归)</a></td>
</tr>
<tr>
<td align="center">77</td>
<td align="center"><a href="#77">构建乘积数组</a></td>
</tr>
<tr>
<td align="center">78</td>
<td align="center"><a href="#78">普通二叉树中两个节点的最低公共祖先</a></td>
</tr>
<tr>
<td align="center">79</td>
<td align="center"><a href="#79">把字符串转换成整数</a></td>
</tr>
</tbody></table>
<h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p>
<h2 id="1-找出数组中重复的数字"><a href="#1-找出数组中重复的数字" class="headerlink" title="1.找出数组中重复的数字"></a>1.找出数组中重复的数字</h2><pre><code>LeetCode 217：Contains Duplicate 
LeetCode 219：Contains Duplicate II 
LeetCode 220：Contains Duplicate III 
LeetCode 287：Find the Duplicate Number
</code></pre><h3 id="1-《剑指offer》p39、leetcode-287"><a href="#1-《剑指offer》p39、leetcode-287" class="headerlink" title="1.《剑指offer》p39、leetcode 287"></a>1.《剑指offer》p39、leetcode 287</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<p>思路：交换法、映射。数组不重复的情形是array[i]=i。遍历数组元素，元素值为m时，与array[m]的值作对比，如果相同则重复了，返回即可，否则二者交换，继续比较，直到遍历完数组。时间o(n)，空间o(1)</p>
<pre><code class="java">public class Solution {
    public boolean duplicate(int numbers[],int length,int [] duplication) {
        for(int i=0; i&lt;length; ++i){
            while(numbers[i]!=i){//注意这里是while
                if(numbers[numbers[i]]==numbers[i]){
                    duplication[0] = numbers[i];
                    return true;
                }else{
                    swap(numbers, i, numbers[i]);
                }
            }
        }
        return false;
    }

    public void swap(int[] nums, int i, int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
</code></pre>
<h3 id="2-LeetCode-217：Contains-Duplicate"><a href="#2-LeetCode-217：Contains-Duplicate" class="headerlink" title="2.LeetCode 217：Contains Duplicate"></a>2.LeetCode 217：Contains Duplicate</h3><p>题目：Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<pre><code>Input: [1,2,3,1]
Output: true
</code></pre><p>思路：</p>
<p>1）将数组排序，判断前后两个元素是否一样，如果一样则返回true，否则返回false； </p>
<p>2）方法（1）对数组进行排序，改变了数组元素的位置；若要求不能修改数组元素，可以创建一个辅助HashSet，判断HashSet中是否已经存在该元素，存在则返回true，否则返回false，并将其加入在HashSet中。</p>
<pre><code class="java">//法一：排序(改变了位置,时间o(nlogn)，空间o(1))
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for(int i=0; i&lt;nums.length-1; ++i){
        if(nums[i+1]==nums[i]){
            return true;
        }
    }
    return false;
}

//法二：hashSet(不改变位置，时间o(n),空间o(n))
public boolean containsDuplicate2(int[] nums) {
    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
    for(int num: nums){
        if(!set.add(num)){
            return true;
        }
    }
    return false;
}
</code></pre>
<h3 id="3-LeetCode-219：Contains-Duplicate-II"><a href="#3-LeetCode-219：Contains-Duplicate-II" class="headerlink" title="3.LeetCode 219：Contains Duplicate II"></a>3.LeetCode 219：Contains Duplicate II</h3><p>题目：给定一个数组nums和一个整数k，是否存在两个不相等的整数 i 和 j，使得nums[i] == nums[j]，并且i和j之间的距离最多为k。</p>
<pre><code>Input: nums = [1,2,3,1], k = 3
Output: true

Input: nums = [1,0,1,1], k = 1
Output: true

Input: nums = [1,2,3,1,2,3], k = 2
Output: false
</code></pre><p>思路：辅助map存储数组元素值-元素索引，遍历数组即可，时间o(n)，空间o(n)</p>
<pre><code class="java">public boolean containsNearbyDuplicate(int[] nums, int k) {
    //值-索引
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i=0; i&lt;nums.length; ++i){
        if(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i]))&lt;=k){//找到重复
            return true;
        }else{
            map.put(nums[i], i);//更新键值对
        }
    }
    return false;
}
</code></pre>
<h3 id="4-LeetCode-220：Contains-Duplicate-III"><a href="#4-LeetCode-220：Contains-Duplicate-III" class="headerlink" title="4.LeetCode 220：Contains Duplicate III"></a>4.LeetCode 220：Contains Duplicate III</h3><p>题目：给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。</p>
<p>思路：维持一个大小为k的窗口，由左向右在nums中移动。对于nums[i]，只要查找其之前的元素中是否存在大小范围在[nums[i] - t,nums[i] + t]的元素，如果存在就返回true。还要注意整数的溢出问题，Long</p>
<pre><code class="java">//使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。
//思路：treeset滑窗保存有序元素
//treeset.ceiling--返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null
//treeset.floor--返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    if (nums == null || nums.length == 0 || k &lt;= 0){
        return false;
    }
    TreeSet&lt;Long&gt; treeSet = new TreeSet&lt;&gt;();
    for(int i=0; i&lt;nums.length; ++i){
        if(i&gt;k){//超过滑窗k，删除treeset中的一个元素
            treeSet.remove((long)nums[i-k-1]);
        }
        Long left = treeSet.ceiling((long)nums[i]-t);
        Long right = treeSet.floor((long)nums[i]+t);
        if(left!=null &amp;&amp; right!=null &amp;&amp; right&gt;=left){
            return true;
        }
        treeSet.add((long)nums[i]);
    }
    return false;
}
</code></pre>
<p><a name="2"></a></p>
<h2 id="2-不修改数组找出重复的数字"><a href="#2-不修改数组找出重复的数字" class="headerlink" title="2.不修改数组找出重复的数字"></a>2.不修改数组找出重复的数字</h2><p>《剑指offer》p41. </p>
<p>题目：在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。</p>
<p>第一种思路：与题目1思路相似，利用哈希表，创建一个相同长度的辅助数组，将数组元素存在对应辅助数组下标处，很容易发现重复的数字。辅助空间O(n)</p>
<p>思路：二分查找。若有重复出现，则数字的个数会大于区间的长度，O(nlogn)、O(1)。</p>
<p>详细思路：如果数组中有重复的数，那么n+1个0~n范围内的数中，一定有几个数的个数大于1。那么，我们可以利用这个思路解决该问题。</p>
<p>我们把从1<del>n的数字从中间的数字m分为两部分，前面一半为1</del>m，后面一半为m+1<del>n。如果1</del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，反之，如果大于m，那么这一半的区间一定包含重复的数字；如果小于m，另一半m+1~n的区间里一定包含重复的数字。接下来，我们可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p>
<p>由于如果1<del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，我们可以逐步减少m，然后判断1</del>m之间是否有重复的数，即，我们可以令m=m-1，然后再计算1<del>m的数字的数目是否等于m，如果等于m，再令m=m-1，如果大于m，则说明1</del>m的区间有重复的数，如果小于m，则说明m+1~n有重复的数，不断重复此过程。</p>
<pre><code class="java">/**
 * FileName: Hello
 * Author:   braincao
 * Date:     2018/8/29 15:21
 * Description: 《剑指offer》P41.不修改数组找出重复的数字
 */
public class Hello{
    public static void main(String[] args){
        int[] c = new int[]{2,3,3,5,5,2,6,7};
        System.out.println(getDuplication(c,8));
    }
    static int getDuplication(int[] array, int length){
        int left = 1;
        int right = array.length - 1;
        while(left&lt;=right) {
            int mid = (left + right) / 2;
            int cnt = count(array, length, left, mid);
            if (left == right) {
                if (cnt &gt; 1)
                    return left;
                else
                    break;
            }
            if (cnt &gt; (mid - left + 1)) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }

        return -1;
    }

    static int count(int[] array, int length, int start, int end){
        int cnt = 0;
        for(int i=0; i&lt;length; ++i){
            if(array[i]&gt;=start &amp;&amp; array[i]&lt;=end){
                cnt++;
            }
        }
        return cnt;
    }
}
</code></pre>
<p><a name="3"></a></p>
<h2 id="3-0-n-1中缺失的数字-2道"><a href="#3-0-n-1中缺失的数字-2道" class="headerlink" title="3.0~n-1中缺失的数字(2道)"></a>3.0~n-1中缺失的数字(2道)</h2><pre><code>0~n-1中缺失的数字(数组有序)--《剑指offer》p266
0~n-1中缺失的数字(数组无序)--leetcode 268
</code></pre><h3 id="1-0-n-1中缺失的数字-数组有序"><a href="#1-0-n-1中缺失的数字-数组有序" class="headerlink" title="1.0~n-1中缺失的数字(数组有序)"></a>1.0~n-1中缺失的数字(数组有序)</h3><p>《剑指offer》p266</p>
<p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0<del>n-1之内。在范围0</del>n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>思路：排序数组，问题转换成找出第一个下标与值不等的那个下标对应的数，显然是二分查找，时间o(logn)</p>
<pre><code class="java">//0~n-1中缺失的数字(数组有序)。思路：利用二分查找查找第一个nums[i]!=i的数字
public static int findLostNumber(int[] arr){
    int left = 0;
    int right = arr.length-1;
    while(left&lt;=right){
        int mid = left+(right-left)/2;
        if(arr[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找
            left = mid+1;
        }
        else if(arr[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素
            if(mid==left || (mid&gt;left&amp;&amp;arr[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的
                return mid;
            }
            else{//往左边找
                right = mid-1;
            }
        }
    }

    return arr.length;//之前的都相符，说明缺失的数字在最右边
}

public static void main(String[] args){
    int[] nums = new int[]{0,1,2,3,4,5,7,8,9};//0~9一共10个数，数组长度为9，缺失的数字为6
    System.out.println(findLostNumber(nums));
}
</code></pre>
<h3 id="2-0-n-1中缺失的数字-数组无序"><a href="#2-0-n-1中缺失的数字-数组无序" class="headerlink" title="2.0~n-1中缺失的数字(数组无序)"></a>2.0~n-1中缺失的数字(数组无序)</h3><p>leetcode 268</p>
<p>题目：Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<pre><code>Input: [3,0,1]
Output: 2

Input: [9,6,4,2,3,5,7,0,1]
Output: 8
</code></pre><p>这道题的几种思路如下：</p>
<pre><code>1. 二分查找(not good)
把数组排序，用二分查找来找到缺失值。时间o(nlogn)

1. 累加(good)
计算1+2+...+n. 用和值减去数组中数的和值，最后的差就是我们要的结果。这个过程中要防止溢出。

3. 异或(best)
异或运算有一个性质，x^y^y=x. 结果与x和y的顺序无关。我们把0～n与数组中的数都异或到一起，那么最后的结果就是缺失的那个数。
</code></pre><p>法一(不好)：先排序，再利用二分查找找第一个下标不符的元素，时间o(nlogn)，代码如下：</p>
<pre><code class="java">public int missingNumber(int[] nums) {
    Arrays.sort(nums);//先排序
    int left = 0;
    int right = nums.length-1;
    while(left&lt;=right){
        int mid = left+(right-left)/2;
        if(nums[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找
            left = mid+1;
        }
        else if(nums[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素
            if(mid==left || (mid&gt;left&amp;&amp;nums[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的
                return mid;
            }
            else{//往左边找
                right = mid-1;
            }
        }
    }

    return nums.length;//之前的都相符，说明缺失的数字在最右边
}
</code></pre>
<p>法二忽略</p>
<p>法三(更好)：<strong>异或性质。0～n与数组中的数都异或到一起，最后的结果即为所求的缺失数字</strong>，代码如下：</p>
<pre><code class="java">public int missingNumber(int[] nums) {
    int res = 0;
    for(int i=0; i&lt;nums.length; ++i){
        res ^= i;
        res ^= nums[i];
    }
    return res^nums.length;
}
</code></pre>
<p><a name="4"></a></p>
<h2 id="4-数组中数字出现的次数-3道"><a href="#4-数组中数字出现的次数-3道" class="headerlink" title="4.数组中数字出现的次数(3道)"></a>4.数组中数字出现的次数(3道)</h2><p>《剑指offer》p275、leetcode 260、leetcode 136、leetcode 137、leetcode 540</p>
<p>题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。</p>
<p>思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求</p>
<p>题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。</p>
<p>思路2：</p>
<pre><code>​1.所有数字异或;
​2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);
​3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)
​</code></pre><p>题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字</p>
<p>思路3：</p>
<pre><code>1.这里不能用异或了，但是还是考虑位运算思路;
2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除,则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1
3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好
</code></pre><p>代码：</p>
<pre><code class="java">/**
 * 题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。
 * 思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求
 *
 * 题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。
 * 思路2：1.所有数字异或;
 *       2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);
 *       3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)
 *
 * 题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字
 * 思路3：1.这里不能用异或了，但是还是考虑位运算思路;
 *       2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，
 *         则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1
 *       3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好
 */
public class Solution {
    //题目1：找出唯一一个一个出现了一次的数字--&gt;所有数字异或
    public static int findSingleNumber(int[] arr){
        int res = 0;
        for(int i: arr){
            res ^= i;
        }

        return res;
    }
    /**
     * 题目2：找出这两个只出现一次的数字--&gt;
     * 1.所有数字异或;
     * 2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);
     * 3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)
     */
    public static int[] findSingleNumber2(int[] arr){
        int tempRes = 0;
        for(int i: arr){//1.将数组所有数字异或
            tempRes ^= i;
        }
        int k=1;//2.找出tempRes从右往左首个1出现在第k位
        while(tempRes!=0){
            if((tempRes&amp;1) == 1){ //出现了首个1
                break;
            }
            else{//还没出现首个1
                k++;
                tempRes = tempRes&gt;&gt;1;
            }
        }
        int groupOne = 0;//3.将原数组数字分组，并在每个组中找出只出现一个的数字
        int groupTwo = 0;
        for(int i: arr){
            int bit = (i&gt;&gt;(k-1)) &amp; 1; //该数的第k位是bit
            if(bit==1){
                groupOne ^= i;
            }
            else{
                groupTwo ^= i;
            }
        }
        return new int[]{groupOne, groupTwo};
    }

    /**
     * 题目3：找出这两个只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字--&gt;
     * 1.这里不能用异或了，但是还是考虑位运算思路;
     * 2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，
     *   则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1
     * 3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好
     */
    public static int findSingleNumber3(int[] arr) {
        int[] bits = new int[32]; //int类型4字节，32位
        for(int number: arr){//将数组中所有数字的二进制表示的每一位都加起来，每一位的和存在bits数组中
            for(int i=0; i&lt;32; ++i){ //从个位到第32位依次相加存储
                bits[i] += (number&gt;&gt;i)&amp;1; //数字number的第i位上的数
            }
        }
        int res = 0;
        for(int i=0; i&lt;32; ++i) { //把bits每一位上的数%3，如果为0，则所求的数该位也为0，否则为1
            res += ((bits[i]%3)&lt;&lt;i);
        }
        return res;
    }

    public static void main(String[] args){
        int[] arr = {1,2,1,2,3};//找出一个出现一次的数字
        int[] arr2 = {1,2,1,2,3,4}; //找出两次出现一次的数字
        int[] arr3 = {1,2,1,1,2,5,2}; //找出两次出现一次的数字
        System.out.println(findSingleNumber(arr));//找出一个出现一次的数字。out:3
        System.out.println(findSingleNumber2(arr2)[0] + &quot; &quot; + findSingleNumber2(arr2)[1]);//找出两次出现一次的数字。out:3,4
        System.out.println(findSingleNumber3(arr3));//找出这两个只出现一次的数字，其他都出现三次。out:5
    }
}
</code></pre>
<p><a name="5"></a></p>
<h2 id="5-数组中出现次数超过一半的数字"><a href="#5-数组中出现次数超过一半的数字" class="headerlink" title="5.数组中出现次数超过一半的数字"></a>5.数组中出现次数超过一半的数字</h2><p>《剑指offer》p205、leetcode 169</p>
<p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<p>思路：</p>
<p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p>
<p>法二_更简单高效的方法：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p>
<p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p>
<pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {
    int len = array.length;
    int middle = len/2;
    int left = 0;
    int right = len-1;
    int index = partition(array, left, right, left);
    while(index != middle){//如果不是中位数
        if(index &lt; middle){//说明中位数在index的右边
            left = index + 1;
            index = partition(array, left, right, left);
        }
        else if(index &gt; middle){//说明中位数在index的左边
            right = index - 1;
            index = partition(array, left, right, left);
        }
    }
    //现在array[index]是中位数了
    int res = 0;
    if(check(array, array[index])){//检查array[index]是否真的出现次数超过一半，不超过返回0
        res = array[index];
    }
    return res;
}
public static int partition(int[] arr, int left, int right, int pivotIndex){
    int pivot = arr[pivotIndex];
    swap(arr, pivotIndex, right);
    int storeIndex = left;
    for(int i=left; i&lt;=right; i++){
        if(arr[i] &lt; pivot){
            swap(arr, i, storeIndex);
            storeIndex++;
        }
    }
    swap(arr, storeIndex, right);
    return storeIndex;
}

public static boolean check(int[] arr, int key){//经过算法后求出的数，再次进行检查看看是否真的超过一半，不符合条件res=0
    int times = 0;
    for(int i=0; i&lt;arr.length; ++i){
        if(arr[i] == key){
            times++;
        }
    }
    if(times &gt; (arr.length/2)){
        return true;
    }
    return false;
}

public static void swap(int[] arr, int i, int j){
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre>
<p>法二：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p>
<pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {
    if(array==null || array.length==0){
        return 0;
    }
    if(array.length==1){
        return array[0];
    }
    int times = 1;
    int num = array[0];
    for(int i=1; i&lt;array.length; ++i){
        if(array[i]==num){
            times++;
        }
        else{
            times--;
            if(times==0){
                times = 1;
                num = array[i];
            }
        }
    }

    if(times&gt;1){//一定是
        return num;
    }
    if(times==1){//有可能不是，再重新检查该数出现次数是否超过数组长度一半，不超过返回0
        int temp = 0;
        for(int i=0; i&lt;array.length; ++i){
            if(array[i]==num){
                temp++;
            }
        }
        if(temp &gt; (array.length)/2){
            return num;
        }
    }
    return 0;
}
public static void main(String[] args){
    int[] array = new int[]{2,2,2,2,2,1,3,4,5};
    System.out.println(MoreThanHalfNum_Solution(array));
}
</code></pre>
<p><a name="6"></a></p>
<h2 id="6-数组中出现次数超过1-3的数字"><a href="#6-数组中出现次数超过1-3的数字" class="headerlink" title="6.数组中出现次数超过1/3的数字"></a>6.数组中出现次数超过1/3的数字</h2><p>leetcode 229</p>
<p>题目：Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space.</p>
<p>给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)</p>
<pre><code>Input: [3,2,3]
Output: [3]

Input: [1,1,1,3,3,2,2,2]
Output: [1,2]
</code></pre><p>思路：每次从nums中拿出3个不一样的数作为一组，肯定会出现两种情况。一，nums被取空了，那么nums中每个数出现次数最多占总次数的1/3，不存在超过1/3的数字；二，还有剩余，这个情况就复杂了，有可能剩余多个，但是……但是，<strong>最多只可能剩余两种数</strong>。 为什么？ 3个不同的数凑一组才能删掉，所以不可能删掉超过1/3的数。所以超过1/3的数肯定被剩下来，但是，<strong>剩下来的俩数并不一定都是超过1/3的</strong>，这点额外注意。 很容易举个例子， 比如</p>
<p><code>1 1 1 1 1 2 2 3 3 4 4 5--最后剩1,4--&gt;只有1是结果</code></p>
<p>我们把原问题转换为如何快速高效的从数组中每次去掉3个不同的数，最后把剩下的两个不同的数保存起来，重新遍历数组判断即可。</p>
<p>代码实现：用a,b表示两种不同的数，用计数器cnta,cntb表示a,b不同的数出现的次数来计数，在遍历数组的过程中计数抵消，看他们俩最终还剩下多少个。</p>
<pre><code class="java">//给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)
//思路：遍历数组，每次抵消三个不同的数，最后剩下的2个数重新遍历数组判断。
public List&lt;Integer&gt; majorityElement(int[] nums) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(nums==null || nums.length==0){
        return res;
    }

    int a = nums[0];
    int b = nums[0];//a,b存两种不同的数
    int cnta = 0;
    int cntb = 0;//cnta,cntb对a,b两种不同的数出现次数的计数，当计数为0时，重置a/b
    for(int num: nums){//遍历字符串
        if(a==num){
            cnta++;
            continue;
        }
        if(b==num){
            cntb++;
            continue;
        }
        if(cnta==0){//a的计数为0，重置a
            a = num;
            cnta = 1;
            continue;
        }
        if(cntb==0){//b的计数为0，重置b
            b = num;
            cntb = 1;
            continue;
        }
        cnta--;
        cntb--;//当前的num和a,b都不同，则一起抵消
    }

    cnta = 0;
    cntb = 0;
    //最后剩下的有a,b,重新遍历数组查看是否次数超过1/3
    for(int num: nums){
        if(num==a){
            cnta++;
        }
        else if(num==b){
            cntb++;
        }
    }
    if(cnta&gt;(nums.length)/3){
            res.add(a);
    }
    if(cntb&gt;(nums.length)/3){
        res.add(b);
    }

    return res;
}
</code></pre>
<p><a name="7"></a></p>
<h2 id="7-统计指定数字在排序数组中出现的次数"><a href="#7-统计指定数字在排序数组中出现的次数" class="headerlink" title="7.统计指定数字在排序数组中出现的次数"></a>7.统计指定数字在排序数组中出现的次数</h2><p>《剑指offer》p263、leetcode 34</p>
<p>题目：统计一个数字在排序数组中出现的次数。</p>
<p>思路：</p>
<p>因为数组排序，很明显要用二分查找。</p>
<p>法一(不可取)，最差时间o(n)。先二分查找k在数组array中的索引，然后从该索引处向左向右外扩，找出所有相等的数。</p>
<p>法二(更好的方法)：充分利用二分查找直接找到第一个k和最后一个k，二者索引相减即为出现的个数。时间o(logn)</p>
<p>什么时候是第一个k：找到的k的前面一个元素如果不等于k，则此时是第一个k</p>
<p>什么时候是最后一个k：找到的k的后面一个元素如果不等于k，则此时是第一个k</p>
<pre><code class="java">//统计指定数字在排序数组中出现的次数。思路：充分利用二分查找第一个k和最后一个k的位置，两者的区间长度即为所求次数
public static int GetNumberOfK(int [] array , int k) {
    if(array==null || array.length==0){
        return 0;
    }
    //二分查找左边第一个k的位置
    int left = getFirst(array, k);
    int right = getLast(array, k);
    if(left==-1 || right==-1){//数组中没有k
        return 0;
    }
    if(left&lt;=right){
        return right-left+1;
    }
    return 0;
}
//二分查找第一个k的位置
public static int getFirst(int[] nums, int k){
    int left = 0;
    int right = nums.length-1;
    while(left&lt;=right){
        int mid = left + (right-left)/2;
        if(nums[mid]==k){
            if( (mid&gt;left&amp;&amp;nums[mid-1]!=k) || mid==left){//找到第一个k
                return mid;
            }
            else{//不是第一个k，继续往左边找
                right = mid-1;
            }
        }
        else if(nums[mid]&lt;k){//k在右边
            left = mid+1;
        }
        else{//k在左边
            right = mid-1;
        }
    }
    return -1;//没找到k，返回-1
}
//二分查找最后一个k的位置
public static int getLast(int[] nums, int k){
    int left = 0;
    int right = nums.length-1;
    while(left&lt;=right){
        int mid = left + (right-left)/2;
        if(nums[mid]==k){
            if( (mid&lt;right&amp;&amp;nums[mid+1]!=k) || mid==right){//找到最后一个k
                return mid;
            }
            else{//不是最后一个k，继续往右边找
                left = mid+1;
            }
        }
        else if(nums[mid]&lt;k){//k在右边
            left = mid+1;
        }
        else{//k在左边
            right = mid-1;
        }
    }
    return -1;//没找到k，返回-1
}

public static void main(String[] args){
    int[] nums = new int[]{1,2,3,4,5,5,5,5,5,5,5,7,8,11};//out:7
    System.out.println(GetNumberOfK(nums, 5));
}
</code></pre>
<p><a name="8"></a></p>
<h2 id="8-二维数组中的查找"><a href="#8-二维数组中的查找" class="headerlink" title="8.二维数组中的查找"></a>8.二维数组中的查找</h2><p>《剑指offer》p44、leetcode74</p>
<p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>思路：从二维数组右上角开始查找，因为从右上角/左下角开始比较的话若不相等可以删除不符合条件的一行或者一列</p>
<p>以右上角为例，若相等则返回true；若target比右上角大，说明目标在其下面，则删除所在行；若target比右上角小，说明目标在其左侧，则删除所在列</p>
<p>以左上角为例，若target比左上角大，则不能缩小范围，因为右侧和下侧的元素都比左上角，右下角同理，pass！</p>
<pre><code class="java">public boolean Find(int target, int [][] array) {
    if(array==null || array.length==0){
        return false;
    }
    int m = array.length-1;
    if(array[0].length==0){
        return false;
    }
    int n = array[0].length-1;
    int i = 0;
    int j = n;
    while(i&lt;=m &amp;&amp; j&gt;=0){
        if(array[i][j] == target){
            return true;
        }
        else if(target&lt;array[i][j]){
            j--;
        }
        else{
            i++;
        }
    }
    return false;
}
</code></pre>
<p><a name="9"></a></p>
<h2 id="9-替换空格"><a href="#9-替换空格" class="headerlink" title="9.替换空格"></a>9.替换空格</h2><p>《剑指offer》p51</p>
<p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>思路：先遍历字符串计算空格出现次数，然后设置新数组大小，从后往前遍历数组，替换空格。</p>
<pre><code class="java">public class Solution {
    public String replaceSpace(StringBuffer str) {
        int cnt = 0;
        for(int i=0; i&lt;str.length(); i++)
        {
            if(str.charAt(i)==&#39; &#39;)
            {
                cnt++;
            }
        }
        int newLen = str.length() + cnt*2;
        char[] newStr = new char[newLen];
        int i = str.length()-1;
        int j = newLen-1;
        while(i&gt;=0){
            if(str.charAt(i)==&#39; &#39;){
                newStr[j--] = &#39;0&#39;;
                newStr[j--] = &#39;2&#39;;
                newStr[j--] = &#39;%&#39;;
            }
            else{
                newStr[j--] = str.charAt(i);
            }
            i--;
        }

        return new String(newStr);
    }
}
</code></pre>
<p><a name="10"></a></p>
<h2 id="10-Replace-Words–字典树"><a href="#10-Replace-Words–字典树" class="headerlink" title="10.Replace Words–字典树"></a>10.Replace Words–字典树</h2><p>LeetCode 648. Replace Words 字典树练习</p>
<p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p>
<p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with theroot forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p>
<p>You need to output the sentence after the replacement.</p>
<p>Example 1:</p>
<pre><code>Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]
sentence = &quot;the cattle was rattled by the battery&quot;
Output: &quot;the cat was rat by the bat&quot;
</code></pre><p>题意：用字典中存在的前缀代替句子中的单词，若有多个前缀可以表示单词，则选择最短的一个<br>​<br>暴力思路：1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根(换长度最小的那个); 2.将words数组重新组成sentence返回即可</p>
<pre><code class="java">class Solution {
    public String replaceWords(List&lt;String&gt; dict, String sentence) {
        //1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根
        String[] words = sentence.split(&quot; &quot;);
        for(int i=0; i&lt;words.length; ++i){
            int min = Integer.MAX_VALUE;
            for(String root: dict){
                if(words[i].startsWith(root) &amp;&amp; root.length()&lt;min){
                    words[i] = root;
                }
            }
        }

        //2.将words数组重新组成sentence返回即可
        StringBuilder res = new StringBuilder();
        for(int i=0; i&lt;words.length; ++i){
            res.append(words[i] + &quot; &quot;);
        }
        return res.toString().trim();
    }
}
</code></pre>
<p>优化思路(字典树):这道题给了我们一个前缀字典，又给了一个句子，让我们将句子中较长的单词换成其前缀(如果在前缀字典中存在的话)。我们对于句子中的一个长单词如何找前缀呢，是不是可以根据第一个字母来快速定位呢，比如cattle这个单词的首字母是c，那么我们在前缀字典中找所有开头是c的前缀，为了方便查找，我们<strong>将首字母相同的前缀都放到同一个数组中，总共需要26个数组</strong>，所以我们可以定义一个二维数组来装这些前缀。还有，我们希望短前缀在长前缀的前面，因为题目中要求用最短的前缀来替换单词，所以我们可以<strong>先按单词的长度来给所有的前缀排序</strong>，然后再依次加入对应的数组中，这样就可以保证短的前缀在前面。</p>
<p>提交显示暴力思路50ms，优化思路19ms，优化的还不错。</p>
<pre><code class="java">public static String replaceWords(List&lt;String&gt; dict, String sentence) {
    //1.roots数组按长度排序
    Collections.sort(dict);

    //2.构建字典树，采用HashMap，用首字母索引，首字母相同的前缀都放到同一个数组中，总共需要26个数组
    Map&lt;Integer, ArrayList&lt;String&gt;&gt; wordTree = new HashMap&lt;&gt;();
    for(int i=0; i&lt;dict.size(); ++i){
        int wordIndex =  dict.get(i).charAt(0)-&#39;a&#39;;
        if(!wordTree.containsKey(wordIndex)){
            wordTree.put(wordIndex, new ArrayList&lt;String&gt;());
        }
        wordTree.get(wordIndex).add(dict.get(i));
    }

    //3.将sentencesplit(&quot; &quot;)分成words单词数组，每个单词通过字典树进行前缀判断，有词根的换成词根
    String[] words = sentence.split(&quot; &quot;);
    for(int i=0; i&lt;words.length; ++i){
        int wordIndex = words[i].charAt(0)-&#39;a&#39;;
        if(wordTree.containsKey(wordIndex)){
            for(int j=0; j&lt;wordTree.get(wordIndex).size(); ++j){
                if(words[i].startsWith(wordTree.get(wordIndex).get(j))){
                    words[i] = wordTree.get(wordIndex).get(j);
                }
            }
        }
    }

    //4.将words数组重新组成sentence返回即可
    StringBuilder res = new StringBuilder();
    for(int i=0; i&lt;words.length; ++i){
        res.append(words[i] + &quot; &quot;);
    }
    return res.toString().trim();
}
</code></pre>
<p><a name="11"></a></p>
<h2 id="11-Find-And-Replace-in-String"><a href="#11-Find-And-Replace-in-String" class="headerlink" title="11.Find And Replace in String"></a>11.Find And Replace in String</h2><p>LeetCode 833. Find And Replace in String</p>
<p>题目：To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<p>Example 1:</p>
<pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]
Output: &quot;eeebffff&quot;
Explanation: &quot;a&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;.
&quot;cd&quot; starts at index 2 in S, so it&#39;s replaced by &quot;ffff&quot;.
</code></pre><p>Example 2:</p>
<pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]
Output: &quot;eeecd&quot;
Explanation: &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. 
&quot;ec&quot; doesn&#39;t starts at index 2 in the original S, so we do nothing.
</code></pre><p>题目大意：给了原始的字符串S，给出了要开始替换的位置indexes，判断S在indexes的位置向后是否能匹配sources中对应位置的元素，如果相等，则把S的该部分替换成targets对应的部分。</p>
<p>思路：</p>
<p>不可能直接对S进行替换操作的，因为那样直接改变了S的值和长度，影响以后的匹配操作。</p>
<p>而应该将原字符串S按照indexs拆分成几段子字符串，然后分别进行替换，最终拼接返回即可。同时应该从右往左处理原字符串，替换用replaceFirst()</p>
<p>将indexes按逆序排序，然后对S从右往左依次查找可替换的单词，如果出现在指定位置，则替换。由于indexes排序后，会变化，因此需要用map结构保存原来的索引。</p>
<pre><code class="java">public static String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {
    if(S==null || S.length()==0){
        return S;
    }
    //由于indexes排序后，会变化，因此需要用map结构保存原来的索引。
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:index[i] value:i
    for(int i=0; i&lt;indexes.length; ++i){
        map.put(indexes[i], i);
    }
    //将indexes按排序
    Arrays.sort(indexes);
    //将原字符串S按照indexs拆分成几段子字符串，然后分别进行判断
    String[] words = new String[indexes.length+1];
    //字符串从右往左处理，同时index也从最大到最小
    for(int i=indexes.length-1; i&gt;=0; --i){
        String last;//当前需要处理的子字符串，判断是否需要替换
        if(i==indexes.length-1){
            last = S.substring(indexes[i]);
        }
        else{
            last = S.substring(indexes[i], indexes[i+1]);
        }
        int tempIndex = map.get(indexes[i]); //当前字符串对应的index
        if(last.startsWith(sources[tempIndex])){
            words[i+1] = last.replaceFirst(sources[tempIndex],targets[tempIndex]);
        }
        else{
            words[i+1] = last;
        }
    }
    words[0] = S.substring(0,indexes[0]).replaceFirst(sources[0],targets[0]);//最前面的字符串

    //将替换完的words数组拼接成最终的字符串
    StringBuilder res = new StringBuilder();
    for(int i=0; i&lt;words.length; ++i){
        res.append(words[i]);
    }
    return res.toString();
}
</code></pre>
<p><a name="12"></a></p>
<h2 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12.从尾到头打印链表"></a>12.从尾到头打印链表</h2><p>《剑指offer》p58.</p>
<p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<p>思路：</p>
<p>法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可</p>
<p>法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可</p>
<p>法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可</p>
<p>法四：递归实现，从头遍历链表，但是递归实现</p>
<pre><code class="java">//法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可
public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {
    ListNode p = listNode;
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    while(p!=null){
        res.add(p.val);
        p = p.next;
    }
    Collections.reverse(res);
    return res;
}

//法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可
public ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) {
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(listNode==null){
        return res;
    }
    ListNode p = listNode;
    ListNode cur = p.next;
    p.next = null;
    while(cur!=null){
        ListNode temp = cur;
        cur = cur.next;
        temp.next = p;
        p = temp;
    }
    while(p!=null){
        res.add(p.val);
        p = p.next;
    }
    return res;
}

//法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可
public ArrayList&lt;Integer&gt; printListFromTailToHead3(ListNode listNode) {
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(listNode==null){
        return res;
    }
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    ListNode p = listNode;
    while(p!=null){
        stack.push(p.val);
        p = p.next;
    }
    while(!stack.isEmpty()){
        res.add(stack.pop());
    }
    return res;
}

//法四：递归实现，从头遍历链表，但是递归实现
ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
public ArrayList&lt;Integer&gt; printListFromTailToHead4(ListNode listNode) {
    if(listNode!=null){
        printListFromTailToHead4(listNode.next);
        res.add(listNode.val);
    }
    return res;
}
</code></pre>
<p><a name="13"></a></p>
<h2 id="13-反转链表-三道"><a href="#13-反转链表-三道" class="headerlink" title="13.反转链表(三道)"></a>13.反转链表(三道)</h2><h3 id="1-反转全部链表"><a href="#1-反转全部链表" class="headerlink" title="1.反转全部链表"></a>1.反转全部链表</h3><p>《剑指offer》p142、《左神》p40、leetcode206</p>
<p>题目：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>思路：头插法</p>
<pre><code class="java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode newHead = head;
        head = head.next;
        newHead.next = null; //这步别忘了
        while(head!=null){
            ListNode tempNode = head;
            //原链表继续遍历下一个
            head = head.next;
            //头插法
            tempNode.next = newHead;
            newHead = tempNode;
        }
        return newHead;
    }
}
</code></pre>
<h3 id="2-反转部分链表"><a href="#2-反转部分链表" class="headerlink" title="2.反转部分链表"></a>2.反转部分链表</h3><p>《左神》p42、leetcode92</p>
<p>题目：这道题目规定了要进行反转的位置区间。</p>
<pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL
</code></pre><p>思路：我们要先<strong>添加一个哨兵</strong>，指向head节点（最后返回头指针的next即可）；然后一直往后访问，一直到要反转的节点的前一位停下来。</p>
<p>我们要<strong>记录下两个节点的位置</strong>：开始反转位置的节点的前一位、开始反转位置的节点。因为在反转后，开始反转的节点的前一个节点的next指针要指向反转的最后一个节点，开始反转的节点的next要指向反转的最后一个节点的后一个节点。</p>
<p>然后<strong>进行与上面一题同样的反转即可</strong>。</p>
<pre><code class="java">public ListNode reverseBetween(ListNode head, int m, int n) {
    if(head==null || head.next==null || m&gt;=n || m&lt;=0){
        return head;
    }

    //1.哨兵，这样不用考虑m==1从头反转的问题，都转化成从中间反转
    ListNode guard = new ListNode(0);
    guard.next = head;
    ListNode p = guard;
    //2..将p移到要反转部分的前一个节点，移动次数为m-1次
    for(int i=1; i&lt;=m-1; ++i){
        p = p.next;
        if(p==null){//如果遍历完链表都没有加到m，则不需要反转
            return head;
        }
    }

    if(p.next==null || p.next.next==null){//需要反转的部分为空或者只有一个节点，则不需要反转
        return head;
    }

    //3.保存反转部分的前一个节点
    ListNode pre = p;

    //4.反转部分链表(头插法)
    p = p.next;
    ListNode cur = p.next;
    p.next=null;
    ListNode last = p;//保存反转部分的最后一个节点
    for(int i=m; i&lt;n; ++i){
        ListNode temp = cur;
        cur = cur.next;
        temp.next = p;
        p = temp;
        if(cur==null){
            break;
        }
    }

    //5.拼接反转部分前，反转部分，反转部分后的链表
    last.next = cur;
    pre.next = p;

    return guard.next;
}
</code></pre>
<h3 id="3-分组翻转链表"><a href="#3-分组翻转链表" class="headerlink" title="3.分组翻转链表"></a>3.分组翻转链表</h3><p>leetcode 25 Reverse Nodes in k-Group、《左神》68</p>
<p>题目：将链表的每k个节点逆序。给定一个单链表的头结点head，实现一个调整单链表的函数，使得每k个节点之间逆序，如果最后不管k个节点一组，则不调整最后几个节点。</p>
<p>Example:</p>
<pre><code>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5
For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5
For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5
</code></pre><p>思路：先遍历一次链表记录长度，然后分组进行翻转即可。</p>
<pre><code class="java">public ListNode reverseKGroup(ListNode head, int k) {
    if(head==null || head.next==null || k&lt;2){
        return head;
    }
    //1.遍历一遍链表记录链表长度
    int len = 0;
    ListNode p = head;
    while(p!=null){
        len++;
        p = p.next;
    }

    //2.分组翻转链表
    ListNode guard = new ListNode(0);//哨兵
    guard.next = head;
    ListNode pre = guard;//缓存翻转后的尾节点指针
    ListNode cur = guard.next;//哨兵
    ListNode last = cur;//缓存翻转后的尾节点指针
    while(len&gt;=k){//翻转这么多次
        len -= k;
        int tempK = k;

        while(tempK!=0){//每次翻转k个节点
            ListNode temp = cur;
            cur = cur.next;
            temp.next = pre.next;//头插法
            pre.next = temp;
            tempK--;
        }
        last.next = cur;//翻转后的链表尾部连接到需要反转部分的下一个节点
        pre = last;
        last = cur;
    }
    return guard.next;
}
</code></pre>
<p><a name="14"></a></p>
<h2 id="14-根据前序-中序遍历数组来重建二叉树"><a href="#14-根据前序-中序遍历数组来重建二叉树" class="headerlink" title="14.根据前序+中序遍历数组来重建二叉树"></a>14.根据前序+中序遍历数组来重建二叉树</h2><p>《剑指offer》p62、leetcode105</p>
<p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>思路：在函数recon中，先根据前序遍历数组的第一个数字创建根节点，之后在中序遍历数组中找到根节点的位置，这样就能确定左、右子树节点的数量。在前序遍历和中序遍历数组中划分了左、右子树节点的值之后，就可以递归地调用函数recon去分别构建它的左、右子树。</p>
<pre><code class="java">class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}
public class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder==null || preorder.length==0){
            return null;
        }
        return recon(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);
    }
    //递归重建二叉树
    public TreeNode recon(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd){
        if(preStart&gt;preEnd || inStart&gt;inEnd){
            return null;
        }
        TreeNode root = new TreeNode(preorder[preStart]);//前序遍历第一个节点为根节点
        int rootIndex = findRootIndex(inorder, inStart, inEnd, root.val);//前序遍历的根节点在中序遍历数组的位置索引
        int leftCnt = rootIndex-inStart;//左子树节点的个数
        root.left = recon(preorder, preStart+1, preStart+leftCnt, inorder, inStart, rootIndex-1);
        root.right = recon(preorder, preStart+leftCnt+1, preEnd, inorder, rootIndex+1, inEnd);

        return root;
    }

    //找到根节点在中序遍历中的位置
    public int findRootIndex(int[] order, int start, int end, int root){
        int index = -1;
        for(int i=start; i&lt;=end; ++i){
            if(order[i]==root){
                index = i;
            }
        }
        return index;
    }
}
</code></pre>
<p><a name="15"></a></p>
<h2 id="15-二叉树的下一个节点"><a href="#15-二叉树的下一个节点" class="headerlink" title="15.二叉树的下一个节点"></a>15.二叉树的下一个节点</h2><p>《剑指offer》p65.</p>
<p>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<p>思路：这个节点可以分为三种情况<br>​    </p>
<blockquote>
<p>1.该节点有右子树：下一个节点就是它的右子树中最左子节点</p>
<p>2.该节点没有右子树且是父节点的左子节点：下一个节点就是它的父节点</p>
<p>3.该节点没有右子树且是父节点的右子节点：沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点</p>
</blockquote>
<pre><code class="java">class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode == null){
            return null;
        }
        //如果该节点有右子树，返回其右子树中最左的子节点
        if(pNode.right != null){
            pNode = pNode.right;
            while(pNode.left != null){
                pNode = pNode.left;
            }
            return pNode;
        }
        //如果该节点没有右子树
        while(pNode.next != null){
            //该节点是父节点的左子节点，返回父节点
            if(pNode.next.left== pNode){
                return pNode.next;
            }
            //该节点是父节点的右子节点，沿着指向父节点的指针一直向上遍历，
            // 直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点
            pNode = pNode.next;
        }
        //如果第3中情况下一直向上遍历到根节点，则没有要找的下一个节点，返回null
        return null;
    }
}
</code></pre>
<p><a name="16"></a></p>
<h2 id="16-Populating-Next-Right-Pointers-in-Each-Node"><a href="#16-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="16.Populating Next Right Pointers in Each Node"></a>16.Populating Next Right Pointers in Each Node</h2><p>leetcode 116.</p>
<p>题目：Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>题目大意：将满二叉树每个节点的next指针赋值，每个节点的next指针指向同一层的下一个节点，要求空间复杂度是O(1)。本题的前提是给定的二叉树是满二叉树，即所有的叶子节点都在同一层。举例如下</p>
<p>原始：</p>
<pre><code>     1
   /  \
  2    3
 / \  / \
4  5  6  7
</code></pre><p>变为：</p>
<pre><code>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</code></pre><p>思路：如果有下一层的话，为下一层的子节点的next指针赋值。每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器，并且不用递归，循环层即可完成</p>
<pre><code class="java">public void connect(TreeLinkNode root)
{
    TreeLinkNode pRoot = root;
    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点
    while(pRoot!=null){//层的循环
        guard.next=null;//哨兵，指向下一层的第一个节点
        TreeLinkNode cur = guard;
        if(pRoot.left!=null) {//如果有下层的话
            while(pRoot!=null){//依次为下一层的每个节点next指针
                cur.next = pRoot.left;
                cur.next.next = pRoot.right;
                cur = cur.next.next;
                pRoot = pRoot.next;
            }
        }
        pRoot = guard.next;//进入下一层的第一个节点
    }
}
</code></pre>
<p><a name="17"></a></p>
<h2 id="17-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#17-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="17.Populating Next Right Pointers in Each Node II"></a>17.Populating Next Right Pointers in Each Node II</h2><p>leetcode 117.Populating Next Right Pointers in Each Node</p>
<p>题目：本题要求和上面一样，不同的是这里给定的二叉树不一定是满二叉树。You may only use constant extra space</p>
<p>原始：</p>
<pre><code>     1
   /  \
  2    3
 / \    \
4   5    7
</code></pre><p>变为：</p>
<pre><code>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL
</code></pre><p>思路：因为可能不是满二叉树而是任意二叉树，所以下一层的第一个节点需要手动寻找，我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器</p>
<pre><code class="java">public void connect(TreeLinkNode root)
{
    TreeLinkNode pRoot = root;
    //我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个哨兵，代表第一个节点
    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点
    while(pRoot!=null){
        guard.next=null;//哨兵，指向下一层的第一个节点
        TreeLinkNode cur = guard;

        while(pRoot!=null){//依次为下一层的节点next指针赋值
            if(pRoot.left!=null){
                cur.next = pRoot.left;
                cur = cur.next;
            }
            if(pRoot.right!=null){
                cur.next = pRoot.right;
                cur = cur.next;
            }
            pRoot = pRoot.next;
        }

        pRoot = guard.next;//进入下一层(下一层的root从下一层的第一个节点guard.next开始)
    }
}
</code></pre>
<p><a name="18"></a></p>
<h2 id="18-两个栈实现队列"><a href="#18-两个栈实现队列" class="headerlink" title="18.两个栈实现队列"></a>18.两个栈实现队列</h2><p>《剑指offer》p68、leetcode232、《左神》5</p>
<p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<pre><code class="java">import java.util.Stack;
public class Solution {
    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();
    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();

    //入队
    public void push(int node) {
        stack1.push(node);
    }

    //出队
    public int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
</code></pre>
<p><a name="19"></a></p>
<h2 id="19-两个队列实现栈"><a href="#19-两个队列实现栈" class="headerlink" title="19.两个队列实现栈"></a>19.两个队列实现栈</h2><p>《剑指offer》p71、leetcode225</p>
<p>题目：两个队列实现栈</p>
<pre><code class="java">class MyStack {
    Queue&lt;Integer&gt; que1;
    Queue&lt;Integer&gt; que2;
    /** Initialize your data structure here. */
    public MyStack() {
        que1 = new LinkedList&lt;&gt;();
        que2 = new LinkedList&lt;&gt;();
    }

    /** Push element x onto stack. */
    public void push(int x) {
        if(!que1.isEmpty()){
            que1.offer(x);
        }
        else{
            que2.offer(x);
        }
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        while(!que1.isEmpty()){
            int temp = que1.poll();
            if(que1.isEmpty()){
                return temp;
            }
            else{
                que2.offer(temp);
            }
        }

        while(!que2.isEmpty()){
            int temp = que2.poll();
            if(que2.isEmpty()){
                return temp;
            }
            else{
                que1.offer(temp);
            }
        }

        return -1;
    }

    /** Get the top element. */
    public int top() {
        while(!que1.isEmpty()){
            int temp = que1.poll();
            que2.offer(temp);
            if(que1.isEmpty()){
                return temp;
            }
        }

        while(!que2.isEmpty()){
            int temp = que2.poll();
            que1.offer(temp);
            if(que2.isEmpty()){
                return temp;
            }
        }
        return -1;
    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        return que1.isEmpty() &amp;&amp; que2.isEmpty();
    }
}
</code></pre>
<p><a name="20"></a></p>
<h2 id="20-斐波那契数列-三道"><a href="#20-斐波那契数列-三道" class="headerlink" title="20.斐波那契数列(三道)"></a>20.斐波那契数列(三道)</h2><pre><code>斐波那契数列--《剑指offer》p75 
青蛙跳台阶--《剑指offer》p77、leetcode 70
变态跳台阶--牛客网 
</code></pre><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h3><p>《剑指offer》p75</p>
<p>题目：大家都知道斐波那契数列f(n)=f(n-1)+f(n-2)，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p>
<p>思路：动态规划问题。解法：自上而下递归分析，自下而上循环实现。</p>
<pre><code class="java">public static int Fibonacci(int n) {
    if(n==0){
        return 0;
    }
    if(n==1){
        return 1;
    }
    int n1 = 0;
    int n2 = 1;
    for(int i=2; i&lt;=n; ++i){
        int temp = n1+n2;
        n1 = n2;
        n2 = temp;
    }
    return n2;
}
</code></pre>
<h3 id="2-青蛙跳台阶"><a href="#2-青蛙跳台阶" class="headerlink" title="2.青蛙跳台阶"></a>2.青蛙跳台阶</h3><p>《剑指offer》p77、leetcode 70</p>
<p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p>
<p>思路：就是斐波那切数列</p>
<pre><code class="java">public int JumpFloor(int target) {
    if(target==1){
        return 1;
    }
    if(target==2){
        return 2;
    }
    int n1 = 1;
    int n2 = 2;
    for(int i=3; i&lt;=target; ++i){
        int temp = n1 + n2;
        n1 = n2;
        n2 = temp;
    }
    return n2;
}
</code></pre>
<h3 id="3-变态跳台阶"><a href="#3-变态跳台阶" class="headerlink" title="3.变态跳台阶"></a>3.变态跳台阶</h3><p>牛客网上的</p>
<p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p>思路：动态规划分析：f(n)=f(n-1)+f(n-2)+…f(1)+1，因此需要数组来缓存之前的值，但其实不需要数组，直接用变量来缓存即可，即f(n)=之前的和+1。</p>
<pre><code class="java">public int JumpFloorII(int target) {
    if(target==1){
        return 1;
    }
    if(target==2){
        return 2;
    }
    int sumTemp = 3;//缓存之前的和
    int resTemp = 0;
    for(int i=3; i&lt;=target; ++i){
        resTemp = sumTemp+1;//当前的结果值
        sumTemp += resTemp; //把当前的结果值加到缓存和中
    }
    return resTemp;
}
</code></pre>
<p><a name="21"></a></p>
<h2 id="21-斐波那契数列变种-两道"><a href="#21-斐波那契数列变种-两道" class="headerlink" title="21.斐波那契数列变种(两道)"></a>21.斐波那契数列变种(两道)</h2><pre><code>Length of Longest Fibonacci Subsequence--leetcode 873 
Split Array into Fibonacci Sequence--leetcode842 
</code></pre><h3 id="1-Length-of-Longest-Fibonacci-Subsequence"><a href="#1-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="1.Length of Longest Fibonacci Subsequence"></a>1.Length of Longest Fibonacci Subsequence</h3><p>leetcode 873</p>
<p>题目：给定一个严格递增的正整数数组形成序列 A ，找到A中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p>
<p>子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列</p>
<p>Example 1:</p>
<pre><code>Input: [1,2,3,4,5,6,7,8]
Output: 5
Explanation:
The longest subsequence that is fibonacci-like: [1,2,3,5,8].
</code></pre><p>思路：动态规划问题。二维dp问题。</p>
<p>使用一维DP解决不了这个问题，因为一维DP只保存了到某个为止的最长斐波那契数列，但是新的数字到来之后能不能满足之前的费布拉奇数列是未知的。所以使用二维DP。</p>
<p>dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。</p>
<p>核心方程：dp[j][k]=dp[i][j]+1</p>
<p>条件是 A[i] + A[j] = A[k]</p>
<p>这个算法的时间复杂度是O(n^2)，空间复杂度是O(n^2).</p>
<pre><code class="java">//二维dp问题。dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。
//核心方程：dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]
public static int lenLongestFibSubseq(int[] A) {
    if(A==null || A.length==0){
        return 0;
    }
    int m = A.length;
    int[][] dp = new int[m][m];//dp[i][j]表示以A[i]、A[j]结尾的斐波那契数列长度，初始化为2
    for(int i=0; i&lt;m; i++){
        for(int j=i+1; j&lt;m; ++j){
            dp[i][j] = 2;
        }
    }

    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//map存放A[]数组便于下面查找。key:a[i], value:i
    for(int i=0; i&lt;A.length; ++i){
        map.put(A[i], i);
    }

    //dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]
    int res = 0;
    for(int j=0; j&lt;m; j++){
        for(int k=j+1; k&lt;m; ++k){
            int a_i = A[k]-A[j];
            if(a_i&lt;A[j] &amp;&amp; map.containsKey(a_i)){
                dp[j][k] = Math.max(dp[j][k], dp[map.get(a_i)][j]+1);
                res = Math.max(res, dp[j][k]);
            }
        }
    }

    return res;
}
</code></pre>
<h3 id="2-Split-Array-into-Fibonacci-Sequence"><a href="#2-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="2.Split Array into Fibonacci Sequence"></a>2.Split Array into Fibonacci Sequence</h3><p>leetcode 842、与leetcode 306类似</p>
<p>题目：给出了一个有0-9数字组成的纯数字字符串。判断能否组成斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。最终要返回的是任何一个组合即可。</p>
<p>Example 1:</p>
<pre><code>Input: &quot;123456579&quot;
Output: [123,456,579]
</code></pre><p>思路:回溯法。本题和下面的刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p>
<p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p>
<p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p>
<p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p>
<p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p>
<p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p>
<p>本题需要把斐波那契数列的各个数字存起来，同时还要注意要防止int溢出</p>
<pre><code class="java">public List&lt;Integer&gt; splitIntoFibonacci(String S) {
    int L = S.length();
    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();

    for(int i=1; i&lt;=(L-1)/2; ++i){//第一个数的长度为[1,(L-1)/2]
        String s1 = S.substring(0,i);//第一个数
        if(S.startsWith(&quot;0&quot;) &amp;&amp; s1.length()&gt;1){//第一个数长度超过2起始位不能为0
            break;
        }
        Long num1 = Long.valueOf(s1);
        if(num1&gt;Integer.MAX_VALUE){//防止int溢出
            break;
        }
        for(int j=i+1;j&lt;=L-1&amp;&amp;(L-j)&gt;=(j-i)&amp;&amp;(L-j)&gt;=i; ++j){//第三个数大于等于第一、第二个数
            String s2 = S.substring(i,j);//第二个数
            if(S.charAt(i)==&#39;0&#39; &amp;&amp; s2.length()&gt;1){//第二个数长度超过2起始位不能为0
                break;
            }
            Long num2 = Long.valueOf(s2);
            if(num2&gt;Integer.MAX_VALUE){//防止int溢出
                break;
            }

            if(isValid(S.substring(j), num1, num2, res)){//进行斐波那契判断
                return res;
            }
        }
    }

    res.clear();
    return res;
}

public boolean isValid(String S, long num1, long num2, List&lt;Integer&gt; temp){
    if(S.equals(&quot;&quot;)){//递归结束
        temp.add((int) num1);
        temp.add((int) num2);
        return true;
    }
    long sum = num1 + num2;
    if(sum&gt;Integer.MAX_VALUE){//防止int溢出
        return false;
    }
    String sumStr = &quot;&quot; + sum;
    if(sumStr.length()&gt;1 &amp;&amp; S.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0
        return false;//剪枝，回溯点
    }
    if(S.startsWith(sumStr)){
        temp.add((int) num1);
        return isValid(S.substring(sumStr.length()), num2, sum, temp);//递归判断
    }else{
        temp.clear();
        return false;
    }
}
</code></pre>
<p><a name="22"></a></p>
<h2 id="22-Additive-Number"><a href="#22-Additive-Number" class="headerlink" title="22.Additive Number"></a>22.Additive Number</h2><p>leetcode 306</p>
<p>题目：给出了一个有0-9数字组成的纯数字字符串。判断它能不能组成所谓的“加法数字”，即斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。</p>
<p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p>
<pre><code>Input: &quot;112358&quot;
Output: true 
Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8

Input: &quot;199100199&quot;
Output: true 
Explanation: The additive sequence is: 1, 99, 100, 199.
1 + 99 = 100, 99 + 100 = 199
</code></pre><p>思路:回溯法。刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p>
<p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p>
<p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p>
<p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p>
<p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p>
<p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p>
<pre><code class="java">//回溯法问题。关键在于确定前两个数即可。
//三个数的长度: 第一个数,[0,i)，长度为i；第二个数,[i,j)长度为j-i; 第三个数(和):[j,L-1],长度L-j
//三个数的长度最长的范围：第一个数长度上限:x=(L-1)/2; 第二个数长度下限：y=x，第三个数长度下限: y
public static boolean isAdditiveNumber(String num) {
    int L = num.length();
    for(int i=1; i&lt;=(L-1)/2; ++i){//i从1起，第一个数长度至少为1

        if(num.startsWith(&quot;0&quot;) &amp;&amp; i&gt;1){
            break;//第一个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环
        }

        for(int j=i+1; j&lt;=L-1 &amp;&amp; (L-j)&gt;=i &amp;&amp; (L-j)&gt;=(j-i); ++j){//第三个数长度不小于第一个数，第三个数长度不小于第二个数
            if(num.charAt(i)==&#39;0&#39; &amp;&amp; j-i&gt;1){
                break;//第二个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环
            }

            long num1 = Long.valueOf(num.substring(0, i));//第一个数
            long num2 = Long.valueOf(num.substring(i, j));//第二个数

            if(isAdditive(num.substring(j), num1, num2)){
                return true;//找到满足斐波那契条件的一个划分序列
            }
        }
    }

    return false;
}

public static boolean isAdditive(String num, long num1, long num2){
    if(num.equals(&quot;&quot;)){
        return true; //递归结束，回溯点
    }
    long sum = num1+num2;
    String sumStr = &quot;&quot; + sum;
    int sumLen = sumStr.length();
    if(sumLen&gt;1 &amp;&amp; num.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0
        return false;//剪枝，回溯点
    }
    if(num.startsWith(sumStr)){//如果和在字符串中，则进行下一次递归
        return isAdditive(num.substring(sumLen), num2, sum);
    }
    return false;
}

public static void main(String[] args){
    String num = &quot;123&quot;;
    System.out.println(isAdditiveNumber(num));
}
</code></pre>
<p><a name="23"></a></p>
<h2 id="23-旋转数组的最小数字-三道"><a href="#23-旋转数组的最小数字-三道" class="headerlink" title="23.旋转数组的最小数字(三道)"></a>23.旋转数组的最小数字(三道)</h2><pre><code>《剑指offer》p82
Find Minimum in Rotated Sorted Array--leetcode153
Find Minimum in Rotated Sorted Array 2--leetcode154
</code></pre><h3 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="1.旋转数组的最小数字"></a>1.旋转数组的最小数字</h3><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>普通二分查找思路：顺序解法o(n)，从头到尾遍历数组一次，我们就能找出最小的数字。但本题部分排序，排序的题优先考虑二分查找，因此采用二分查找的双指针的思路，o(logn)。</p>
<p><strong>两个指针代表两大阵营</strong>(原数组/旋转的那部分数组)，最终会相邻，第二个指针指向的刚好是最小的元素</p>
<pre><code class="java">//这里是部分排序的数组，考虑二分查找
public static int minNumberInRotateArray(int [] array) {
    if(array==null){
        return 0;
    }
    int len = array.length;
    if(len==0){
        return 0;
    }
    if(len==1){
        return array[0];
    }
    int left = 0;
    int right = len-1;
    while(left&lt;right){//二分查找
        //结束条件：两个指针最终会相邻，代表两大阵营(原数组/旋转的那部分数组)，第二个指针指向的刚好是最小的元素
        if(left+1==right){//结束条件
            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况
                return nums[right];
            }else{
                return nums[0];
            }
        }
        int mid = (left+right)/2;
        //特殊情况，当left、right、mid对应的三个数相等时，无法判断最小的数位于哪一边，因此要顺序查找
        if(array[mid]==array[left]&amp;&amp;array[mid]==array[right]){
            return search(array,left, right);
        }
        if(array[mid]&gt;=array[left]){//最小值在右半边
            left = mid;
        }
        else if(array[mid]&lt;=array[right]){//最小值在左半边
            right = mid;
        }
    }
    return array[left];
}

public static int search(int[] array, int left, int right){
    for(int i=left+1; i&lt;=right; ++i){
        if(array[i]&lt;array[i-1]){//顺序查找，注意这里也不是完全遍历，而是第一个比之前小的数就是所求
            return array[i];
        }
    }
    return array[left];
}
</code></pre>
<p>牛客网答案区很干练的二分查找思路：(仅供参考一般想不到，还是用上面自己想的即可)</p>
<pre><code>采用二分法解答这个问题，
mid = low + (high - low)/2
需要考虑三种情况：
(1)array[mid] &gt; array[high]:
出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。
low = mid + 1
(2)array[mid] == array[high]:
出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边
还是右边,这时只好一个一个试 ，
high = high - 1
(3)array[mid] &lt; array[high]:
出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左
边。因为右边必然都是递增的。
high = mid
注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字
比如 array = [4,6]
array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;
如果high = mid - 1，就会产生错误， 因此high = mid
但情形(1)中low = mid + 1就不会错误
</code></pre><p>代码：</p>
<pre><code class="java">public class Solution {
    public int minNumberInRotateArray(int [] array) {
        int low = 0 ; int high = array.length - 1;   
        while(low &lt; high){
            int mid = low + (high - low) / 2;        
            if(array[mid] &gt; array[high]){
                low = mid + 1;
            }else if(array[mid] == array[high]){
                high = high - 1;
            }else{
                high = mid;
            }   
        }
        return array[low];
    }
}
</code></pre>
<h3 id="2-Find-Minimum-in-Rotated-Sorted-Array-2"><a href="#2-Find-Minimum-in-Rotated-Sorted-Array-2" class="headerlink" title="2.Find Minimum in Rotated Sorted Array 2"></a>2.Find Minimum in Rotated Sorted Array 2</h3><p>leetcode154</p>
<p>题目：和153一样，这里新增数组可以有重复数字，如[1,3,3,3]</p>
<p>思路：思路还是一样，就是需要考虑重复的问题，改动如下：</p>
<pre><code class="java">public static int findMin(int[] nums) {
    int len = nums.length;
    if(len==1){
        return nums[0];
    }
    //left、right代表原数组、旋转数组两大阵营，结束条件是相邻
    int left = 0;
    int right = nums.length-1;
    while(left&lt;right){
        int mid = (left+right)/2;
        if(left+1==right){//结束条件
            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况
                return nums[right];
            }else{
                return nums[0];
            }
        }
        if(nums[mid]==nums[left]&amp;&amp; nums[mid]==nums[right]){
            return search(nums);
        }
        else if(nums[mid]&gt;=nums[left]){//在右半边
            left = mid;
        }
        else if(nums[mid]&lt;=nums[right]){//在左半边
            right = mid;
        }
    }
    return nums[left];
}

public static int search(int[] array){
    int min = array[0];
    for(int i=1; i&lt;array.length; ++i){
        min = Math.min(min, array[i]);//顺序查找，注意这里必须完全全部遍历
    }
    return min;
}
</code></pre>
<p><a name="24"></a></p>
<h2 id="24-矩阵中的路径"><a href="#24-矩阵中的路径" class="headerlink" title="24.矩阵中的路径"></a>24.矩阵中的路径</h2><p>《剑指offer》p89、leetcode 79</p>
<p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<pre><code>a b c e
s f c s
a d e e
</code></pre><p>思路：二维矩阵中路径查找问题通常用回溯法。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法可以看成蛮力法的升级版。</p>
<pre><code class="java">public static boolean hasPath(char[] matrix, int rows, int cols, char[] str)
{
    if(str==null){
        return true;
    }
    if(matrix==null || matrix.length&lt;str.length){
        return false;
    }
    //路径查找中，不能重复进入相同的格子，因此需要设置标记矩阵，初始为false
    boolean[] visited = new boolean[rows*cols];

    for(int i=0; i&lt;rows; ++i){
        for(int j=0; j&lt;cols; ++j){
            int index = i*cols+j;
            if(matrix[index]==str[0]){//如果第一个字符匹配，则开始回溯法匹配路径
                if(isPath(matrix,rows,cols,i,j,str,0, visited)){//匹配成功
                    return true;
                }
            }
        }
    }
    return false;
}

public static boolean isPath(char[] matrix, int rows, int cols, int i, int j, char[] str, int strIndex, boolean[] visited){
    if(strIndex==str.length){
        return true;//查找完成，找到路径的结束条件
    }
    int index = i*cols+j;
    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[index]==true){
        return false;//查找到边界外或已经访问过，false
    }
    if(matrix[index]==str[strIndex]){//如果当前字符匹配，则开始回溯法匹配路径
        visited[index] = true;
        //上下左右回溯法查找
        if(isPath(matrix,rows,cols,i-1,j,str,strIndex+1, visited)
                ||isPath(matrix,rows,cols,i+1,j,str,strIndex+1,visited)
                ||isPath(matrix,rows,cols,i,j-1,str,strIndex+1,visited)
                ||isPath(matrix,rows,cols,i,j+1,str,strIndex+1,visited)){
            return true;
        }
    }
    visited[index] = false;//回溯
    return false;
}
</code></pre>
<p>leetcode79的代码：</p>
<pre><code class="java">public static boolean exist(char[][] board, String word) {
    if(board==null || board.length==0 || word==null || word.length()==0){
        return false;
    }

    int m = board.length;
    int n = board[0].length;
    if((m*n)&lt;word.length()){
        return false;
    }
    boolean[][] visited = new boolean[m][n];//避免重复访问的标记数组，初始为false

    for(int i=0; i&lt;m; ++i){
        for(int j=0; j&lt;n; ++j){
            if(board[i][j]==word.charAt(0)){
                if(isPath(board, m, n, i, j, word, 0, visited))
                    return true;
            }
        }
    }

    return false;
}

public static boolean isPath(char[][] board, int m, int n, int i, int j, String word, int strIndex, boolean[][] visited){
    if(strIndex==word.length()){
        return true;//查找完成，结束条件
    }
    if(i&lt;0 || j&lt;0 || i&gt;=m || j&gt;=n || visited[i][j]==true || board[i][j]!=word.charAt(strIndex)){
        return false;//剪枝，错误条件:访问越界或已经访问过或当前字符不匹配
    }
    visited[i][j] = true;
    if(isPath(board, m, n, i-1, j, word, strIndex+1, visited)||
            isPath(board, m, n, i+1, j, word, strIndex+1, visited)||
            isPath(board, m, n, i, j-1, word, strIndex+1, visited)||
            isPath(board, m, n, i, j+1, word, strIndex+1, visited)){
        return true;
    }

    visited[i][j] = false;//回溯
    return false;
}
</code></pre>
<p><a name="25"></a></p>
<h2 id="25-机器人的运动范围"><a href="#25-机器人的运动范围" class="headerlink" title="25.机器人的运动范围"></a>25.机器人的运动范围</h2><p>《剑指offer》p92.</p>
<p>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<p>思路：通常物体或人在二维矩阵运动这类问题够可以用回溯法解决。</p>
<pre><code class="java">public int movingCount(int threshold, int rows, int cols)
{
    int[] res = new int[]{0};//最多可到达的格子数，存成数组便于参数传递修改
    boolean[][] visited = new boolean[rows][cols];//记录访问过的标记位数组，初始化为false
    return isPath(rows, cols, 0, 0, visited, res, threshold);
}

//回溯法矩阵路径查找，返回能到达格子的个数
public static int isPath(int rows, int cols, int i, int j, boolean[][] visited, int[] res, int k){
    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[i][j]==true || (digitSum(i)+digitSum(j))&gt;k){
        return res[0];//剪枝的结束条件:访问越界或已经访问过或行列数位和大于k
    }
    visited[i][j] = true;
    res[0]++;
    int resTemp;
    resTemp = Math.max(isPath(rows,cols,i-1,j,visited,res,k), res[0]);
    resTemp = Math.max(isPath(rows,cols,i+1,j,visited,res,k), resTemp);
    resTemp = Math.max(isPath(rows,cols,i,j-1,visited,res,k), resTemp);
    resTemp = Math.max(isPath(rows,cols,i,j+1,visited,res,k), resTemp);
    return resTemp;
}

//一个数字的数位和
public static int digitSum(int num){
    int sum = 0;
    while(num!=0){
        sum += (num%10);
        num/=10;
    }
    return sum;
}
</code></pre>
<p><a name="26"></a></p>
<h2 id="26-Unique-Paths-两道"><a href="#26-Unique-Paths-两道" class="headerlink" title="26.Unique Paths(两道)"></a>26.Unique Paths(两道)</h2><h3 id="1-Unique-Paths"><a href="#1-Unique-Paths" class="headerlink" title="1.Unique Paths"></a>1.Unique Paths</h3><p>leetcode 62 Unique Paths</p>
<p>题目：给定m*n的矩阵，机器人从左上走到右下，每次只能向右或向下，How many possible unique paths are there?</p>
<p>思路：dp问题，dp[i][j]表示走至当前格子时的unique paths数。</p>
<p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p>
<p>dp问题，自上而下分析上述方程，自下而上循环解决</p>
<pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1
public static int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];//dp[i][j]表示走至当前格子时的unique paths数

    dp[0][0] = 1;
    for(int i=0; i&lt;m; ++i){
        for(int j=0; j&lt;n; ++j){
            if(i==0){//第一行的dp[0][j]=1
                dp[i][j] = 1;
            }
            else{
                if(j==0){//每行的第一个dp[i][0]=dp[i-1][0]
                    dp[i][j] = dp[i-1][j];
                }
                else{//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
    }

    return dp[m-1][n-1];
}
</code></pre>
<p><strong>优化:</strong>上述方法时间o(m<em>n)、空间o(m</em>n)，其实只用o(n)的空间即可，对每行来说只缓存上一行的dp即可</p>
<pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1
public static int uniquePaths(int m, int n) {
    if(m==1 || n==1){
        return 1;
    }
    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数，初始第一行的dp[j]=1
    dp[0] = 1;

    for(int i=0; i&lt;m; ++i){
        for(int j=1; j&lt;n; ++j){//直接从第1列开始就行了，第0列不用考虑
            if(i==0){//初始第一行的dp[j]=1
                dp[j] = 1;
            }
            else{
                dp[j] = dp[j-1] + dp[j];//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[n-1];
}
</code></pre>
<h3 id="2-Unique-Paths-2"><a href="#2-Unique-Paths-2" class="headerlink" title="2.Unique Paths 2"></a>2.Unique Paths 2</h3><p>leetcode 63 Unique Paths 2</p>
<p>题目：和Unique Paths一样，左上到右下，每次只能向右或者向下，但是新增了障碍物条件，Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>example:</p>
<pre><code>Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
</code></pre><p>思路：还是一样的。dp问题，用了优化后思路，dp[j]缓存上一行的unique paths数</p>
<p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p>
<p>dp问题，自上而下分析上述方程，自下而上循环解决</p>
<pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1
public static int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    if(obstacleGrid[0][0]==1){//如果起始点是障碍物
        return 0;
    }
    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数
    dp[0] = 1;

    for(int i=0; i&lt;m; ++i){
        for(int j=0; j&lt;n; ++j){
            if(i==0){//初始第一行的dp[j]=1
                if(obstacleGrid[i][j]!=1){
                    if(j&gt;0){
                        dp[j] = dp[j-1];
                    }
                }
                else{
                    dp[j] = 0;//有障碍物，此路不通
                }
            }
            else{//其他行
                if(obstacleGrid[i][j]!=1){
                    if(j&gt;0){
                        dp[j] = dp[j-1] + dp[j];
                    }
                }
                else{
                    dp[j] = 0;//有障碍物，此路不通
                }
            }
        }
    }

    return dp[n-1];
}
</code></pre>
<p><a name="27"></a></p>
<h2 id="27-剪绳子"><a href="#27-剪绳子" class="headerlink" title="27.剪绳子"></a>27.剪绳子</h2><p>《剑指offer》p96.</p>
<p>题目：给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]* k[1] * … *k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>思路：</p>
<blockquote>
<p>问题是求最优解；</p>
<p>整体的问题的最优解是依赖各个子问题的最优解；</p>
<p>子问题之间还有互相重叠的更小的子问题；</p>
<p>为避免子问题的重复计算，我们存储子问题的最优解。从上往下分析问题，从下往上求解问题。</p>
</blockquote>
<p>上面的几个条件可以看出，属于动态规划问题。</p>
<p>dp方程：<code>f(n) = max(f(i)*f(n-i))</code></p>
<pre><code class="java">public static int maxProduct(int n){
    if(n==2){
        return 1;
    }
    if(n==3){
        return 2;
    }
    int[] res = new int[n+1];
    res[1] = 1;
    res[2] = 2;
    res[3] = 3;
    for(int i=4; i&lt;=n; ++i){
        for(int j=1; j&lt;=(i/2); ++j){
            res[i] = Math.max(res[j]*res[i-j], res[i]);//f(n)=max(f(i)*f(n-i))
        }
    }

    return res[n];
}
</code></pre>
<p><a name="28"></a></p>
<h2 id="28-不用加减乘除做加法"><a href="#28-不用加减乘除做加法" class="headerlink" title="28.不用加减乘除做加法"></a>28.不用加减乘除做加法</h2><p>牛客网、leetcode 371</p>
<p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<p>思路：首先看十进制是如何做的： 5+7=12，三步走 </p>
<blockquote>
<p>第一步：相加各位的值，不算进位，得到2。 </p>
</blockquote>
<blockquote>
<p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p>
</blockquote>
<blockquote>
<p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p>
</blockquote>
<p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p>
<blockquote>
<p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p>
</blockquote>
<blockquote>
<p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p>
</blockquote>
<blockquote>
<p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 </p>
</blockquote>
<p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p>
<pre><code class="java">public int Add(int num1,int num2) {
    int temp;
    while(num2!=0){
        temp = num1^num2;//加
        num2 = (num1&amp;num2)&lt;&lt;1;//进位
        num1 = temp;
    }
    return num1;
}
</code></pre>
<p><a name="29"></a></p>
<h2 id="29-Two-Sum"><a href="#29-Two-Sum" class="headerlink" title="29.Two Sum"></a>29.Two Sum</h2><p>leetcode 1</p>
<p>题目：给定数组(非有序)和target，找到nums[i]+nums[j]==target的i、j，假定给定条件一定会有一个解</p>
<p>Example:</p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre><p>思路1：暴力解法，时间o(n2)，空间o(1)–38ms</p>
<pre><code class="java">public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    for(int i=0; i&lt;nums.length-1; ++i){
        for(int j=i+1; j&lt;nums.length; ++j){
            if( (nums[i] + nums[j]) == target ){
                res[0] = i;
                res[1] = j;
            }
        }
    }
    return res;
}
</code></pre>
<p>思路2：只遍历一次数组，辅助map，temp=target-nums[i],看map中是否有temp，有则返回两者索引即可，没有将当前nums[i]存入map，继续遍历。时间o(n)，空间o(n)–5ms</p>
<pre><code class="java">public static int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:nums[i]; value:i
    for(int i=0; i&lt;nums.length; ++i){
        int temp = target-nums[i];
        if(!map.containsKey(temp)){
            map.put(nums[i], i);
        }
        else{
            return new int[]{map.get(temp), i};
        }
    }
    return new int[]{0,0};
}
</code></pre>
<p><a name="30"></a></p>
<h2 id="30-二进制中1的个数"><a href="#30-二进制中1的个数" class="headerlink" title="30.二进制中1的个数"></a>30.二进制中1的个数</h2><p>《剑指offer》p100、leetcode191 Number of 1 Bits</p>
<p>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>本题超级技巧：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong></p>
<p>思路：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>，通过这个小技巧，我们只要循环判断n=n&amp;(n-1)是否为0，即可统计1的个数。整数中有多少个1，则循环多少次。</p>
<p>有了这个思路，可以轻松解以下相关题目。位运算相关题目</p>
<p>用一条语句判断一个整数是不是2的整数次方。</p>
<p><code>if(n&amp;(n-1)==0) return true;</code></p>
<p>输入两个整数m,n,计算需要改变m的二进制表示中的多少位才能得到n？<br>​<br>​<code>int x=m^n; return NumberOf1(x);</code></p>
<p>解法一：从尾部到最高位(0到32位)，依次找1。不好</p>
<pre><code class="java">public static int NumberOf2(int n) {//从尾部到最高位(0到32位)，依次找1
    int res = 0;
    int temp = 1;
    int cnt = Integer.toBinaryString(n).length();//返回二进制的位数，这样不用暴力的写32位了
    while(cnt!=0){
        if((n&amp;temp)==temp){
            res++;
        }
        temp=temp&lt;&lt;1;
        cnt--;
    }
    return res;
}
</code></pre>
<p>解法二：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>。每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)</p>
<pre><code class="java">public static int NumberOf1(int n) {
    int res = 0;
    while(n!=0){
        n=(n-1)&amp;n; //每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)
        res++;
    }
    return res;
}
</code></pre>
<p><a name="31"></a></p>
<h2 id="31-数值的整数次方"><a href="#31-数值的整数次方" class="headerlink" title="31.数值的整数次方"></a>31.数值的整数次方</h2><p>《剑指offer》p110、leetcode 50</p>
<p>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>思路：记得考虑base==0与exponent&lt;0的情况。解法三更为优化，递归实现将exponent二分下去减少乘法运算次数。判断一个整数为奇数偶数，这里把%运算换成位运算，效率更高（二进制最低位如果为1则为奇数，为0则为偶数）。</p>
<p><strong>超级知识点</strong>：注意MIN_VALUE取反的情况。在JDK中，整型类型是有范围的 -2147483648～2147483647（-2^31-2^31-1），最大值为Integer.MAX_VALUE，即2147483647，最小值为Integer.MIN_VALUE -2147483648。</p>
<p>Integer.MIN_VALUE取反或者取绝对值呢仍为Integer.MIN_VALUE，因为绝对值2147483648超过Integer.MAX_VALUE 2147483647。</p>
<p><strong>因此有如下重要结论：</strong><br>​<br>​    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE<br>​    Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</p>
<p>解法一：无耻解法2333</p>
<pre><code class="java">public static double Power(double base, int exponent) {
    return Math.pow(base, exponent);
}
</code></pre>
<p>解法二：逐个base相乘即可</p>
<pre><code class="java">public static double Power(double base, int exponent) {
    double res = 1;
    boolean positive = true;

    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE
    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
    if(exponent==Integer.MIN_VALUE){
        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不ååå行，必须为偶数参与二分)
    }

    if(exponent&lt;0){
        positive = false;
    }
    exponent = Math.abs(exponent);
    while(exponent!=0){
        exponent--;
        res*=base;
    }
    return positive?res:(1/res);
}
</code></pre>
<p>解法三，效率更高：</p>
<pre><code class="java">//a^n = a^(n/2)*a^(n/2)
public static double Power(double base, int exponent) {
    double res = 1;
    boolean positive = true;//exponent正负的标记位

    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE
    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
    if(exponent==Integer.MIN_VALUE){
        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不行，必须为偶数参与二分)
    }
    if(exponent&lt;0){
        positive = false;
        exponent = -exponent;
    }

    while(exponent!=0){
        if((exponent&amp;1)==1){//exponent是奇数
            res*=base;
            exponent--;
        }else{//exponent是偶数，二分，减少乘法次数，效率更高
            base*=base;
            exponent/=2;
        }
    }
    return positive?res:(1/res);
}

public static void main(String[] args){
    System.out.println(Power(2, -2147483648));
}
</code></pre>
<p><a name="32"></a></p>
<h2 id="32-打印从1到最大的n位数"><a href="#32-打印从1到最大的n位数" class="headerlink" title="32.打印从1到最大的n位数"></a>32.打印从1到最大的n位数</h2><p>《剑指offer》p114</p>
<p>题目：打印从1到最大的n位数（本题是大数问题，当n位数很多时，只能用其他的数据结构来存储我们的非常大的数字）</p>
<p>思路：使用数组，采用数字全排列的方法。如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。当然打印的时候，我们应该不输出左边的0</p>
<p>解法一：递归实现全排列，顺序打印（代码比较简单，但可能会栈溢出）</p>
<pre><code class="java">public class Hello{
    public static void main(String[] args){
        printOneToNBit(3);
    }
    //打印从1到最大的n位数，就是一个n个数的全排列，用递归实现
    static void printOneToNBit(int n){
        int[] number = new int[n]; //n位的数组存放数字的全排列
        for(int i=0; i&lt;10; ++i){
            number[0] = i;
            OneToNBit(number, n, 0);
        }
    }
    //递归实现数字全排列
    static void OneToNBit(int[] number, int n, int index){
        //递归结束条件，已经完成一个数字全排列，打印出来
        if(index == n-1){
            printNumber(number);
            return;
        }
        index++;
        for(int i=0; i&lt;10; ++i){
            number[index] = i;
            OneToNBit(number, n, index);
        }
    }
    //打印一个数组排列，左边的0都不输出
    static void printNumber(int[] number){
        boolean notFirst = false;
        for(int i=0; i&lt;number.length; ++i){
            if(number[i]!=0){
                notFirst = true;
            }
            if(notFirst){
                System.out.print(number[i]);
            }
        }
        System.out.println();
    }

}
</code></pre>
<p>解法二：字符串存数字，采用循环，不断加1。这个思路在两个数相加（大数问题）等题目中可以用到。</p>
<pre><code class="java">//打印从1到最大的n位数
public static void printOneToNBit(int n){
    //大数问题，用字符串来存数字
    StringBuilder num = new StringBuilder();
    for(int i=0; i&lt;n; ++i){
        num.append(&quot;0&quot;);
    }

    while(!addOne(num)){
        printNum(num);//字符串每次加1，然后打印,直到n位的最大数
    }
}

//字符串每次加1，然后打印,直到n位的最大数
public static boolean addOne(StringBuilder num){
    int cnt = 0;//前一位的进位
    for(int i=num.length()-1; i&gt;=0; --i){
        int temp = num.charAt(i)-&#39;0&#39;+cnt;//第i位上的数字

        if(i==num.length()-1){//个位加1
            temp++;
        }
        if(temp==10){//如果有进位，操作如下
            if(i==0){//如果当前是最高位且有进位，说明已经到达是最大数，return true
                return true;
            }
            num.setCharAt(i, &#39;0&#39;);//进位后当前位为0
            cnt = 1;//进位1
        }
        else{//如果没进位
            num.setCharAt(i, (char)(&#39;0&#39;+temp));
            break;//没有进位了，跳出循环即可
        }
    }

    return false;
}

//打印数字，左边的0不打印
public static void printNum(StringBuilder num){
    boolean leftCnt = true;
    for(int i=0; i&lt;num.length(); ++i){
        char temp = num.charAt(i);
        if(temp!=&#39;0&#39;) {
            leftCnt = false;
        }
        if(!leftCnt){
            System.out.print(temp);
        }
    }
    System.out.println();
}

public static void main(String[] args){
    printOneToNBit(3);
}
</code></pre>
<p><a name="33"></a></p>
<h2 id="33-删除链表中重复的节点-两道"><a href="#33-删除链表中重复的节点-两道" class="headerlink" title="33.删除链表中重复的节点(两道)"></a>33.删除链表中重复的节点(两道)</h2><pre><code>1.Remove Duplicates from Sorted List((保留一个重复节点)---leetcode83
2.Remove Duplicates from Sorted List 2(不保留重复节点)---《剑指offer》p122、leetcode82
</code></pre><h3 id="1-Remove-Duplicates-from-Sorted-List"><a href="#1-Remove-Duplicates-from-Sorted-List" class="headerlink" title="1.Remove Duplicates from Sorted List"></a>1.Remove Duplicates from Sorted List</h3><p>leetcode 83</p>
<p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点保留一个，返回链表头指针。</p>
<p>Example:</p>
<pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3
Output: 1-&gt;2-&gt;3
</code></pre><p>代码：</p>
<pre><code class="java">public ListNode deleteDuplicates(ListNode head) {
    if(head==null || head.next==null){
        return head;
    }

    ListNode cur = head;

    while(cur.next!=null){
        if(cur.next.val==cur.val){
            cur.next = cur.next.next;
        }else{
            cur = cur.next;
        }
    }

    return head;
}
</code></pre>
<h3 id="2-Remove-Duplicates-from-Sorted-List-II"><a href="#2-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="2.Remove Duplicates from Sorted List II"></a>2.Remove Duplicates from Sorted List II</h3><p>《剑指offer》p122、leetcode82</p>
<p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>思路：</p>
<blockquote>
<p>1.需要两个指针，一个指向前一个节点pre，另一个指向当前节点p。如果遇到相等的节点，p向后移动，pre不动，存下此时相等数值tempVal方便后面的比较，直到遇到p和p.next不相等，pre就可以指向当前的p。</p>
<p>2.注意：链表开头可能就开始有重复的节点，所以设置一个哨兵guard(0)，</p>
</blockquote>
<pre><code class="java">public static  ListNode deleteDuplication(ListNode pHead)
{
    //链表为空或只有一个节点，返回pHead
    if(pHead==null || pHead.next==null){
        return pHead;
    }

    //设置哨兵
    ListNode guard = new ListNode(0);
    guard.next = pHead;

    ListNode pre = guard;//重复节点的前一个节点
    ListNode cur = guard.next; //用于遍历的节点

    //遍历链表
    while(cur!=null){
        if(cur.next!=null &amp;&amp; cur.next.val==cur.val){//后一节点==当前节点
            int temp = cur.val;//存储重复的值，用于后边比较
            while(cur!=null &amp;&amp; cur.val==temp){//如果重复
                cur = cur.next;
            }
            pre.next = cur;
        }
        else{//后一节点!=当前节点
            pre = pre.next;
            cur = cur.next;
        }
    }

    return guard.next;
}
</code></pre>
<p><a name="34"></a></p>
<h2 id="34-正则表达式匹配"><a href="#34-正则表达式匹配" class="headerlink" title="34.正则表达式匹配"></a>34.正则表达式匹配</h2><p>《剑指offer》p124、leetcode 10</p>
<p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。*表示前面字符0~无穷个，.表示任意一个字符。要求全部，匹配，不是部分匹配。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p>
<p>思路：二维DP问题。这道题的核心是分析’<em>‘，DP[i][j]代表计算str[:i]与patten[:j]匹不匹配.最终要得到的结果就是dp[s.length()][p.length()]，转移方程如下(时间复杂度O(m\</em>n)，空间复杂度O(n)):</p>
<pre><code>dp[i][j] = dp[i - 1][j - 1], 如果s[i] == p[j] || p[j] == &#39;.&#39;

=dp[i][j - 2], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] != p[j - 1](只能匹配0次)

=dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] == p[j - 1](匹配0\1\多次)

返回：
dp[s.length()][p.length()]
</code></pre><p>代码：</p>
<pre><code class="java">//正则匹配. *。思路：二维DP。
public boolean isMatch(String s, String p) {
    if(s == null || p == null) return false;
    boolean[][] dp = new boolean[s.length()+1][p.length()+1];
    dp[0][0] = true;
    for(int i = 0; i &lt; p.length(); i++){
        if (p.charAt(i) == &#39;*&#39; &amp;&amp; dp[0][i-1]) {
            dp[0][i+1] = true;
        }
    }
    for(int i = 0; i &lt; s.length(); i++){
        for(int j = 0; j &lt; p.length(); j++){
            if(s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;){
                dp[i+1][j+1] = dp[i][j];
            }
            if(p.charAt(j) == &#39;*&#39;){
                if(s.charAt(i) != p.charAt(j-1) &amp;&amp; p.charAt(j-1) != &#39;.&#39;){
                    dp[i+1][j+1] = dp[i+1][j-1];
                }else{
                    dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];
                }
            }
        }
    }
    return dp[s.length()][p.length()];
}

public static void main(String[] args){
    char[] str = new char[]{&#39;a&#39;,&#39;a&#39;,&#39;a&#39;};
    char[] pattern = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;*&#39;, &#39;a&#39;, &#39;c&#39;, &#39;*&#39;, &#39;a&#39;};
    char[] str2 = new char[]{&#39;a&#39;,&#39;b&#39;};
    char[] pattern2 = new char[]{&#39;.&#39;,&#39;*&#39;,&#39;c&#39;};
    String s = &quot;ab&quot;;
    String p = &quot;.*c&quot;;//这对测试用例解决了一个大bug，很好

    System.out.println(isMatch(s,p));
}
</code></pre>
<p><a name="35"></a></p>
<h2 id="35-表示数值的字符串"><a href="#35-表示数值的字符串" class="headerlink" title="35.表示数值的字符串"></a>35.表示数值的字符串</h2><p>《剑指offer》p127、leetcode 65</p>
<p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<p>思路：+A.Be+C，对字符串分别判断A、B、C部分是否存在且是否正确，都正确则返回true。注意边界条件：</p>
<p>1.整数部分判断，整数部分可以没有，但没有则必须：</p>
<pre><code>有小数部分，小数点+小数部分--&gt;  -.123正确, -.错误 
没有小数点，也没有小数部分--&gt;  -正确
</code></pre><p>2.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)</p>
<p>3.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)</p>
<pre><code class="java">public class Solution{
    //+A.Be+C
    public static boolean isNumeric(char[] str) {
        if(str==null || str.length==0){
            return false;
        }

        //遍历字符串
        int index = 0;

        //1.正负号判断
        if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){
            index++;
        }

        //2.整数部分判断(整数部分可以没有 但没有则必须要有小数部分，-.123正确, -.错误)
        boolean num = false;//是否有整数部分
        int indexTemp = readNum(str, index);
        if(indexTemp&gt;index){//有整数部分
            num = true;
        }
        index = indexTemp;

        //3.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)
        if(index&lt;str.length &amp;&amp; str[index]==&#39;.&#39;){
            index++;
            indexTemp = readNum(str, index);
            if(!num &amp;&amp; indexTemp==index){//小数部分前面如果没有整数则必须要有小数部分
                return false;
            }
            index = indexTemp;
            num = true;
        }

        //4.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)
        if(index&lt;str.length &amp;&amp; (str[index]==&#39;e&#39;||str[index]==&#39;E&#39;) ){
            if(!num){//e部分前面没有数字，false (e9错误)
                return false;
            }
            index++;
            if(index==str.length){//有e但没有后面的整数部分，false
                return false;
            }
            if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){
                index++;
            }
            indexTemp = readNum(str, index);
            if(indexTemp==index){//有e但没有后面的整数部分，false
                return false;
            }
            index = indexTemp;
        }

        if(index!=str.length){//如果都判断完了，字符串还有字符，false
            return false;
        }
        return true;
    }

    //遍历读取数字部分，返回不是数字的索引
    public static int readNum(char[] str, int index){
        while(index&lt;str.length){
            int temp = str[index]-&#39;0&#39;;
            if(temp&lt;0 || temp&gt;9){//不是数字
                return index;
            }
            else{//是数字
                index++;
            }
        }
        return index;
    }
    public static void main(String[] args){
        String s1 = &quot;.5&quot;;//Expected:true
        String s2 = &quot;.&quot;;//Expected:false
        String s = &quot;100.&quot;;//Expected:true
        String s4 = &quot;-&quot;;//Expected:true
        System.out.println(isNumeric(s4.trim().toCharArray()));
    }
}
</code></pre>
<p><a name="36"></a></p>
<h2 id="36-调整数组顺序使奇数位于偶数前面-3道"><a href="#36-调整数组顺序使奇数位于偶数前面-3道" class="headerlink" title="36.调整数组顺序使奇数位于偶数前面(3道)"></a>36.调整数组顺序使奇数位于偶数前面(3道)</h2><pre><code>《剑指offer》p129(需要保持顺序不变)
leetcode 905(不用保持顺序)
leetcode 328(调整链表的奇偶顺序)
</code></pre><h3 id="《剑指offer》p129-需要保持顺序不变"><a href="#《剑指offer》p129-需要保持顺序不变" class="headerlink" title="《剑指offer》p129(需要保持顺序不变)"></a>《剑指offer》p129(需要保持顺序不变)</h3><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p>思路：遍历一遍数组，记下奇数偶数个数；建立新数组temp后，再遍历一遍原数组，奇数偶数分开放到新数组temp中；将新数组temp的值赋给原数组array。时间o(n)，空间o(n)</p>
<pre><code class="java">public static void reOrderArray(int [] array) {
    if(array==null || array.length&lt;2){
        return;
    }
    int cntOdd = 0;//记录奇数个数
    for(int i: array){//遍历一遍数组，记下奇数偶数个数
        if((i&amp;1)==1){
            cntOdd++;
        }
    }
    int oddIndex = 0;//奇数index
    int evenIndex = cntOdd;//偶数index
    int[] tempArray = new int[array.length];
    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，奇数偶数分开放到新数组temp中
        if((array[i]&amp;1)== 1){
            tempArray[oddIndex++] = array[i];
        }
        else{
            tempArray[evenIndex++] = array[i];
        }
    }

    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，将新数组temp的值赋给原数组array
        array[i] = tempArray[i];
    }
}
</code></pre>
<h3 id="Sort-Array-By-Parity"><a href="#Sort-Array-By-Parity" class="headerlink" title="Sort Array By Parity"></a>Sort Array By Parity</h3><p>leetcode 905</p>
<p>题目：偶数在前，奇数在后，不用保持顺序</p>
<p>Example :</p>
<pre><code>Input: [3,1,2,4]
Output: [2,4,3,1]
The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
</code></pre><p>思路：既然不用保持顺序，那么就不用空间o(n)的辅助了，思路：遍历一遍数组，两个指针变量，partition思想</p>
<pre><code class="java">//偶数在前，奇数在后，不用保持顺序。思路：遍历一遍数组，两个指针变量，partition思想
public static int[] sortArrayByParity(int[] A) {
    if(A==null || A.length&lt;2){
        return A;
    }

    int storeEven = 0;//遍历一遍数组，把偶数放在前面。storeEven左边都是偶数
    for(int i=0; i&lt;A.length; ++i){
        if((A[i]&amp;1)==0){
            swap(A, storeEven++, i);
        }
    }
    return A;
}
public static void swap(int[] A, int i, int j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
}
</code></pre>
<h3 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h3><p>leetcode 328</p>
<p>题目：Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>
<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>
<p>题目大意：奇数号节点在前，偶数号节点在后，同时要求时间o(n)，空间o(1)</p>
<p>Example 1:</p>
<pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL    
</code></pre><p>Example 2:</p>
<pre><code>Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL
Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL
</code></pre><p>思路：拆分成两个链表，奇数号链表、偶数号链表，最后再合成即可</p>
<pre><code class="java">public ListNode oddEvenList(ListNode head) {
    if(head==null || head.next==null || head.next.next==null){
        return head;
    }
    //奇数号链表
    ListNode oddHead = head;
    ListNode oddP = oddHead;

    //偶数号链表
    ListNode evenHead = head.next;
    ListNode evenP = evenHead;

    //遍历并拆分原链表
    ListNode cur = oddP.next.next;
    oddP.next = null;
    evenP.next = null;
    ListNode temp;
    while(cur!=null &amp;&amp; cur.next!=null){
        //奇数号节点
        temp = cur;
        cur = cur.next;
        oddP.next = temp;
        oddP = oddP.next;
        oddP.next = null;

        //偶数号节点
        temp = cur;
        cur = cur.next;
        evenP.next = temp;
        evenP = evenP.next;
        evenP.next = null;
    }
    if(cur!=null){//如果还剩一个奇数号节点
        oddP.next = cur;
        oddP = oddP.next;
        oddP.next = null;
    }

    //连接奇偶两个链表
    oddP.next = evenHead;
    return oddHead;
}
</code></pre>
<p><a name="37"></a></p>
<h2 id="37-链表中倒数第k个结点-两道"><a href="#37-链表中倒数第k个结点-两道" class="headerlink" title="37.链表中倒数第k个结点(两道)"></a>37.链表中倒数第k个结点(两道)</h2><pre><code>《剑指offer》p134--返回倒数第k个结点
《左神》p35==leetcode19--删除倒数第k个结点
</code></pre><h3 id="1-返回倒数第k个结点"><a href="#1-返回倒数第k个结点" class="headerlink" title="1.返回倒数第k个结点"></a>1.返回倒数第k个结点</h3><p>《剑指offer》p134</p>
<p>题目：输入一个链表，输出该链表中倒数第k个结点。</p>
<p>思路：双指针，遍历一遍链表即可。时间o(n),空间o(1)</p>
<pre><code class="java">public static ListNode FindKthToTail(ListNode head,int k) {
    if(head==null || k&lt;=0){
        return null;
    }
    ListNode right = head;//先出发，走k-1个节点
    ListNode left = head;//后出发，直到right.next为null时left即为所求

    //1.right先走k-1个节点
    while(k!=1){
        right = right.next;
        if(right==null){
            return null;//链表的节点数都不够k个，更没有倒数第k个节点了
        }
        k--;
    }

    //2.left、right一起走，直到right.next==null
    while(right.next!=null){
        left = left.next;
        right = right.next;
    }
    return left;
}
</code></pre>
<h3 id="2-删除倒数第k个节点"><a href="#2-删除倒数第k个节点" class="headerlink" title="2.删除倒数第k个节点"></a>2.删除倒数第k个节点</h3><p>《左神》35==leetcode19，思路差不多，删除时应该首先遍历到倒数第k+1个节点，且需要设置哨兵</p>
<pre><code class="java">//删除倒数第n个节点，则需要找到倒数第n+1个节点，需要设置哨兵
public ListNode removeNthFromEnd(ListNode head, int n) {
    if(head==null || n&lt;=0){
        return null;
    }

    //1.设置哨兵
    ListNode guard = new ListNode(0);
    guard.next = head;

    //2.找到倒数第n+1个节点
    ListNode right = guard;//先出发，走n-1个节点
    ListNode left = guard;//后出发，直到right.next为null时left即为所求

    //1.right先走n个节点
    while(n!=0){
        right = right.next;
        n--;
    }

    //2.left、right一起走，直到right.next==null，此时left指向倒数第n+1个节点
    while(right.next!=null){
        left = left.next;
        right = right.next;
    }

    //3.删除倒数第k个节点
    left.next = left.next.next;
    return guard.next;
}
</code></pre>
<p><a name="38"></a></p>
<h2 id="38-判断链表是否有环-两道"><a href="#38-判断链表是否有环-两道" class="headerlink" title="38.判断链表是否有环(两道)"></a>38.判断链表是否有环(两道)</h2><h3 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1.判断链表是否有环"></a>1.判断链表是否有环</h3><p>leetcode 141</p>
<p>题目：Given a linked list, determine if it has a cycle in it.</p>
<p>思路：每次fast走两步，low走一步，如果两者相遇则有环，如果遇到null则无环</p>
<pre><code class="java">public boolean hasCycle(ListNode head) {
    if(head==null){
        return false;
    }
    //判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环
    ListNode right = head;//走两步
    ListNode left = head;//走一步
    while(right!=null &amp;&amp; right.next!=null){
        right = right.next.next;
        left = left.next;
        if(right==left){//如果相遇，则有环
            return true;
        }
    }
    return false;
}
</code></pre>
<h3 id="2-判断链表是否有环，有则返回环的入口结点"><a href="#2-判断链表是否有环，有则返回环的入口结点" class="headerlink" title="2.判断链表是否有环，有则返回环的入口结点"></a>2.判断链表是否有环，有则返回环的入口结点</h3><p>《剑指offer》p139、leetcode 142</p>
<p>题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>思路：</p>
<blockquote>
<p>1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</p>
<p>如果有环：前后指针相遇的地方一定在环中，此时遍历这个环计算环的节点数k，之后从头遍历链表，前指针比后指针多走k步，前后指针再次相遇时即为为环的入口节点</p>
</blockquote>
<pre><code class="java">class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}

//给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
public ListNode EntryNodeOfLoop(ListNode pHead)
{
    if(pHead==null){
        return null;
    }
    //1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环
    ListNode right = pHead;//走两步
    ListNode left = pHead;//走一步
    boolean haveCycle = false; //是否有环
    while(right!=null &amp;&amp; right.next!=null){
        right = right.next.next;
        left = left.next;
        if(right==left){//如果相遇，则有环
            haveCycle = true;
            break;
        }
    }
    if(!haveCycle){//如果没环，返回null
        return null;
    }

    //2.有环，找出环的入口节点。
    //  思路：2.1遍历环计算环中节点个数k个；
    //       2.2从头遍历链表，两个指针，一个先走k，两个一起走直到相遇即为入口节点

    //2.1遍历环计算环中节点个数k个
    int cycleNum = 1; //环中节点个数
    while(right.next!=left){
        cycleNum++;
        right = right.next;
    }

    //2.2从头遍历链表，两个指针，一个先走cycleNum-1个节点，两个一起走直到相遇时left即为入口节点
    right = pHead;
    left = pHead;
    while(cycleNum!=1){//right先走cycleNum-1个节点
        right = right.next;
        cycleNum--;
    }

    while(right.next!=left){//right、left两个一起走，直到相遇时的left节点即为所求
        right = right.next;
        left = left.next;
    }
    return left;
}
</code></pre>
<p><a name="39"></a></p>
<h2 id="39-两个单链表相交的第一个公共节点-2道"><a href="#39-两个单链表相交的第一个公共节点-2道" class="headerlink" title="39.两个单链表相交的第一个公共节点(2道)"></a>39.两个单链表相交的第一个公共节点(2道)</h2><pre><code>两个链表的第一个公共节点(无环)--《剑指offer》p253、leetcode 160
两个链表的第一个公共节点(可能有环，需自己判断)--《左神》62，掌握这一道题就够了
</code></pre><h3 id="1-两个链表的第一个公共节点-无环"><a href="#1-两个链表的第一个公共节点-无环" class="headerlink" title="1.两个链表的第一个公共节点(无环)"></a>1.两个链表的第一个公共节点(无环)</h3><p>《剑指offer》p253、leetcode 160</p>
<p>题目：输入两个链表，链表无环，找出它们的第一个公共结点。如果不相交返回null</p>
<p>思路：</p>
<p>法一：因为要从两个链表的尾部往前一一判断，因此需要借助两个栈的辅助。java栈的实现可以用LinkedList。时间o(m+n)，空间o(m+n)</p>
<p>法二(更简单的办法)：链表长度差。首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到第一个相同的结点就是他们的第一个公共结点。时间o(m+n)，空间o(1)</p>
<pre><code class="java">//返回两个无环链表相交的第一个节点，如果不相交返回null
public static ListNode FindFirstNoCycleCommonNode(ListNode head1, ListNode head2){
    if(head1==null || head2==null){
        return null;
    }
    //1.计算两个链表的长度
    int len1 = 1;
    int len2 = 1;
    ListNode p1 = head1;
    ListNode p2 = head2;
    while(p1.next!=null){
        len1++;
        p1 = p1.next;
    }
    while(p2.next!=null){
        len2++;
        p2 = p2.next;
    }
    if(p1!=p2){//两个链表的最后一个节点不相同，说明不相交
        return null;
    }
    //2.计算长度差k，让长链表先走k步
    ListNode longList = len1&gt;=len2?head1:head2;
    ListNode shortList = longList==head1?head2:head1;
    int k = Math.abs(len1-len2);
    while(k!=0){
        longList = longList.next;
        k--;
    }
    //3.两个链表一起走，直到找到相交的第一个节点
    while(longList!=null &amp;&amp; shortList!=null){
        if(longList==shortList){
            return longList;
        }
        longList = longList.next;
        shortList = shortList.next;
    }
    return null;//不相交
}
</code></pre>
<h3 id="2-两个链表的第一个公共节点-可能有环，需自己判断"><a href="#2-两个链表的第一个公共节点-可能有环，需自己判断" class="headerlink" title="2.两个链表的第一个公共节点(可能有环，需自己判断)"></a>2.两个链表的第一个公共节点(可能有环，需自己判断)</h3><p>《左神》62，掌握这一道题就够了</p>
<p>题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null</p>
<p>思路：</p>
<p>1.判断两个链表是否有环</p>
<pre><code>1.1 若一个链表有环，另一个链表无环，则不可能相交，返回null
1.2 都无环则判断两个无环链表的第一个公共节点，没有返回null
</code></pre><p>2.若有环，判断两个有环链表的第一个公共节点。</p>
<pre><code>2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)

2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null
</code></pre><p>代码：</p>
<pre><code class="java">class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
public class Solution{
    /**
     * 题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null
     * 思路：
     *   1.判断两个链表是否有环，都无环则判断两个无环链表的第一个公共节点，没有返回null
     *   2.判断两个有环链表的第一个公共节点。
     *     2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)
     *     2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null
     */
    public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) {
        if(head1==null || head2==null){
            return null;
        }

        ListNode beginNodeOfCycle1 = hasCycle(head1);//链表head1是否有环，无环返回null，有环返回入口节点
        ListNode beginNodeOfCycle2 = hasCycle(head2);//链表head2是否有环，无环返回null，有环返回入口节点
        //1.两个链表都无环，判断两个无环链表的第一个公共节点，没有返回null
        if (beginNodeOfCycle1==null &amp;&amp; beginNodeOfCycle2==null) {
            return noCycleCommonNode(head1, head2);
        }

        //2.两个链表都有环
        if (beginNodeOfCycle1!=null &amp;&amp; beginNodeOfCycle2!=null) {
            //2.1beginNodeOfCycle1==beginNodeOfCycle2,交点在发生在环前,与无环链表公共节点求法类似(长度差，分别先后走找交点)
            if(beginNodeOfCycle1==beginNodeOfCycle2){
                ListNode p1 = head1;
                ListNode p2 = head2;
                int len1 = 0;
                int len2 = 0;
                while(p1!=beginNodeOfCycle1){
                    len1++;
                    p1 = p1.next;
                }
                while(p2!=beginNodeOfCycle2){
                    len2++;
                    p2 = p2.next;
                }
                ListNode longHead = len1&gt;=len2 ? head1 : head2;
                ListNode shortHead = longHead==head1 ? head2 : head1;
                int k = Math.abs(len1-len2);

                while(k!=0){//长链表先走k步
                    longHead = longHead.next;
                    k--;
                }
                while(longHead!=beginNodeOfCycle1 &amp;&amp; shortHead!=beginNodeOfCycle2){//两个链表一起走
                    if(longHead==shortHead){//找到公共节点
                        return longHead;
                    }
                    longHead = longHead.next;
                    shortHead = shortHead.next;
                }
            }
            //2.2beginNodeOfCycle11=beginNodeOfCycle2,交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null
            else{
                while(beginNodeOfCycle1.next!=beginNodeOfCycle1){
                    beginNodeOfCycle1 = beginNodeOfCycle1.next;
                    if(beginNodeOfCycle1==beginNodeOfCycle2){//环中找到了第一个公共节点，返回
                        return beginNodeOfCycle1;
                    }
                }
                return null;//环中没有公共节点，即两个有环链表独立不相交的
            }
        }

        //一个链表有环，一个链表无环，返回null
        return null;
    }

    //判断一个链表是否有环，没环返回null，如果有环返回入口节点
    public ListNode hasCycle(ListNode pHead){
        ListNode p1 = pHead;//每次走两步
        ListNode p2 = pHead;//每次走一步
        boolean hasCycle = false;
        while(p2.next!=null &amp;&amp; p1.next.next!=null){
            p2 = p2.next.next;
            p1 = p1.next;
            if(p1==p2){
                hasCycle = true;//两个指针相遇则有环
                break;
            }
        }
        if(hasCycle){//链表有环，返回入口节点
            //1.计算环的节点个数
            ListNode temp = p1;
            int k = 1;
            while(p1.next!=temp){
                k++;
                p1 = p1.next;
            }

            //2.right指针从链表头先走k步
            ListNode right = pHead;
            ListNode left = pHead;
            while(k!=0){
                right = right.next;
                k--;
            }

            //3.left从头和right一起走，直到相遇
            while(left!=right){
                left = left.next;
                right = right.next;
            }
            return left;//找到入口节点并返回
        }
        return null;//链表无环，返回null
    }

    //判断两个无环链表的第一个公共节点，没有则返回null
    public ListNode noCycleCommonNode(ListNode head1, ListNode head2){
        //长度差，一个先走k步，然后同时走，看是否有公共节点
        if(head1==null || head2==null){
            return null;
        }
        ListNode p1 = head1;
        ListNode p2 = head2;
        int len1 = 1;
        int len2 = 1;
        while(p1.next!=null){
            len1++;
            p1 = p1.next;
        }
        while(p2.next!=null){
            len2++;
            p2 = p2.next;
        }
        if(p1!=p2){//两个链表的最后一个节点不等，则没有公共节点，返回null
            return null;
        }

        ListNode longHead = len1&gt;=len2 ? head1 : head2;
        ListNode shortHead = longHead==head1 ? head2 : head1;
        int k = Math.abs(len1-len2);

        while(k!=0){//长链表先走k步
            longHead = longHead.next;
            k--;
        }

        while(longHead!=null &amp;&amp; shortHead!=null){//两个链表一起走
            if(longHead==shortHead){//找到公共节点
                return longHead;
            }
            longHead = longHead.next;
            shortHead = shortHead.next;
        }
        return null;//没有公共节点，返回null
    }
}
</code></pre>
<p><a name="40"></a></p>
<h2 id="40-合并两个排序的链表"><a href="#40-合并两个排序的链表" class="headerlink" title="40.合并两个排序的链表"></a>40.合并两个排序的链表</h2><p>《剑指offer》p145、leetcode21、《左神》84</p>
<p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p>思路：正常的遍历两个链表结点，每次将较小的节点插到新链表的尾部即可。设置哨兵</p>
<pre><code class="java">//合并两个有序的链表，设置一个哨兵
public ListNode Merge(ListNode list1,ListNode list2) {
    ListNode guard = new ListNode(0);
    ListNode p = guard;
    ListNode temp;
    while(list1!=null &amp;&amp; list2!=null){
        if(list1.val&lt;=list2.val){
            temp = list1;
            list1 = list1.next;

        }
        else{
            temp = list2;
            list2 = list2.next;
        }
        temp.next = null;
        p.next = temp;
        p = p.next;
    }
    if(list1!=null){
        p.next = list1;
    }
    if(list2!=null){
        p.next = list2;
    }
    return guard.next;
}
</code></pre>
<p><a name="41"></a></p>
<h2 id="41-树的子结构"><a href="#41-树的子结构" class="headerlink" title="41.树的子结构"></a>41.树的子结构</h2><p>《剑指offer》p148、leetcode 572</p>
<p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<p>思路：分为两步。第一步，先序遍历树A，在树A中找到和树B的根节点值相同的节点R；第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构</p>
<pre><code class="java">class TreeNode {
     int val = 0;
     TreeNode left = null;
     TreeNode right = null;

     public TreeNode(int val) {
        this.val = val;
     }
}

//两个二叉树A、B，判断B是否是A的子结构。思路：先序遍历A，找到与B的根节点相同的节点，判断子结构是否相同
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
    if(root1==null || root2==null){
        return false;
    }

    if(root1.val==root2.val){
        if(isSame(root1, root2)){
            return true;
        }
    }

    return HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}
public boolean isSame(TreeNode root1, TreeNode root2){
    if(root2==null){
        return true;
    }
    if(root1==null){
        return false;
    }

    if(root1.val==root2.val){
        return isSame(root1.left, root2.left) &amp;&amp; isSame(root1.right, root2.right);
    }
    return false;
}
</code></pre>
<p><a name="42"></a></p>
<h2 id="42-二叉树的翻转-镜像-与对称-2道"><a href="#42-二叉树的翻转-镜像-与对称-2道" class="headerlink" title="42.二叉树的翻转(镜像)与对称(2道)"></a>42.二叉树的翻转(镜像)与对称(2道)</h2><pre><code>《剑指offer》p157--二叉树的翻转(转换成镜像二叉树)
leetcode 101、《剑指offer》p159--判断二叉树是否是对称
</code></pre><h3 id="1-二叉树的翻转-镜像"><a href="#1-二叉树的翻转-镜像" class="headerlink" title="1.二叉树的翻转(镜像)"></a>1.二叉树的翻转(镜像)</h3><p>《剑指offer》p157</p>
<p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>思路：前序遍历树的每一个结点，对每个节点的左右子树互换，递归下去即可。</p>
<pre><code class="java">//操作给定的二叉树，将其变换为源二叉树的镜像。思路：左右子树互换，递归下去即可
public void Mirror(TreeNode root) {
    if(root==null){
        return;
    }
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;

    Mirror(root.left);
    Mirror(root.right);
}
</code></pre>
<h3 id="2-对称的二叉树"><a href="#2-对称的二叉树" class="headerlink" title="2.对称的二叉树"></a>2.对称的二叉树</h3><p>《剑指offer》p159、leetcode 101 </p>
<p>题目：判断一颗二叉树是不是对称的</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>思路：根左右与根右左的递归判断即可。</p>
<p>从根开始，先判断其左右孩子，如果都不存在则为true</p>
<p>如果只有一个为空或者两个指向的val值不同则为false</p>
<p>当根的左右孩子节点相同时，再判断其左孩子的左孩子和右孩子的右孩子、左孩子的右孩子和右孩子的左孩子</p>
<pre><code class="java">//判断一颗二叉树是不是对称的。思路：根左右与根右左的递归判断即可
public boolean isSymmetrical(TreeNode pRoot)
{
    if(pRoot==null){
        return true;
    }
    if(pRoot.left==null &amp;&amp; pRoot.right==null){
        return true;
    }
    if(pRoot.left!=null &amp;&amp; pRoot.right!=null){
        return isSymmetricalDetail(pRoot.left, pRoot.right);
    }
    return false;
}
public boolean isSymmetricalDetail(TreeNode root1, TreeNode root2){
    if(root1==null &amp;&amp; root2==null){
        return true;
    }
    if(root1==null || root2==null){
        return false;
    }
    if(root1.val==root2.val){
        return isSymmetricalDetail(root1.left, root2.right) &amp;&amp; isSymmetricalDetail(root1.right, root2.left);
    }
    return false;
}
</code></pre>
<p><a name="43"></a></p>
<h2 id="43-顺时针打印矩阵"><a href="#43-顺时针打印矩阵" class="headerlink" title="43.顺时针打印矩阵"></a>43.顺时针打印矩阵</h2><p>《剑指offer》p161、leetcode 54 spiral Matrix(螺旋矩阵)</p>
<p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>思路：先定义好打印一圈的函数，然后根据矩阵大小确定需要打印几圈。</p>
<pre><code class="java">import java.util.ArrayList;
public class Solution{
    //顺时针打印矩阵。思路：先定义打印一圈的函数，再确定打印几圈
    public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) {
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        if(matrix==null){
            return res;
        }
        int m = matrix.length;
        int n = matrix[0].length;

        int startI = 0;
        int startJ = 0;
        int endI = m-1;
        int endJ = n-1;
        int cycleNum = (int)Math.ceil((double)Math.min(m,n)/2);//一共打印cycleNum圈

        while(cycleNum!=0){//循环打印cycleNum圈
            printOneCycle(matrix, startI, startJ, endI, endJ, res);
            startI++;
            startJ++;
            endI--;
            endJ--;
            cycleNum--;
        }
        return res;
    }
    //定义打印一圈的函数。限定一圈的边界需要两个参数，圈的左上角元素和右下角元素的坐标
    public static void printOneCycle(int[][] matrix, int startI, int startJ, int endI, int endJ, ArrayList&lt;Integer&gt; res){
        //1.打印圈的上边，每圈都有
        int temp = startJ;
        while(temp&lt;=endJ) {
            res.add(matrix[startI][temp]);
            temp++;
        }
        //2.打印圈的右边，必须两行以上
        temp = startI+1;
        while(endI&gt;startI &amp;&amp; temp&lt;=endI){
            res.add(matrix[temp][endJ]);
            temp++;
        }
        //3.打印圈的下边，必须两行以上、两列以上
        temp = endJ-1;
        while(endI&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;=startJ){
            res.add(matrix[endI][temp]);
            temp--;
        }
        //4.打印圈的左边，必须三行以上、两列以上
        temp = endI - 1;
        while(endI-1&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;startI){
            res.add(matrix[temp][startJ]);
            temp--;
        }
    }
    public static void main(String[] args){
        int[][] matrix = new int[][]{{1,2,3,4},
                                    {5,6,7,8},
                                    {9,10,11,12},
                                    {13,14,15,16}};
        System.out.println(printMatrix(matrix));
    }
}
</code></pre>
<p><a name="44"></a></p>
<h2 id="44-包含min函数的栈"><a href="#44-包含min函数的栈" class="headerlink" title="44.包含min函数的栈"></a>44.包含min函数的栈</h2><p>《剑指offer》p165、leetcode155</p>
<p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））</p>
<p>思路：如果只用一个元素保存最小的元素，那么当最小的元素被弹出后，就没有办法得到剩余元素中最下的元素。因此引入辅助栈，每次将最小元素（之前的最小元素和新压入的元素两者的较小者）都保存起来放到辅助栈里。</p>
<pre><code class="java">import java.util.Stack;

public class Solution {

    Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();
    Stack&lt;Integer&gt; minStk = new Stack&lt;&gt;(); //辅助栈，每次push时都压入当前最小值（node与minStk栈顶元素中的较小者）
    public void push(int node) {
        stk.push(node);
        if(minStk.empty() || node &lt; minStk.peek()){
            minStk.push(node);
        }
        else{
            minStk.push(minStk.peek());
        }
    }

    public void pop() {
        stk.pop();
        minStk.pop();
    }

    public int top() {
        return stk.peek();
    }

    public int min() {
        return minStk.peek();
    }
}
</code></pre>
<p><a name="45"></a></p>
<h2 id="45-栈的压入、弹出序列"><a href="#45-栈的压入、弹出序列" class="headerlink" title="45.栈的压入、弹出序列"></a>45.栈的压入、弹出序列</h2><p>《剑指offer》p168、leetcode 946</p>
<p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p>思路：借助一个辅助栈来模拟入栈弹栈过程。每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环（直到出栈序列遍历完返回true）；如果不等：入栈后面的数字（直到入栈序列遍历完还没找到则false）</p>
<pre><code class="java">//每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环；如果不等：入栈后面的数字
public static boolean IsPopOrder(int [] pushA,int [] popA) {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    int len = pushA.length;
    int pushAIndex = 0;
    int popAIndex = 0;
    while(popAIndex&lt;len){
        if(stack.isEmpty() || popA[popAIndex]!=stack.peek()){
            if(pushAIndex==len){ //直到入栈序列遍历完还没找到则false
                return false;
            }
            stack.push(pushA[pushAIndex]);
            pushAIndex++;
        }else{
            if(!stack.isEmpty()){
                stack.pop();
                popAIndex++;
            }
        }
    }
    return true;//直到出栈序列遍历完返回true
}
</code></pre>
<p><a name="46"></a></p>
<h2 id="46-二叉树的层序遍历-3道"><a href="#46-二叉树的层序遍历-3道" class="headerlink" title="46.二叉树的层序遍历(3道)"></a>46.二叉树的层序遍历(3道)</h2><pre><code>二叉树的层序遍历--《剑指offer》p171
二叉树的层序遍历，按行打印--《剑指offer》p174、leetcode 102、leetcode107
二叉树的层序遍历，之字形按行打印--《剑指offer》p176、leetcode 103
</code></pre><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h3><p>《剑指offer》p171</p>
<p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>思路：借助队列实现层序遍历</p>
<pre><code class="java">//二叉树的层序遍历。思路：辅助队列
public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(root==null){
        return res;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode temp = queue.poll();
        res.add(temp.val);
        if(temp.left!=null){
            queue.offer(temp.left);
        }
        if(temp.right!=null){
            queue.offer(temp.right);
        }
    }
    return res;
}
</code></pre>
<h3 id="2-二叉树的层序遍历，按行打印"><a href="#2-二叉树的层序遍历，按行打印" class="headerlink" title="2.二叉树的层序遍历，按行打印"></a>2.二叉树的层序遍历，按行打印</h3><p>《剑指offer》p174、leetcode 102、leetcode107</p>
<p>题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数。</p>
<pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCnt
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(pRoot==null){
        return res;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(pRoot);
    int curCnt = 1;
    int nextCnt = 0;
    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();
    while(!queue.isEmpty()){
        TreeNode temp = queue.poll();
        resTemp.add(temp.val);
        curCnt--;

        if(temp.left!=null){
            queue.offer(temp.left);
            nextCnt++;
        }
        if(temp.right!=null){
            queue.offer(temp.right);
            nextCnt++;
        }

        if(curCnt==0){
            res.add(resTemp);
            resTemp = new ArrayList&lt;&gt;();
            curCnt = nextCnt;
            nextCnt = 0;
        }
    }
    return res;
}
</code></pre>
<h3 id="3-二叉树的层序遍历，之字形按行打印"><a href="#3-二叉树的层序遍历，之字形按行打印" class="headerlink" title="3.二叉树的层序遍历，之字形按行打印"></a>3.二叉树的层序遍历，之字形按行打印</h3><p>《剑指offer》p176、leetcode 103</p>
<p>题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数；且辅助奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)</p>
<pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCnt
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(pRoot==null){
        return res;
    }
    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
    queue.offer(pRoot);
    int curCnt = 1;
    int nextCnt = 0;
    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();
    boolean odd = true; //奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)
    while(!queue.isEmpty()){
        TreeNode temp = queue.poll();
        resTemp.add(temp.val);
        curCnt--;

        if(temp.left!=null){
            queue.offer(temp.left);
            nextCnt++;
        }
        if(temp.right!=null){
            queue.offer(temp.right);
            nextCnt++;
        }

        if(curCnt==0){
            if(!odd){//当前行是偶数行，从右往左，reverse下
                Collections.reverse(resTemp);
            }
            res.add(resTemp);
            resTemp = new ArrayList&lt;&gt;();
            curCnt = nextCnt;
            nextCnt = 0;
            odd = !odd;//下一行的奇偶是!odd
        }
    }
    return res;
}
</code></pre>
<p><a name="47"></a></p>
<h2 id="47-递归与非递归实现二叉树前序、中序、后序遍历"><a href="#47-递归与非递归实现二叉树前序、中序、后序遍历" class="headerlink" title="47.递归与非递归实现二叉树前序、中序、后序遍历"></a>47.递归与非递归实现二叉树前序、中序、后序遍历</h2><p>《左神》88、 leetcode144、94、145</p>
<p>题目：递归与非递归实现二叉树前序、中序、后序遍历</p>
<h3 id="1-前序："><a href="#1-前序：" class="headerlink" title="1.前序："></a>1.前序：</h3><pre><code class="java">//递归实现前序遍历
ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {
    if(root==null){
        return res;
    }
    res.add(root.val);
    if(root.left!=null){
        res = preorderTraversal(root.left);
    }
    if(root.right!=null){
        res = preorderTraversal(root.right);
    }
    return res;
}

//非递归实现前序遍历
public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(root==null){
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈
    TreeNode temp = root;
    while(temp!=null || !stack.isEmpty()){
        if(temp!=null){
            res.add(temp.val);//压栈之前先访问
            stack.push(temp);
            temp = temp.left;
        }
        else{
            temp = stack.pop().right;
        }
    }
    return res;
}
</code></pre>
<h3 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h3><pre><code class="java">//递归实现中序遍历
ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {
    if(root==null){
        return res;
    }
    if(root.left!=null){
        res = inorderTraversal(root.left);
    }
    res.add(root.val);
    if(root.right!=null){
        res = inorderTraversal(root.right);
    }
    return res;
}
​
//非递归实现中序遍历
public List&lt;Integer&gt; inorderTraversal(TreeNode root) { 
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(root==null){ 
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    TreeNode temp = root;
    while(temp!=null || !stack.isEmpty()){
        if(temp!=null){
            stack.push(temp);
            temp = temp.left;
        }
        else{
            temp = stack.pop();
            res.add(temp.val);
            temp = temp.right;
        }
    }
    return res;
}
</code></pre>
<p>​    </p>
<h3 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h3><pre><code class="java">//递归实现后序遍历
ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root){
    if(root==null){
        return res;
    }
    if(root.left!=null){
        res = postorderTraversal(root.left);
    }
    if(root.right!=null){
        res = postorderTraversal(root.right);
    }
    res.add(root.val);
    return res;
}

//非递归实现后序遍历。思路：1.根右左压栈，利用中间栈output来存储逆后序遍历的结果 + 2.最后再一起输出即可
public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    if(root==null){
        return res;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈,存根节点
    Stack&lt;TreeNode&gt; output = new Stack&lt;&gt;();//还需要一个辅助栈来存储逆后序遍历的结果
    TreeNode temp = root;
    while(temp!=null || !stack.isEmpty()){
        if(temp!=null){
            stack.push(temp);
            output.push(temp);
            temp = temp.right;
        }
        else{
            temp = stack.pop().left;
        }
    }
    while(!output.isEmpty()){
        res.add(output.pop().val);
    }
    return res;
}
</code></pre>
<p><a name="48"></a></p>
<h2 id="48-判断数组是否为二叉搜索树的后续遍历序列"><a href="#48-判断数组是否为二叉搜索树的后续遍历序列" class="headerlink" title="48.判断数组是否为二叉搜索树的后续遍历序列"></a>48.判断数组是否为二叉搜索树的后续遍历序列</h2><p>《剑指offer》p179.</p>
<p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<p>思路：后序遍历序列是左右根，所以先取数组中最后一个数，作为根节点。</p>
<pre><code>1.找根
2.找根左右的左右分界线(从左往右第一个比根大的即为右)
3.右可以没有，如果有右，则右中不含比根小的，否则false
4.递归判断下去
</code></pre><p>代码：</p>
<pre><code class="java">//题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果,假设输入的数组的任意两个数字都互不相同。
/**
 * 思路：
 *   1.找根
 *   2.找根左右的左右分界线(从左往右第一个比根大的即为➡右)
 *   3.右可以没有，如果有右，则右中不含比根小的，否则false
 *   4.递归判断下去
 */
​    public boolean VerifySquenceOfBST(int [] sequence) {
​        if(sequence==null || sequence.length==0){
​            return false;
​        }
​        if(sequence.length==1){
​            return true;
​        }
​        return VerifySquenceOfBSTDetail(sequence, 0, sequence.length-1);
​    }
​    public boolean VerifySquenceOfBSTDetail(int[] sequence, int start, int end){
​        if(start&gt;end){
​            return false;
​        }
​        if(start==end){
​            return true;
​        }
​        //1.找根
​        int root = sequence[end];
​
​        //2.找左右分界线
​        int rightIndex = start;
​        int temp = start;
​        while(temp&lt;end){
​            if(sequence[temp]&gt;root){//第一个比root大的节点即为右
​                rightIndex = temp;
​                break;
​            }
​            temp++;
​        }
​        if(temp==end){//只有左，没有右，则递归判断左即可
​            return VerifySquenceOfBSTDetail(sequence, start, end-1);
​        }
​
    //3.有右，则右中不能含比根小的，否则返回false
    temp = rightIndex;
    while(temp&lt;end){
        if(sequence[temp]&lt;root){//右中含比根小的，返回false
            return false;
        }
        temp++;
    }

    //4.递归判断左、右序列即可
    if(rightIndex==start){//只有左，没有右，递归判断右即可
        return VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);
    }
    else{//有左有右
        return VerifySquenceOfBSTDetail(sequence, start, rightIndex-1) &amp;&amp; VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);
    }
}
</code></pre>
<p><a name="49"></a></p>
<h2 id="49-二叉树中和为指定值的路径-2道"><a href="#49-二叉树中和为指定值的路径-2道" class="headerlink" title="49.二叉树中和为指定值的路径(2道)"></a>49.二叉树中和为指定值的路径(2道)</h2><pre><code>leetcode 112--二叉树中和为指定值的一条路径
《剑指offer》p182、leetcode 113--二叉树中和为指定值的所有路径(回溯法)
</code></pre><h3 id="1-Path-Sum"><a href="#1-Path-Sum" class="headerlink" title="1.Path Sum"></a>1.Path Sum</h3><p>leetcode 112</p>
<p>题目：二叉树中和为指定值的一条路径。</p>
<p>思路：正常递归遍历即可。</p>
<pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的一条路径。
List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();
public boolean hasPathSum(TreeNode root, int sum) {
    if(root==null){
        return false;
    }
    sum -= root.val;
    if(root.left==null &amp;&amp; root.right==null &amp;&amp; sum==0){//当前节点为叶节点且路径和==sum，true
        return true;
    }
    return hasPathSum(root.left,sum) || hasPathSum(root.right, sum);
}
</code></pre>
<h3 id="2-Path-Sum-2"><a href="#2-Path-Sum-2" class="headerlink" title="2.Path Sum 2"></a>2.Path Sum 2</h3><p>《剑指offer》p182、leetcode 113</p>
<p>题目：二叉树中和为指定值的所有路径。输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<p>思路：回溯法。遍历树每一条到叶子节点的路径，找寻符合条件的路径。到叶子节点如果还没有找到路径，就要回退到父节点继续寻找，依次类推。</p>
<pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的所有路径。思路：递归+回溯法
ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//存放所有路径
ArrayList&lt;Integer&gt; tempPath = new ArrayList&lt;&gt;();//存放当前路径
public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {
    if(root==null){
        return res;
    }
    target -= root.val;
    tempPath.add(root.val);
    if(root.left==null &amp;&amp; root.right==null &amp;&amp; target==0){//当前节点是叶节点且路径和==target，满足条件
        res.add(new ArrayList&lt;&gt;(tempPath));
    }
    FindPath(root.left, target);
    FindPath(root.right, target);
    tempPath.remove(tempPath.size()-1);//回溯点
    return res;
}
</code></pre>
<p><a name="50"></a></p>
<h2 id="50-复杂链表的复制"><a href="#50-复杂链表的复制" class="headerlink" title="50.复杂链表的复制"></a>50.复杂链表的复制</h2><p>《剑指offer》p187、《左神》56、leetcode138</p>
<p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<p>思路：分而治之，复杂问题分成小问题一一解决。时间o(n) 空间o(1)<br>1、遍历链表并复制结点，复制的结点在相应节点之后：a-&gt;b-&gt;c-&gt;d-&gt;e为a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’-&gt;d-&gt;d’-&gt;e-&gt;e’<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p>
<pre><code class="java">class RandomListNode {
    public int label;
    public RandomListNode next, random;
    public RandomListNode(int x) {
        this.label = x;
    }
};
public class Solution2 {
    public RandomListNode copyRandomList(RandomListNode head) {
        if(head==null){
            return null;
        }

        RandomListNode p = head;
        //1.遍历链表，复制节点
        while(p!=null){
            RandomListNode newNode = new RandomListNode(p.label);
            newNode.next = p.next;
            p.next = newNode;
            p = p.next.next;
        }

        //2.遍历链表，复制random指针
        p = head;
        while(p!=null){
            if(p.random!=null){
                p.next.random = p.random.next;
            }
            p = p.next.next;
        }

        //3.拆分链表，将复制链表拆出来
        p = pHead;
        RandomListNode newHead = new RandomListNode(0);//新链表的哨兵
        RandomListNode newP = newHead;
        while(p!=null){
            RandomListNode temp = p.next;
            p.next = p.next.next;
            temp.next = null;
            newP.next = temp;
            newP = newP.next;
            p = p.next;
        }

    return newHead.next;
    }
}
</code></pre>
<p><a name="51"></a></p>
<h2 id="51-二叉搜索树与双向链表-两道"><a href="#51-二叉搜索树与双向链表-两道" class="headerlink" title="51.二叉搜索树与双向链表(两道)"></a>51.二叉搜索树与双向链表(两道)</h2><h3 id="1-二叉搜索树转双向链表"><a href="#1-二叉搜索树转双向链表" class="headerlink" title="1.二叉搜索树转双向链表"></a>1.二叉搜索树转双向链表</h3><p>《剑指offer》p191、leetcode426、《左神》74</p>
<p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：中序遍历+记录有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序，因此需要辅助保存当前链表最后一个节点。</p>
<pre><code class="java">class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x){
        val = x;
        this.left = null;
        this.right = null;
    }
}
public class Solution2 {
    public TreeNode Convert(TreeNode root){
        if(root==null){
            return null;
        }
        TreeNode lastPointer = null;//当前有序双向链表的最后一个节点
        lastPointer = ConvertDetail(lastPointer, root);
        while(lastPointer.left!=null){
            lastPointer = lastPointer.left;
        }
        return lastPointer;
    }
    //中序遍历，返回当前有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序的了
    private TreeNode ConvertDetail(TreeNode lastPointer, TreeNode root){
        if(root==null){
            return lastPointer;
        }
        if(root.left!=null){
            lastPointer = ConvertDetail(lastPointer, root.left);
        }
        root.left = lastPointer;
        if(lastPointer!=null){
            lastPointer.right = root;
        }
        lastPointer = root;
        if(root.right!=null){
            lastPointer = ConvertDetail(lastPointer, root.right);
        }
        return lastPointer;
    }
}
</code></pre>
<h3 id="2-有序数组转平衡二叉树"><a href="#2-有序数组转平衡二叉树" class="headerlink" title="2.有序数组转平衡二叉树"></a>2.有序数组转平衡二叉树</h3><p>leetcode 108</p>
<p>题目：Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>思路：数组中间的数做root，递归二分即可。</p>
<pre><code class="java">//有序数组转成平衡二叉树。思路：数组中间的数做root，递归二分即可
public TreeNode sortedArrayToBST(int[] nums) {
    if(nums==null || nums.length==0){
        return null;
    }
    return sortedArrayToBSTDetail(nums, 0, nums.length-1);
}
public TreeNode sortedArrayToBSTDetail(int[] nums, int start, int end){
    if(start&lt;0 || end&gt;=nums.length || start&gt;end){
        return null;
    }
    int mid = (start+end)/2;
    TreeNode root = new TreeNode(nums[mid]);

    root.left = sortedArrayToBSTDetail(nums, start, mid-1);
    root.right = sortedArrayToBSTDetail(nums, mid+1, end);
    return root;
}
</code></pre>
<p><a name="52"></a></p>
<h2 id="52-序列化二叉树"><a href="#52-序列化二叉树" class="headerlink" title="52.序列化二叉树"></a>52.序列化二叉树</h2><p>《剑指offer》p194、leetcode 297(序列化反序列化二叉树）、leetcode 449(序列化反序列化平衡二叉树)</p>
<p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>思路：序列化：前序遍历，遇到子节点为空用”$”代替；反序列化：按照前序遍历序列化的顺序进行反推。</p>
<pre><code class="java">//请实现两个函数，分别用来序列化和反序列化二叉树
//1.序列化：前序遍历，遇到空节点为空用&quot;null&quot;代替
public String serialize(TreeNode root) {
    StringBuilder res = new StringBuilder();
    serializeDetail(root, res);
    return res.toString();
}
//这样分开的话，递归的时候不用保存全局变量res，防止二叉树太深导致的递归栈溢出
public void serializeDetail(TreeNode root, StringBuilder res){
    if(root==null){
        res.append(&quot;null,&quot;);
        return;
    }
    res.append(root.val + &quot;,&quot;);
    serializeDetail(root.left, res);
    serializeDetail(root.right, res);
}

//2.反序列化：按照前序遍历序列化的顺序进行反推,将String转成ArrayList&lt;String&gt;方便删除同时节省空间
public TreeNode deserialize(String data) {
    if(data==null || data.length()==0){
        return null;
    }
    String[] str = data.split(&quot;,&quot;);
    ArrayList&lt;String&gt; strr = new ArrayList&lt;&gt;(Arrays.asList(str));
    return deserializeDetail(strr);
}
public TreeNode deserializeDetail(ArrayList&lt;String&gt; strr){
    if(strr.size()==0){
        return null;
    }
    String temp = strr.get(0);
    strr.remove(0);
    if(temp.equals(&quot;null&quot;)){
        return null;
    }
    TreeNode root = new TreeNode(Integer.valueOf(temp));
    root.left = deserializeDetail(strr);
    root.right = deserializeDetail(strr);
    return root;
}
</code></pre>
<p><a name="53"></a></p>
<h2 id="53-全排列-组合问题-五道"><a href="#53-全排列-组合问题-五道" class="headerlink" title="53.全排列/组合问题(五道)"></a>53.全排列/组合问题(五道)</h2><pre><code>1.字符串的全排列(abc,acb...)--《剑指offer》p197
2.无重复数字的全排列--leetcode 46
3.有重复数字的全排列--leetcode 47
4.八皇后问题--《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)
5.字符串s1的全排列是否在s2字符串中--leetcode 567
</code></pre><h3 id="1-字符串的全排列"><a href="#1-字符串的全排列" class="headerlink" title="1.字符串的全排列"></a>1.字符串的全排列</h3><p>《剑指offer》p197</p>
<p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<p>例如输入字符串abc，则打印由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。注意aac aac只能有一个，需要过滤重复</p>
<p>思路：递归。我们求整个字符串的排列，可以看成两步：首先求出所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换……</p>
<pre><code class="java">//字符串的全排列
public ArrayList&lt;String&gt; Permutation(String str) {
    ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();
    if(str==null || str.length()==0){
        return res;
    }
    PermutationDetail(res, str.toCharArray(), 0);
    Collections.sort(res);//最后排序一下，按字典序输出
    return res;
}

public void PermutationDetail(ArrayList&lt;String&gt; res, char[] str, int index){
    if(index==str.length){//递归出口
        String temp = String.valueOf(str);
        if(!res.contains(temp)){//过滤重复
            res.add(String.valueOf(str));
        }
        return;
    }
    for(int i=index; i&lt;str.length; ++i){
        swap(str, i, index);//每次递归将index位置字符与后面所有字符进行分别交换
        PermutationDetail(res, str, index+1);//当前位置交换后进行下一位上的排列递归
        swap(str, i, index);
    }
}
public void swap(char[] str, int i, int j){
    char temp = str[i];
    str[i] = str[j];
    str[j] = temp;
}
</code></pre>
<h3 id="2-无重复数字的全排列"><a href="#2-无重复数字的全排列" class="headerlink" title="2.无重复数字的全排列"></a>2.无重复数字的全排列</h3><p>leetcode 46</p>
<p>题目：和字符串的全排列一样，换汤不换药。给定一个无重复数字的序列，返回这些数所能排列出所有序列。</p>
<pre><code>Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre><p>代码：</p>
<pre><code class="java">//数字的全排列
public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(nums==null || nums.length==0){
        return res;
    }
    permuteDetail(res, nums, 0);
    return res;
}
public void permuteDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){
    if(index==nums.length){//递归出口
        Integer[] temp = new Integer[nums.length];
        for(int i= 0;i&lt;nums.length;i++){
            temp[i]= nums[i];//int-&gt;Integer
        }
        res.add(Arrays.asList(temp));
    }
    for(int i=index; i&lt;nums.length; ++i){
        swap(nums, i, index);//每次递归将index位置字符与后面所有字符进行分别交换
        permuteDetail(res, nums, index+1);//当前位置交换后进行下一位上的排列递归
        swap(nums, i, index);
    }
}
public void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
</code></pre>
<h3 id="3-有重复数字的全排列"><a href="#3-有重复数字的全排列" class="headerlink" title="3.有重复数字的全排列"></a>3.有重复数字的全排列</h3><p>leetcode 47</p>
<p>题目：给定一个有重复数字的序列，返回这些数所能排列出所有序列。注意需要把重复的全排列给过滤掉</p>
<p>思路：有重复的数字的全排列。为了过滤重复，对于同一个值，只交换一次，否则跳过。为了保证这一点，辅助<strong>hash表</strong>来过滤重复的元素，如果重复则跳过不交换即可。</p>
<pre><code class="java">//有重复数组的全排列。需要过滤重复，思路：用hash即可，不用排序
public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(nums==null || nums.length==0){
        return res;
    }
    permuteUniqueDetail(res, nums, 0);
    return res;
}
public void permuteUniqueDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){
    if(index==nums.length){//递归出口
        Integer[] itg = new Integer[nums.length];
        for(int i=0; i&lt;nums.length; ++i){//int-&gt;Integer
            itg[i] = nums[i];
        }
        List&lt;Integer&gt; temp = Arrays.asList(itg);
        res.add(temp);
    }

    Set&lt;Integer&gt; used = new HashSet&lt;&gt;();//hashSet记录已经访问过的数，避免重复排列
    for(int i=index; i&lt;nums.length; ++i){
        if(used.add(nums[i])){//对于同一个值，只交换一次，否则跳过。
            swap(nums, index, i);
            permuteUniqueDetail(res, nums, index+1);
            swap(nums, index, i);
        }
    }
}
public void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
</code></pre>
<h3 id="4-八皇后问题"><a href="#4-八皇后问题" class="headerlink" title="4.八皇后问题"></a>4.八皇后问题</h3><p>《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)</p>
<p>题目：在n*n的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角斜线上。下图中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请求出总共有多少种摆法或者输出八皇后摆法。</p>
<p>思路：八皇后问题(不能同一行、列、对角线)。<strong>思路：转化为数字的全排列问题。总体思路: 0-n全排列的总数 - check(全排列出现同时在对角线上的)。</strong></p>
<p>详细思路：八个皇后的任意两个不能处在同一行，那么这肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把ColumnIndex的八个数字分别用0-7初始化，接下来我们要做的事情就是对数组ColumnIndex做全排列。由于我们是用不同的数字初始化数组中的数字，因此任意两个皇后肯定不同列。我们只需要判断得到的每一个排列对应的八个皇后是不是在同一对角斜线上，也就是数组的两个下标i和j，是不是i-j==ColumnIndex[i]-Column[j]或者j-i==ColumnIndex[i]-ColumnIndex[j]。</p>
<pre><code class="java">//八皇后问题(不能同一行、列、对角线)。思路：转化为数字的全排列问题：76548321-&gt;皇后分别在：第一行的7，第二行的6...
public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {
    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();
    if(n&lt;1){
        return res;
    }
    int[] nums = new int[n];//将八皇后问题转成不重复数字全排列问题
    for(int i=0; i&lt;n; ++i){//0-n个数字全排列之前初始化
        nums[i] = i;
    }
    solveNQueensDetail(res, nums, 0);//全排列并且判断是否满足八皇后，满足的排列存入结果
    return res;
}
//全排列并判断是否满足八皇后(不能出现在同一对角线)
public static void solveNQueensDetail(List&lt;List&lt;String&gt;&gt; res, int[] nums, int index){
    if(index==nums.length){//递归出口
        if(!check(nums)){//不满足八皇后(同一对角线)
            return;
        }
        List&lt;String&gt; tempList = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;nums.length; ++i){//将八皇后排列转成输出格式--&gt;..Q.
            StringBuilder sb = new StringBuilder();
            int cnt = nums[i];
            int ct = 0;
            while(ct&lt;cnt){
                sb.append(&quot;.&quot;);
                ct++;
            }
            sb.append(&quot;Q&quot;);
            ct++;
            while(ct&lt;nums.length){
                sb.append(&quot;.&quot;);
                ct++;
            }
            tempList.add(sb.toString());
        }
        res.add(tempList);
        return;
    }
    for(int i=index; i&lt;nums.length; ++i){
        swap(nums, index, i);
        solveNQueensDetail(res, nums, index+1);
        swap(nums, index, i);
    }
}
public static void swap(int[] nums, int i, int j){
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
//判断是否同一对角线
public static boolean check(int[] nums){//检查一种排列是否出现在同一对角线，是则不是八皇后排列
    for(int i=0; i&lt;nums.length-1; ++i){
        for (int j=i+1; j&lt;nums.length; ++j){
            if( Math.abs(i-j)==Math.abs(nums[i]-nums[j]) ){
                return false;
            }
        }
    }
    return true;
}
</code></pre>
<h3 id="5-字符串s1的全排列是否在s2字符串中"><a href="#5-字符串s1的全排列是否在s2字符串中" class="headerlink" title="5.字符串s1的全排列是否在s2字符串中"></a>5.字符串s1的全排列是否在s2字符串中</h3><p>leetcode 567 Permutation in String</p>
<p>题目：Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p>
<pre><code>Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;
Output:True
Explanation: s2 contains one permutation of s1 (&quot;ba&quot;).
</code></pre><p>思路：</p>
<p>方法1：最简单最暴力的方法其实就是找到s1的所有<strong>全排列</strong>，然后在s2中查找是否这些全排列字符串在s2中。但是这种方法<strong>耗时太大，会导致超时</strong>。</p>
<p>方法2：<strong>滑动窗口</strong><br>其实不需要找到s1的全排列，因为我们只需要考虑s2中是否包含s1中同样个数的字符，并且这些字符是连在一起的就行了。因此，我们可以使用一个滑动窗口，在s2上滑动。在这个滑动窗口中的字符及其个数是否刚好等于s1中的字符及其个数，此外滑动窗口保证了这些字符是连在一起的。</p>
<p>具体思路：辅助两个map键值对来模拟滑动窗口中的字符情况，由于都是小写字母，不用map，直接用int[26]来模拟map即可</p>
<p>注意：判断两个数组是否相等<code>Arrays.equals(int[] num1, int[] num2);</code></p>
<pre><code class="java">public static boolean checkInclusion(String s1, String s2) {
    if(s1==null || s1.length()==0){
        return true;
    }
    if(s2==null || s2.length()==0 || s1.length()&gt;s2.length()){
        return false;
    }
    int[] map1 = new int[26];//s1的字符键值对
    int[] map2 = new int[26];//s2上滑动窗口的字符键值对
    for(int i=0; i&lt;s1.length(); ++i){//记录s1的字符map
        map1[s1.charAt(i)-&#39;a&#39;]++;
    }
    for(int i=0; i&lt;s2.length(); ++i){//遍历s2，滑动窗口
        map2[s2.charAt(i)-&#39;a&#39;]++;
        if((i+1)&gt;=s1.length()){//滑动窗口
            if(Arrays.equals(map1, map2)){//如果两个map包含的字符一样，则找到了s2中的s1的全排列
                return true;
            }
            else{//否则，滑动窗口map2删除最左边的元素
                map2[s2.charAt(i-s1.length()+1)-&#39;a&#39;]--;
            }
        }
    }
    return false;
}
</code></pre>
<p><a name="54"></a></p>
<h2 id="54-打印出给定字符串中字符的所有组合"><a href="#54-打印出给定字符串中字符的所有组合" class="headerlink" title="54.打印出给定字符串中字符的所有组合"></a>54.打印出给定字符串中字符的所有组合</h2><p>题目：”abc”-&gt;打印a,b,c,ab,ac,bc,abc</p>
<p>思路：在字符串位置的index到chs.length()-1中找number个数，组合成字符串放在list中，每次递归到chs[index]字符时，都有两种选择：</p>
<p>1.放进组合，在begin+1到chs.length()-1中找number-1个数；</p>
<p>2.不放进组合，在begin+1到chs.length()-1中找number个数</p>
<pre><code class="java">public static void combine(char[] chs){
    if(chs==null || chs.length==0){
        return;
    }
    if(chs.length==1){
        System.out.println(chs[0]);
    }
    List&lt;Character&gt; tempList = new ArrayList&lt;&gt;();
    for(int i=1; i&lt;=chs.length; ++i){//组合数字的个数[1~chs.length]
        combineDetail(chs, i, 0, tempList);
    }
}
//从index开始找combineNum个数字的组合，并打印
public static void combineDetail(char[] chs, int combineNum, int index, List&lt;Character&gt; tempList){
    if(combineNum==0){ //找到一种number个字符的组合，将list-&gt;String打印出来并回溯
        System.out.println(tempList.toString());
        return;
    }
    if(index==chs.length){//递归出口: 找完number个字符的所有组合，返回
        return;
    }

    //当前位置的数字放进组合，则往后需要找combineNum-1个数
    tempList.add(chs[index]);
    combineDetail(chs, combineNum-1, index+1, tempList);

    //当前位置的数字不放进组合，则往后需要找combineNum个数
    tempList.remove(Character.valueOf(chs[index]));//回溯
    combineDetail(chs, combineNum, index+1, tempList);
}

public static void main(String[] args) {
    char[] nums = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};
    combine(nums);
}

out:

[a]
[b]
[c]
[a, b]
[a, c]
[b, c]
[a, b, c]
</code></pre>
<p><a name="55"></a></p>
<h2 id="55-大-小根堆–优先队列实现-两道"><a href="#55-大-小根堆–优先队列实现-两道" class="headerlink" title="55.大/小根堆–优先队列实现(两道)"></a>55.大/小根堆–优先队列实现(两道)</h2><pre><code>找出数组中最小的k个数(优先队列大根堆)--《剑指offer》p209
找出数组中第k大的数(优先队列小根堆)--leetcode 215
</code></pre><p>注：java优先队列默认小根堆</p>
<h3 id="1-找出数组中最小的k个数-优先队列大根堆"><a href="#1-找出数组中最小的k个数-优先队列大根堆" class="headerlink" title="1.找出数组中最小的k个数(优先队列大根堆)"></a>1.找出数组中最小的k个数(优先队列大根堆)</h3><p>《剑指offer》p209</p>
<p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p>
<p>思路：辅助一个k长的优先队列大根堆，遍历数组的同时每次用大根堆替换k长容器的值(适合海量不能修改数组的数据)—&gt;o(nlogk)。<strong>大根堆的实现用优先队列大根堆</strong></p>
<pre><code class="java">//找出数组中最小的k个数(优先队列大根堆)。思路：用优先队列的大根堆。时间o(nlogk)，空间o(k)
public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {
    if(input==null || input.length==0 || k&lt;1 || k&gt;input.length){
        return new ArrayList&lt;&gt;();
    }

    //由于java默认小根堆，所以定义一个k长的大根堆
    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2 - o1;
        }
    });

    for (int i=0; i&lt;input.length; ++i){
        if(i&lt;k){
            queue.offer(input[i]);
        }
        else{
            if(queue.peek()&gt;input[i]){//把大的数都出堆，留下最小的k个数
                queue.poll();
                queue.offer(input[i]);
            }
        }
    }
    return new ArrayList&lt;&gt;(queue);//treeSet-&gt;ArrayList&lt;Integer&gt;
}
</code></pre>
<h3 id="2-找出数组中第k大的数-优先队列小根堆"><a href="#2-找出数组中第k大的数-优先队列小根堆" class="headerlink" title="2.找出数组中第k大的数(优先队列小根堆)"></a>2.找出数组中第k大的数(优先队列小根堆)</h3><p>leetcode 215 Kth Largest Element in an Array</p>
<p>题目：Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<p>Example 1:</p>
<pre><code>Input: [3,2,1,5,6,4] and k = 2
Output: 5
</code></pre><p>思路：辅助用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)</p>
<pre><code class="java">//返回数组中第k大的数,k总是有效的。思路：用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)
public int findKthLargest(int[] nums, int k) {
    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();//默认小根堆
    for (int i=0; i&lt;nums.length; ++i){
        if(i&lt;k){
            queue.offer(nums[i]);
        }
        else{
            if(queue.peek()&lt;nums[i]){//注意这里要比较一下，不满足就不用出堆
                queue.poll();
                queue.offer(nums[i]);
            }
        }
    }
    return queue.poll();
}
</code></pre>
<p><a name="56"></a></p>
<h2 id="56-数据流中的中位数"><a href="#56-数据流中的中位数" class="headerlink" title="56.数据流中的中位数"></a>56.数据流中的中位数</h2><p>《剑指offer》p209、leetcode 295</p>
<p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<p>思路：对于数据流，对应的就是在线算法了，一道很经典的题目就是在1亿个数中找到最大的前100个数，这是一道堆应用题，找最大的前100个数，那么我们就创建一个大小为100的最小化堆，每来一个元素就与堆顶元素比较，因为堆顶元素是目前前100大数中的最小数，前来的元素如果比该元素大，那么就把原来的堆顶替换掉。那么对于这一道题呢？如果单纯的把所有元素放到一个数组里，每次查找中位数最快也要O(n)，综合下来是O(n^2)的复杂度。<br>我们可以利用上面例子中的想法：动态查找考虑堆，中位数左边的数比它小，右边的数比它大。故用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器，因为要找中位数所以也要保证两边容器的数据个数差不超过1。</p>
<p>java堆的实现用优先队列</p>
<pre><code class="java">import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;

public class Solution {

    //左边的大根堆，存比中位数小的数
    private Queue&lt;Integer&gt; bigHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return o2-o1;
        }
    });
    //右边的小根堆，存比中位数大的数
    private Queue&lt;Integer&gt; smallHeap = new PriorityQueue&lt;&gt;();

    //优先放左边的大根堆，左边的大根堆与右边的小根堆的size只能差1
    public void Insert(Integer num) {
        if( bigHeap.size()==smallHeap.size() ){//放左边大根堆
            if(!smallHeap.isEmpty() &amp;&amp; smallHeap.peek()&lt;num) {//如果num比右边的小根堆的peek大，应该交换下放到右边
                bigHeap.offer(smallHeap.poll());
                smallHeap.offer(num);
            }else{
                bigHeap.offer(num);
            }
        }
        else if( bigHeap.size()&gt;smallHeap.size() ){//放右边小根堆
            if(bigHeap.peek()&gt;num){//如果num比左边的大根堆的peek小，应该交换下放到左边
                smallHeap.offer(bigHeap.poll());
                bigHeap.offer(num);
            }else{
                smallHeap.offer(num);
            }
        }
    }

    public Double GetMedian() {
        if( bigHeap.size()&gt;smallHeap.size() ){
            return (double)bigHeap.peek();
        }
        else{
            return  ((double)bigHeap.peek() + (double)smallHeap.peek()) / 2;
        }
    }


    public static void main(String[] args){
        Solution s = new Solution();
        int[] nums = new int[]{5,2,3,4,1,6,7,0,8};
        for(int i=0; i&lt;nums.length; ++i){
            s.Insert(nums[i]);
        }
        System.out.println(s.GetMedian());
    }
}
</code></pre>
<p><a name="57"></a></p>
<h2 id="57-数组中最大连续子序列的和"><a href="#57-数组中最大连续子序列的和" class="headerlink" title="57.数组中最大连续子序列的和"></a>57.数组中最大连续子序列的和</h2><p>《剑指offer》p218、leetcode 53</p>
<p>题目：给一个数组，返回它的最大连续子序列的和</p>
<p>思路：</p>
<p>法一：动态规划。DP[i]表示以i结尾的数组，目前最大连续子序列的和是DP[i]。递推公式：DP[i] = max{DP[i-1] + A[i],A[i]}</p>
<p>法二：更高效。动态规划需要额外数组存，所以本题改进不用额外的空间，直接<strong>辅助两个变量遍历一遍数组即可</strong>。两个变量：tempMax记录数组中每一段和大于0的连续子数组，整个数组有很多个这样的tempMax；最后的resultMax是这些tempMax最大的</p>
<pre><code class="java">//有负数的数组中，连续子序列的最大和为多少。思路：辅助两个变量，resMax,tempMax，当tempMax&lt;=0时，tempMax=0
public int FindGreatestSumOfSubArray(int[] array) {
    int resMax = array[0];
    int tempMax = 0;
    for(int i=0; i&lt;array.length; ++i){
        tempMax += array[i];
        resMax = Math.max(resMax, tempMax);
        if(tempMax&lt;=0){//当tempMax&lt;=0，那当前这段连续子数组就不要了，tempMax重置为0
            tempMax = 0;
        }
    }
    return resMax;
}
</code></pre>
<p><a name="58"></a></p>
<h2 id="58-1到n整数中1出现的次数"><a href="#58-1到n整数中1出现的次数" class="headerlink" title="58.1到n整数中1出现的次数"></a>58.1到n整数中1出现的次数</h2><p>《剑指offer》p221、leetcode 233</p>
<p>题目：求1 到 n 中1出现的次数。e.g.1~13的整数中1出现的次数：1、10、11、12、13因此共出现5次</p>
<p>思路：按位进行讨论计算。对数字的每一位单独拿出讨论，按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可。</p>
<p><strong>计算规则：</strong></p>
<pre><code>​若weight为0，则1出现次数为round*base
若weight为1，则1出现次数为round*base+former+1
​若weight大于1，则1出现次数为round*base+base
​
​```

详细请参考[从1到n整数中1出现的次数：O(logn)算法](https://blog.csdn.net/yi_afly/article/details/52012593)

​```java
//求出1到n出现1的次数。思路：按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可
public static int NumberOf1Between1AndN_Solution(int n) {
    int res = 0;

    int round = n;
    int weight;
    int former;
    int base = 1;
    while(round!=0){
        weight = round%10;
        round /= 10;
        former = n%base;
        res += round*base;//res += weight*base

        if(weight==1){//res += former + 1
            res += former + 1;
        }
        else if(weight&gt;1){//res += base
            res += base;
        }
        base *= 10;
    }

    return res;
}
</code></pre><p><a name="59"></a></p>
<h2 id="59-正整数序列中的第n个数字"><a href="#59-正整数序列中的第n个数字" class="headerlink" title="59.正整数序列中的第n个数字"></a>59.正整数序列中的第n个数字</h2><p>《剑指offer》p221、leetcode 400</p>
<p>题目：在整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n个数字，n是正数且在32为整形范围内(n &lt; 231)。e.g.第5位是5，第13位是1</p>
<p>思路：一位数0-9数字在序列中占10位，两位数10-99数字在序列中占2<em>90=180位，三位数100-999有3</em>900=2700位。当n=1001时，n-10-180=811&gt;0 &amp;&amp; n-10-180-2700&lt;0，且811=3*270+1，说明第n位在三位数的100之后第270个数字即370的中间一位，即7。</p>
<pre><code class="java">//正整数序列中的第n个数字。思路：
public static int findNthDigit(int n) {
    if(n&lt;10){
        return n;
    }
    int digitLen = 2; //当前区间的位数，如：10~99的2
    int start = 10; //当前区间的起始数，如：10~99的10
    int base = 90; //当前区间的所有位数，如10~99的90
    n -= 9;
    while(n!=0){
        int objectNum = (int)Math.ceil((double)n/digitLen) + start -1;//定位到了目标数字
        if(objectNum&lt;(start*10)){//目标数字就在当前区间,这样判断是为了防止int溢出
            int loc = n%digitLen; //定位到目标数字的第几位，从左往右
            if(loc==0){
                loc = digitLen-1;
            }
            else{
                loc = loc-1;
            }
            String num = String.valueOf(objectNum);
            return num.charAt(loc)-&#39;0&#39;;
        }
        else{//目标数字在下一个区间
            n -= (base*digitLen);
            digitLen++;
            start *= 10;
            base *= 10;
        }
    }
    return -1;
}
</code></pre>
<p><a name="60"></a></p>
<h2 id="60-把数组排成最小的数"><a href="#60-把数组排成最小的数" class="headerlink" title="60.把数组排成最小的数"></a>60.把数组排成最小的数</h2><p>《剑指offer》p227、leetcode 179</p>
<p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<p>注意：</p>
<p>我们要判断一个数字的最高位上的数字，故最方便的方法是：数字转成字符串。</p>
<p>且数字拼接过程很可能大数溢出int类型，更要用字符串拼接比较</p>
<p>思路：</p>
<p><strong>1.先把数组中的整数转换成字符串，2.然后用compareTo中定义比较规则，3.并根据该规则调用库函数sort()排序，4.最后把排序后数字字符串依次打印出来即为所求最小的数字。时间复杂度就是排序的时间复杂度o(nlogn)</strong></p>
<pre><code class="java">//把数组排成最小的数
public static String PrintMinNumber(int [] numbers) {
    //1.int[] --&gt; String[]
    String[] strings = new String[numbers.length];
    for(int i=0; i&lt;numbers.length; ++i){
        strings[i] = numbers[i]+&quot;&quot;;
    }

    //2.定义字符串排序的比较规则
    Comparator&lt;String&gt; com = new Comparator&lt;String&gt;() {
        @Override
        public int compare(String o1, String o2) {
            String s1 = o1 + o2;
            String s2 = o2 + o1;
            return s1.compareTo(s2);
        }
    };

    //3.对String[]排序
    Arrays.sort(strings, com);

    //4.拼接字符串
    StringBuilder sb = new StringBuilder();
    for(int i=0; i&lt;strings.length; ++i){
        sb.append(strings[i]);
    }
    if(sb.charAt(0)==&#39;0&#39;){//&quot;0000&quot;--&gt;&quot;0&quot;
        return &quot;0&quot;;
    }
    return sb.toString();
}
</code></pre>
<p><a name="61"></a></p>
<h2 id="61-求把一个数字翻译成不同字符串的个数-DP"><a href="#61-求把一个数字翻译成不同字符串的个数-DP" class="headerlink" title="61.求把一个数字翻译成不同字符串的个数(DP)"></a>61.求把一个数字翻译成不同字符串的个数(DP)</h2><p>《剑指offer》p231、leetcode 91</p>
<p>题目: 求把数字翻译成字符串的个数。0-&gt;a,1-&gt;b…11-&gt;l,25-&gt;z。求一个数字有多少种不同的翻译方法。e.g.258-&gt;2,58、25,8</p>
<p>题目分析：这道题要求解码方法，跟之前那道 Climbing Stairs 爬梯子问题 非常的相似，但是还有一些其他的限制条件，比如说一位数时不能为0，两位数不能大于26，其十位上的数也不能为0，除去这些限制条件，跟爬梯子基本没啥区别，也勉强算特殊的斐波那契数列，当然需要用动态规划DP来解。</p>
<p>思路：DP问题。f(i)为第i位开始到最右边结束的数字的翻译个数。–&gt;动态规划题，解题分析步骤如下。</p>
<p><strong>1.从左往右DP分析</strong>：定义f(i)为从i至字符串s最右边结束的不同字符串的个数，因此所求为f(0)。<strong>f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)</strong></p>
<p><strong>2.详细的DP方程：</strong> f(i) = </p>
<pre><code>0,   s[i]==‘0’
f(i+2),   s[i+1]==‘0’ &amp;&amp; (s[i]==‘1’ || s[i]==‘2’)
0,   s[i+1]==‘0’ &amp;&amp; (else)
f(i+1)+f(i+2),   s[i+1]!=&#39;0&#39; &amp;&amp; s[i]==‘1’ || （s[i]==‘2’ &amp;&amp; s[i+1]-‘0’&lt;=6)
f(i+1),     s[i+1]!=&#39;0&#39; &amp;&amp; (else)
</code></pre><p>且递归结束条件为:</p>
<pre><code>i==s.length  return 1;
s[i]==&#39;0&#39;  return 0;
</code></pre><p><strong>3.从右往左循环实现</strong> 递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题</p>
<p>代码一：按dp方程直接翻译的递归代码</p>
<pre><code class="java">//求把一个数字翻译成不同字符串的个数
public static int numDecodings(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    return numDecodingsDetail(s.toCharArray(), 0);
}
//从右往左，每次递归表示从String s中的index至最右边字符串结束，可翻译成不同字符串的个数
//f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)
public static int numDecodingsDetail(char[] chs, int index){
    if(index&lt;chs.length &amp;&amp; chs[index]==&#39;0&#39;){
        return 0;
    }
    if(index&lt;chs.length-1){
        if(chs[index+1]==&#39;0&#39;){//后一个为0，必须与后一个连成字母，不满足为0
            if(chs[index]==&#39;1&#39; || chs[index]==&#39;2&#39;){//与后一个连成字母
                return numDecodingsDetail(chs,index+2);
            }
            else{//匹配错误，返回0
                return 0;
            }
        }
        else{//后一个不为0，可以不与后一个连成字母，同时如果连成字母需要判断
            if(chs[index]==&#39;1&#39; || (chs[index]==&#39;2&#39; &amp;&amp; chs[index+1]&lt;=&#39;6&#39;)){//自成一派+与后一个连成字母
                return numDecodingsDetail(chs, index+1) + numDecodingsDetail(chs,index+2);
            }
            else {//不能与后一个连成字母，只能自成一派
                return numDecodingsDetail(chs, index+1);
            }
        }
    }
    return 1;//index==chs.length 递归结束
}

代码二：递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题（这个代码是按照剑指offer的题目来的，A-0,Z-25）

//求把一个数字翻译成不同字符串的个数
public static int numDecodings(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    //1.把数字每一位拆分，存到数组中
    char[] chs = s.toCharArray();

    //2.从右往左，res[]存放动态规划循环计算的每一个f(i)结果，最后要返回的是res[0]
    int[] res = new int[chs.length];
    //每次计算f(i)时的临时计数器
    int tempCount = 0;
    for(int i=chs.length-1; i&gt;=0; --i){//从右往左循环计算
        if(i==chs.length-1) {
            tempCount = 1; //如果是最右边的数字时，初始化翻译个数=1
        }
        else{//f(i) = f(i+1)
            tempCount = res[i+1];
        }
        //f(i) = f(i+1) + g(i,i+1)*f(i+2)
        if(i&lt;chs.length-1){//判断后一个字母的情况
            int temp = Integer.parseInt(&quot;&quot;+chs[i]+chs[i+1]);
            if(temp&gt;=10 &amp;&amp; temp&lt;=25){//可以连成字母
                if((i+2)&lt;chs.length){
                    tempCount += res[i+2];//f(i+1)+f(i+2)
                }
                else{
                    tempCount += 1;
                }
            }
        }
        res[i] = tempCount;
    }
    return res[0];
}
</code></pre>
<p><a name="62"></a></p>
<h2 id="62-礼物的最大价值"><a href="#62-礼物的最大价值" class="headerlink" title="62.礼物的最大价值"></a>62.礼物的最大价值</h2><p>《剑指offer》p233、leetcode 64</p>
<p>题目：礼物的最大价值。</p>
<p>在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。</p>
<p>从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。</p>
<p>例如，对于如下棋盘：</p>
<pre><code>1*  10  3  8
12*  2  9  6
5*  *7  4  11
3  7*  16*  5*
</code></pre><p>res = 1+12+5+7+7+16+5 = 53</p>
<p>思路：</p>
<p>典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)</p>
<p>递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</p>
<p>循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</p>
<pre><code class="java">/**
 题目：礼物的最大价值。
 * 在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。
 * 从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。
 * 例如，对于如下棋盘：
 *      1*    10   3    8
        12*   2    9    6
        5*    *7    4    11
        3    7*    16*   5*
    res = 1+12+5+7+7+16+5 = 53
 思路：
    典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)
    递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]
    循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]
 */
public class Solution{
    public static void main(String[] args){
        int[][] gift = {{1,10,3,8},{12,2,9,6},{5,7,4,11},{3,7,16,5}};
        System.out.println(maxValue(gift, 4, 4)); //out:53
    }
    public static int maxValue(int[][] gift, int m, int n){
        /**
         * @Description: m*n大小的棋盘gift[][]
         * 递归分析f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]
         * 循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]
         */
        if(gift==null || m&lt;=0 || n&lt;=0){
            return 0;
        }
        int[][] maxValue = new int[m][n];
        for(int i=0; i&lt;m; ++i){ //从左上往右下进行循环计算
            for(int j=0; j&lt;n; ++j){
                int temp = 0;
                if((i-1)&gt;=0){
                    temp = Math.max(temp, maxValue[i-1][j]);
                }
                if((j-1)&gt;=0){
                    temp = Math.max(temp, maxValue[i][j-1]);
                }
                maxValue[i][j] = temp + gift[i][j];
            }
        }
        return maxValue[m-1][n-1];
    }
}
</code></pre>
<p>优化改进空间复杂度，使用一维数组<br>•题目中可知，坐标(i,j)的最大礼物价值仅仅取决于坐标为(i-1,j)和(i,j-1)两个格子；<br>•因此第i-2行以上的最大价值没有必要保存下来。<br>•使用一维数组保存，数组的长度为gift的列数：(0…j-1)保存的是(i,0)…(i,j-1)的最大价值；(j…cols-1)保存的是(i-1,j)…(i-1,cols-1)的最大价值。即：数组前j个数字分别是当前第i行前j个格子的maxvule,而之后的数字分别保存前面第i-1行n-j个格子的maxVlue。</p>
<pre><code class="java">//leetcode 64 Minimum Path Sum的代码，一样的
public int minPathSum(int[][] grid) {
    if(grid==null || grid.length==0 || grid[0].length==0){
        return 0;
    }
    int m = grid.length;
    int n = grid[0].length;

    int[] min = new int[n];//辅助一维数组，数组的长度为grid的列数
    for(int i=0; i&lt;m; ++i){
        for(int j=0; j&lt;n; ++j){
            if(i == 0){//第一行
                if(j==0){//第一列
                    min[j] = grid[i][j];
                }
                else {
                    min[j] = grid[i][j] + min[j-1];
                }
            }
            else{//后面几行
                if(j==0){//第一列
                    min[j] = min[j] + grid[i][j];
                }
                else{
                    min[j] = Math.min(min[j-1], min[j]) + grid[i][j];
                }
            }
        }
    }
    return min[n-1];
}
</code></pre>
<p><a name="63"></a></p>
<h2 id="63-最长不含重复字符的子字符串长度"><a href="#63-最长不含重复字符的子字符串长度" class="headerlink" title="63.最长不含重复字符的子字符串长度"></a>63.最长不含重复字符的子字符串长度</h2><p>《剑指offer》p236、leetcode 3</p>
<p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p>
<p>思路：</p>
<p>不重复子串可能有多个，而最长不重复子串长度只有一个唯一的值。</p>
<p><strong>遍历一遍字符串，同时借助辅助hashMap</strong>记录字符是否出现及上一次出现的位置。时间o(n)，空间o(n)</p>
<p>三个变量：</p>
<p>int resMax = 0; //记录最长的不重复字符子串的长度</p>
<p>int tempMax = 0; //记录当前不重复字符子串的长度</p>
<p>int startIndex = 0; //记录当前不重复字符子串的开始位置，初始化为0</p>
<pre><code class="java">//Longest Substring Without Repeating Characters最长不含重复字符的子字符串长度
//思路：遍历一遍字符串，辅助hashMap存字符是否出现过或上一次出现的位置。时间o(n), 空间o(n)
public int lengthOfLongestSubstring(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    if(s.length()==1){
        return 1;
    }


    int resMax = 0;//最终返回的最大长度
    int tempMax = 0;//当前的最大长度
    int startIndex = 0;//当前最大长度的起始位置

    //1.辅助hashMap存字符是否出现过或上一次出现的位置
    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();

    //2.遍历一遍字符串
    for(int i=0; i&lt;s.length(); ++i){
        char temp = s.charAt(i);
        //如果字符没出现过或字符上一次出现的位置在startIndex的前面，那么当前字符有效，计算更新相应长度即可
        if(!hashMap.containsKey(temp) || hashMap.get(temp)&lt;startIndex){
            tempMax = i-startIndex+1;
            resMax = Math.max(tempMax, resMax);
        }else{//当前字符重复了
            startIndex = hashMap.get(temp)+1; //下次的startIndex为重复字符上一次出现位置的下一个位置
        }
        hashMap.put(temp, i);//不管重复与否，都要更新字符出现的位置
    }

    return resMax;
}
</code></pre>
<p><a name="64"></a></p>
<h2 id="64-丑数-两道"><a href="#64-丑数-两道" class="headerlink" title="64.丑数(两道)"></a>64.丑数(两道)</h2><pre><code>判断一个数是否为丑数--leetcode 263
求第N个丑数是几--《剑指offer》p240
</code></pre><h3 id="1-判断一个数是否为丑数"><a href="#1-判断一个数是否为丑数" class="headerlink" title="1.判断一个数是否为丑数"></a>1.判断一个数是否为丑数</h3><p>leetcode 263</p>
<p>题目：给定一个数，判断是否为丑数(丑数定义:只含因子2、3、5的正数，1也算丑数)</p>
<pre><code>Input: 6
Output: true
Explanation: 6 = 2 × 3
</code></pre><p>思路：就正常判断因子即可。</p>
<pre><code class="java">//判断一个数是否为丑数
public boolean isUgly(int num) {
    if(num&lt;1) {
        return false;
    }
    if(num==1){
        return true;
    }
    while(num%2==0){
        num /= 2;
    }
    while(num%3==0){
        num /= 3;
    }
    while(num%5==0){
        num /= 5;
    }
    if(num==1){
        return true;
    }
    return false;
}
</code></pre>
<h3 id="2-求第N个丑数是几"><a href="#2-求第N个丑数是几" class="headerlink" title="2.求第N个丑数是几"></a>2.求第N个丑数是几</h3><p>《剑指offer》p240</p>
<p>题目：把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<p>思路：</p>
<p>空间换时间。丑数一定是丑数<em>2/</em>3/*5得来的，直接用数组存下1到index的丑数</p>
<p>关键是怎么保证每一个丑数的大小顺序的–&gt;三个变量：index2、index3、index5</p>
<p>每次该放下一个丑数时，三个变量分别记录了当前可以<em>2/</em>3/*5的最小的丑数位置</p>
<p>每次分别对这三个位置上的丑数<em>2</em>3*5后找出最小的一个，即为当前的丑数，之后更新三个变量即可</p>
<pre><code class="java">//丑数
public static int GetUglyNumber_Solution(int index) {
    if(index&lt;=0){
        return 0;
    }
    if(index==1){
        return 1;
    }
    int[] res = new int[index+1];//存1到index的丑数，返回res[index]
    res[1] = 1;
    int index2 = 1;
    int index3 = 1;
    int index5 = 1;
    for(int i=2; i&lt;=index; ++i){
        res[i] = min(res[index2]*2, res[index3]*3, res[index5]*5);//该放res[i]丑数了，找三个中最小的
        while(res[index2]*2&lt;=res[i]){//更新三个变量
            index2++;
        }
        while(res[index3]*3&lt;=res[i]){
            index3++;
        }
        while(res[index5]*5&lt;=res[i]){
            index5++;
        }
    }

    return res[index];
}

public static int min(int a, int b, int c){
    int temp = a&lt;b ? a : b;
    return temp&lt;c ? temp : c;
}
</code></pre>
<p><a name="65"></a></p>
<h2 id="65-第一个只出现一次的字符"><a href="#65-第一个只出现一次的字符" class="headerlink" title="65.第一个只出现一次的字符"></a>65.第一个只出现一次的字符</h2><pre><code>第一个只出现一次的字符(数组)--《剑指offer》p243、leetcode 387
第一个只出现一次的字符(字符流)--《剑指offer》p247
</code></pre><p>题目：给定数组或是输入一个字符流，返回第一个只出现一次的的字符位置。在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p>
<pre><code>e.g.输入&quot;abaccdeff&quot; --&gt; 则输出&#39;b&#39;
</code></pre><p>思路：不管是数组还是字符流，都用这个思路。<strong>遍历一遍str，辅助hashMap，value记录字符出现第一次的位置，若字符重复出现，则value记录-1。最后再遍历一遍hashMap，找除了-1之外的最小value即可所求</strong>。时间o(n)，空间o(256)</p>
<p>数据是数组的代码：</p>
<pre><code class="java">//给定数组的代码，字符流的情况一样的。思路：遍历一遍str，辅助hashMap记录字符出现的位置，再遍历一遍hashMap即可。时间o(n)，空间o(256)
public int firstUniqChar(String str) {
    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();//key:字符，value:字符出现一次value为上次出现的位置，字符出现多次value存-1
    //1.遍历字符串,辅助hashMap记录字符出现的位置
    for(int i=0; i&lt;str.length(); ++i){
        char temp = str.charAt(i);
        if(!hashMap.containsKey(temp)){//字符只出现一次，存出现的位置
            hashMap.put(temp,i);
        }
        else{//字符出现多次，存-1
            hashMap.put(temp, -1);
        }
    }

    //2.遍历hashMap来找第一次只出现一次的字符
    int res = Integer.MAX_VALUE;
    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){
        if(entry.getValue()!=-1){
            res = Math.min(res, entry.getValue());//找最小的只出现一次的字符位置
        }
    }
    return res==Integer.MAX_VALUE ? -1 : res;
}

数据是字符流的代码：

public class Solution{

    private int[] chIndex;
    private static int cnt = 0; //计数当前输入到第几个数了，初始为0

    public Solution(){
        chIndex = new int[256];//初始化哈希数组，每个字符都未出现，
    }

    //Insert one char from stringstream
    public void Insert(char ch){
        cnt++;
        if(chIndex[ch]==0) {//之前未出现过，则更新值为当前位置，说明出现了第一次
            chIndex[ch] = cnt;
        }
        else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2
            chIndex[ch] = -1;
        }
    }

    //return the first appearence once char in current stringstream
    public char FirstAppearingOnce(){
        int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置
        char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符
        for(int i=0; i&lt;256; ++i){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)
            if(chIndex[i]&gt;0 &amp;&amp; chIndex[i]&lt;minIndex){
                minIndex = chIndex[i];
                resChar = (char)i;
            }
        }
        return resChar;
    }
}
</code></pre>
<p>当然，本题中hashMap可以用256的数组，也可以用hashMap</p>
<pre><code class="java">private HashMap&lt;Character, Integer&gt; hashMap;
private static int cnt = 0; //计数当前输入到第几个数了，初始为0

public Solution(){
    hashMap = new HashMap&lt;&gt;();
}

//Insert one char from stringstream
public void Insert(char ch){
    cnt++;
    if(!hashMap.containsKey(ch)) {//之前未出现过，则更新值为当前位置，说明出现了第一次
        hashMap.put(ch, cnt);
    }
    else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2
        hashMap.put(ch, -1);
    }
}

//return the first appearence once char in current stringstream
public char FirstAppearingOnce(){
    int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置
    char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符
    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)
        if(entry.getValue()!=-1 &amp;&amp; entry.getValue()&lt;minIndex){
            minIndex = entry.getValue();
            resChar = entry.getKey();
        }
    }
    return resChar;
}
</code></pre>
<p><a name="66"></a></p>
<h2 id="66-归并排序相关-3道"><a href="#66-归并排序相关-3道" class="headerlink" title="66.归并排序相关(3道)"></a>66.归并排序相关(3道)</h2><pre><code>数组的归并排序
数组中的逆序对个数(2道)--《剑指offer》p249、leetcode 493
单链表的归并排序--leetcode 148
</code></pre><h3 id="1-数组的归并排序"><a href="#1-数组的归并排序" class="headerlink" title="1.数组的归并排序"></a>1.数组的归并排序</h3><p>经典的归并排序算法，时间o(nlog)，空间o(n)</p>
<p>来源<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p>
<pre><code class="java">import java.util.Arrays;
public class Solution {
    //归并排序。思路：分而治之，先分后治,辅助数组temp[]
    public static void mergeSort(int[] nums){
        if(nums==null || nums.length&lt;2){
            return;
        }
        int[] temp = new int[nums.length]; //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
        mergeSortDetail(nums, 0, nums.length-1, temp);
    }

    //分
    private static void mergeSortDetail(int[] nums, int left, int right, int[] temp){
        if(left&lt;right){//一个数字不用merge，只有两个以上才merge
            int mid = (left+right)/2;
            mergeSortDetail(nums, left, mid, temp);//左边归并排序，使得左子序列有序
            mergeSortDetail(nums, mid+1, right, temp);//右边归并排序，使得右子序列有序
            merge(nums, left, mid, right, temp);//将两个有序子数组合并操作
        }
    }

    //治
    private static void merge(int[] nums, int left, int mid, int right, int[] temp){
        int tempIndex = 0;//temp数组的当前位置
        int i = left; //左序列的索引
        int j = mid+1; //右序列的索引
        while(i&lt;=mid &amp;&amp; j&lt;=right){//将左、右序列的元素有序的放进temp数组中
            temp[tempIndex++] = nums[i]&lt;=nums[j] ? nums[i++] : nums[j++];
        }
        while(i&lt;=mid){//将左边剩余元素填充进temp中
            temp[tempIndex++] = nums[i++];
        }
        while(j&lt;=right){//将右边剩余元素填充进temp中
            temp[tempIndex++] = nums[j++];
        }

        //将temp中的元素全部拷贝到nums原数组中
        tempIndex = 0;
        while(left&lt;=right){
            nums[left++] = temp[tempIndex++];
        }
    }
    public static void main(String []args){
        int[] nums = {9,8,7,6,5,4,3,2,1};
        mergeSort(nums);
        System.out.println(Arrays.toString(nums));
    }
}
</code></pre>
<h3 id="2-数组中的逆序对-2道"><a href="#2-数组中的逆序对-2道" class="headerlink" title="2.数组中的逆序对(2道)"></a>2.数组中的逆序对(2道)</h3><pre><code>《剑指offer》p249
Reverse Pairs--leetcode 493 
</code></pre><h4 id="2-1-求出数组中逆序对的个数"><a href="#2-1-求出数组中逆序对的个数" class="headerlink" title="2.1 求出数组中逆序对的个数"></a>2.1 求出数组中逆序对的个数</h4><p>《剑指offer》p249</p>
<p>思路：用归并排序思想，在归并排序的过程中计数逆序对。时间o(nlogn)，空间o(n)，稳定。先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数（也就是逆序数），这三个过程加起来就是整体的逆序数目了。</p>
<p>注意:归并排序merge过程中的<strong>从右往左排序的巧妙思想</strong>！</p>
<pre><code class="java">//数组中逆序对的总数。思路：归并排序思想
// 先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数
public static int InversePairs(int [] array) {
    if(array==null || array.length&lt;2){
        return 0;
    }
    int[] temp = new int[array.length];
    return InversePairsDetail(array, 0, array.length-1, temp)%1000000007;
}
public static int InversePairsDetail(int[] array, int left, int right, int[] temp){
    int res = 0;
    if(left&lt;right){
        int mid = (left+right)/2;
        res += InversePairsDetail(array, left, mid, temp);//左边的逆序数
        res += InversePairsDetail(array, mid+1, right, temp);//右边的逆序数
        res += merge(array, left, mid, right, temp);//左边与右边的逆序数
    }
    return res%1000000007;
}
public static int merge(int[] array, int left, int mid, int right, int[] temp){
    int res = 0;
    int i = mid;//左序列指针，从右往左
    int j = right;//右序列指针，从右往左
    int tempIndex = right;//临时数组指针，从右往左
    while(i&gt;=left &amp;&amp; j&gt;mid){
        if(array[i]&gt;array[j]){//是一个逆序对，且前面的比后面的大，又找到很多个逆序对
            temp[tempIndex--] = array[i--];
            res += (j-mid);//又找到很多个逆序对
            res %= 1000000007;
        }
        else{
            temp[tempIndex--] = array[j--];
        }
    }
    while(i&gt;=left){//前面的数组还有
        temp[tempIndex--] = array[i--];
    }
    while(j&gt;mid){//后面的数组还有
        temp[tempIndex--] = array[j--];
    }

    tempIndex = right; //最后还是要完成排序
    while(left&lt;=right){
        array[right--] = temp[tempIndex--];
    }
    return res%1000000007;
}
</code></pre>
<h4 id="2-2-Reverse-Pairs"><a href="#2-2-Reverse-Pairs" class="headerlink" title="2.2 Reverse Pairs"></a>2.2 Reverse Pairs</h4><p>leetcode 493 </p>
<p>题目：和上面的逆序数有点不一样，Given an array nums, we call (i, j) an important reverse pair if i &lt; j and <strong>nums[i] &gt; 2*nums[j].</strong></p>
<pre><code>Input: [1,3,2,3,1]
Output: 2
</code></pre><p>思路：还是逆序对的归并排序思想，只不过找逆序对的算法不同，因此简要修改判断即可</p>
<pre><code class="java">//数组中逆序对的总数。思路：归并排序思想
//先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数
public int reversePairs(int[] nums) {
    if(nums==null || nums.length&lt;2){
        return 0;
    }
    int[] temp = new int[nums.length];
    return InversePairsDetail(nums, 0, nums.length-1, temp);
}
public int InversePairsDetail(int[] array, int left, int right, int[] temp){
    int res = 0;
    if(left&lt;right){
        int mid = (left+right)/2;
        res += InversePairsDetail(array, left, mid, temp);//左边排序，且计算左边的逆序对个数
        res += InversePairsDetail(array, mid+1, right, temp);//右边排序，且计算右边的逆序对个数
        //merge左右两边排序前，计算左右两边的逆序对个数
        for (int i = left, j = mid+1; i &lt;= mid &amp;&amp; j &lt;= right;){
            if (array[i] &gt; (long) array[j] * 2){//long必须有
                res += mid - i + 1;
                j++;
            }
            else i++;
        }

        merge(array, left, mid, right, temp);//左右两边归并排序
    }
    return res;
}
//正常的左右两边归并排序
public void merge(int[] array, int left, int mid, int right, int[] temp){
    int i = mid;//左序列指针，从右往左
    int j = right;//右序列指针，从右往左
    int tempIndex = right;//临时数组指针，从右往左
    while(i&gt;=left &amp;&amp; j&gt;mid){
        if(array[i]&gt;array[j]){
            temp[tempIndex--] = array[i--];
        }
        else{
            temp[tempIndex--] = array[j--];
        }
    }
    while(i&gt;=left){//前面的数组还有
        temp[tempIndex--] = array[i--];
    }
    while(j&gt;mid){//后面的数组还有
        temp[tempIndex--] = array[j--];
    }

    tempIndex = right; //最后还是要完成排序
    while(left&lt;=right){
        array[right--] = temp[tempIndex--];
    }
}
</code></pre>
<h3 id="3-单链表的归并排序"><a href="#3-单链表的归并排序" class="headerlink" title="3.单链表的归并排序"></a>3.单链表的归并排序</h3><p>leetcode 148 </p>
<p>见 <a href="#93.0">93.0单链表的归并排序</a></p>
<p><a name="67"></a></p>
<h2 id="67-二叉搜索树的第k小节点-中序遍历"><a href="#67-二叉搜索树的第k小节点-中序遍历" class="headerlink" title="67.二叉搜索树的第k小节点(中序遍历)"></a>67.二叉搜索树的第k小节点(中序遍历)</h2><p>《剑指offer》p269、leetcode 230</p>
<p>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p>
<p>思路：中序遍历即可。时间o(n)，空间o(1)</p>
<pre><code class="java">//二叉搜索树中第k小节点。将k存到数组中便于修改传参，对二叉树中序遍历判断即可 
TreeNode KthNode(TreeNode pRoot, int k)
{
    if(pRoot==null || k&lt;1){
        return null;
    }
    int[] ks = new int[1];
    ks[0] = k;
    return KthNodeDetail(pRoot, ks);
}
TreeNode KthNodeDetail(TreeNode pRoot, int[] ks)
{
    TreeNode res = null;
    if(pRoot.left!=null){
        res = KthNodeDetail(pRoot.left, ks);
    }
    if(res!=null){
        return res;
    }
    ks[0]--;
    if(ks[0]==0){
        return pRoot;
    }
    if(pRoot.right!=null){
        res = KthNodeDetail(pRoot.right, ks);
    }
    return res;
}
</code></pre>
<p><a name="68"></a></p>
<h2 id="68-二叉树的深度-两道"><a href="#68-二叉树的深度-两道" class="headerlink" title="68.二叉树的深度(两道)"></a>68.二叉树的深度(两道)</h2><pre><code>    求二叉树的深度--leetcode104
    判断是否为平衡二叉树--leetcode110
</code></pre><h3 id="1-求二叉树的深度"><a href="#1-求二叉树的深度" class="headerlink" title="1.求二叉树的深度"></a>1.求二叉树的深度</h3><p>leetcode104、《剑指offer》p271</p>
<p>思路：递归</p>
<pre><code class="java">public int treeDepth(TreeNode head){
    if(head==null){
        return 0;
    }
    return Math.max( treeDepth(head.left)+1, treeDepth(head.right)+1 );
}
</code></pre>
<h3 id="2-判断是否为平衡二叉树"><a href="#2-判断是否为平衡二叉树" class="headerlink" title="2.判断是否为平衡二叉树"></a>2.判断是否为平衡二叉树</h3><p>leetcode110、《剑指offer》p271</p>
<p>题目：给一个二叉树，判断是否为平衡二叉树</p>
<p>思路1：遍历树，对每一个节点进行判断是否满足平衡树的条件—&gt;递归重复判断计算，不可取</p>
<pre><code class="java">//判断是否为平衡二叉树
public boolean IsBalanced_Solution(TreeNode root) {
    if(root==null){
        return true;
    }
    int left = getDepth(root.left);
    int right = getDepth(root.right);
    if(Math.abs(left-right)&lt;2){
        return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);
    }
    return false;
}
//求二叉树的深度
public int getDepth(TreeNode root){
    if(root==null){
        return 0;
    }
    return 1 + Math.max(getDepth(root.left), getDepth(root.right));
}
</code></pre>
<p>思路2：后序遍历(左右根)，从下往上依次判断每个节点是否满足平衡二叉树的条件。这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算—&gt;可取</p>
<pre><code class="java">//判断是否为平衡二叉树。好的方法:后序遍历(左右根),从下往上依次判断每个节点是否满足平衡二叉树的条件。
// 这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算
public boolean IsBalanced_Solution(TreeNode root) {
    if(root==null){
        return true;
    }
    if(IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)){
        int left = getDepth(root.left);
        int right = getDepth(root.right);
        if(Math.abs(left-right)&lt;2){
            return true;
        }
    }
    return false;
}
//求二叉树的深度
public int getDepth(TreeNode root){
    if(root==null){
        return 0;
    }
    return 1 + Math.max(getDepth(root.left), getDepth(root.right));
}
</code></pre>
<p><a name="69"></a></p>
<h2 id="69-数组中和为s的数字-四道"><a href="#69-数组中和为s的数字-四道" class="headerlink" title="69.数组中和为s的数字(四道)"></a>69.数组中和为s的数字(四道)</h2><pre><code>数组中和为s的两个数字(有序数组)--《剑指offer》p280
数组中和为s的两个数字(无序数组)--leetcode 1
打印出和为s的所有连续正数序列--《剑指offer》p280
求和为s的所有连续正数序列的总数(转化为找因子的思想)--leetcode 829
</code></pre><h3 id="1-数组中和为s的两个数字-有序数组"><a href="#1-数组中和为s的两个数字-有序数组" class="headerlink" title="1.数组中和为s的两个数字(有序数组)"></a>1.数组中和为s的两个数字(有序数组)</h3><p>《剑指offer》p280</p>
<p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>思路：从数组两端向中间扫，时间o(n)，空间o(1)，当然因为有序可以加一点二分的思想减少比较次数。</p>
<pre><code class="java">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) {
    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
    int resMax = Integer.MAX_VALUE;

    int left = 0;
    int right = array.length-1;
    //left、right往中间扫
    while(left&lt;right){
        int mid = left + (right-left)/2;
        if(array[mid]&gt;=sum){//二分判断，需要往左边找
            right = mid - 1;
            continue;
        }
        int temp = array[left] + array[right];
        if(temp==sum){
            if(array[left]*array[right]&lt;resMax){//看是否乘积最小
                resMax = array[left]*array[right];
                if(!res.isEmpty()){
                    res.clear();
                }
                res.add(array[left]);
                res.add(array[right]);
            }
        }
        if(temp &lt; sum){//左边的数++
            left++;
        }
        else{//右边的数--
            right--;
        }
    }

    return res;
}
</code></pre>
<h3 id="2-数组中和为s的两个数字-无序数组"><a href="#2-数组中和为s的两个数字-无序数组" class="headerlink" title="2.数组中和为s的两个数字(无序数组)"></a>2.数组中和为s的两个数字(无序数组)</h3><p>leetcode 1</p>
<p>题目：Given an array of integers(无序), return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>思路：因为数组无序，因此需要辅助map，时间o(n)，空间o(n)</p>
<pre><code class="java">public int[] twoSum(int[] nums, int target) {
    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
    for(int i=0; i&lt;nums.length; ++i){
        int temp = target - nums[i];
        if(map.containsKey(temp)){
           return new int[]{map.get(temp), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{0,0};
}
</code></pre>
<h3 id="3-打印出和为s的所有连续正数序列"><a href="#3-打印出和为s的所有连续正数序列" class="headerlink" title="3.打印出和为s的所有连续正数序列"></a>3.打印出和为s的所有连续正数序列</h3><p>《剑指offer》p280、leetcode 829</p>
<p>输入一个整数s，打印出所有和为s的连续正数序列(至少含有两个数)</p>
<p>如：输入15，1+2+3+4+5=4+5+6=7+8=15，因此输出{1,2,3,4,5},{4,5,6},{7,8}三个序列</p>
<p>思路：</p>
<p>思路：</p>
<pre><code>    从递增数组中两个和为s的数得到启示，设置两个变量，一个记录当前序列的最小的数small，一个记录当前序列的最大的数big。
    初始化small=0,big=1
    若是当前的正数序列之和小于S，big++
    若是当前的正数序列之和大于S，small++
    因为和为s的序列至少包括两个数，所以small要小于等于s的一半
</code></pre><p>代码：</p>
<pre><code class="java">//和为s的连续整数序列
public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) {
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if(sum&lt;3){
        return res;
    }
    int small = 1;
    int big = 2;
    int tempRes = small+big;//当前序列的和
    ArrayList&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();//缓存当前序列
    tempList.add(small);
    tempList.add(big);
    while(small &lt;= sum/2){//至少两个数的和为sum，所以small不能超过sum的一半
        if(tempRes&lt;=sum){
            if(tempRes==sum){
                res.add(new ArrayList&lt;&gt;(tempList));
            }
            big++;
            tempRes += big;
            tempList.add(big);
        }
        else if(tempRes&gt;sum){
            tempRes-=small;
            tempList.remove((Object)small);
            small++;
        }
    }
    return res;
}
</code></pre>
<h3 id="4-求和为s的所有连续正数序列的总数-转化为找因子的思想"><a href="#4-求和为s的所有连续正数序列的总数-转化为找因子的思想" class="headerlink" title="4.求和为s的所有连续正数序列的总数(转化为找因子的思想)"></a>4.求和为s的所有连续正数序列的总数(转化为找因子的思想)</h3><p>leetcode 829</p>
<p>题目：Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? 和为s的连续整数序列一共有多少种。和为s的连续整数序列一共有多少种，题目中N特别大，o(n)会超时，因此必须o(logn)。</p>
<pre><code>    Input: 5
    Output: 2
    Explanation: 5 = 5 = 2 + 3
</code></pre><p>思路：变型求和公式转化问题，时间o(logn)，空间o(1)。</p>
<p>详细思路： 连续数列的求和公式–&gt;（n1+n2)*(n2-n1+1)=2*N，(n1&lt;n2)，其中(n1+n2)和(n2-n1+1)一定要是2*N的因子，因此<strong>转化成求2*N的因子的问题</strong>，将时间复杂度控制在了O(logn)</p>
<pre><code class="java">public int consecutiveNumbersSum(int N) {
    int res = 1;//一共有res种方法，本身也算一种，因此初始为1
    int target = 2*N;
    int index = (int)Math.sqrt(target);

    for(int i=2; i&lt;=index; ++i){//从2遍历到index找target的因子，直接优化到了o(logn)
        if(target%i==0){//i是target的一个因子
            //两元一次方程解出n1、n2，注意n1&lt;n2
            int n2 = (i+target/i-1)/2;
            int n1 = target/i-n2;
            if(n1&lt;n2 &amp;&amp; (n1 + n2)*(n2 - n1 + 1)==target){//找到一个从n1~n2的连续序列和为s
                res++;
            }
        }
    }
    return res;
}
</code></pre>
<p><a name="70"></a></p>
<h2 id="70-翻转字符串-两道"><a href="#70-翻转字符串-两道" class="headerlink" title="70.翻转字符串(两道)"></a>70.翻转字符串(两道)</h2><pre><code>    给定一句话，翻转这句话的单词顺序(单词不变)--《剑指offer》p284、leetcode 151
    左旋转字符串(abcXYZdef循环左移3位--&gt;XYZdefabc)--《剑指offer》p284
</code></pre><h3 id="1-翻转一句话的单词顺序-单词不变"><a href="#1-翻转一句话的单词顺序-单词不变" class="headerlink" title="1.翻转一句话的单词顺序(单词不变)"></a>1.翻转一句话的单词顺序(单词不变)</h3><p>《剑指offer》p284、leetcode 151</p>
<p>题目：给定一句话，翻转这句话的单词顺序(单词不变)</p>
<p>思路：先split(“ “)成数组，再反着拼装即可。时间o(n)，空间o(n)</p>
<pre><code class="java">public String reverseWords(String s) {
    String[] strs = s.split(&quot; &quot;);
    StringBuilder res = new StringBuilder();
    for(int i=strs.length-1; i&gt;=0; --i){
        if(strs[i].equals(&quot;&quot;)){
            continue;
        }
        res.append(strs[i] + &quot; &quot;);
    }
    return res.toString().trim();
}
</code></pre>
<h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2.左旋转字符串"></a>2.左旋转字符串</h3><p>《剑指offer》p284</p>
<p>题目：左旋转字符串(abcXYZdef循环左移3位–&gt;XYZdefabc)</p>
<p>思路1(不可取): 用substring()函数拼接即可，当然substring()会依赖辅助空间。</p>
<pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabc
public static String LeftRotateString(String str,int n) {
    if(n&lt;1 || str==null || str.length()&lt;2){
        return str;
    }
    return str.substring(n) + str.substring(0,n);
}
</code></pre>
<p>思路2(可取): 当不能用substring()去依赖辅助空间时，直接在原字符串上修改。分成需要移位的左边和剩下右边的两部分，<strong>先将这两部分分别翻转，然后再整个翻转即可</strong>。时间o(n)，空间o(1)</p>
<pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabc
public static String LeftRotateString(String str,int n) {
    if(n&lt;1 || str==null || str.length()&lt;2){
        return str;
    }
    char[] chs = str.toCharArray();
    reverse(chs, 0, n-1);
    reverse(chs, n, chs.length-1);
    reverse(chs,0,chs.length-1);
    return String.valueOf(chs);
}
//翻转一个字符串：首尾向中间扫，字符互换即可
private static void reverse(char[] str, int start, int end){
    if(start&gt;=end){
        return;
    }
    while(start&lt;end){
        char temp = str[start];
        str[start] = str[end];
        str[end] = temp;
        start++;
        end--;
    }
}
</code></pre>
<p><a name="71"></a></p>
<h2 id="71-滑动窗口最大值-双端队列"><a href="#71-滑动窗口最大值-双端队列" class="headerlink" title="71.滑动窗口最大值(双端队列)"></a>71.滑动窗口最大值(双端队列)</h2><p>《剑指offer》p288、《左神》19、leetcode239</p>
<p>题目：滑动窗口的最大值。给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。如{2,3,4,2,6,2,5,1}及滑动窗口的大小3，最大值分别为{4,4,6,6,6,5}</p>
<p>思路：双端队列。滑动窗口先进先出因此借助双端队列，使用队列保存数组的下标，从头遍历数组，根据如下规则进行入队、出队：  </p>
<pre><code>0. 如果队列为空，则当前数字入队列
1. 如果当前数字大于队列尾，则删除队列尾，然后当前数字入队列
2. 如果当前数字小于等于队列尾，则当前数字入队列
3. 如果队列头超出滑动窗口范围，则删除队列头
4. 这样能始终保证队头为当前的最大值
5. 时间o(n)，空间o(k)
</code></pre><p>代码：</p>
<pre><code>//滑动窗口最大值--&gt;双端队列
public static int[] maxSlidingWindow(int[] nums, int k) {
    if(nums==null || nums.length==0 || k&lt;1 || k&gt;nums.length){
        return new int[0];
    }

    int[] res = new int[nums.length-k+1];//滑动窗口最大值
    int resCnt = 0;
    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();//双端队列,存的不是数组元素，而是下标，便于判断滑动窗口位置
    for (int i=0; i&lt;nums.length; ++i){//遍历数组
        if(!deque.isEmpty() &amp;&amp; deque.getFirst()+k==i){//进行滑动窗口:双端队列的头部已经不在窗口中，头部出队
            deque.pollFirst();
        }
        while(!deque.isEmpty() &amp;&amp; nums[i]&gt;nums[deque.getLast()]){//如果当前数比双端队列的尾部大，则一直pollLast，直到当前数比尾部小或相等
            deque.pollLast();
        }
        deque.offerLast(i);

        if(i+1&gt;=k){//存储当前窗口最大值
            res[resCnt++] = nums[deque.getFirst()];
        }
    }
    return res;
}
</code></pre><p><a name="72"></a></p>
<h2 id="72-打印n个骰子所有可能的点数和及概率"><a href="#72-打印n个骰子所有可能的点数和及概率" class="headerlink" title="72.打印n个骰子所有可能的点数和及概率"></a>72.打印n个骰子所有可能的点数和及概率</h2><p>《剑指offer》p294.</p>
<p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s，输入n，打印出s的所有可能的值出现的概率。示例如下(n=2)：</p>
<pre><code>2个骰子，点数和为2出现的概率为: 0.027777777777777776
2个骰子，点数和为3出现的概率为: 0.05555555555555555
2个骰子，点数和为4出现的概率为: 0.08333333333333333
2个骰子，点数和为5出现的概率为: 0.1111111111111111...
</code></pre><p>递归思路：</p>
<pre><code class="python">def getsumcount(self, number, summ):
    if number &lt; 1 or summ &lt; number or summ &gt; 6 * number:
        return 0
    if number == 1:
        return 1
    resCount = 0
    resCount = self.getsumcount(number-1, summ-1)+self.getsumcount(number-1, summ-2)+self.getsumcount(number-1, summ-3)+self.getsumcount(number-1, summ-4)+self.getsumcount(number-1, summ-5)+self.getsumcount(number-1, summ-6)
    return resCount
def po(self, number):
    total = pow(6, number)
    for i in range(number, 6*number+1):
        res = self.getsumcount(number, i)
        ratio = res/total
        print(i, ratio)
</code></pre>
<p>循环思路：<strong>先算所有出现的点数和及出现次数，再算概率(出现次数/6^number)。一个一个骰子往上加，辅助两个数组交替着存所有出现的点数和为n的出现次数，resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</strong></p>
<p>详细思路(可以不看了，初学看)：n个骰子的总点数，最小为n，最大为6n，n个骰子出现的所有点数排列的个数为6^n。我们先统计每一个点数和出现的次数，定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组的第s-n个元素里;然后把每一个点数和出现的次数除以6^n，就能求出每个点数和出现的概率。因此本题重点是统计每一个点数和出现的次数，不难发现这是一种递归的思路，自下而上循环实现,从1个骰子开始，每次加一个骰子计算。用两个数组来存储骰子点数和的每一种出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的综合，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</p>
<p>代码:</p>
<pre><code class="java">//n个骰子的所有出现的点数和及概率。思路：两个数组存所有出现的点数和及出现次数，再算概率。
//详细思路:一个一个骰子往上加，点数和为n的出现次数resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]
public static void printSumRatio(int number){
    if(number&lt;1){
        return;
    }
    //1.辅助两个数组并初始化
    int[][] res = new int[2][6*number+1];//定义两个数组，交换着统计number个骰子所有可能的点数和出现的次数，数组长度为6*n+1
    int resFlag = 0;//交换数组的标志位

    for(int i=1; i&lt;=6; ++i){//当1个骰子时，初始化res数组
        res[resFlag][i] = 1;
    }

    //2.交换着使用两个数组，统计number个骰子所有点数和出现的次数
    for(int i=2; i&lt;=number; ++i){//一个一个骰子往上加
        for(int j=1; j&lt;i; ++j){//当有i个骰子时，[1,i)的点数和为0，全部清空
            res[1-resFlag][j] = 0;
        }
        for(int j=i; j&lt;=6*i; ++j){//当有i个骰子时,给[i,6*i]赋值
            for(int k=1; k&lt;=6&amp;&amp;j&gt;k; ++k){
                res[1-resFlag][j] += res[resFlag][j-k];//resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]
            }
        }

        resFlag = 1-resFlag;//交换数组，改变flag
    }

    //3.计算并打印number个骰子所有可能的点数和及概率
    double totalCount = Math.pow(6, number);//number个骰子出现的不同情况的总次数为6^n次方
    for(int i=number; i&lt;=6*number; ++i){
        double ratio = (double)res[resFlag][i]/totalCount;//点数和为res[i]的概率
        System.out.println(number + &quot;个骰子，点数和为&quot; + i + &quot;出现的概率为&quot; + ratio);
    }
}

public static void main(String[] args){
    printSumRatio(2);
    //out:
    //2个骰子，点数和为2出现的概率为0.027777777777777776
    //2个骰子，点数和为3出现的概率为0.05555555555555555
    //2个骰子，点数和为4出现的概率为0.08333333333333333
    //2个骰子，点数和为5出现的概率为0.1111111111111111
    //2个骰子，点数和为6出现的概率为0.1388888888888889
    //2个骰子，点数和为7出现的概率为0.16666666666666666
    //2个骰子，点数和为8出现的概率为0.1388888888888889
    //2个骰子，点数和为9出现的概率为0.1111111111111111
    //2个骰子，点数和为10出现的概率为0.08333333333333333
    //2个骰子，点数和为11出现的概率为0.05555555555555555
    //2个骰子，点数和为12出现的概率为0.027777777777777776
}
</code></pre>
<p><a name="73"></a></p>
<h2 id="73-扑克牌中的顺子-2道"><a href="#73-扑克牌中的顺子-2道" class="headerlink" title="73.扑克牌中的顺子(2道)"></a>73.扑克牌中的顺子(2道)</h2><pre><code>整个数组是否为一个顺子(同时有大小王)--《剑指offer》p298.
整个数组分组后每组都要为顺子--leetcode 846
</code></pre><h3 id="1-整个数组是否为一个顺子-同时有大小王"><a href="#1-整个数组是否为一个顺子-同时有大小王" class="headerlink" title="1.整个数组是否为一个顺子(同时有大小王)"></a>1.整个数组是否为一个顺子(同时有大小王)</h3><p>《剑指offer》p298.</p>
<p>题目：扑克牌中的顺子：从扑克牌中随机抽5张牌,判断是不是顺子(即这5张牌是不是连续的)。2-10为数字本身，A为1，J、Q、K 为11、12、13，大小王可以看成任意的数字(解题时可以看成0)。</p>
<p>思路：</p>
<pre><code>0.定义长度为numbers的数组(这里不限于解决5张,判断numbers张牌是否为顺子);
1.数组排序；
2.统计数组中0的个数;
3.统计排序后数组相邻数字间的空缺数(eg数字57间空缺1);
4.2、3两步统计的0个数大于等于空缺数--&gt;顺子，否则不是顺子
</code></pre><p>代码：</p>
<pre><code class="java">//判断扑克牌顺子(2张及以上连续),大小王0可以代表任意牌。思路：数组排序,记录大小王的个数，遍历数组判断是否为顺子即可
public static boolean isContinuous(int [] numbers) {
    if(numbers==null || numbers.length&gt;13 || numbers.length&lt;2){
        return false;
    }
    //1.数组排序
    Arrays.sort(numbers);

    //2.记录大小王的个数并判断是否为顺子
    int superCnt = 0;//记录大小王的个数
    int superCntCopy = 0;//保存大小王个数
    for(int i=0; i&lt;numbers.length-1; ++i){
        if(numbers[i]==0){//是大小王
            superCnt++;
            superCntCopy++;
        }
        else if(numbers[i]==numbers[i+1]){//相等，即出现对儿，不是顺子
            return false;
        }
        else if(numbers[i]+1==numbers[i+1]){//连续
            continue;
        }
        else if(numbers[i]+1!=numbers[i+1]){//遇到不连续的牌，看看能不能凑个王
            if( (numbers[i+1]-numbers[i]-1) &lt;= superCnt ){//可以用王凑
                superCnt -= (numbers[i+1]-numbers[i]-1);
            }else{//不够王了
                return false;
            }
        }
    }
    //3.王太多还剩下几张王，放在牌头与牌尾后还剩下王，则不是顺子
    if(superCnt&gt;0 &amp;&amp; superCnt&gt;(numbers[superCntCopy]-numbers[numbers.length-1]+12)){
        return false;
    }
    return true;
}
</code></pre>
<h3 id="2-整个数组分组后每组都要为顺子"><a href="#2-整个数组分组后每组都要为顺子" class="headerlink" title="2.整个数组分组后每组都要为顺子"></a>2.整个数组分组后每组都要为顺子</h3><p>leetcode 846</p>
<p>题目：Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.</p>
<pre><code>Input: hand = [1,2,3,6,2,3,4,7,8], W = 3
Output: true
Explanation: Alice&#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].
</code></pre><p>思路：1.hand长度不能整除W，false;2.hand排序;3.由于[1,2,3],[2,3,4]也可以，需要<strong>辅助数组缓存访问标记</strong>用于后续判断;4.遍历数组一组一组进行判断</p>
<pre><code class="java">public boolean isNStraightHand(int[] hand, int W) {
    //1.hand长度不能整除W，false
    if(hand==null || hand.length==0 || W&lt;1 || W&gt;hand.length || hand.length%W!=0){
        return false;
    }

    //2.hand排序
    Arrays.sort(hand);

    //3.辅助数组缓存访问标记用于后续判断
    boolean[] visited = new boolean[hand.length];

    //4.遍历数组一组一组进行判断
    int cnt = W;
    for(int i=0; i&lt;hand.length; ++i){
        if(!visited[i]){//如果没有被访问过之前，以此为新group的起始位置开始寻找一个group
            visited[i] = true;
            int left = i;
            int right = i+1;
            while(cnt!=1){//寻找一个group
                if(right&gt;=hand.length){//找完了hand都没凑成一个group,false
                    return false;
                }
                if(!visited[right]){
                    if(hand[left]+1&lt;hand[right]){//断层太大，不可能连续了，false
                        return false;
                    }
                    else if(hand[left]+1==hand[right]){//前后连续
                        visited[right] = true;
                        left = right;
                        cnt--;
                    }
                }
                right++;
            }
            //找完了一个group，重置cnt
            cnt = W;
        }
    }
    return true;//找完了所有group，没有返回false说明都符合条件,true
}
</code></pre>
<p><a name="74"></a></p>
<h2 id="74-圆圈中剩下的数-约瑟夫环问题"><a href="#74-圆圈中剩下的数-约瑟夫环问题" class="headerlink" title="74.圆圈中剩下的数(约瑟夫环问题)"></a>74.圆圈中剩下的数(约瑟夫环问题)</h2><p>《剑指offer》p300、《左神》43、leetcode 292</p>
<p>题目：圆圈中最后剩下的数字。0,1…n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字，求出这个圆圈里剩下的最后一个数字。e.g n=5([0,1,2,3,4]),m=3,out:3</p>
<p>思路1：用<strong>双端队列</strong>模拟这个循环环的问题，每排除一个数需要m步运算，n个数就需要O(mn)，空间复杂度为O(n)</p>
<pre><code class="java">//圆圈中剩下的数。思路:用双端队列模拟这个过程，时间o(nm),空间o(n)
public static int LastRemaining_Solution(int n, int m) {
    if(m&lt;1 || n&lt;1){
        return -1;
    }
    if(n==1){
        return 1;
    }

    //1.辅助o(n)双端队列
    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();
    for(int i=0; i&lt;n; ++i){
        deque.offerLast(i);
    }

    //2.模拟弹出过程,直到双端队列中剩下一个数为止
    int cnt = m;
    while(deque.size()&gt;1){
        cnt--;
        if(cnt==0){//弹出一个数，重置cnt
            deque.pollFirst();
            cnt = m;
        }
        else{
            deque.offerLast(deque.pollFirst());
        }
    }
    return deque.pollFirst();
}
</code></pre>
<p>思路2(更好)：分析这个题的数学规律，直接求解:<code>f(n,m)=[(f(n-1,m)+m]%n</code>，时间o(n)，空间o(1)。</p>
<pre><code class="java">//f(n,m)=[(f(n-1,m)+m]%n
//f(n,m)=0(n=1);f(n,m)=[(f(n-1,m)+m)%n](n&gt;1)
public int LastRemaining_Solution(int n, int m) {
    if(m&lt;1 || n&lt;1){
        return -1;
    }
    int res = 0;
    for(int i=2; i&lt;=n; ++i){
        res = (res+m)%i;
    }
    return res;
}
</code></pre>
<p><a name="75"></a></p>
<h2 id="75-股票的最大利润问题-四道"><a href="#75-股票的最大利润问题-四道" class="headerlink" title="75.股票的最大利润问题(四道)"></a>75.股票的最大利润问题(四道)</h2><pre><code>只允许买卖一次股票，求最大收益--《剑指offer》p304、leetcode 121
允许多次买卖，求最大收益--《剑指offer》p304、leetcode 122
只允许买卖两次股票，求最大收益--leetcode 123
只允许买卖k次股票，求最大收益--leetcode 188
</code></pre><h3 id="1-只允许买卖一次股票，求最大收益"><a href="#1-只允许买卖一次股票，求最大收益" class="headerlink" title="1.只允许买卖一次股票，求最大收益"></a>1.只允许买卖一次股票，求最大收益</h3><p>《剑指offer》p304</p>
<p>题目：只允许买卖一次股票，求最大收益</p>
<p>思路：以当前股票为基准，找到之前的最小值，用来更新最大利润。时间o(n)</p>
<pre><code class="java">//股票的最大利润，只允许买卖一次股票，求最大收益。思路:两个变量即可，每天都尝试卖一次，不断更新最大利润。时间o(n),空间o(1)
public int maxProfit(int[] prices) {
    if(prices==null || prices.length&lt;2){
        return 0;
    }
    int min = prices[0];//存之前最小的股价
    int resMax = 0; //存最大的利润
    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润
        resMax = Math.max(resMax, prices[i]-min);
        if(prices[i]&lt;min){
            min = prices[i];
        }
    }
    return resMax;
}
</code></pre>
<h3 id="2-允许多次买卖，求最大收益"><a href="#2-允许多次买卖，求最大收益" class="headerlink" title="2.允许多次买卖，求最大收益"></a>2.允许多次买卖，求最大收益</h3><p>《剑指offer》p304、leetcode 122</p>
<p>题目：允许多次买卖，求最大收益</p>
<p>思路：每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)</p>
<pre><code class="java">//股票的最大利润，允许多次买卖，求最大收益。思路:每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)
public int maxProfit(int[] prices) {
    if(prices==null || prices.length&lt;2){
        return 0;
    }
    int resMax = 0; //存最大的利润
    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润
        int temp = prices[i]-prices[i-1];
        if(temp&gt;0){
            resMax += temp;
        }
    }
    return resMax;
}
</code></pre>
<h3 id="3-只允许买卖两次股票，求最大收益"><a href="#3-只允许买卖两次股票，求最大收益" class="headerlink" title="3.只允许买卖两次股票，求最大收益"></a>3.只允许买卖两次股票，求最大收益</h3><p>leetcode 123</p>
<p>题目：只允许买卖两次股票，求最大收益</p>
<p>思路：3、4两题可以用DP解决，但是这里用更巧妙的方法，直接看第4题即可，本题的解法就是第4题的k=2</p>
<h3 id="4-只允许买卖k次股票，求最大收益"><a href="#4-只允许买卖k次股票，求最大收益" class="headerlink" title="4.只允许买卖k次股票，求最大收益"></a>4.只允许买卖k次股票，求最大收益</h3><p>leetcode 188</p>
<p>题目：只允许买卖k次股票，求最大收益</p>
<p>思路：3、4两题都用二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益。</p>
<pre><code class="java">//k次买卖的最大股票收益。思路：二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益
public int maxProfit(int k, int[] prices) {
    int len = prices.length;
    if (k &gt;= len / 2) return quickSolve(prices);//可以最多次买卖，求最大收益即可

    int[][] t = new int[k + 1][len];
    for (int i = 1; i &lt;= k; i++) {
        int tmpMax =  -prices[0];//tmpMax就是自己的钱包，就是当前的收益
        for (int j = 1; j &lt; len; j++) {
            t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);//卖
            tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);//买
        }
    }
    return t[k][len - 1];
}

//允许多次买卖，把所有的收益都加起来即可
private int quickSolve(int[] prices) {
    int len = prices.length, profit = 0;
    for (int i = 1; i &lt; len; i++)
        // as long as there is a price gap, we gain a profit.
        if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];
    return profit;
}
</code></pre>
<p><a name="76"></a></p>
<h2 id="76-求1-2-3-…-n"><a href="#76-求1-2-3-…-n" class="headerlink" title="76.求1+2+3+…+n"></a>76.求1+2+3+…+n</h2><p>《剑指offer》p307.</p>
<p>题目：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>思路：递归。</p>
<p>这里可以通过递归的方式进行计算，<strong>但是很疑问的地方在于如何结束递归</strong><br>​<br>这里可以有多种的方式，基本方向是采用逻辑与或的方式来计算，</p>
<p><strong>用或运算通过n==0来短路，这样在n=0的时候不需要计算递归的值</strong></p>
<pre><code class="java">public static int Sum_Solution(int n) {
    int res = 0;
    boolean b = n==0 || (res=n+Sum_Solution(n-1))&gt;0;
    return res;
}
</code></pre>
<p><a name="77"></a></p>
<h2 id="77-构建乘积数组"><a href="#77-构建乘积数组" class="headerlink" title="77.构建乘积数组"></a>77.构建乘积数组</h2><p>《剑指offer》p312、leetcode 238</p>
<p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],</p>
<p>其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p>
<p>思路1(不可取)：如果没有不能使用除法的限制,可以用公式B[i]=A[0]*A[1]*…..*A[n-1]/A[i]表示,使用除法时要特别注意A[i]等于0的情况。时间o(n)，空间o(1)，但是这里不能用除法</p>
<p>思路2(不可取)：现在要求不能使用除法，一个直观的解法是用连乘n-1个数字得到B[i]，时间o(n^2)</p>
<p>思路3(可取)：辅助一个数组temp[]的思想(但这里就用B做辅助数组)，时间o(n),空间o(1)</p>
<p>1.先从后往前存储(temp[i]=A[i]*A[i+1]*…A[length-1])，此时先将B[]看成辅助数组temp[]</p>
<p>2.再从前往后计算(tempRes=A[0],B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]…)</p>
<p>代码：</p>
<pre><code class="java">public int[] multiply(int[] A) {
    if(A==null || A.length==0){
        return new int[0];
    }
    int[] B = new int[A.length];//存放结果，但从后往前计算时先将B看成辅助数组

    //1.1.先从后往前存储(temp[i]=A[i]*A[i+1]*...A[length-1])，此时先将B[]看成辅助数组
    B[A.length-1] = A[A.length-1];
    for(int i=A.length-2; i&gt;=0; i--){
        B[i] = B[i+1] * A[i];
    }

    //2.再从前往后计算(tempRes=1,B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]...)
    int tempRes = 1;
    for(int i=0; i&lt;A.length-1; ++i){
        B[i] = tempRes * B[i+1];
        tempRes *= A[i];
    }

    B[A.length-1] = tempRes;//最后一个元素

    return B;
}
</code></pre>
<p><a name="78"></a></p>
<h2 id="78-普通二叉树中两个节点的最低公共祖先"><a href="#78-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="78.普通二叉树中两个节点的最低公共祖先"></a>78.普通二叉树中两个节点的最低公共祖先</h2><p>《剑指offer》p326、leetcode 236</p>
<p>题目：普通二叉树中两个节点的最低公共祖先</p>
<p>思路1(不可取)：从root开始寻找</p>
<p>如果当前节点的左子节点是两个节点的祖先(应该继续对左子节点判断)</p>
<p>如果当前节点的右子节点是两个节点的祖先(应该继续对右子节点判断)</p>
<p>当前结点不同时为两个结点的祖先(一边一个)，即为最低公共祖先</p>
<p>这种方法自上而下重复遍历，不太好</p>
<pre><code class="java">class TreeNode {
    int val;
    TreeNode left = null;
    TreeNode right = null;
    TreeNode(int val) {
        this.val = val;
    }
}
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (hasNode(root.left, p) &amp;&amp; hasNode(root.left, q)) {
        return lowestCommonAncestor(root.left, p, q);
    } else if (hasNode(root.right, p) &amp;&amp; hasNode(root.right, q)) {
        return lowestCommonAncestor(root.right, p, q);
    }
    return root;
}

//遍历以root为根的树，判断是否含有节点p
public boolean hasNode(TreeNode root, TreeNode p) {
    if (root == null) {
        return false;
    }
    if (root == p) {
        return true;
    }
    return hasNode(root.left, p) || hasNode(root.right, p);
}
</code></pre>
<p>思路2(可取)：遍历两次树，分别找出从root到两个节点的路径(用两个List存下来)，变成求两个list中的最后一个公共结点</p>
<pre><code class="java">//普通二叉树中两个节点的最低公共祖先
public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q){
    if(root==null || p==null || q==null){
        return null;
    }
    ArrayList&lt;TreeNode&gt; arrayListP = new ArrayList&lt;&gt;();
    ArrayList&lt;TreeNode&gt; arrayListQ = new ArrayList&lt;&gt;();//两个List存路径
    if(!findPath(root,p,arrayListP) || !findPath(root,q,arrayListQ)){//没找到p、q
        return null;
    }

    int index = 0;
    while(index&lt;arrayListP.size() &amp;&amp; index&lt;arrayListQ.size()){//对两个路径list找最后一个公共节点
        if(arrayListP.get(index)!=arrayListQ.get(index)){
            break;
        }
        index++;
    }
    return index==0 ? root: arrayListP.get(index-1);
}
//遍历二叉树，找root到target节点的路径(路径存在res中)，如果没找到target返回true
public boolean findPath(TreeNode root, TreeNode target, ArrayList&lt;TreeNode&gt; res){
    if(root==null){
        return false;
    }
    res.add(root);
    if(root==target){
        return true;
    }
    if (findPath(root.left, target, res) || findPath(root.right, target, res)){
        return true;
    }
    res.remove(res.size()-1);//回溯
    return false;
}
</code></pre>
<p><a name="79"></a></p>
<h2 id="79-把字符串转换成整数"><a href="#79-把字符串转换成整数" class="headerlink" title="79.把字符串转换成整数"></a>79.把字符串转换成整数</h2><p>《剑指offer》p318、leetcode 8</p>
<p>题目：把字符串(包括数字字母符号,可以为空)转换成整数，不符合条件返回0。<br>即实现Integer.valueOf(string)的功能，要求不能使用字符串转换整数的库函数</p>
<p>思路：字符串转换成数组，res用long，从前往后遍历即可，本题核心是对以下情况的处理</p>
<p>要点：</p>
<pre><code>1.字母判断
2.溢出
3.正负号
</code></pre><p>代码：</p>
<pre><code class="java">public int myAtoi(String str){
    if(str==null || str.trim().length()==0){
        return 0;
    }

    char[] chs = str.trim().toCharArray();//转换成数组
    boolean isPositive = true;//正负号
    int index = 0;
    long res = 0;

    if(chs[index]==&#39;+&#39; || chs[index]==&#39;-&#39;){
        isPositive = chs[index]==&#39;-&#39; ? false : true;
        index++;
    }

    while(index&lt;chs.length){
        int temp = chs[index]-&#39;0&#39;;
        if(temp&lt;0||temp&gt;9){//是否是数字判断
            return 0;//这里在leetoce中应该为break，题目要求有一点点不一样
        }
        res = res*10L + (long)temp;
        index++;
        if(isPositive==true){//溢出判断
            if(res&gt;Integer.MAX_VALUE){
                return Integer.MAX_VALUE;
            }
        }
        else{
            if(res*(-1L)&lt;Integer.MIN_VALUE){
                return Integer.MIN_VALUE;
            }
        }
    }

    return isPositive==true ? (int)res : (int)res*(-1);//正负号判断
}
</code></pre>

      
       <hr><span style="font-style: italic;color: gray;"> 欢迎转载，欢迎错误指正与技术交流，欢迎交友谈心 </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">赏</a>
</p>


<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>剑指offer刷题</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">49.7k</span></p>
    <p><span class="copy-title">本文作者:</span>Brain Cao</p>
    <p><span class="copy-title">发布时间:</span>2018-09-21, 17:32:47</p>
    <p><span class="copy-title">最后更新:</span>2020-02-22, 14:21:33</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2018/09/21/sword-offer-algorithm/" title="剑指offer刷题">https://braincao.cn/2018/09/21/sword-offer-algorithm/</a>
    <p>
        <span class="copy-title">版权声明:</span>本文为博主原创文章，遵循 <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank"><i class="fa fa-creative-commons"></i> BY-NC-SA 4.0 版权协议</a>，转载请保留原文链接与作者。
    </p>
</div>





    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2016-2020 Braincao</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>喜欢请收藏,疼爱就打赏</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">支付宝</label></span><span><label><input type="radio" name="pay" value="weixin">微信</label></span>
    </div>
</div>


</body>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#前端','#博客','#hexo','#gitee','#算法刷题','#DFS','#动态规划','#投资理财','#git','#hosts','#github','#计网','#java','#leetcode','#linux','#职业管理','#多线程','#数据库','#面经','#python','#排序算法','#spring','#技术之外',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().split('\n').length - 1, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0px;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: #fafafa;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 552px;
    }
    .nav.fullscreen {
        margin-left: -552px;
    }
    .nav-left {
        width: 130px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
