<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Braincao&#39;s Blog</title>
      <link href="/2020/02/21/blog-index/"/>
      <url>/2020/02/21/blog-index/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>本博客主要记录技术相关的学习笔记与总结，少量包含阶段性节点的成长轨迹与人生思索。它不像微信收藏那样碎片化，也不像商业博文太过公开，它是可自由控制且更为专业性的私人空间。</p><p>所有博文中，绝大多数为原创或有自我沉淀部分，价值高低个人不做评判，因为分享的同时也在收获自己。</p><p>由于第三方评论插件安全性不足，关闭了评论功能，如需联系我请查看关于页面。当然，本博主随时可接受金钱勾引，在每页最下方点击神奇按钮即可启动资本关怀，这是我最大的动力。</p><h2 id="实时统计"><a href="#实时统计" class="headerlink" title="实时统计"></a>实时统计</h2><p>截至目前，本人已写 <code class="article_number"></code> 篇文章， 共 <code class="site_word_count"></code> 字，</p><p>本站访问人数：<code class="site_uv"></code>人次 ， 访问量：<code class="site_pv"></code>次</p><h2 id="博客功能"><a href="#博客功能" class="headerlink" title="博客功能"></a>博客功能</h2><ul><li>搜索支持文章标题、标签(#标签)、全文搜索(in:)</li><li>pad/手机等移动端适配</li><li>页面全局vim式快捷键，快捷键说明如下</li></ul><table><thead><tr><th align="center">key</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">s/S</td><td align="center">全屏/取消全屏</td></tr><tr><td align="center">w/W</td><td align="center">显示/关闭文章目录</td></tr><tr><td align="center">gg/GG</td><td align="center">到页顶</td></tr><tr><td align="center">shift+G/g</td><td align="center">到页尾</td></tr><tr><td align="center">j/J</td><td align="center">向下滑动</td></tr><tr><td align="center">k/K</td><td align="center">向上滑动</td></tr><tr><td align="center">i/I</td><td align="center">启动搜索</td></tr><tr><td align="center">ESC</td><td align="center">若搜索框有内容，清除内容； 若搜索框无内容，取消搜索</td></tr><tr><td align="center">上</td><td align="center">向上选择文章</td></tr><tr><td align="center">下</td><td align="center">向下选择文章</td></tr><tr><td align="center">回车</td><td align="center">打开当前选中的文章，默认打开第一个</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速github访问速度</title>
      <link href="/2020/02/20/github-hosts/"/>
      <url>/2020/02/20/github-hosts/</url>
      
        <content type="html"><![CDATA[<p>通过修改hosts，解决github访问慢及加载不出头像问题</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>github访问慢及加载不出头像问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>在<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>网站查下列域名对应的IP地址，如果同一个域名有好几个ip，那就ping一下选个速度最快的。</p><p>修改hosts，<code>sudo vi /etc/hosts</code>，添加下面域名解析，再刷新dns：<code>sudo killall -HUP mDNSResponder</code></p><pre><code>#解决git clone 速度慢的问题,这个不要动192.30.253.112 github.com151.101.185.194 github.global.ssl.fastly.net#下面的实时查192.30.253.119 gist.github.com199.232.28.133 assets-cdn.github.com199.232.28.133 raw.githubusercontent.com199.232.28.133 gist.githubusercontent.com199.232.28.133 cloud.githubusercontent.com199.232.28.133 camo.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 avatars4.githubusercontent.com199.232.28.133 avatars5.githubusercontent.com199.232.28.133 avatars6.githubusercontent.com199.232.28.133 avatars7.githubusercontent.com199.232.28.133 avatars8.githubusercontent.com#解决浏览器下载master-zip包的问题140.82.113.10 codeload.github.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hosts </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左神刷题</title>
      <link href="/2018/09/21/leftgod-algorithm/"/>
      <url>/2018/09/21/leftgod-algorithm/</url>
      
        <content type="html"><![CDATA[<p>此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetcode题目，尽量都留存了最优解，部分简单的题目没有进行总结。</p><a id="more"></a><p>此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetcode题目，尽量都留存了最优解，部分简单的题目没有进行总结。左神的书——《程序员代码面试指南》</p><h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">按照左右半区的方式重新组合单链表</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">用递归函数和栈操作逆序栈</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">猫狗队列</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">用一个栈来实现另一个栈的排序</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">汉诺塔问题</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">构造数组的MaxTree</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">最大子矩阵(直方图-栈)</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">找两个排序数组的中位数</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">删除链表中的节点(两道)</a></td></tr><tr><td align="center">10</td><td align="center"><a href="#10">找到/删除链表的中间节点(两道)</a></td></tr><tr><td align="center">11</td><td align="center"><a href="#11">删除链表a/b处的节点</a></td></tr><tr><td align="center">12</td><td align="center"><a href="#12">判断一个链表是否为回文结构</a></td></tr><tr><td align="center">13</td><td align="center"><a href="#13">将单链表按某值划分成左边小，中间相等，右边大</a></td></tr><tr><td align="center">14</td><td align="center"><a href="#14">单链表的归并排序</a></td></tr><tr><td align="center">15</td><td align="center"><a href="#15">单链表的快速排序</a></td></tr><tr><td align="center">16</td><td align="center"><a href="#16">单链表的选择排序</a></td></tr><tr><td align="center">17</td><td align="center"><a href="#17">两个链表生成相加链表</a></td></tr><tr><td align="center">18</td><td align="center"><a href="#18">删除单链表的重复节点(三道)</a></td></tr><tr><td align="center">19</td><td align="center"><a href="#19">向有序的环形单链表中插入新节点</a></td></tr><tr><td align="center">20</td><td align="center"><a href="#20">打印二叉树的边界节点</a></td></tr><tr><td align="center">21</td><td align="center"><a href="#21">编辑距离</a></td></tr><tr><td align="center">22</td><td align="center"><a href="#22">找出数组中左边比他小右边比他大的所有元素</a></td></tr><tr><td align="center">23</td><td align="center"><a href="#23">判断二叉树为BST(二叉搜索树)</a></td></tr><tr><td align="center">24</td><td align="center"><a href="#24">Replace Words(字典树应用)</a></td></tr><tr><td align="center">25</td><td align="center"><a href="#25">BFS/DFS思想</a></td></tr><tr><td align="center">26</td><td align="center"><a href="#26">BFS相关题目(1道)</a></td></tr><tr><td align="center">27</td><td align="center"><a href="#27">DFS相关题目(4道)</a></td></tr><tr><td align="center">28</td><td align="center"><a href="#28">图的几种最短路算法(4道)</a></td></tr><tr><td align="center">29</td><td align="center"><a href="#29">Word Ladder(2道)(SPFA最短路算法应用)</a></td></tr><tr><td align="center">30</td><td align="center"><a href="#30">字符串匹配(kmp算法)</a></td></tr><tr><td align="center">31</td><td align="center"><a href="#31">两数相除(转为减法)</a></td></tr><tr><td align="center">32</td><td align="center"><a href="#32">sqrt(x)</a></td></tr><tr><td align="center">33</td><td align="center"><a href="#33">乱序的数组中找到最长的递增子序列</a></td></tr><tr><td align="center">34</td><td align="center"><a href="#34">蓄水池问题</a></td></tr><tr><td align="center">35</td><td align="center"><a href="#35">满足指定sum条件的长度最小的子数组</a></td></tr><tr><td align="center">36</td><td align="center"><a href="#36">最大值减去最小值小于或等于num的子数组数量</a></td></tr><tr><td align="center">37</td><td align="center"><a href="#37">几道未整理的</a></td></tr></tbody></table><h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p><h2 id="1-按照左右半区的方式重新组合单链表"><a href="#1-按照左右半区的方式重新组合单链表" class="headerlink" title="1.按照左右半区的方式重新组合单链表"></a>1.按照左右半区的方式重新组合单链表</h2><p>《左神》86、牛客网有编程挑战题</p><p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。</p><pre><code>1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5 </code></pre><p>要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p><p>思路：遍历两遍链表，先找到左半区的最后一个节点，再左右半区重新拼接链表。时间O(N)，空间O(1)</p><pre><code class="java">public static void relocateList(ListNode head) {    if(head==null || head.next==null || head.next.next==null || head.next.next.next==null){        return;    }    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode left = guard.next;//左半区    ListNode right;//左半区的最后一个节点    //1.遍历一遍链表，找到左半区的最后一个节点    ListNode fast = guard;    ListNode low = guard;    while(fast.next!=null &amp;&amp; fast.next.next!=null){//fast走两步，low走一步        fast = fast.next.next;        low = low.next;    }    right = low;//找到了左半区的最后一个节点    //2.再左右半区重新拼接链表    ListNode rightCopy = right;//缓存左半区的最后一个节点    while(left!=rightCopy){        //1.剥离当前节点        ListNode temp = right.next;        right.next = temp.next;        temp.next = null;        //2.拼接左右半区节点        temp.next = left.next;        left.next = temp;        left = left.next.next;    }}</code></pre><p><a name="2"></a></p><h2 id="2-用递归函数和栈操作逆序栈"><a href="#2-用递归函数和栈操作逆序栈" class="headerlink" title="2.用递归函数和栈操作逆序栈"></a>2.用递归函数和栈操作逆序栈</h2><p>《左神》8</p><p>题目：一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函数来实现，而不能用另外的数据结构。</p><p>思路：两个递归函数搞定</p><pre><code class="java">import java.util.Stack;//用递归函数和栈操作逆序栈public class ReverseStack {    //逆序栈元素    public void reverseStackRecursively(Stack&lt;Integer&gt; stack) {        if(stack.isEmpty()){            return;        }        int bottom = getAndDelBottom(stack);        reverseStackRecursively(stack);        stack.push(bottom);    }    //删除并返回栈底元素    public int getAndDelBottom(Stack&lt;Integer&gt; stack){        int curData = stack.pop();        if(stack.isEmpty()){            return curData;        }        else{            int last = getAndDelBottom(stack);            stack.push(curData);            return last;        }    }}</code></pre><p><a name="3"></a></p><h2 id="3-猫狗队列"><a href="#3-猫狗队列" class="headerlink" title="3.猫狗队列"></a>3.猫狗队列</h2><p>《左神》10</p><p>题目：实现一种狗猫队列的结构，要求如下：</p><p>（1）用户可以调用add方法将cat类或dog类的实例放入队列中；</p><p>（2）用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出；</p><p>（3）用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出；</p><p>（4）用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出；</p><p>（5）用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例；</p><p>（6）用户可以调用isDogEmpty方法，检查队列中是否还有dog类的实例；</p><p>（7）用户可以调用isCatEmpty方法，检查队列中是否还有cat类的实例。</p><p>思路：新定义带时间戳的Pet类(PetEnterQue)，然后用两个队列(dogQue\catQue)结合时间戳来定义新类(dogCatQue)，猫狗队列就是这个类的一个实例</p><pre><code class="java">import java.util.LinkedList;import java.util.Queue;/** * 猫狗队列。 */public class Pet {    private String type;    public Pet(String type) {        this.type = type;    }    public String getPetType() {        return type;    }}public class Dog extends Pet{    public Dog() {        super(&quot;dog&quot;);    }}public class Cat extends Pet{    public Cat() {        super(&quot;cat&quot;);    }}//新定义一个带时间戳的Pet类public class PetEnterQue{    private Pet pet;    private long count; //时间戳    public PetEnterQue(Pet pet, long count) {        this.pet = pet;        this.count = count;    }    public Pet getPet() {        return pet;    }    public long getCount() {        return count;    }}//这个类的实例就是一个猫狗队列public class dogCatQue{    private Queue&lt;PetEnterQue&gt; dogQue;    private Queue&lt;PetEnterQue&gt; catQue;    private long count;    public dogCatQue(){        dogQue = new LinkedList&lt;&gt;();        catQue = new LinkedList&lt;&gt;();        count = 0;    }    public void offer(Pet pet){        if(pet.getPetType().equals(&quot;dog&quot;)){            dogQue.offer(new PetEnterQue(pet, count++));        }        else{            catQue.offer(new PetEnterQue(pet, count++));        }    }    public Pet pollDog(){        if(dogQue.isEmpty()){            return null;        }        return dogQue.poll().getPet();    }    public Pet pollCat(){        if(catQue.isEmpty()){            return null;        }        return catQue.poll().getPet();    }    public Pet pollAll(){        if(dogQue.isEmpty()){            if(!catQue.isEmpty()){                return catQue.poll().getPet();            }        }        else if(catQue.isEmpty()){            if(!dogQue.isEmpty()){                return dogQue.poll().getPet();            }        }        else{//比较时间戳，将早进队列的Pet出队            return dogQue.peek().getCount()&gt;catQue.peek().getCount()? catQue.poll().getPet() :dogQue.poll().getPet();        }        return null;    }    public boolean isEmpty(){        return dogQue.isEmpty() &amp;&amp; catQue.isEmpty();    }    public boolean isDogEmpty(){        return dogQue.isEmpty();    }    public boolean isCatEmpty(){        return catQue.isEmpty();    }}</code></pre><p><a name="4"></a></p><h2 id="4-用一个栈来实现另一个栈的排序"><a href="#4-用一个栈来实现另一个栈的排序" class="headerlink" title="4.用一个栈来实现另一个栈的排序"></a>4.用一个栈来实现另一个栈的排序</h2><p>《左神》13</p><p>题目：在一个栈中元素的类型为整型，现在想将该栈从栈顶到栈底按从大到小的顺序排序，只许申请一个栈，除此之外，可以申请其他变量，但是不能申请额外的数据结构。</p><pre><code class="java">//用一个栈来实现另一个栈的排序public static void sortStackByStack(Stack&lt;Integer&gt; stack){    Stack&lt;Integer&gt; help = new Stack&lt;&gt;();    while(!stack.isEmpty()){        int temp = stack.pop();        while(!help.isEmpty() &amp;&amp; temp&gt;help.peek()){            stack.push(help.pop());        }        help.push(temp);    }    while(!help.isEmpty()){        stack.push(help.pop());    }}public static void main(String[] args){    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    stack.push(4);    stack.push(3);    stack.push(76);    stack.push(5);    stack.push(8);    stack.push(9);    System.out.println(stack);    sortStackByStack(stack);    System.out.println(stack);}</code></pre><p><a name="5"></a></p><h2 id="5-汉诺塔问题-两道"><a href="#5-汉诺塔问题-两道" class="headerlink" title="5.汉诺塔问题(两道)"></a>5.汉诺塔问题(两道)</h2><h3 id="1-正常汉诺塔：可以直接从左移到右，不需经过中间"><a href="#1-正常汉诺塔：可以直接从左移到右，不需经过中间" class="headerlink" title="1.正常汉诺塔：可以直接从左移到右，不需经过中间"></a>1.正常汉诺塔：可以直接从左移到右，不需经过中间</h3><p><strong>法一递归(常用这个)：</strong></p><pre><code class="java">//汉诺塔tower of hanoi问题。法一:递归public static void towerOfHanoi(int n) {    move(&quot;left&quot;, &quot;right&quot;, &quot;mid&quot;, n);}public static void move(String start, String end, String buffer, int n){    if(n==1){        System.out.println(&quot;from &quot; + start + &quot; to &quot; + end);        return;    }    move(start, buffer, end, n-1); //将1-n-1移动到buffer，即缓冲区    System.out.println(&quot;from &quot; + start + &quot; to &quot; + end); //将n移动到目标柱子上    move(buffer, end, start, n-1); // 将1-n-1移动到目标柱子上}public static void main(String[] args){    towerOfHanoi(3);    //out:    //from left to right    //from left to mid    //from right to mid    //from left to right    //from mid to left    //from mid to right    //from left to right}</code></pre><p>法二用栈：</p><pre><code class="java">public class HanoiStack {    public static void main(String[] args) {        Stack hanoi = new Stack();        hanoi.push(new Problem(4, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;));        Problem myProblem = null;        while (!hanoi.isEmpty() &amp;&amp; (myProblem = (Problem) hanoi.pop()) != null) {            if (myProblem.n == 1) {                System.out.println(myProblem.A+&quot;-&gt;&quot;+myProblem.C);            } else {                hanoi.push(new Problem(myProblem.n-1, myProblem.B, myProblem.A, myProblem.C));                hanoi.push(new Problem(1, myProblem.A, myProblem.B, myProblem.C));                hanoi.push(new Problem(myProblem.n-1, myProblem.A, myProblem.C, myProblem.B));            }        }    }}class Problem {    int n;    char A, B, C;    public Problem(int n, char A, char B, char C) {        this.n = n;        this.A = A;        this.B = B;        this.C = C;    }}</code></pre><h3 id="2-特殊汉诺塔：不可以直接从左移到右，必须经过中间"><a href="#2-特殊汉诺塔：不可以直接从左移到右，必须经过中间" class="headerlink" title="2.特殊汉诺塔：不可以直接从左移到右，必须经过中间"></a>2.特殊汉诺塔：不可以直接从左移到右，必须经过中间</h3><p>《左神》14</p><p>法一递归：</p><pre><code class="java">//法一：递归。public static int hanoiProblem1(int num, String left, String mid, String right){    if(num&lt;1){        return 0;    }    return process(num, left, mid, right, left, right);}public static int process(int num, String left, String mid, String right, String from, String to){    if(num==1){        if(from.equals(mid) || to.equals(mid)){            System.out.println(&quot;move 1 from &quot; + from + &quot; to &quot; + to);            return 1;        }        else{            System.out.println(&quot;move 1 from &quot; + from + &quot; to mid&quot;);            System.out.println(&quot;move 1 from mid to &quot; + to);            return 2;        }    }    else{        if(from.equals(mid) || to.equals(mid)){            String another = (from.equals(left)||to.equals(left))? right : left;            int step1 = process(num-1, left, mid, right, from, another);            System.out.println(&quot;move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);            int step2 = 1;            int step3 = process(num-1, left, mid, right, another, to);            return step1 + step2 + step3;        }        else{            int step1 = process(num-1, left, mid, right, from, to);            int step2 = 1;            System.out.println(&quot;move &quot; + num + &quot; from &quot; + from + &quot; to mid&quot;);            int step3 = process(num-1, left, mid, right, to, from);            int step4 = 1;            System.out.println(&quot;move &quot; + num + &quot; from mid to &quot; + to);            int step5 = process(num-1, left, mid, right, from, to);            return step1 + step2 + step3 + step4 + step5;        }    }}</code></pre><p>法二：栈。</p><p>非递归的方法核心思想：</p><p>1.由于必须经过中间，把三个柱子想成三个栈，每次操作栈顶的一个元素，只有四个动作L-&gt;M、M-&gt;L、M-&gt;R、R-&gt;M</p><p>2.最优步骤时，每次四个动作只有一个动作能同时满足3、4两个原则，因为满足3、4时直接进行该步骤即可，直到最终第三个栈元素都移过去结束</p><p>3.每次移动元素时，栈顶元素小压大</p><p>4.每次移动元素时，与上一次移动操作不可互逆(那就是重复无意义的操作)</p><pre><code class="java">import java.util.Stack;enum Action{    No, LToM, MToL, RToM, MToR}public class Solution2{    //法二：栈    public static int hanoiProblem2(int num, String left, String mid, String right){        if(num&lt;1){            return 0;        }        Stack&lt;Integer&gt; ls = new Stack&lt;&gt;();        Stack&lt;Integer&gt; ms = new Stack&lt;&gt;();        Stack&lt;Integer&gt; rs = new Stack&lt;&gt;();        ls.push(Integer.MAX_VALUE);        ms.push(Integer.MAX_VALUE);        rs.push(Integer.MAX_VALUE);        for(int i=num; i&gt;=1; i--){            ls.push(i);        }        Action[] record = {Action.No};//record[0]存储上一次操作        int res = 0;        while(rs.size()!=num+1){            res += fstack_To_tStack(record, Action.LToM, Action.MToL, ls, ms, left, mid);            res += fstack_To_tStack(record, Action.MToL, Action.LToM, ms, ls, mid, left);            res += fstack_To_tStack(record, Action.RToM, Action.MToR, rs, ms, right, mid);            res += fstack_To_tStack(record, Action.MToR, Action.RToM, ms, rs, mid, right);        }        return res;    }    private static int fstack_To_tStack(Action[] record, Action nowAct, Action nowActReverse, Stack&lt;Integer&gt;fstack, Stack&lt;Integer&gt;tstack, String from, String to){        if(record[0]!=nowActReverse &amp;&amp; fstack.peek()&lt;tstack.peek()){//和上次操作不互逆 且 栈顶满足小压大，即为当前应该走的一步            tstack.push(fstack.pop());            System.out.println(&quot;move &quot; + tstack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);            record[0] = nowAct;            return 1;        }        return 0;    }    public static void main(String[] args){//        System.out.println(hanoiProblem1(2,&quot;left&quot;, &quot;mid&quot;, &quot;right&quot;));//法一:递归        System.out.println(hanoiProblem2(2,&quot;left&quot;, &quot;mid&quot;, &quot;right&quot;));//法二:栈    }}</code></pre><p><a name="6"></a></p><h2 id="6-构造数组的MaxTree"><a href="#6-构造数组的MaxTree" class="headerlink" title="6.构造数组的MaxTree"></a>6.构造数组的MaxTree</h2><p>leetcode 654、《左神》22</p><p>题目：对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree。MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。</p><p>思路：现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。</p><p>核心转化为了怎么找到左边/右边第一个比它大的数呢？用栈，递减序列即可。</p><p>以找每个数左边第一个比他大的数为例，从左到右遍历每个数，栈中保持递减序列，新来的数不停的Pop出栈顶直到栈顶比新数大或没有数。以[3,1,2]为例，首先3入栈，接下来1比3小，无需pop出3，1入栈，并且确定了1往左第一个比他大的数为3。接下来2比1大，1出栈，2比3小，2入栈。并且确定了2往左第一个比他大的数为3。用同样的方法可以求得每个数往右第一个比他大的数。时间复杂度O(n)，空间复杂度也是O(n)为最优解法。</p><p><strong>本题最巧妙的一点是如何找某数的左边最近的比它大的值和右边最近的比它大的值。取左右两边的较小的数作为该数的父节点。</strong></p><pre><code class="java">import java.util.Stack;class Node{    public int value;    public Node left;    public Node right;    public Node(int data){        this.value = data;    }}public class Solution {    //构造数组的MaxTree。核心:如何找某数的左边最近的比它大的值和右边最近的比它大的值(辅助栈和数组)。取左右两边的较小的数作为该数的父节点。    public static Node makeMaxTree(int[] arr) {        if(arr==null || arr.length==0){            return null;        }        if(arr.length==1){            return new Node(arr[0]);        }        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        int[] lmax = new int[arr.length];//存储找出某数的左边最近的比它大的值的索引        int[] rmax = new int[arr.length];//存储找出某数的右边最近的比它大的值的索引        for(int i=0; i&lt;arr.length; ++i){//从左往右遍历，找出某数的左边最近的比它大的值。栈递减序列            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i]){                stack.pop();            }            lmax[i] = !stack.isEmpty() ? stack.peek() : -1;//左边最近的比它大的值，如果左边没有比它大的，则为-1            stack.push(i);        }        stack.clear();//清空栈        for(int i=arr.length-1; i&gt;=0; --i){//从右往左遍历，找出某数的右边最近的比它大的值。栈递减序列            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i]){                stack.pop();            }            rmax[i] = !stack.isEmpty() ? stack.peek() : -1;//左边最近的比它大的值，如果左边没有比它大的，则为-1            stack.push(i);        }        //两个数组(左边首个最大、右边首个最大)存储好了，取较小的节点作为父节点，开始构建maxTree        Node[] nodes = new Node[arr.length];        for(int i=0; i&lt;nodes.length; ++i){            nodes[i] = new Node(arr[i]);        }        Node head = null;        for(int i=0; i&lt;arr.length; ++i){            if(lmax[i]==-1 &amp;&amp; rmax[i]==-1){                head = nodes[i];            }            else if(lmax[i]==-1 &amp;&amp; rmax[i]!=-1){                if(nodes[rmax[i]].left == null){                    nodes[rmax[i]].left = nodes[i];                }                else{                    nodes[rmax[i]].right = nodes[i];                }            }            else if(rmax[i]==-1 &amp;&amp; lmax[i]!=-1){                if(nodes[lmax[i]].right == null){                    nodes[lmax[i]].right = nodes[i];                }                else{                    nodes[lmax[i]].left = nodes[i];                }            }            else if(arr[lmax[i]]&lt;arr[rmax[i]]){                if(nodes[lmax[i]].right == null){                    nodes[lmax[i]].right = nodes[i];                }                else{                    nodes[lmax[i]].left = nodes[i];                }            }            else if(arr[lmax[i]]&gt;arr[rmax[i]]){                if(nodes[rmax[i]].left == null){                    nodes[rmax[i]].left = nodes[i];                }                else{                    nodes[rmax[i]].right = nodes[i];                }            }        }        return head;    }    public static void main(String[] args){        int[] arr = new int[]{3,1,2};        System.out.println(makeMaxTree(arr));    }}</code></pre><p><a name="7"></a></p><h2 id="7-最大子矩阵-2道-直方图-单调栈"><a href="#7-最大子矩阵-2道-直方图-单调栈" class="headerlink" title="7.最大子矩阵(2道)(直方图-单调栈)"></a>7.最大子矩阵(2道)(直方图-单调栈)</h2><pre><code>1.Largest Rectangle in Histogram(直方图面积)--leetcode 842.Maximal Rectangle(最大子矩阵大小)--leetcode85、《左神》26</code></pre><h3 id="1-Largest-Rectangle-in-Histogram-直方图面积"><a href="#1-Largest-Rectangle-in-Histogram-直方图面积" class="headerlink" title="1.Largest Rectangle in Histogram(直方图面积)"></a>1.Largest Rectangle in Histogram(直方图面积)</h3><p>leetcode 84</p><p>题目：Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. out: 10</p><p>思路：<strong>辅助单调栈，递增存储</strong>。遍历原直方图数组，递增往栈里存储，如果遇到比栈顶小的元素时，循环栈顶弹出并计算resMax，直到继续递增存储。时间o(n)，空间o(n)</p><pre><code class="java">public int largestRectangleArea(int[] heights) {    if(heights==null || heights.length==0){        return 0;    }    if(heights.length==1){        return heights[0];    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断    int resMax = 0;    for(int i=0; i&lt;heights.length; ++i){        while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()]){//每次遇到比栈顶小的元素时，对栈进行判断            int j = stack.pop();            int k = stack.isEmpty() ? -1 : stack.peek();            resMax = Math.max(resMax, (i-k-1)*heights[j]);        }        stack.push(i);//递增存储    }    while(!stack.isEmpty()){//考虑[1,2,3]的情况，栈一直递增存储，最后必须要清空栈        int j = stack.pop();        int k = stack.isEmpty() ? -1 : stack.peek();        resMax = Math.max(resMax, (heights.length-k-1)*heights[j]);    }    return resMax;}</code></pre><h3 id="2-Maximal-Rectangle-最大子矩阵大小"><a href="#2-Maximal-Rectangle-最大子矩阵大小" class="headerlink" title="2.Maximal Rectangle(最大子矩阵大小)"></a>2.Maximal Rectangle(最大子矩阵大小)</h3><p>leetcode85、《左神》26</p><p>题目：Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><pre><code>1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 6.</code></pre><p>思路：一行一行进行，对矩阵每一行为底的直方图数组求解直方图最大面积，直方图最大面积：用单调递增栈。</p><pre><code class="java">public int maximalRectangle(char[][] matrix) {    if(matrix==null || matrix.length==0){        return 0;    }    int m = matrix.length;    int n = matrix[0].length;    if(n==0){        return 0;    }    int res = 0;    int[] temp = new int[n+1];//以矩阵每一行为底的直方图数组，最后一个元素temp[n]要为0，便于求解直方图面积    for(int i=0; i&lt;m; ++i){//一行一行处理直方图的最大面积        for(int j=0; j&lt;n; ++j){//每一行先更新直方图            if(matrix[i][j] == &#39;0&#39;){                temp[j] = 0;            }else{                temp[j]++;            }        }        res = Math.max(res, largeArea(temp)); //直方图最大面积    }    return res;}//求一行的直方图最大面积--单调递增栈public int largeArea(int[] heights){    if(heights.length==1){        return heights[0];    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断    int resMax = 0;    for(int i=0; i&lt;heights.length; ++i){        while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()]){//每次遇到比栈顶小的元素时，对栈进行判断            int j = stack.pop();            int k = stack.isEmpty() ? -1 : stack.peek();            resMax = Math.max(resMax, (i-k-1)*heights[j]);        }        stack.push(i);//递增存储    }    return resMax;}</code></pre><p><a name="8"></a></p><h2 id="8-找两个排序数组的中位数"><a href="#8-找两个排序数组的中位数" class="headerlink" title="8.找两个排序数组的中位数"></a>8.找两个排序数组的中位数</h2><p>leetcode 4</p><p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p><pre><code class="java">//Median of Two Sorted Arrays找两个排序数组的中位数。思路：二分法，核心是注意怎么二分和边界条件public double findMedianSortedArrays(int[] nums1, int[] nums2) {    int n = nums1.length;    int m = nums2.length;    int left = (n + m + 1) / 2;    int right = (n + m + 2) / 2;    return 0.5 * (getKth(nums1,0,n-1,nums2,0,m-1,left) + getKth(nums1,0,n-1,nums2,0,m-1,right));}private double getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){    int len1 = end1 - start1 + 1;    int len2 = end2 - start2 + 1;    if(len1 &gt; len2){        return getKth(nums2,start2,end2,nums1,start1,end1,k);    }    if(len1 == 0) return nums2[start2 + k - 1];    if(k == 1) return Math.min(nums1[start1],nums2[start2]);    int s1 = Math.min(start1 + k/2 - 1, start1 + len1 - 1);    int s2 = Math.min(start2 + k/2 - 1, start2 + len2 - 1);//两个数组的k/2位置上的数，如果数组长度小于k/2，直接比len-1上的数    if(nums1[s1] &lt; nums2[s2]){//nums1数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2        return getKth(nums1,s1+1,end1,nums2,start2,end2,k-Math.min(k/2,len1));    }else{//nums2数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2        return getKth(nums1,start1,end1,nums2,s2+1,end2,k-Math.min(k/2,len2));    }}</code></pre><p><a name="9"></a></p><h2 id="9-删除链表中的节点-两道"><a href="#9-删除链表中的节点-两道" class="headerlink" title="9. 删除链表中的节点(两道)"></a>9. 删除链表中的节点(两道)</h2><pre><code>1.删除某个链表中指定的（非末尾）节点--leetcode237、《左神》832.删除链表中等于给定值 val 的所有节点--leetcode203</code></pre><h3 id="1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"><a href="#1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。" class="headerlink" title="1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"></a>1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。</h3><p>leetcode237、《左神》83</p><p>思路：后一个节点的val覆盖当前节点，删除后一个节点即可</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public void deleteNode(ListNode node) {        node.val = node.next.val;        node.next = node.next.next;    }}</code></pre><h3 id="2-删除链表中等于给定值-val-的所有节点"><a href="#2-删除链表中等于给定值-val-的所有节点" class="headerlink" title="2.删除链表中等于给定值 val 的所有节点"></a>2.删除链表中等于给定值 val 的所有节点</h3><p>leetcode203、《左神》73</p><pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre><p>思路：遍历链表删除即可。</p><pre><code class="java">public ListNode removeElements(ListNode head, int val){    if(head==null){        return null;    }    ListNode resHead = new ListNode(0); //哨兵    resHead.next = head;    ListNode p = resHead;    ListNode cur = p.next;    while(cur!=null){        if(cur.val==val){            p.next = cur.next;//这种删除思想特别好        }        else{            p = cur;        }        cur = cur.next;    }    return resHead.next;}</code></pre><p><a name="10"></a></p><h2 id="10-找到-删除链表的中间节点-两道"><a href="#10-找到-删除链表的中间节点-两道" class="headerlink" title="10.找到/删除链表的中间节点(两道)"></a>10.找到/删除链表的中间节点(两道)</h2><pre><code>1.找到链表的中间节点--leetcode 8762.删除链表的中间节点--《左神》38</code></pre><h3 id="1-找到链表的中间节点"><a href="#1-找到链表的中间节点" class="headerlink" title="1.找到链表的中间节点"></a>1.找到链表的中间节点</h3><p>leetcode 876</p><p>题目：Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p><p>If there are two middle nodes, return the second middle node.</p><pre><code>Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])</code></pre><p>思路：两个指快慢指针走即可。</p><pre><code class="java">public ListNode middleNode(ListNode head) {    if(head.next==null){        return head;    }    ListNode right = head;    ListNode left = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    return right.next==null ? left : left.next;}</code></pre><h3 id="2-删除链表的中间节点"><a href="#2-删除链表的中间节点" class="headerlink" title="2.删除链表的中间节点"></a>2.删除链表的中间节点</h3><p>《左神》38.</p><p>题目：删除一个链表的中间节点，当链表只有一个节点的时候或者head节点为空的时候返回head，当链表有两个节点的时候删除第一个节点，当链表有三个节点的时候删除第二个节点，当链表有四个节点的时候删除第二个节点，当链表有五个节点的时候删除第三个节点…</p><p>思路：一个链表长度每增加二，要删除的节点就后移一个节点，要删除一个节点需要知道它的前一个节点。</p><pre><code class="java">//删除链表中间节点。思路：两个快慢指针走即可public static ListNode removeMidNode(ListNode head){    if(head==null || head.next==null){//空节点或只有一个节点        return head;    }    if(head.next.next==null){//两个节点，删除第一个节点        head = head.next;        return head;    }    ListNode right = head.next.next;    ListNode left = head;//要删除节点的上一个节点    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    left.next = left.next.next;//删除中间节点    return head;}</code></pre><p><a name="11"></a></p><h2 id="11-删除链表a-b处的节点"><a href="#11-删除链表a-b处的节点" class="headerlink" title="11.删除链表a/b处的节点"></a>11.删除链表a/b处的节点</h2><p>《左神》38.</p><p>题目：给两个整数a，b(a&lt;=b)，实现删除链表a/b处节点的函数。若r=0，不删除；其他r的值向上取整，比如r在范围(2/5,3/5]中，取3，删除第三个节点。</p><p>思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点</p><pre><code class="java">//删除链表a/b处的节点。思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点public static ListNode removeByRatio(ListNode head, int a, int b){    if(a==0 || b==0 || a==b || head==null){//不删除任何节点        return head;    }    //1.遍历链表，得其长度len    ListNode p = head;    int len = 0;    while(p!=null){        len++;        p = p.next;    }    //2.计算a/b处是第k个节点    int k = (int)Math.ceil( ((double)a/b)*len );    if(k&lt;0){//a/b为负数，不删除节点        return head;    }    //3.删除第k个节点    if(k==1){        head = head.next;        return head;    }    p = head;//从头遍历    while(k!=2){//走到第k-1处        p = p.next;        k--;    }    p.next = p.next.next;//删除第k个节点    return head;}</code></pre><p><a name="12"></a></p><h2 id="12-判断一个链表是否为回文结构"><a href="#12-判断一个链表是否为回文结构" class="headerlink" title="12.判断一个链表是否为回文结构"></a>12.判断一个链表是否为回文结构</h2><p>《左神》48、leetcode234</p><p>题目：判断一个链表是否为回文链表(1\121\1221)，要求时间o(n)，空间o(1)</p><p>思路：由于要求时间o(n)，空间o(1)，感觉必须要动链表了。1.先找到中间节点，2.然后右半边逆序，3.然后分别从头部和中间开始比较元素是否相等即可。时间o(n)，空间o(1)。</p><pre><code class="java">//判断一个链表是否为回文结构。思路：1.两个快慢指针先找到中间节点，2.然后右半边链表逆序，3.再从头遍历比较元素是否相等public boolean isPalindrome(ListNode head) {    if(head==null || head.next==null){        return true;    }    //2.两个快慢指针先找到中间节点    ListNode left = head;    ListNode right = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    //2.现将left后边的链表逆序    ListNode cur = left.next;    ListNode temp = cur;    cur = cur.next;    temp.next = null;    while(cur!=null){        temp = cur;        cur = cur.next;        temp.next = left.next;        left.next = temp;    }    //3.从头遍历比较元素是否相等    right = left.next;    left = head;    while(right!=null){        if(left.val!=right.val){//遇到元素不等，不是回文结构，false            return false;        }        left = left.next;        right = right.next;    }    return true;}public static void main(String[] args){    ListNode head = new ListNode(1);    head.next = new ListNode(2);    head.next.next = new ListNode(3);    head.next.next.next = new ListNode(3);    head.next.next.next.next = new ListNode(2);    head.next.next.next.next.next = new ListNode(1);    System.out.println(isPalindrome(head));//true}</code></pre><p><a name="13"></a></p><h2 id="13-将单向链表按某值划分成左边小，中间相等，右边大"><a href="#13-将单向链表按某值划分成左边小，中间相等，右边大" class="headerlink" title="13.将单向链表按某值划分成左边小，中间相等，右边大"></a>13.将单向链表按某值划分成左边小，中间相等，右边大</h2><p>《左神》52.</p><p>题目：给定一个单向链表的头结点head,节点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的节点，中间部分都是值等于privot的节点，右部分都是大于privot的节点。<br>例如:链表9-0-4-5-1，pivot=3。<br>调整后是1-0-4-9-5，也可以是0-1-9-5-4。 </p><p>思路：解法一：我们可以利用数组额外空间，利用数组partition排序来实现。时间o(n) 空间o(n)</p><pre><code>​1. 先遍历一遍链表，得到链表长度。​2. 建立一个链表数组。​3. 利用三向快排的划分​4. 调整数组中的next值。​</code></pre><p>解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可。时间o(n) 空间o(1)</p><pre><code class="java">class Node {    public int val;    public Node next;    public Node(int x) {        val = x;        this.next = null;    }}public class Solution2 {    //解法一：我们可以利用数组额外空间来实现    //时间o(n) 空间o(n)    //1. 先遍历一遍链表，得到链表长度。    //2. 建立一个链表数组。    //3. 利用三向快排的划分    //4. 调整数组中的next值。    public static Node listPartition1(Node head, int privot){        if(head==null || head.next==null){            return head;        }        //1.遍历链表得到长度。        int len = 0;        Node p = head;        while(p!=null){            len++;            p = p.next;        }        //2.建立一个链表数组。        Node[] arr = new Node[len];        p = head;        for(int i=0; i&lt;len; ++i){            arr[i] = p;            p = p.next;        }        //3.数组partition排序        paitition(arr, 0, len-1, privot);        //4.重新连接数组的node        for(int i=0; i&lt;len-1; ++i){            arr[i].next = arr[i+1];        }        arr[len-1].next = null;        return arr[0];    }    public static void paitition(Node[] arr, int left, int right, int privot){        //注意的这里的partition保持了数组原来的顺序        int small = left;        int big = right;        for(int i=left; i&lt;=right&amp;&amp;i&lt;=big; ++i){            if(arr[i].val&lt;privot){                swap(arr, i, small++);            }            else if(arr[i].val&gt;privot){                swap(arr, i, big--);            }        }        while(big&lt;right){            swap(arr, big++, right--);        }    }    //解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可    //时间o(n) 空间o(1)    public static Node listPartition2(Node head, int privot){        if(head==null || head.next==null){            return head;        }        Node small = new Node(0);        Node smallCopy = small;        Node equal = new Node(0);        Node equalCopy = equal;        Node big = new Node(0);        Node bigCopy = big;        Node p = head;        while(p!=null){//遍历链表            if(p.val&lt;privot){                Node temp = p;                p = p.next;                temp.next = null;                small.next = temp;                small = temp;            }            else if(p.val == privot){                Node temp = p;                p = p.next;                temp.next = null;                equal.next = temp;                equal = temp;            }            else{                Node temp = p;                p = p.next;                temp.next = null;                big.next = temp;                big = temp;            }        }        small.next = equalCopy.next;        equal.next = bigCopy.next;        return smallCopy.next;    }    public static void main(String[] args){        Node head = new Node(9);        Node p = head;        p.next = new Node(0);        p = p.next;        p.next = new Node(3);        p = p.next;        p.next = new Node(4);        p = p.next;        p.next = new Node(5);        p = p.next;        p.next = new Node(1);        show(head);//        head = listPartition1(head, 3);        head = listPartition2(head, 3);        System.out.println();        show(head);    }    public static void show(Node head){        while(head!=null){            System.out.print(head.val + &quot; &quot;);            head = head.next;        }    }    public static void swap(Node[] arr, int i, int j){        Node temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}//out: 9 0 3 4 5 1        0 1 3 9 4 5 </code></pre><p><a name="14"></a></p><h2 id="14-单链表的归并排序"><a href="#14-单链表的归并排序" class="headerlink" title="14.单链表的归并排序"></a>14.单链表的归并排序</h2><p>leetcode148</p><p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p><p>思路：归并排序应该是单链表排序最好的方法了，时间o(nlogn)，空间o(1)。分而治之，先找到中间节点，拆分成两个链表，merge</p><pre><code class="java">public static ListNode sortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode left = head;    ListNode right = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        left = left.next;        right = right.next.next;    }    right = left.next;    left.next = null;//将链表从中间节点拆分，分离成两个链表    left = sortList(head);    right = sortList(right);    return merge(left, right);}public static ListNode merge(ListNode l1, ListNode l2){    ListNode guard = new ListNode(0);    ListNode p = guard;    ListNode temp;    while(l1!=null &amp;&amp; l2!=null){        if(l1.val&lt;=l2.val){            temp = l1;            l1 = l1.next;        }        else{            temp = l2;            l2 = l2.next;        }        temp.next = null;        p.next = temp;        p = p.next;    }    if(l1!=null){        p.next = l1;    }    if(l2!=null){        p.next = l2;    }    return guard.next;}public static void show(ListNode head){    while(head!=null){        System.out.print(head.val + &quot; &quot;);        head = head.next;    }    System.out.println();}public static void main(String[] args){    ListNode head = new ListNode(1);    head.next = new ListNode(2);    head.next.next = new ListNode(5);    head.next.next.next = new ListNode(4);    head.next.next.next.next = new ListNode(7);    show(head);    show(sortList(head));    //out:1 2 5 4 7    //    1 2 4 5 7}</code></pre><p><a name="15"></a></p><h2 id="15-单链表的快速排序"><a href="#15-单链表的快速排序" class="headerlink" title="15.单链表的快速排序"></a>15.单链表的快速排序</h2><p>leetcode148</p><p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p><pre><code>Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4</code></pre><p>思路：partition思想，用三个指针来控制，pBase指针指向枢纽值结点，pleft指针指向当前最后一个比枢纽值小的结点，pright结点用于遍历，将遇到的比pBase小的结点的值交换到前面去。<br>​<br><img src="https://img-blog.csdnimg.cn/20200215151042325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="ListquickSort"></p><pre><code class="java">//单链表的快排public ListNode sortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode tail = head;    while(tail.next!=null){        tail = tail.next;    }    quickSortList(head, tail);    return head;}public void quickSortList(ListNode head, ListNode tail){    if(head==tail || head==null || tail==null){        return;    }    ListNode pBase = head; //基准key节点    ListNode pSmall = head; //此节点之前的节点都是比pBase小的    ListNode cur = head.next; //遍历节点    while(cur!=tail.next){        if(cur.val&lt;pBase.val){            pSmall = pSmall.next;            swap(pSmall, cur);        }        cur = cur.next;    }    swap(pBase, pSmall);    quickSortList(head, pSmall);    quickSortList(pSmall.next, tail);}public void swap(ListNode a, ListNode b){    int temp = a.val;    a.val = b.val;    b.val = temp;}</code></pre><p><a name="16"></a></p><h2 id="16-单链表的选择排序"><a href="#16-单链表的选择排序" class="headerlink" title="16.单链表的选择排序"></a>16.单链表的选择排序</h2><p>《左神》79、和88题(单链表快排)一起看</p><p>题目：单链表的选择排序</p><p>思想：时间o(n^2)，空间o(1)，正常的选择排序思想，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，接入到排序好的链表部分，这里注意节点的断开与接入的指针变量操作</p><pre><code class="java">//单链表的选择排序。时间o(n^2)public static ListNode selectSortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode resHeadCopy = new ListNode(0); //哨兵，最终返回resHeadCopy.next    ListNode resHead = resHeadCopy; //存储排序链表的最后一个节点    while(head.next!=null){//选择排序，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，连接到resHead后        ListNode minTemp = head;        ListNode minPre=null;        ListNode cur = head.next;//遍历剩下链表        ListNode curPre = head;        while(cur!=null){//每次都从剩下链表头结点遍历，找剩下链表中最小节点            if(cur.val&lt;minTemp.val){                minTemp = cur;                minPre = curPre;            }            curPre = cur;            cur = cur.next;        }        ListNode temp = minTemp;//这是找到的min节点        if(temp==head){//如果min节点是头结点            head = head.next;//断开min节点        }        else{            minPre.next = minPre.next.next; //断开min节点        }        temp.next = null;//断开min节点        resHead.next = temp;//min节点连入排序链表尾        resHead = temp;    }    resHead.next = head; //链表剩下最后一个节点接入    return resHeadCopy.next;}</code></pre><p><a name="17"></a></p><h2 id="17-两个链表生成相加链表"><a href="#17-两个链表生成相加链表" class="headerlink" title="17.两个链表生成相加链表"></a>17.两个链表生成相加链表</h2><p>《左神》59、leetcode 2</p><p>题目：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><p>思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位，注意如果最后还有进位，别忘了再生成一个节点</p><pre><code class="java">//两个链表生成相加链表。思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    ListNode guard = new ListNode(0);    ListNode p = guard;    int cnt = 0;//进位    int sum;//每两个节点的和    while(l1!=null &amp;&amp; l2!=null){        sum = l1.val + l2.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l1 = l1.next;        l2 = l2.next;    }    while(l1!=null){        sum = l1.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l1 = l1.next;    }    while(l2!=null){        sum = l2.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l2 = l2.next;    }    if(cnt!=0){//如果还有进位，则再创建一个节点        p.next = new ListNode(1);    }    return guard.next;}</code></pre><p><a name="18"></a></p><h2 id="18-删除单链表的重复节点-三道"><a href="#18-删除单链表的重复节点-三道" class="headerlink" title="18.删除单链表的重复节点(三道)"></a>18.删除单链表的重复节点(三道)</h2><h3 id="1-链表有序，保留一个"><a href="#1-链表有序，保留一个" class="headerlink" title="1.链表有序，保留一个"></a>1.链表有序，保留一个</h3><p>leetcode 83</p><p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p><pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>思路：时间o(n)，空间o(1)，遍历删除即可</p><pre><code class="java">public static ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode p = head;    ListNode cur = head.next;    while(cur!=null){        if(p.val==cur.val){            p.next = cur.next;        }        else{            p = cur;        }        cur = cur.next;    }    return head;}</code></pre><h2 id="2-链表有序，不保留"><a href="#2-链表有序，不保留" class="headerlink" title="2.链表有序，不保留"></a>2.链表有序，不保留</h2><p>leetcode 82</p><p>题目：Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><p>Example 1:</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5</code></pre><p>思路：定义一个哨兵，定义一个前驱指针和一个现指针，每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位。</p><p>代码：</p><pre><code class="java">public ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode pre = guard;//前驱指针    ListNode cur = guard.next;    while(cur!=null){        if(cur.next!=null &amp;&amp; cur.next.val==cur.val){//有重复，要准备删除了            int temp = cur.val;//缓存要删除的val            while(cur!=null &amp;&amp; cur.val==temp){                cur = cur.next;            }            pre.next = cur;        }        else{            pre = cur;            cur = cur.next;        }    }    return guard.next;}</code></pre><h3 id="3-链表无序"><a href="#3-链表无序" class="headerlink" title="3.链表无序"></a>3.链表无序</h3><p>《左神》71</p><p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p><pre><code>Input: 1-&gt;2-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>思路：哈希set。时间o(n)，空间o(n)</p><pre><code class="java">public static void deleteDuplicate(ListNode head){    if(head==null || head.next==null){        return;    }    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();//哈希表    ListNode p = head;    ListNode cur = head.next;    set.add(p.val);    while(cur!=null){        if(set.contains(cur.val)){            p.next = cur.next;        }        else{            set.add(cur.val);            p = cur;        }        cur = cur.next;    }}</code></pre><p><a name="19"></a></p><h2 id="19-向有序的环形单链表中插入新节点"><a href="#19-向有序的环形单链表中插入新节点" class="headerlink" title="19.向有序的环形单链表中插入新节点"></a>19.向有序的环形单链表中插入新节点</h2><p>《左神》82</p><p>题目：一个环形单链表从头节点 head 开始不降序，同时由最后的节点指回头节点。给定这样的一个环形单链表的头节点 head 和 一个整数 num ，请生成节点值为 num 的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p><p>思路：直接从头结点遍历插入即可，时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p><pre><code class="java">//环形有序链表中插入新节点public static ListNode insertNum(ListNode head, int num){    ListNode newNode = new ListNode(num);    if(head==null){        newNode.next = newNode;        return newNode;    }    ListNode cur = head;    if(num &lt;= head.val){//如果要插入到头结点之前        while(cur.next!=head){            cur = cur.next;        }        newNode.next = head;        cur.next = newNode;        head = newNode;    }    else{        while(true){            if(cur.next.val&gt;=num){                newNode.next = cur.next;                cur.next = newNode;                break;            }            cur = cur.next;        }    }    return head;}</code></pre><p><a name="20"></a></p><h2 id="20-打印二叉树的边界节点"><a href="#20-打印二叉树的边界节点" class="headerlink" title="20.打印二叉树的边界节点"></a>20.打印二叉树的边界节点</h2><p>《左神》95、 leetcode545(会员)</p><p>题目：给定一颗二叉树的头结点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p><pre><code>1.头节点为边界节点2.叶结点为边界节点3.如果节点在其所在的层中是最左边或最右边，那么也是边界节点</code></pre><p><a name="21"></a></p><h2 id="21-编辑距离"><a href="#21-编辑距离" class="headerlink" title="21.编辑距离"></a>21.编辑距离</h2><p>leetcode 72</p><p>题目：Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:</p><pre><code>Insert a characterDelete a characterReplace a characte</code></pre><p>Example 1:</p><pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)rorse -&gt; rose (remove &#39;r&#39;)rose -&gt; ros (remove &#39;e&#39;)Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#39;t&#39;)inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)exection -&gt; execution (insert &#39;u&#39;)</code></pre><p>思路：DP问题。维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。</p><p>转移方程：当word1[i]==word2[j]时，dp[i][j] = dp[i-1][j-1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1。</p><pre><code>if word1[i-1]==word2[j-1]：    dp[i][j] = dp[i - 1][j - 1]else:     dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 //替换、删除、插入   </code></pre><p>代码：   </p><pre><code class="java">public int minDistance(String word1, String word2) {    if(word1==null || word2==null){        return 0;    }    int len1 = word1.length();    int len2 = word2.length();    int[][] dp = new int[len1+1][len2+1];    for (int i=0; i&lt;=len2; ++i){//第一行        dp[0][i] = i;    }    for (int i=0; i&lt;=len1; ++i){//第一列        dp[i][0] = i;    }    for(int i=1; i&lt;=len1; ++i){        for (int j=1; j&lt;=len2; ++j){            if(word1.charAt(i-1) == word2.charAt(j-1)){                dp[i][j] = dp[i-1][j-1];            }            else{                dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1;            }        }    }    return dp[len1][len2];}public int min(int a, int b, int c){    int temp = Math.min(a,b);    return Math.min(temp,c);}</code></pre><p><a name="22"></a></p><h2 id="22-找出数组中左边比他小右边比他大的所有元素"><a href="#22-找出数组中左边比他小右边比他大的所有元素" class="headerlink" title="22.找出数组中左边比他小右边比他大的所有元素"></a>22.找出数组中左边比他小右边比他大的所有元素</h2><p>题目：给定一个不重复的数组，找出所有符合条件的元素：该元素左边都比它小，右边都比它大。e.g. [1,2,3,4,5]–&gt;out:[1,2,3,4,5]所有元素都满足。时间要求o(n)</p><p>思路：<strong>辅助一个o(n)数组temp[]，遍历两次数组即可</strong>。第一次从后往前记录temp[]，temp[i]表示从结尾到i时最小的数，第二次遍历从前往后，tempMax存从头到i时最大的数，如果nums[i]比tempMax大且比temp[i]小则nums[i]符合条件。</p><pre><code class="java">//找出数组中左边比他小右边比他大的所有元素。思路：辅助o(n)的temp[]，遍历两遍数组即可public static ArrayList&lt;Integer&gt; findEleBigLeftSmallRight(int[] numbers){    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(numbers==null || numbers.length==0){        return res;    }    int len = numbers.length;    if(len==1){//只有一个节点时直接返回该节点，无需比较        res.add(numbers[0]);        return res;    }    //1.从后往前遍历，存最小的数    int[] temp = new int[len];//辅助数组    temp[len-1] = numbers[len-1];    for(int i=len-2; i&gt;=0; --i){        temp[i] = numbers[i]&lt;temp[i+1] ? numbers[i] : temp[i+1];    }    //2.从前往后遍历，找符合条件的数    int tempMax = Integer.MIN_VALUE;//存最大的数    for(int i=0; i&lt;len-1; ++i){        if(numbers[i]&gt;tempMax &amp;&amp; numbers[i]&lt;temp[i+1]){            res.add(numbers[i]);//符合条件        }        if(numbers[i]&gt;tempMax){            tempMax = numbers[i];        }    }    if(numbers[len-1]&gt;tempMax){//最后一个数        res.add(numbers[len-1]);    }    return res;}</code></pre><p><a name="23"></a></p><h2 id="23-判断二叉树为BST-二叉搜索树"><a href="#23-判断二叉树为BST-二叉搜索树" class="headerlink" title="23.判断二叉树为BST(二叉搜索树)"></a>23.判断二叉树为BST(二叉搜索树)</h2><p>leetcode 98</p><p>题目：判断二叉树为BST(二叉搜索树)</p><p>思路：中序遍历判断且使用全局变量记录前继节点的值</p><p>代码：</p><pre><code class="java">private Long last = Long.MIN_VALUE;//全局变量记录前继节点的值//中序遍历判断public boolean isValidBST(TreeNode root) {    if(root==null){        return true;    }        if(!isValidBST(root.left)){        return false;    }    if(root.val&lt;=last){        return false;    }    last = Long.valueOf(root.val);    return isValidBST(root.right);}</code></pre><p><a name="24"></a></p><h2 id="24-Replace-Words-字典树应用"><a href="#24-Replace-Words-字典树应用" class="headerlink" title="24.Replace Words(字典树应用)"></a>24.Replace Words(字典树应用)</h2><p>leetcode 648</p><p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p>Example 1:</p><pre><code>Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot;Note:The input will only have lower-case letters.1 &lt;= dict words number &lt;= 10001 &lt;= sentence words number &lt;= 10001 &lt;= root length &lt;= 1001 &lt;= sentence words length &lt;= 1000</code></pre><p>题目大意：给定一个字典，里面是词根root，给定一句话，如果这句话的单词前缀是字典中词根，则将单词用词根替换，如果有多个词根，找最短的词根替换，最后返回替换好的话</p><p>思路1(不可取)：暴力替换。将这句话split成words[]单词组，将每个单词从前往后字符组的依次与hash字典中的词根比较，如果出现就替换。时间o(nk),n这句话，k字典，空间辅助hash o(k)。时间效率很低</p><pre><code class="java">public String replaceWords(List&lt;String&gt; dict, String sentence) {    HashSet&lt;String&gt; set = new HashSet&lt;&gt;(dict);    String[] words = sentence.split(&quot; &quot;);    StringBuilder sb = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        for(int j=1; j&lt;words[i].length(); ++j){            String root = words[i].substring(0,j);            if(set.contains(root)){                words[i] = root;                break;            }        }        sb.append(words[i] + &quot; &quot;);    }    return sb.toString().trim();}</code></pre><p>思路2(可取，但还是不够好)：不暴力替换，采用了字典树的思想。1.字典的roots词根用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组;2.将这句话split成words[]单词组，遍历words单词数组，一个单词一个单词的在字典树中替换，最后返回替换好的话。时间o(n)，空间o(k),n是原句子，k是字典</p><pre><code class="java">//思路：字典树思想。将字典中的词根按照首字母构建字典public String replaceWords(List&lt;String&gt; dict, String sentence) {    HashSet[] set = new HashSet[26];//字典树，用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组    String[] words = sentence.split(&quot; &quot;);    StringBuilder sb = new StringBuilder();    //1.构建字典树,26个字母开头索引    for(int i=0; i&lt;dict.size(); ++i){        String word = dict.get(i);        int wordIndex =  word.charAt(0)-&#39;a&#39;;        if(set[wordIndex]==null){            set[wordIndex] = new HashSet&lt;String&gt;();        }        set[wordIndex].add(word);    }    //2.遍历words单词数组，一个单词一个单词的在字典树中替换    for(int i=0; i&lt;words.length; ++i){        int wordIndex = words[i].charAt(0)-&#39;a&#39;;        if(set[wordIndex]==null){//这个单词在字典树中没有首字母索引，即也没有词根对应，continue            sb.append(words[i] + &quot; &quot;);            continue;        }        Iterator&lt;String&gt; iterator = set[wordIndex].iterator();        while(iterator.hasNext()) {            String root = iterator.next();            if (words[i].startsWith(root) &amp;&amp; root.length() &lt; words[i].length()) {//找最短的词根替换                words[i] = root;            }        }        sb.append(words[i] + &quot; &quot;);//替换好的单词加入到新话中    }    return sb.toString().trim();}</code></pre><p>思路3(高效字典树，棒):思路2只是很简单用首字母进行索引实现字典树，但还是不够，应该使用字典树(也叫前缀树)实现高效查询。</p><pre><code class="java">//字典树节点class TrieNode{    char c;    TrieNode[] children = new TrieNode[26];    boolean isComplete = false;    public TrieNode(char c){        this.c = c;    }}class Solution {    //思路：构建字典树。    public String replaceWords(List&lt;String&gt; dict, String sentence) {        if(sentence==null || sentence.length()&lt;2 || dict==null || dict.size()==0){            return sentence;        }        //1.遍历字典中的词根，构建字典树        TrieNode root = new TrieNode(&#39;c&#39;);//字典树的根节点        for(String dictWord: dict){//遍历字典中的词根            char[] chs = dictWord.toCharArray();            TrieNode temp = root;            for(char c: chs){//对每个词根进行字典树构建                if(temp.children[c-&#39;a&#39;]==null){                    temp.children[c-&#39;a&#39;] = new TrieNode(c);                }                temp = temp.children[c-&#39;a&#39;];            }            temp.isComplete = true;//一个词根构建完，标记位置为true        }        //2.遍历原话的words[]单词数组，对每个单词进行字典树替换        StringBuilder sb = new StringBuilder();        String[] words = sentence.split(&quot; &quot;);        for(int i=0; i&lt;words.length; ++i){//遍历原单词数组words[]            TrieNode temp = root;            StringBuilder tempSb = new StringBuilder();            boolean can_change = false;//是否找到一个可以替换的词根            for(char ch: words[i].toCharArray()){                if(temp.children[ch-&#39;a&#39;]==null){//当前字符在字典树中没有索引                    break;                }                tempSb.append(ch);                temp = temp.children[ch-&#39;a&#39;];                if(temp.isComplete==true){//找到了当前单词对应的一个词根                    can_change = true;                    break;                }            }            if(can_change){//将单词替换成词根                sb.append(tempSb.toString() + &quot; &quot;);            }            else{//没有对应的词根，单词不变                sb.append(words[i] + &quot; &quot;);            }        }        return sb.toString().trim();    }}</code></pre><p><a name="25"></a></p><h2 id="25-BFS-DFS思想"><a href="#25-BFS-DFS思想" class="headerlink" title="25.BFS/DFS思想"></a>25.BFS/DFS思想</h2><p>参考：<a href="https://www.cnblogs.com/developerY/p/3323264.html" target="_blank" rel="noopener">LeoYang<br>Coding and learning<br>BFS和DFS详解以及java实现</a></p><p>总的来说，BFS多用于寻找最短路径的问题，DFS多用于快速发现底部节点。</p><h3 id="BFS广度优先搜索-遍历"><a href="#BFS广度优先搜索-遍历" class="headerlink" title="BFS广度优先搜索/遍历"></a>BFS广度优先搜索/遍历</h3><p>BFS主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对A再加1，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问），而对于连通图来说，每个顶点都会被访问。加上每个顶点的邻接链表都会被遍历，因此<strong>BFS的时间复杂度是O（V+E</strong>），其中V是顶点个数，E是边数，也就是所有邻接表中的元素个数。</p><h3 id="DFS深度优先搜索-遍历"><a href="#DFS深度优先搜索-遍历" class="headerlink" title="DFS深度优先搜索/遍历"></a>DFS深度优先搜索/遍历</h3><p>DFS深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。</p><p><a name="26"></a></p><h2 id="26-BFS相关题目-1道"><a href="#26-BFS相关题目-1道" class="headerlink" title="26.BFS相关题目(1道)"></a>26.BFS相关题目(1道)</h2><h3 id="BFS相关题目-1-01-Matrix"><a href="#BFS相关题目-1-01-Matrix" class="headerlink" title="BFS相关题目_1.01 Matrix"></a>BFS相关题目_1.01 Matrix</h3><p>leetcode 542</p><p>题目：Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p><pre><code>Example 1: Input:0 0 00 1 00 0 0Output:0 0 00 1 00 0 0Example 2: Input:0 0 00 1 01 1 1Output:0 0 00 1 01 2 1Note:The number of elements of the given matrix will not exceed 10,000.There are at least one 0 in the given matrix.The cells are adjacent in only four directions: up, down, left and right.</code></pre><p>思路：BFS。这道题给了我们一个只有0和1的矩阵，让我们求每一个1到离其最近的0的距离，其实也就是求一个距离场，而求距离场那么BFS将是不二之选。</p><pre><code>1.首先遍历一次矩阵，将值为0的点都存入queue，将值为1的点换成MAX_VALUE;2.对队列中的每一个0进行BFS上下左右搜索:从queue中取出一个数字，遍历其周围四个点，如果越界或者周围点的值小于等于当前值加1，则直接跳过;否则将周围点的值更新为当前值加1，然后把周围点的坐标加入queue</code></pre><p>代码：</p><pre><code class="java">public int[][] updateMatrix(int[][] matrix) {    if(matrix==null || matrix.length==0 || matrix[0].length==0){        return matrix;    }    int m = matrix.length;    int n = matrix[0].length;    //1.把原矩阵中1换成MAX_VALUE; 2.把0全部放进队列    Queue&lt;Pair&lt;Integer,Integer&gt; &gt; queue = new LinkedList&lt;&gt;();    for(int i=0; i&lt;m; ++i){        for (int j=0; j&lt;n; ++j){            if(matrix[i][j]==0){                queue.offer(new Pair&lt;&gt;(i, j));            }            else{                matrix[i][j] = Integer.MAX_VALUE;            }        }    }    //3.对队列中的每一个0进行BFS上下左右搜索    int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,-1}, {0,1}}; //上下左右    while(!queue.isEmpty()){        Pair&lt;Integer, Integer&gt; origin = queue.poll();        for(int i=0; i&lt;4; ++i){            int x = origin.getKey() + dirs[i][0];            int y = origin.getValue() + dirs[i][1];            if(x&lt;0 || x&gt;=m || y&lt;0 || y&gt;=n || matrix[x][y]&lt;=( matrix[origin.getKey()][origin.getValue()]+1 ) ){                continue;            }            matrix[x][y] = matrix[origin.getKey()][origin.getValue()]+1;            queue.offer(new Pair&lt;&gt;(x, y));//BFS入队别忘了        }    }    return matrix;}</code></pre><p><a name="27"></a></p><h2 id="27-DFS相关题目-4道"><a href="#27-DFS相关题目-4道" class="headerlink" title="27.DFS相关题目(4道)"></a>27.DFS相关题目(4道)</h2><h3 id="DFS相关题目-1-Number-of-Islands"><a href="#DFS相关题目-1-Number-of-Islands" class="headerlink" title="DFS相关题目_1.Number of Islands"></a>DFS相关题目_1.Number of Islands</h3><p>leetcode 200</p><p>题目：Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><pre><code>Example 1:Input:11110110101100000000Output: 1</code></pre><p>思路：找岛屿的个数。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索，计数器加1</p><p>代码：</p><pre><code class="java">public int numIslands(char[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int res = 0;    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==&#39;1&#39;){//找到一个岛屿                dfs(grid, m, n, i, j);//对该岛屿进行dfs搜索土地，并将岛屿的全部土地变为&#39;0&#39;已访问                res++;            }        }    }    return res;}public void dfs(char[][] grid, int m, int n, int i, int j){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==&#39;0&#39;){        return;    }    grid[i][j] = &#39;0&#39;;//标记为已访问    dfs(grid, m , n, i-1, j);    dfs(grid, m , n, i+1, j);    dfs(grid, m , n, i, j-1);    dfs(grid, m , n, i, j+1);//上下左右}</code></pre><h3 id="DFS相关题目-2-Max-Area-of-Island"><a href="#DFS相关题目-2-Max-Area-of-Island" class="headerlink" title="DFS相关题目_2.Max Area of Island"></a>DFS相关题目_2.Max Area of Island</h3><p>leetcode 695</p><p>题目：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p><pre><code>Example 1:[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.(斜着的不算)</code></pre><p>思路：在很多岛屿中，返回最大岛屿面积。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索并计算面积。</p><p>代码：</p><pre><code class="java">public int maxAreaOfIsland(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int resMax = 0;    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==1){//找到一个岛屿                int[] tempMax = new int[]{0};//计算当前岛屿的面积                dfs(grid, m, n, i, j, tempMax);//对该岛屿进行dfs搜索土地并计算面积，并将岛屿的全部土地变为&#39;0&#39;已访问                resMax = Math.max(resMax, tempMax[0]);            }        }    }    return resMax;}public void dfs(int[][] grid, int m, int n, int i, int j, int[] tempMax){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==0){        return;    }    grid[i][j] = 0;//标记为已访问    tempMax[0]++;    dfs(grid, m , n, i-1, j, tempMax);    dfs(grid, m , n, i+1, j, tempMax);    dfs(grid, m , n, i, j-1, tempMax);    dfs(grid, m , n, i, j+1, tempMax);//上下左右}</code></pre><h3 id="DFS相关题目-3-Island-Perimeter"><a href="#DFS相关题目-3-Island-Perimeter" class="headerlink" title="DFS相关题目_3.Island Perimeter"></a>DFS相关题目_3.Island Perimeter</h3><p>leetcode 463</p><p>题目大意：二维地图，每个单元格的长度为1的方形。1代表陆地，0代表水，上、下、左、右四个方向的单元格相连，求出相连陆地单元格的周长。 </p><p>思路：图中只有唯一一个岛屿,不用dfs，直接遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可。</p><p>代码：</p><pre><code class="java">//求图中唯一岛屿的周长。思路：//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可//对岛屿的一个节点计算周长的规律:周围相邻有0/1/2/3/4的节点的话，对应的周长分别为4/3/3/2/1/0public int islandPerimeter(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int resPrm = 0;//该岛屿的周长    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==1){                int temp = 4;                if(i-1&gt;=0 &amp;&amp; grid[i-1][j]==1){//上：有相邻的一个节点                    temp--;                }                if(i+1&lt;m &amp;&amp; grid[i+1][j]==1){//下：有相邻的一个节点                    temp--;                }                if(j-1&gt;=0 &amp;&amp; grid[i][j-1]==1){//左：有相邻的一个节点                    temp--;                }                if(j+1&lt;n &amp;&amp; grid[i][j+1]==1){//右：有相邻的一个节点                    temp--;                }                resPrm += temp;            }        }    }    return resPrm;}</code></pre><h3 id="DFS相关题目-4-Surrounded-Regions"><a href="#DFS相关题目-4-Surrounded-Regions" class="headerlink" title="DFS相关题目_4.Surrounded Regions"></a>DFS相关题目_4.Surrounded Regions</h3><p>leetcode 130</p><p>题目：这道题的意思是将所有被X包围的O都变为X(边缘的不算)</p><p>思路：1.从图的4个边界出发DFS找O的土地，全部换成*;2.遍历图中剩下的节点，将O换成X，将*换成O</p><p>代码：</p><pre><code class="java">public void solve(char[][] board) {    if(board==null || board.length==0 || board[0].length==0){        return;    }    int m = board.length;    int n = board[0].length;    //1.从图的4个边界出发DFS找O的土地，全部换成*    for (int i = 0; i &lt; n; ++i){        dfsSolve(board, m, n, 0, i);//上边界        dfsSolve(board, m, n, m-1, i);//下边界    }    for (int i = 0; i &lt; m; ++i){        dfsSolve(board, m, n, i, 0);//左边界        dfsSolve(board, m, n, i, n-1);//右边界    }    //2.遍历图中剩下的节点，将O换成X，将*换成O    for (int i = 0; i &lt; m; ++i) {        for (int j = 0; j &lt; n; ++j) {            if(board[i][j]==&#39;*&#39;){                board[i][j]=&#39;O&#39;;            }            else if(board[i][j]==&#39;O&#39;){                board[i][j]=&#39;X&#39;;            }        }    }}//从图的4个边界出发DFS找O的土地，访问过的换成*public void dfsSolve(char[][] grid, int m, int n, int i, int j){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==&#39;X&#39; || grid[i][j]==&#39;*&#39;){        return;    }    grid[i][j] = &#39;*&#39;;//把边界O换成*    dfsSolve(grid, m, n, i+1, j);//上    dfsSolve(grid, m, n, i-1, j);//下    dfsSolve(grid, m, n, i, j-1);//左    dfsSolve(grid, m, n, i, j+1);//右}</code></pre><p><a name="28"></a></p><h2 id="28-图的几种最短路算法-4道"><a href="#28-图的几种最短路算法-4道" class="headerlink" title="28.图的几种最短路算法(4道)"></a>28.图的几种最短路算法(4道)</h2><pre><code>1.单源最短路径_1.Dijkstra算法2.单源最短路径_2.Bellman-Ford算法3.单源最短路径_3.SPFA算法4.多源最短路径_Floyd-Warshall算法</code></pre><h3 id="1-单源最短路径-1-Dijkstra算法"><a href="#1-单源最短路径-1-Dijkstra算法" class="headerlink" title="1.单源最短路径_1.Dijkstra算法"></a>1.单源最短路径_1.Dijkstra算法</h3><p>普通实现的时间复杂度为O(V2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O(E+VlogV)</p><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s</p><p>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><p>图片截图：</p><p><img src="https://img-blog.csdnimg.cn/20200215151327162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="dijkstra.png)"></p><p>自己跑过的代码：</p><pre><code class="java">/** * @FileName: Dijkstra * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: Dijkstra最短路径算法实现 */public class Dijkstra {    private static int N = Integer.MAX_VALUE - 2;    private static int[][] Graph = {            {0, 1, 5, N, N, N, N, N, N},            {1, 0, 3, 7, 5, N, N, N, N},            {5, 3, 0, N, 1, 7, N, N, N},            {N, 7, N, 0, 2, N, 3, N, N},            {N, 5, 1, 2, 0, 3, 6, 9, N},            {N, N, 7, N, 3, 0, N, 5, N},            {N, N, N, 3, 6, N, 0, 2, 7},            {N, N, N, N, 9, 5, 2, 0, 4},            {N, N, N, N, N, N, 7, 4, 0}};    public static void main(String[] args) {        dijkstra(0, Graph);    }    /**     * Dijkstra最短路径。     * 即图中&quot;节点vs&quot;到其它各个节点的最短路径。     *     * @param vs    起始节点     * @param Graph 图     */    public static void dijkstra(int vs, int[][] Graph) {        int NUM = Graph.length;//图中节点的个数        int[] prenode = new int[NUM];//前驱节点数组        int[] mindist = new int[NUM];// 最短距离数组        boolean[] find = new boolean[NUM];// 该节点是否已经找到最短路径，即已经确定节点的集合，初始里面只有vs节点        int vnear = 0;        for (int i = 0; i &lt; NUM; i++) {//初始化            prenode[i] = i;            mindist[i] = Graph[vs][i];            find[i] = false;        }        find[vs] = true;//节点自己到自己的最短路径能找到        for (int v = 1; v &lt; NUM; v++) {//循环NUM-1次            // 每次循环找一个距离vs最近的节点vnear和最短距离min            int min = Integer.MAX_VALUE;            for (int j = 0; j &lt; NUM; j++) {                if (!find[j] &amp;&amp; mindist[j] &lt; min) {                    min = mindist[j];                    vnear = j;                }            }            find[vnear] = true;//vnear节点已经确定，访问标记            // 根据vnear修正vs到其他所有节点的前驱节点及距离，即松弛操作            for (int k = 0; k &lt; NUM; k++) {                if (!find[k] &amp;&amp; (min + Graph[vnear][k]) &lt; mindist[k]) {                    prenode[k] = vnear;                    mindist[k] = min + Graph[vnear][k];                }            }        }        for (int i = 0; i &lt; NUM; i++) {            System.out.println(&quot;v&quot; + vs + &quot;...v&quot; + prenode[i] + &quot;-&gt;v&quot; + i + &quot;, s=&quot; + mindist[i]);        }    }}out:v0...v0-&gt;v0, s=0v0...v1-&gt;v1, s=1v0...v1-&gt;v2, s=4v0...v2-&gt;v3, s=-2147483647v0...v3-&gt;v4, s=-2147483645v0...v7-&gt;v5, s=-2147483642v0...v2-&gt;v6, s=-2147483647v0...v2-&gt;v7, s=-2147483647v0...v2-&gt;v8, s=-2147483647</code></pre><h3 id="2-单源最短路径-2-Bellman-Ford算法"><a href="#2-单源最短路径-2-Bellman-Ford算法" class="headerlink" title="2.单源最短路径_2.Bellman-Ford算法"></a>2.单源最短路径_2.Bellman-Ford算法</h3><p>时间o(VE),比dijkstra慢</p><p>Bellman-Ford 算法描述：</p><p>1.创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；<br>计算最短路径，执行 V - 1 次遍历，每次遍历中，依赖所有边进行松弛操作；</p><p>2.松弛操作：对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；</p><p>3.检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</p><p>自己跑过的代码：</p><pre><code class="java">import java.util.HashSet;import java.util.Set;/** * @FileName: Dijkstra * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: Bellman-Ford最短路径算法实现 */class Edge{    int start; //有向边的起点    int end;   //有向边的终点    int weight;//边的权重}public class Bellman {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构、源节点的下标(0~节点个数-1)     * @return     */    public void Bellman_Ford(int[][] graph, int source){        //图结构中的节点数目、边集合        int nodenum = graph.length;        Set&lt;Edge&gt; edge = new HashSet&lt;&gt;();//边集合        //1.根据graph的图结构给edge[]边数组赋值        for(int i=0; i&lt;nodenum; ++i){            for(int j=i+1; j&lt;nodenum; ++j){                if(graph[i][j]!=N &amp;&amp; graph[i][j]!=0){//有边的话就赋值，最终有edgeIndex条边                    Edge tempEdge = new Edge();                    tempEdge.start = i;                    tempEdge.end = j;                    tempEdge.weight = graph[i][j];                    edge.add(tempEdge);                }            }        }        //2.为dist最短路径数组初始化赋值        int[] dist = new int[nodenum];        for(int i=0; i&lt;nodenum; i++){            dist[i]=graph[source][i];        }        dist[source]=0;        //3.循环nodenum-1次,每次都遍历所有边，进行松弛操作        for(int i=0; i&lt;nodenum-1; i++)//循环nodenum-1次        {            for (Edge edgeTemp: edge){//每次都遍历所有边，进行松弛操作                int start = edgeTemp.start;                int end = edgeTemp.end;                int weight = edgeTemp.weight;                if(dist[end]&gt;dist[start]+weight){//松弛操作                    dist[end]=dist[start]+weight;                }            }        }        //4.判断是否存在负回路        boolean flag=false;//是否存在回路        for (Edge edgeTemp: edge){            if( dist[edgeTemp.end] &gt; dist[edgeTemp.start]+edgeTemp.weight )            {                flag=true;                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++)                System.out.println(dist[i]);//打印源节点到每个节点的距离        }    }    public static void main(String[] args){        Bellman bellman = new Bellman();        int[][] graph = new int[][]{                                    {0, 1, 5, N},                                    {1, 0, 3, 7},                                    {5, 3, 0, N},                                    {N, 7, N, 0}};        bellman.Bellman_Ford(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径    }}</code></pre><h3 id="3-单源最短路径-3-SPFA算法"><a href="#3-单源最短路径-3-SPFA算法" class="headerlink" title="3.单源最短路径_3.SPFA算法"></a>3.单源最短路径_3.SPFA算法</h3><p>SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。</p><p>很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)。</p><p>但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。</p><p>实现方法：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。</p><p>此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。</p><p>图结构为邻接矩阵的spfa代码：</p><pre><code class="java">import java.util.*;/** * @FileName: SPFA * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: SPFA最短路径算法实现 */public class SPFA {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)     * @return     */    public static int[] spfa(int[][] graph, int source){        int nodenum = graph.length;        int[] dist = new int[nodenum];//最短路径数组        boolean[] used = new boolean[nodenum];//访问标记位        for(int i = 0; i&lt;nodenum; i++){            dist[i] = Integer.MAX_VALUE;            used[i] = false;        }        int[] num = new int[nodenum]; //记录每个节点遍历过的次数，用于检测负向环        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//辅助队列        int path[] = new int[nodenum];         //记录最短路的路径        dist[source] = 0;     //source顶点到自身距离为0        used[source] = true;    //表示source顶点进入数组队        num[source] = 1;       //表示source顶点已被遍历一次        queue.add(source);      //source顶点入队        boolean flag = false;//是否存在回路        while(!queue.isEmpty()) {            int u = queue.poll();   //获取队头            used[u] = false;            for (int v = 0; v &lt; nodenum; ++v) {//对每一个u的相邻节点进行松弛操作                if (graph[u][v] != N) {////u与v直接邻接                    if (dist[v] &gt; dist[u] + graph[u][v]) {                        dist[v] = dist[u] + graph[u][v];                        path[v] = u;                        if (!used[v]) {//如果v没有访问过，入队                            queue.offer(v);                            used[v] = true;                            num[v]++;                            if (num[v] &gt;= nodenum) {//遍历次数大于等于节点数，存在负向环,break                                flag = true;                                break;                            }                        }                    }                }            }            if(flag){//存在负向环,break                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++)                System.out.println(dist[i]);//打印源节点到每个节点的距离        }        return dist;    }    public static void main(String[] args){        int[][] graph = new int[][]{                                    {0, 1, 5, N},                                    {1, 0, 3, 7},                                    {5, 3, 0, N},                                    {N, 7, N, 0}};        int[] dist = spfa(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径        System.out.println(Arrays.toString(dist));//out:[4, 3, 0, 10]    }}</code></pre><p>图结构为邻接链表的spfa代码:</p><pre><code class="java">import java.util.*;/** * @FileName: SPFA * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: SPFA最短路径算法实现 */public class SPFA {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)     * @return 单源最短路径     */    public static int[] spfa(int[][] graph, int source){        //1.邻接矩阵转成邻接表        int nodenum = graph.length;        List[] vex = new List[nodenum];        for(int i=0; i&lt;nodenum; ++i){            vex[i] = new ArrayList();        }        for(int i=0; i&lt;nodenum; ++i){            for(int j=i+1; j&lt;nodenum; ++j){//假设给定的图是无向图                if(graph[i][j]!=N){                    vex[i].add(j);                    vex[j].add(i);                }            }        }        //2.spfa        int[] dist = new int[nodenum];//最短路径数组,初始化为MAX_VALUE        for(int i=0; i&lt;nodenum; ++i){            dist[i] = Integer.MAX_VALUE;        }        boolean[] used = new boolean[nodenum];//访问标记位        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//辅助队列        int[] num = new int[nodenum];//记录每个节点遍历过的次数，用于检测负向环        queue.offer(source);//source顶点入队        dist[source] = 0;//source顶点到自身距离为0        num[source] = 1;//表示source顶点已被遍历一次        used[source] = true;        boolean flag = false;//是否存在负向环        int[] path = new int[nodenum];//记录最短路径，初始化上一个节点都为source        for(int i=0; i&lt;nodenum; ++i){            path[i] = source;        }        while (!queue.isEmpty()){            int u = queue.poll();//获取队头            used[u] = false;            for(int i=0; i&lt;vex[u].size(); ++i){//对u的每个相邻节点v进行松弛操作                int v = (int)vex[u].get(i);                if( dist[v]&gt;dist[u]+graph[u][v] ){                    dist[v] = dist[u]+graph[u][v];                    path[v] = u;                    if(!used[v]){//如果v没有访问过，入队                        queue.offer(v);                        num[v]++;                        used[v] = true;                        if(num[v]&gt;=nodenum){//遍历次数大于等于节点数，存在负向环,break                            flag = true;                            break;                        }                    }                }            }            if(flag){//存在负向环,break                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++){                System.out.println(&quot;source:&quot;+source+&quot;...pass:&quot;+path[i]+&quot;--&gt;dest:&quot;+i+&quot;,distance:&quot;+dist[i]);            }        }        return dist;    }    public static void main(String[] args){        int[][] graph = new int[][]{                {0, 1, 5, N},                {1, 0, 3, 7},                {5, 3, 0, N},                {N, 7, N, 0}};        int[] dist = spfa(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径        System.out.println(Arrays.toString(dist));        //out:        //source:2...pass:1--&gt;dest:0,distance:4        //source:2...pass:2--&gt;dest:1,distance:3        //source:2...pass:2--&gt;dest:2,distance:0        //source:2...pass:1--&gt;dest:3,distance:10        //[4, 3, 0, 10]    }}</code></pre><h3 id="4-多源最短路径-Floyd-Warshall算法"><a href="#4-多源最短路径-Floyd-Warshall算法" class="headerlink" title="4.多源最短路径_Floyd-Warshall算法"></a>4.多源最短路径_Floyd-Warshall算法</h3><p>时间o(V^3)</p><p>最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。</p><p>核心代码:</p><pre><code class="java">for(k=1;k&lt;=n;k++)      for(i=1;i&lt;=n;i++)          for(j=1;j&lt;=n;j++)              if(e[i][j]&gt;e[i][k]+e[k][j])                  e[i][j]=e[i][k]+e[k][j]; </code></pre><p><a name="29"></a></p><h2 id="29-Word-Ladder-2道-SPFA最短路算法应用"><a href="#29-Word-Ladder-2道-SPFA最短路算法应用" class="headerlink" title="29.Word Ladder(2道)(SPFA最短路算法应用)"></a>29.Word Ladder(2道)(SPFA最短路算法应用)</h2><pre><code>Word Ladder--leetcode 127Word Ladder2--leetcode 126</code></pre><h3 id="1-Word-Ladder"><a href="#1-Word-Ladder" class="headerlink" title="1.Word Ladder"></a>1.Word Ladder</h3><p>leetcode 127</p><p>题目：Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p><pre><code>1.Only one letter can be changed at a time.2.Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</code></pre><p>Note:</p><pre><code>Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters.You may assume no duplicates in the word list.You may assume beginWord and endWord are non-empty and are not the same.</code></pre><p>Example 1:</p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5.</code></pre><p>题目大意: </p><p>思路：最短路径问题。1.构造图结构(邻接表); 2.用SPFA最短路算法求beginWord到endWord的最短改变次数</p><p>代码：</p><pre><code class="java">//Word Ladder找出beginWord到endWord的最小改变次数。//思路：最短路问题。1.构图; 2.用SPFA最短路算法求beginWord到endWord的最短改变次数public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {    if(diff(beginWord, endWord)==1){        return 2;    }    //1.构造图的邻接表    int size = wordList.size();    List[] edge = new List[size+2];//size装beginWord，size+1装endWord    for(int i=0; i&lt;edge.length; ++i){        edge[i] = new ArrayList&lt;Integer&gt;();    }    boolean can_arrive = false;//从beginWord到endWord是否能顺利改变    for(int i=0; i&lt;size; ++i){        for(int j=i+1; j&lt;size; ++j){            if(diff(wordList.get(i), wordList.get(j)) == 1){//这两个单词可以转变，图中有边                edge[i].add(j);                edge[j].add(i);            }        }        if(diff(beginWord, wordList.get(i))==1){//字典中的当前单词与beginWord可以改变，图中有边            edge[size].add(i);        }        int temp = diff(endWord, wordList.get(i));        if(temp == 1){//字典中的当前单词与endWord可以改变，图中有边            edge[i].add(size+1);        }        if(temp == 0){//字典中包含endWord，can_arrive            can_arrive = true;        }    }    if(can_arrive==false){        return 0;    }    //2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径    int[] dist = new int[size+2];//求edge[size]节点的单源最短路径数组    for(int i = 0; i&lt;size+2; i++){        dist[i] = Integer.MAX_VALUE;    }    dist[size] = 1;    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    queue.offer(size);//起始节点入队    while(!queue.isEmpty()) {        int queFirstNode = queue.poll();   //获取队头        int dest = dist[queFirstNode];        for(int i=0; i&lt;edge[queFirstNode].size(); ++i){//遍历queFirstNode为起点的每条边            //当队头的节点等于边edgeTemp的起点时,进行松弛操作            int temp = (int)edge[queFirstNode].get(i);            if( dist[temp] &gt; dest+1 ) {                dist[temp] = dest+1;                queue.add(temp);                if(temp == size+1) {//该节点是终点，即改变成功                    return dist[temp];//从起点(size)到终点(size+1)的最短距离                }            }        }    }    return 0;}//判断两个字符串不同的字符个数public int diff(String word1, String word2){    int res = 0;    for(int i=0; i&lt;word1.length(); ++i){        if(word1.charAt(i)!=word2.charAt(i)){            res++;        }    }    return res;}</code></pre><h3 id="2-Word-Ladder2"><a href="#2-Word-Ladder2" class="headerlink" title="2.Word Ladder2"></a>2.Word Ladder2</h3><p>leetcode 126</p><p>题目：题目与上面同，只是结果应该返回所有转换的路径而不是最短的路径长度</p><p>思路：还是构造邻接链表+SPFA最短路径算法，当找到终点时用<strong>dfs</strong>从终点节点反推找出所有不同的最短路径即可。</p><p>Example 1:</p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><p>代码：</p><pre><code class="java">import java.util.*;public class Solution {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    int size;    int[] dist;    List[] edge;    String a;    String b;//这些变量弄成全局是为了dfs函数中使用    List&lt;String&gt; wl;    ArrayList&lt;String&gt; tempPath = new ArrayList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) {        a = beginWord;        b = endWord;        wl = wordList;        size = wordList.size();        //1.构造图的邻接表        edge = new List[size+2];//size装beginWord，size+1装endWord        for(int i=0; i&lt;edge.length; ++i){            edge[i] = new ArrayList&lt;Integer&gt;();        }        boolean can_arrive = false;//从beginWord到endWord是否能顺利改变        if(diff(beginWord, endWord)==1){            edge[size].add(size+1);            edge[size+1].add(size);        }        for(int i=0; i&lt;size; ++i){            for(int j=i+1; j&lt;size; ++j){                if(diff(wordList.get(i), wordList.get(j)) == 1){//这两个单词可以转变，图中有边                    edge[i].add(j);                    edge[j].add(i);                }            }            if(diff(beginWord, wordList.get(i))==1){//字典中的当前单词与beginWord可以改变，图中有边                edge[size].add(i);                edge[i].add(size);            }            int temp = diff(endWord, wordList.get(i));            if(temp == 1){//字典中的当前单词与endWord可以改变，图中有边                edge[i].add(size+1);                edge[size+1].add(i);            }            if(temp == 0){//字典中包含endWord，can_arrive                can_arrive = true;            }        }        if(!can_arrive){            return res;        }        //2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径        dist = new int[size+2];//求edge[size]节点的单源最短路径数组        for(int i = 0; i&lt;size+2; i++){            dist[i] = Integer.MAX_VALUE;        }        dist[size] = 1;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        queue.offer(size);//起始节点入队        while(!queue.isEmpty()) {            int queFirstNode = queue.poll();   //获取队头            int dest = dist[queFirstNode];            for(int i=0; i&lt;edge[queFirstNode].size(); ++i){//遍历queFirstNode为起点的每条边                //当队头的节点等于边edgeTemp的起点时,进行松弛操作                int temp = (int)edge[queFirstNode].get(i);                if( dist[temp] &gt; dest+1 ) {                    dist[temp] = dest+1;                    queue.add(temp);                    if(temp == size+1) {//该节点是终点，即改变成功,用dfs从终点返回回去找路径                        dfs(temp);                        return res;                    }                }            }        }        return res;    }    public void dfs(int p){        if(p==size){//起点            tempPath.add(a);        }        else if(p==size+1){//终点            tempPath.add(b);        }        else{            tempPath.add(wl.get(p));        }        if(dist[p]==1){//递归出口，如果递归到了起点，说明一条路径已经找到了            ArrayList&lt;String&gt; temp = new ArrayList&lt;&gt;(tempPath);            Collections.reverse(temp);            res.add(temp);            if (!tempPath.isEmpty()){                tempPath.remove(tempPath.size()-1);            }            return;        }        //往回走        for(int i=0; i&lt;edge[p].size(); ++i){            int dest = (int)edge[p].get(i);            if(dist[dest]+1 == dist[p]){                dfs(dest);            }        }        if (!tempPath.isEmpty()){            tempPath.remove(tempPath.size()-1);        }    }    //判断两个字符串不同的字符个数    public int diff(String word1, String word2){        int res = 0;        for(int i=0; i&lt;word1.length(); ++i){            if(word1.charAt(i)!=word2.charAt(i)){                res++;            }        }        return res;    }    public static void main(String[] args){        Solution s = new Solution();        String beginWord = &quot;hit&quot;;        String endWord = &quot;cog&quot;;        String[] wordList = new String[]{&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;};        System.out.println(s.findLadders(beginWord, endWord, Arrays.asList(wordList)));        //out:[[hit, hot, dot, dog, cog], [hit, hot, lot, log, cog]]    }}</code></pre><p><a name="30"></a></p><h2 id="30-字符串匹配-kmp算法"><a href="#30-字符串匹配-kmp算法" class="headerlink" title="30.字符串匹配(kmp算法)"></a>30.字符串匹配(kmp算法)</h2><p>leetcode 28</p><p>题目：Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Example 1:</p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Example 2:Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1</code></pre><p>思路：kmp算法。求模式串的next数组，然后进行字符串匹配即可。不用kmp算法之前的时间o(mn),m字符串，n模式串，用kmp算法之后的时候是o(m+n)。下面重点讲解kmp中的next数组怎么求。</p><p>如果不写代码的话，kmp的next非常好求，就是考研时候的那个套路，如”ABAD”–&gt;next:[-1,0,0,1]，有了next数组，拿模式串j和字符串i依次进行匹配即可，如果不等，则i不动，对应模式串跳转到next[j]继续匹配，如果next[j]==-1，则i也+1即可</p><p>代码实现next数组的过程强推油管<a href="https://www.youtube.com/watch?v=GTJr8OvyEVQ" target="_blank" rel="noopener">(KMP) Pattern Matching</a>，下面是自己的总结。</p><p>核心就是代码求kmp的next数组如”ABAD”–&gt;next:[-1,0,0,1],见下面的代码:</p><pre><code class="java">public int strStr(String haystack, String needle) {    if(needle==null || needle.length()==0){        return 0;    }    if(haystack==null || haystack.length()==0){        return -1;    }    int i = 0;    int j = 0;    int[] next = getNext(needle);    while (i &lt; haystack.length() &amp;&amp; j &lt; needle.length())    {        if ( j==-1 || haystack.charAt(i)==needle.charAt(j) )        {            i++;            j++;        }        else            j = next[j];    }    if ( j==needle.length() ){//匹配成功，返回needle出现的位置        return i-j;    }    return -1;}public int[] getNext(String needle){    int[] next = new int[needle.length()];    int j = -1;    int i = 0;    next[0] = -1;    while(i&lt;needle.length()){        if(j==-1 || needle.charAt(i)==needle.charAt(j)){            j++;            i++;            if(i&lt;needle.length()){                next[i] = j;            }        }        else{            j = next[j];        }    }    return next;}</code></pre><p><a name="31"></a></p><h2 id="31-两数相除-转为减法"><a href="#31-两数相除-转为减法" class="headerlink" title="31.两数相除(转为减法)"></a>31.两数相除(转为减法)</h2><p>leetcode 29</p><p>题目：除法运算，但是不能使用/、%、*（除数不会为0）。</p><p>思路：将除法转化为减法，但是单纯的做减法计算次数太粗暴，故采用除数扩大（左移），商随之扩大（左移）的思想，同时要考虑正负两边的最大绝对值是不一样的。最简单的方法是用long去处理。另外一个边界条件需要单独处理：<code>-2147483648/-1= 2147483647</code></p><p>把除数表示为：dividend = 2^i * divisor + 2^(i-1) * divisor + … + 2^0 * divisor。这样一来，我们所求的商就是各系数之和了，而每个系数都可以通过移位操作获得。</p><p>分两步走：</p><pre><code>1）获得i的值；2）将各系数求和。显然每步都是logN的复杂度。</code></pre><p>代码：</p><pre><code class="java">//除法转换为减法。具体思路:除数左移几次，商左移几次。dividend=2^i*divisor+2^(i-1)*divisor+...+2^0*divisor.public int divide(int dividend, int divisor) {    if(dividend == 0){        return 0;    }    boolean isPositive = (dividend&gt;0 &amp;&amp; divisor&gt;0) || (dividend&lt;0 &amp;&amp; divisor&lt;0);    long res = divideDetail( Math.abs((long)dividend), Math.abs((long)divisor) );    if(isPositive &amp;&amp; res&gt;Integer.MAX_VALUE){//溢出特例必须处理-2147483648/-1= 2147483647        res = Integer.MAX_VALUE;    }    return isPositive ? (int)res : -(int)res;}public long divideDetail(long dividend, long divisor){    //1.除数左移, 获取i值    long i = 0;    while(dividend &gt;= (divisor&lt;&lt;1)){        divisor &lt;&lt;= 1;        i++;    }    //2.商左移cnt次，获取多项式系数和，即商系数相加    long res = 0;    while(i&gt;=0){        if(dividend&gt;=divisor){            res += (1L&lt;&lt;i);            dividend -= divisor;        }        divisor &gt;&gt;= 1;        i--;    }    return res;}</code></pre><p><a name="32"></a></p><h2 id="32-sqrt-x"><a href="#32-sqrt-x" class="headerlink" title="32.sqrt(x)"></a>32.sqrt(x)</h2><p>leetcode 69</p><p>题目：Implement int sqrt(int x).求x的平方根。</p><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p>思路1：二分法。定义一个最小精度，用二分法逼近即可。</p><pre><code class="java">//二分法public int mySqrt(int x) {    if(x == 0){        return 0;    }    if(x&lt;4){        return 1;    }    double left = 1;    double right = x;    double mid;    while(left&lt;=right){        mid = left + (right-left)/2;        if(mid*mid==x || right-mid&lt;1e-9){            return (int)mid;        }        else if(mid*mid&gt;x){//因为是double类型所以乘法比除法好，也不会溢出            right = mid;        }        else if(mid*mid&lt;x){            left = mid;        }    }    return 0;}</code></pre><p>思路1的改进：因为题目中所求是int类型，所以不需要double类型去逼近，用int</p><pre><code class="java">//二分法的改进public int mySqrt(int x) {    if(x == 0){        return 0;    }    if(x&lt;4){        return 1;    }    int left = 1;    int right = x;    int mid;    while(left&lt;=right){        mid = left + (right-left)/2;        if(x/mid==mid){            return mid;        }        else if(x/mid&lt;mid){//因为是int类型所以除法比乘法好，这样也可以避免溢出            right = mid-1;        }        else if(x/mid&gt;mid){            left = mid+1;        }    }    return right;//while跳出循环时，right &lt; left，应该返回right}</code></pre><p>思路2：牛顿法。对x的平方根的值一个猜想y。通过执行一个简单的操作去得到一个更好的猜测：只需要求出y和x/y的平均值（它更接近实际的平方根值）。</p><pre><code class="java">//牛顿法public int mySqrt(int x) {    double k=1.0； //当然猜想的数拿来主义会更快k=0x5f3759df;    while(Math.abs(k*k-x)&gt;0.0001) {//精度不能太高，否则太慢        k=(k+x/k)/2;    }    return (int)k;}</code></pre><p><a name="33"></a></p><h2 id="33-乱序的数组中找到最长的递增子序列"><a href="#33-乱序的数组中找到最长的递增子序列" class="headerlink" title="33.乱序的数组中找到最长的递增子序列"></a>33.乱序的数组中找到最长的递增子序列</h2><p>leetcode 300</p><p>题目：Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><p>思路1(可取，但不够好)：DP问题。时间o(n^2)</p><p>设长度为N的数组为{a0，a1, a2, …an-1)，则假定以aj结尾的数组序列的最长递增子序列长度为L(j)，<strong>则L(j)={ max(L(i))+1, i&lt;j且a[i]&lt;a[j] }</strong>。也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。</p><p>例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：</p><pre><code class="java">//最长递增子序列。思路1：一维DP，时间o(n^2)public int lengthOfLIS(int[] nums) {    int len = nums.length;    int[] longest = new int[len];    for (int i=0; i&lt;len; i++){        longest[i] = 1; //初始化都为1    }    //dp[j] = {max(L(i))+1}, 如果i&lt;j且a[i]&lt;a[j]    for (int j=1; j&lt;len; j++) {        for (int i=0; i&lt;j; i++) {            if (nums[j]&gt;nums[i] &amp;&amp; longest[j]&lt;longest[i]+1){ //注意longest[j]&lt;longest[i]+1这个条件，不能省略。                longest[j] = longest[i] + 1; //计算以arr[j]结尾的序列的最长递增子序列长度            }        }    }    //再遍历一遍dp[]数组，取最大的    int max = 0;    for (int j=0; j&lt;len; j++) {        if (longest[j] &gt; max) max = longest[j];  //从longest[j]中找出最大值    }    return max;}</code></pre><p>思路2(更好)：二分。假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。</p><p>下面一步一步试着找出它。</p><p>我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br>此外，我们用一个变量Len来记录现在最长算到多少了</p><p>首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p><p>然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1</p><p>接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2</p><p>再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p><p>继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p><p>第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p><p>第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p><p>第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p><p>最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p><p>于是我们知道了LIS的长度为5。</p><p>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p><p>然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)<del>~</del>于是算法的时间复杂度就降低到了O(NlogN)～！</p><p>代码如下（代码中的数组B从位置0开始存数据）：</p><pre><code class="java">//最长递增子序列。思路2：辅助数组存储有序数列，时间o(nlogn)public int lengthOfLIS(int[] nums) {    int[] dp = new int[nums.length];    int len = 0;    for(int num : nums){        //二分查找，查找不到的话就返回负数,负数从1开始。[1,2,3](索引是0，1，2/找不到的索引是1,2,3) 找num=1.5 返回-2        int i = Arrays.binarySearch(dp, 0, len, num);        if(i &lt; 0) i = -i-1;        dp[i] = num;        if(len == i) len ++;//不是更新的值，而是实实在在的扩张递增序列了，所以len++    }    return len;}</code></pre><p><a name="34"></a></p><h2 id="34-蓄水池问题"><a href="#34-蓄水池问题" class="headerlink" title="34.蓄水池问题"></a>34.蓄水池问题</h2><p>leetcode 42</p><p><img src="https://img-blog.csdnimg.cn/2020021515145692.png" alt="蓄水池.jpg"></p><p>题目：Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>Example:</p><pre><code>Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6</code></pre><p>思路：两头双指针往中间。</p><pre><code class="java">//蓄水池问题。思路：两头双指针往中间public int trap(int[] height) {    int leftmax = 0;//左边最大的板子    int rightmax = 0;//右边最大的板子    int a = 0;    int b = height.length - 1;    int sum = 0;    while(a &lt;= b){        leftmax = Math.max(height[a], leftmax);//每次都更新下左右两边最大的板子        rightmax = Math.max(height[b], rightmax);        if(leftmax &lt; rightmax){//左边比右边的板子小，右边能挡住，因此看左边的短板            sum += leftmax - height[a];            a++;        }else{            sum += rightmax - height[b];            b--;        }    }    return sum;}</code></pre><p><a name="35"></a></p><h2 id="35-满足指定sum条件的长度最小的子数组"><a href="#35-满足指定sum条件的长度最小的子数组" class="headerlink" title="35.满足指定sum条件的长度最小的子数组"></a>35.满足指定sum条件的长度最小的子数组</h2><p>leetcode 209 Minimum Size Subarray Sum</p><p>题目：Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>Example: </p><pre><code>Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint.</code></pre><p>思路：遍历一遍数组，两个指针变量i,j控制窗口动态变化，时间o(n)</p><pre><code class="java">public int minSubArrayLen(int s, int[] nums) {    if(nums==null || nums.length==0){        return 0;    }    int i = 0;    int j = 0;    int resMin = Integer.MAX_VALUE;    int sum = nums[i];    while(j&lt;nums.length){        while(sum &lt; s){//和不够，j++，扩大窗口            j++;            if(j&gt;=nums.length){//循环出口                return resMin==Integer.MAX_VALUE ? 0 : resMin;            }            sum += nums[j];        }        resMin = Math.min(resMin, j-i+1);//更新最小窗口长度        while(sum &gt;= s){//和够了，i++，缩小窗口            resMin = Math.min(resMin, j-i+1);////更新最小窗口长度            sum -= nums[i];            i++;        }    }    return 0;}</code></pre><p><a name="36"></a></p><h2 id="36-最大值减去最小值小于或等于num的子数组数量"><a href="#36-最大值减去最小值小于或等于num的子数组数量" class="headerlink" title="36.最大值减去最小值小于或等于num的子数组数量"></a>36.最大值减去最小值小于或等于num的子数组数量</h2><p>《左神》31</p><p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p><p>思路：数组长度n，时间o(n),空间o(n)</p><p>1、生成两个队列qmax和qmin. 两个指针i,j，标定数组边界</p><p>2、令j不断向右移动（j++）,表示arr[i..j]一直向右扩大，并不断更新qmax和qmin结构，保证qmax和qmin始终维持动态窗口最大值和最小值的更新结构。直到j不满足向右扩张条件时，以arr[i]为左边界且满足条件的子数组(子数组长度&gt;=2)个数为j-i</p><p>3、当进行完步骤2，令i向右移动一个位置并对qmax和qmin做出相应的更新做出相应的更新。 </p><p>4、根据步骤2，步骤3，依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量分别有多少，累加起来起来的数量就是最终的结果。</p><pre><code class="java">//最大值减去最小值小于或等于num的子数组数量(子数组长度大于1)。思路：两个队列qmax和qmin. 两个指针i,j//依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量public static int getNum(int[] arr,int num){    if(arr==null || arr.length&lt;2){        return 0;    }    int i = 0;    int j = 0;//辅助i/j两个指针    Deque&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();    Deque&lt;Integer&gt; qmin = new LinkedList&lt;&gt;();//辅助两个双端队列记录当前子数组的最大/小值    int res = 0;    while(i&lt;arr.length){        while(j&lt;arr.length){//j不断往右扩            while(!qmax.isEmpty() &amp;&amp; arr[j]&gt;=arr[qmax.peekLast()]){//注意这里必须有=                qmax.pollLast();            }            qmax.offerLast(j);            while(!qmin.isEmpty() &amp;&amp; arr[j]&lt;=arr[qmin.peekLast()]){                qmin.pollLast();            }            qmin.offerLast(j);            if(!qmax.isEmpty()&amp;&amp;!qmin.isEmpty() &amp;&amp; arr[qmax.peekFirst()]-arr[qmin.peekFirst()] &lt;= num){                j++;            }            else{//当j不满足继续向右扩的条件时，break并计算当前以arr[i]为底的子数组的个数                break;            }        }        i++;        res += j-i;//计算当前以arr[i]为底的子数组的个数        if(!qmax.isEmpty() &amp;&amp; qmax.peekFirst()&lt;i){//将队列窗口之外的元素索引弹出(i之前的都不要了)            qmax.pollFirst();        }        if(!qmin.isEmpty() &amp;&amp; qmin.peekFirst()&lt;i){            qmin.pollFirst();        }    }    return res;}public static void main(String[] args){    int[] nums = new int[]{1,2,3,4,5};    System.out.println(getNum(nums,1));//out:4  [1,2][2,3][3,4][4,5]}</code></pre><p><a name="37"></a></p><h2 id="37-几道未整理的"><a href="#37-几道未整理的" class="headerlink" title="37.几道未整理的"></a>37.几道未整理的</h2><p>###1.有序数组合并###</p><p>####问题：</p><p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。<br>给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</p><p>####思路：</p><p>这道题很简单，就是一个归并的过程。和归并排序里面的归并函数做法基本一样，但需要注意的是，这道题是把数组B加入到数组A里。我们需要从后往前比较、加入，这样防止覆盖掉数组A前面的有用部分。过程大致为我们每次从两个列表后面元素选取较大的一个，放入A最后，直到某一个列表到达头部，再将另一个剩下部分逆序取出。时间复杂度O（n+m），空间O（1）。</p><p>####代码：</p><pre><code class="java">class A{    public int[] mergeAB(int[] a, int[] b, int n, int m)    {        int pa = n - 1;        int pb = m - 1;        int p = m + n - 1;        do        {            if(pa==-1)                for(int i=p; i&gt;=0; i--)                    a[i] = b[pb--];            else if(pb==-1)                return a;            else                a[p--] = (a[pa]&gt;b[pb])?a[pa--]:b[pb--];        }while(p!=0);    return a;    }}public class Example{    public static void main(String[] args)    {        A cc = new A();        int[] a = {1,3,5,7,11, 0, 0, 0, 0, 0};        int[] b = {2,4,6,8,12};        int[] c = new int[5];        c = cc.mergeAB(a, b, 5, 5);        for(int i: c)            System.out.print(i + &quot; &quot;);    }}//output:1 2 3 4 5 6 7 8 11 12</code></pre><p>###2.三色排序</p><p>####问题：</p><p>有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。<br>给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。</p><p>测试样例：[0,1,1,0,2,2],6</p><p>返回：[0,0,1,1,2,2]</p><p>####思路：</p><p>这是一个经典的荷兰国旗问题，处理过程和快排的划分过程相似，可以参考快排的划分技巧。时间复杂度O（n），空间O（1）。过程为：</p><p>遍历数组之前，在数组左端设立“0区”，初始大小0，在数组右端设立“2区”，初始大小0。遍历数组，如果是1，直接跳到下一个；如果是0，把当前元素与“0区”后一位交换，“0区”大小+1，遍历下一个元素；遇到2，把当前元素与“2区”前一位交换，“2区”大小+1，由于“2区”元素并没有遍历过，所以不跳到后一个位置，继续遍历该位置元素。</p><p>####代码:</p><pre><code class="java">public class ThreeColor {    public int[] sortThreeColor(int[] A, int n) {        // write code here        int i=-1;        int j=n;        int temp;        for(int k=0;k&lt;j;){            if(A[k]==0){                swap(A,++i,k++);             }            else if(A[k]==2){                swap(A,--j,k);            }            else                k++;        }        return A;    }    void swap(int A[],int a,int b){        int temp=A[a];        A[a]=A[b];        A[b]=temp;    }}</code></pre><p>其实拿到这个问题我最先想到的是用计数排序处理，只要三个桶，几乎可以认为是原地的，简单多了。但这里明确说要用交换，而不是计数。在在线课程下面的评论区里，有小伙伴提出和我一样的疑问，老师的回答是:</p><blockquote><p>如果数组里面放的不是int，long这种类型，而是具体一个一个实例呢？你还能压缩在一起吗？比如数组里面放的是“人”这个类的实例，每个实例有一个“身高”的数据项，请把小于160放左边，160~170放中间，170以上放右边。荷兰国旗问题重点介绍的是一种处理数组的技巧。这种技巧从快排中来，掌握了可以解决很多类似的问题。我并不是在强调这么做才对，只是一种技巧而已。</p></blockquote><p>###3.最短子数组问题</p><p>####问题：</p><p>对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。<br>给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。<br>测试样例：<br>[1,4,6,5,9,10],6<br>返回：2</p><p>####思路：<br>拿到这道题，我最直接的想法就是先排序，再比较排序后的数组有变化的位置，位置有变化的元素里的最左的一个到最右的一个，这之间的数组就是题目要求的需要排序的最短子数组。这种方法需要额外空间复杂度O（n），用来保存排序后的数组（或者保存原数组各元素下标情况，这取决于具体实现）。时间复杂度O（nlogn）。</p><p>由上面的这个思路，我们可以想到，其实只要知道，需要调整的元素里最右的元素和最左的元素的位置，就可以得到需要排序的最短子数组的长度。我们知道，如果是有序数组，一定是越往右，数值越大，越往左，数值越小，不满足这个条件的元素，那么就是需要调整的元素。于是可以想到下面的这种处理方法。它可以做到时间复杂度O（n），额外空间复杂度O（1）。处理过程大致为：</p><p>先向右遍历，记住遍历过的元素中的最大值max。如果遍历的当前元素i的值A[i]小于max，说明i是需要向左调整的，记住它。向右遍历，只记录需要向左调整的元素的最右的一个，记为R。<br>再从右至左遍历一次，这次记住遍历过的元素中的最小值min。同理，如果遍历的当前元素i的值A[i]大于min，说明i是需要向右调整的，记住它。遍历过程只记录要调整的最左的一个元素，记为L。A[l]~A[R]就是需要排序的最短子数组，它的长度是R-L+1.</p><p>####代码：</p><pre><code class="java">public int shortestSubsequence(int[] A, int n) {    int max = A[0];    int min = A[n-1];    int l = -1;    int r = 0;    //从左至右遍历，记录最右的当前值小于最大值情况    for(int i=1; i&lt;n; ++i)    {        if(A[i]&gt;=max)            max = A[i];        else            l = i;    }    //从右至左遍历，记录最左的当前值大于最小值情况    for(int j=n-2; j&gt;=0; j--)    {        if(A[j]&lt;min)            min = A[j];        else            r = j;    }    return l-r+1;}</code></pre><p>###4.有序矩阵查找</p><p>####问题：</p><p>现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。<br>给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。</p><p>测试样例：</p><p>[[1,2,3],[4,5,6],[7,8,9]],3,3,10</p><p>返回：false</p><p>####思路：</p><p>这道题可以做到时间复杂度O（m+n），额外空间复杂度O（1）。用下面这个矩阵举例说明。</p><p><img src="https://img-blog.csdnimg.cn/20200215151658115.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="matrix0.jpg"></p><p>我们从右上角或左下角作为起始位置开始遍历。这么做是因为矩阵行列都是有序的，右上角是行最小，列最大，左下角相反。我们这里选择从右上角开始，假设待查值是3。当前值是5，如果待查值比当前值大，那么往下走一步，因为我们知道这一行当前位置是最大的，左面所有元素都小于该值，就不用考虑；如果待查值更小，那么往左走一步，理由同上；如果相等，返回true。待查值3&lt;当前值5，往左走一步，当前值变成2。重复上面过程，当前值=4。3&lt;4,所以再往左走，现在待查值3=当前值3，返回true。如果直到越界都没找到，则返回false。</p><p>####代码：</p><pre><code class="java">boolean findX(int[][] mat, int n, int m, int x){    for(int i=0, j=m-1; (i!=n)&amp;&amp;(j!=-1); ) //起始位置(i,j)从矩阵右上角开始    {        if(x&gt;mat[i][j]) //目标值大于矩阵元素，向下走            i++;        else if(x &lt; mat[i][j])  //目标值小于矩阵元素，向左走            j--;        else if(x == mat[i][j])            return true;    }    return false;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题</title>
      <link href="/2018/09/21/sword-offer-algorithm/"/>
      <url>/2018/09/21/sword-offer-algorithm/</url>
      
        <content type="html"><![CDATA[<p>此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑指offer专题oj，可在上面进行练习验证。</p><a id="more"></a><p>此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑指offer专题oj，可在上面进行练习验证。</p><h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">找出数组中重复的数字</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">不修改数组找出重复的数字</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">0~n-1中缺失的数字(2道)</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">数组中数字出现的次数(3道)</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">数组中出现次数超过一半的数字</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">数组中出现次数超过1/3的数字</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">统计指定数字在排序数组中出现的次数</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">二维数组中的查找</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">替换空格</a></td></tr><tr><td align="center">10</td><td align="center"><a href="#10">Replace Words–字典树</a></td></tr><tr><td align="center">11</td><td align="center"><a href="#11">Find And Replace in String</a></td></tr><tr><td align="center">12</td><td align="center"><a href="#12">从尾到头打印链表</a></td></tr><tr><td align="center">13</td><td align="center"><a href="#13">反转链表(三道)</a></td></tr><tr><td align="center">14</td><td align="center"><a href="#14">重建二叉树</a></td></tr><tr><td align="center">15</td><td align="center"><a href="#15">二叉树的下一个节点</a></td></tr><tr><td align="center">16</td><td align="center"><a href="#16">Populating Next Right Pointers in Each Node</a></td></tr><tr><td align="center">17</td><td align="center"><a href="#717">Populating Next Right Pointers in Each Node II</a></td></tr><tr><td align="center">18</td><td align="center"><a href="#18">两个栈实现队列</a></td></tr><tr><td align="center">19</td><td align="center"><a href="#19">两个队列实现栈</a></td></tr><tr><td align="center">20</td><td align="center"><a href="#20">斐波那契数列(三道)</a></td></tr><tr><td align="center">21</td><td align="center"><a href="#21">斐波那契数列变种_medium难度(两道)</a></td></tr><tr><td align="center">22</td><td align="center"><a href="#22">Additive Number</a></td></tr><tr><td align="center">23</td><td align="center"><a href="#23">旋转数组的最小数字(三道)</a></td></tr><tr><td align="center">24</td><td align="center"><a href="#24">矩阵中的路径</a></td></tr><tr><td align="center">25</td><td align="center"><a href="#25">机器人的运动范围</a></td></tr><tr><td align="center">26</td><td align="center"><a href="#26">Unique Paths(两道)</a></td></tr><tr><td align="center">27</td><td align="center"><a href="#27">剪绳子</a></td></tr><tr><td align="center">28</td><td align="center"><a href="#28">不用加减乘除做加法(位运算)</a></td></tr><tr><td align="center">29</td><td align="center"><a href="#29">Two Sum</a></td></tr><tr><td align="center">30</td><td align="center"><a href="#30">二进制中1的个数</a></td></tr><tr><td align="center">31</td><td align="center"><a href="#31">数值的整数次方</a></td></tr><tr><td align="center">32</td><td align="center"><a href="#32">打印从1到最大的n位数</a></td></tr><tr><td align="center">33</td><td align="center"><a href="#33">删除链表中重复的节点(两道)</a></td></tr><tr><td align="center">34</td><td align="center"><a href="#34">正则表达式匹配</a></td></tr><tr><td align="center">35</td><td align="center"><a href="#35">表示数值的字符串</a></td></tr><tr><td align="center">36</td><td align="center"><a href="#36">调整数组顺序使奇数位于偶数前面(3道)</a></td></tr><tr><td align="center">37</td><td align="center"><a href="#37">链表中倒数第k个结点(两道)</a></td></tr><tr><td align="center">38</td><td align="center"><a href="#38">判断链表是否有环(两道)</a></td></tr><tr><td align="center">39</td><td align="center"><a href="#39">两个单链表相交的第一个公共节点(2道)</a></td></tr><tr><td align="center">40</td><td align="center"><a href="#40">合并两个排序的链表</a></td></tr><tr><td align="center">41</td><td align="center"><a href="#41">树的子结构</a></td></tr><tr><td align="center">42</td><td align="center"><a href="#42">二叉树的翻转(镜像)与对称(2道)</a></td></tr><tr><td align="center">43</td><td align="center"><a href="#43">顺时针打印矩阵</a></td></tr><tr><td align="center">44</td><td align="center"><a href="#44">包含min函数的栈</a></td></tr><tr><td align="center">45</td><td align="center"><a href="#45">栈的压入、弹出序列</a></td></tr><tr><td align="center">46</td><td align="center"><a href="#46">二叉树的层序遍历(3道)</a></td></tr><tr><td align="center">47</td><td align="center"><a href="#47">递归与非递归实现二叉树前序、中序、后序遍历</a></td></tr><tr><td align="center">48</td><td align="center"><a href="#48">判断数组是否为二叉搜索树的后续遍历序列</a></td></tr><tr><td align="center">49</td><td align="center"><a href="#49">二叉树中和为某一值的路径</a></td></tr><tr><td align="center">50</td><td align="center"><a href="#50">复杂链表的复制</a></td></tr><tr><td align="center">51</td><td align="center"><a href="#51">二叉搜索树与双向链表(两道)</a></td></tr><tr><td align="center">52</td><td align="center"><a href="#52">序列化二叉树</a></td></tr><tr><td align="center">53</td><td align="center"><a href="#53">全排列问题(五道)</a></td></tr><tr><td align="center">54</td><td align="center"><a href="#54">打印出给定字符串中字符的所有组合</a></td></tr><tr><td align="center">55</td><td align="center"><a href="#55">大/小根堆–优先队列实现(两道)</a></td></tr><tr><td align="center">56</td><td align="center"><a href="#56">数据流中的中位数</a></td></tr><tr><td align="center">57</td><td align="center"><a href="#57">数组中最大连续子序列的和</a></td></tr><tr><td align="center">58</td><td align="center"><a href="#58">1到n整数中1出现的次数</a></td></tr><tr><td align="center">59</td><td align="center"><a href="#59">正整数序列中的第n个数字</a></td></tr><tr><td align="center">60</td><td align="center"><a href="#60">把数组排成最小的数</a></td></tr><tr><td align="center">61</td><td align="center"><a href="#61">求把一个数字翻译成不同字符串的个数(DP)</a></td></tr><tr><td align="center">62</td><td align="center"><a href="#62">礼物的最大价值</a></td></tr><tr><td align="center">63</td><td align="center"><a href="#63">最长不含重复的子字符串长度</a></td></tr><tr><td align="center">64</td><td align="center"><a href="#64">丑数(两道)</a></td></tr><tr><td align="center">65</td><td align="center"><a href="#65">第一个只出现一次的字符</a></td></tr><tr><td align="center">66</td><td align="center"><a href="#66">归并排序相关(3道)</a></td></tr><tr><td align="center">67</td><td align="center"><a href="#67">二叉搜索树的第k小节点(中序遍历)</a></td></tr><tr><td align="center">68</td><td align="center"><a href="#68">二叉树的深度(两道)</a></td></tr><tr><td align="center">69</td><td align="center"><a href="#69">数组中和为s的数字(四道)</a></td></tr><tr><td align="center">70</td><td align="center"><a href="#70">翻转字符串(两道)</a></td></tr><tr><td align="center">71</td><td align="center"><a href="#71">滑动窗口的最大值(双端队列)</a></td></tr><tr><td align="center">72</td><td align="center"><a href="#72">打印n个骰子所有可能的点数和及概率</a></td></tr><tr><td align="center">73</td><td align="center"><a href="#73">扑克牌中的顺子(2道)</a></td></tr><tr><td align="center">74</td><td align="center"><a href="#74">圆圈中剩下的数(约瑟夫环问题)</a></td></tr><tr><td align="center">75</td><td align="center"><a href="#75">股票的最大利润问题(四道)</a></td></tr><tr><td align="center">76</td><td align="center"><a href="#76">求1+2+3+…+n(不用if而用或短路的方式结束递归)</a></td></tr><tr><td align="center">77</td><td align="center"><a href="#77">构建乘积数组</a></td></tr><tr><td align="center">78</td><td align="center"><a href="#78">普通二叉树中两个节点的最低公共祖先</a></td></tr><tr><td align="center">79</td><td align="center"><a href="#79">把字符串转换成整数</a></td></tr></tbody></table><h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p><h2 id="1-找出数组中重复的数字"><a href="#1-找出数组中重复的数字" class="headerlink" title="1.找出数组中重复的数字"></a>1.找出数组中重复的数字</h2><pre><code>LeetCode 217：Contains Duplicate LeetCode 219：Contains Duplicate II LeetCode 220：Contains Duplicate III LeetCode 287：Find the Duplicate Number</code></pre><h3 id="1-《剑指offer》p39、leetcode-287"><a href="#1-《剑指offer》p39、leetcode-287" class="headerlink" title="1.《剑指offer》p39、leetcode 287"></a>1.《剑指offer》p39、leetcode 287</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>思路：交换法、映射。数组不重复的情形是array[i]=i。遍历数组元素，元素值为m时，与array[m]的值作对比，如果相同则重复了，返回即可，否则二者交换，继续比较，直到遍历完数组。时间o(n)，空间o(1)</p><pre><code class="java">public class Solution {    public boolean duplicate(int numbers[],int length,int [] duplication) {        for(int i=0; i&lt;length; ++i){            while(numbers[i]!=i){//注意这里是while                if(numbers[numbers[i]]==numbers[i]){                    duplication[0] = numbers[i];                    return true;                }else{                    swap(numbers, i, numbers[i]);                }            }        }        return false;    }    public void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><h3 id="2-LeetCode-217：Contains-Duplicate"><a href="#2-LeetCode-217：Contains-Duplicate" class="headerlink" title="2.LeetCode 217：Contains Duplicate"></a>2.LeetCode 217：Contains Duplicate</h3><p>题目：Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><pre><code>Input: [1,2,3,1]Output: true</code></pre><p>思路：</p><p>1）将数组排序，判断前后两个元素是否一样，如果一样则返回true，否则返回false； </p><p>2）方法（1）对数组进行排序，改变了数组元素的位置；若要求不能修改数组元素，可以创建一个辅助HashSet，判断HashSet中是否已经存在该元素，存在则返回true，否则返回false，并将其加入在HashSet中。</p><pre><code class="java">//法一：排序(改变了位置,时间o(nlogn)，空间o(1))public boolean containsDuplicate(int[] nums) {    Arrays.sort(nums);    for(int i=0; i&lt;nums.length-1; ++i){        if(nums[i+1]==nums[i]){            return true;        }    }    return false;}//法二：hashSet(不改变位置，时间o(n),空间o(n))public boolean containsDuplicate2(int[] nums) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for(int num: nums){        if(!set.add(num)){            return true;        }    }    return false;}</code></pre><h3 id="3-LeetCode-219：Contains-Duplicate-II"><a href="#3-LeetCode-219：Contains-Duplicate-II" class="headerlink" title="3.LeetCode 219：Contains Duplicate II"></a>3.LeetCode 219：Contains Duplicate II</h3><p>题目：给定一个数组nums和一个整数k，是否存在两个不相等的整数 i 和 j，使得nums[i] == nums[j]，并且i和j之间的距离最多为k。</p><pre><code>Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: trueInput: nums = [1,2,3,1,2,3], k = 2Output: false</code></pre><p>思路：辅助map存储数组元素值-元素索引，遍历数组即可，时间o(n)，空间o(n)</p><pre><code class="java">public boolean containsNearbyDuplicate(int[] nums, int k) {    //值-索引    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        if(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i]))&lt;=k){//找到重复            return true;        }else{            map.put(nums[i], i);//更新键值对        }    }    return false;}</code></pre><h3 id="4-LeetCode-220：Contains-Duplicate-III"><a href="#4-LeetCode-220：Contains-Duplicate-III" class="headerlink" title="4.LeetCode 220：Contains Duplicate III"></a>4.LeetCode 220：Contains Duplicate III</h3><p>题目：给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。</p><p>思路：维持一个大小为k的窗口，由左向右在nums中移动。对于nums[i]，只要查找其之前的元素中是否存在大小范围在[nums[i] - t,nums[i] + t]的元素，如果存在就返回true。还要注意整数的溢出问题，Long</p><pre><code class="java">//使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。//思路：treeset滑窗保存有序元素//treeset.ceiling--返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null//treeset.floor--返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 nullpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {    if (nums == null || nums.length == 0 || k &lt;= 0){        return false;    }    TreeSet&lt;Long&gt; treeSet = new TreeSet&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        if(i&gt;k){//超过滑窗k，删除treeset中的一个元素            treeSet.remove((long)nums[i-k-1]);        }        Long left = treeSet.ceiling((long)nums[i]-t);        Long right = treeSet.floor((long)nums[i]+t);        if(left!=null &amp;&amp; right!=null &amp;&amp; right&gt;=left){            return true;        }        treeSet.add((long)nums[i]);    }    return false;}</code></pre><p><a name="2"></a></p><h2 id="2-不修改数组找出重复的数字"><a href="#2-不修改数组找出重复的数字" class="headerlink" title="2.不修改数组找出重复的数字"></a>2.不修改数组找出重复的数字</h2><p>《剑指offer》p41. </p><p>题目：在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。</p><p>第一种思路：与题目1思路相似，利用哈希表，创建一个相同长度的辅助数组，将数组元素存在对应辅助数组下标处，很容易发现重复的数字。辅助空间O(n)</p><p>思路：二分查找。若有重复出现，则数字的个数会大于区间的长度，O(nlogn)、O(1)。</p><p>详细思路：如果数组中有重复的数，那么n+1个0~n范围内的数中，一定有几个数的个数大于1。那么，我们可以利用这个思路解决该问题。</p><p>我们把从1<del>n的数字从中间的数字m分为两部分，前面一半为1</del>m，后面一半为m+1<del>n。如果1</del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，反之，如果大于m，那么这一半的区间一定包含重复的数字；如果小于m，另一半m+1~n的区间里一定包含重复的数字。接下来，我们可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p><p>由于如果1<del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，我们可以逐步减少m，然后判断1</del>m之间是否有重复的数，即，我们可以令m=m-1，然后再计算1<del>m的数字的数目是否等于m，如果等于m，再令m=m-1，如果大于m，则说明1</del>m的区间有重复的数，如果小于m，则说明m+1~n有重复的数，不断重复此过程。</p><pre><code class="java">/** * FileName: Hello * Author:   braincao * Date:     2018/8/29 15:21 * Description: 《剑指offer》P41.不修改数组找出重复的数字 */public class Hello{    public static void main(String[] args){        int[] c = new int[]{2,3,3,5,5,2,6,7};        System.out.println(getDuplication(c,8));    }    static int getDuplication(int[] array, int length){        int left = 1;        int right = array.length - 1;        while(left&lt;=right) {            int mid = (left + right) / 2;            int cnt = count(array, length, left, mid);            if (left == right) {                if (cnt &gt; 1)                    return left;                else                    break;            }            if (cnt &gt; (mid - left + 1)) {                right = mid;            } else {                left = mid + 1;            }        }        return -1;    }    static int count(int[] array, int length, int start, int end){        int cnt = 0;        for(int i=0; i&lt;length; ++i){            if(array[i]&gt;=start &amp;&amp; array[i]&lt;=end){                cnt++;            }        }        return cnt;    }}</code></pre><p><a name="3"></a></p><h2 id="3-0-n-1中缺失的数字-2道"><a href="#3-0-n-1中缺失的数字-2道" class="headerlink" title="3.0~n-1中缺失的数字(2道)"></a>3.0~n-1中缺失的数字(2道)</h2><pre><code>0~n-1中缺失的数字(数组有序)--《剑指offer》p2660~n-1中缺失的数字(数组无序)--leetcode 268</code></pre><h3 id="1-0-n-1中缺失的数字-数组有序"><a href="#1-0-n-1中缺失的数字-数组有序" class="headerlink" title="1.0~n-1中缺失的数字(数组有序)"></a>1.0~n-1中缺失的数字(数组有序)</h3><p>《剑指offer》p266</p><p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0<del>n-1之内。在范围0</del>n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>思路：排序数组，问题转换成找出第一个下标与值不等的那个下标对应的数，显然是二分查找，时间o(logn)</p><pre><code class="java">//0~n-1中缺失的数字(数组有序)。思路：利用二分查找查找第一个nums[i]!=i的数字public static int findLostNumber(int[] arr){    int left = 0;    int right = arr.length-1;    while(left&lt;=right){        int mid = left+(right-left)/2;        if(arr[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找            left = mid+1;        }        else if(arr[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素            if(mid==left || (mid&gt;left&amp;&amp;arr[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的                return mid;            }            else{//往左边找                right = mid-1;            }        }    }    return arr.length;//之前的都相符，说明缺失的数字在最右边}public static void main(String[] args){    int[] nums = new int[]{0,1,2,3,4,5,7,8,9};//0~9一共10个数，数组长度为9，缺失的数字为6    System.out.println(findLostNumber(nums));}</code></pre><h3 id="2-0-n-1中缺失的数字-数组无序"><a href="#2-0-n-1中缺失的数字-数组无序" class="headerlink" title="2.0~n-1中缺失的数字(数组无序)"></a>2.0~n-1中缺失的数字(数组无序)</h3><p>leetcode 268</p><p>题目：Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><pre><code>Input: [3,0,1]Output: 2Input: [9,6,4,2,3,5,7,0,1]Output: 8</code></pre><p>这道题的几种思路如下：</p><pre><code>1. 二分查找(not good)把数组排序，用二分查找来找到缺失值。时间o(nlogn)1. 累加(good)计算1+2+...+n. 用和值减去数组中数的和值，最后的差就是我们要的结果。这个过程中要防止溢出。3. 异或(best)异或运算有一个性质，x^y^y=x. 结果与x和y的顺序无关。我们把0～n与数组中的数都异或到一起，那么最后的结果就是缺失的那个数。</code></pre><p>法一(不好)：先排序，再利用二分查找找第一个下标不符的元素，时间o(nlogn)，代码如下：</p><pre><code class="java">public int missingNumber(int[] nums) {    Arrays.sort(nums);//先排序    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left+(right-left)/2;        if(nums[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找            left = mid+1;        }        else if(nums[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素            if(mid==left || (mid&gt;left&amp;&amp;nums[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的                return mid;            }            else{//往左边找                right = mid-1;            }        }    }    return nums.length;//之前的都相符，说明缺失的数字在最右边}</code></pre><p>法二忽略</p><p>法三(更好)：<strong>异或性质。0～n与数组中的数都异或到一起，最后的结果即为所求的缺失数字</strong>，代码如下：</p><pre><code class="java">public int missingNumber(int[] nums) {    int res = 0;    for(int i=0; i&lt;nums.length; ++i){        res ^= i;        res ^= nums[i];    }    return res^nums.length;}</code></pre><p><a name="4"></a></p><h2 id="4-数组中数字出现的次数-3道"><a href="#4-数组中数字出现的次数-3道" class="headerlink" title="4.数组中数字出现的次数(3道)"></a>4.数组中数字出现的次数(3道)</h2><p>《剑指offer》p275、leetcode 260、leetcode 136、leetcode 137、leetcode 540</p><p>题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。</p><p>思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求</p><p>题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。</p><p>思路2：</p><pre><code>​1.所有数字异或;​2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);​3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)​</code></pre><p>题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字</p><p>思路3：</p><pre><code>1.这里不能用异或了，但是还是考虑位运算思路;2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除,则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为13.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好</code></pre><p>代码：</p><pre><code class="java">/** * 题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。 * 思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求 * * 题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。 * 思路2：1.所有数字异或; *       2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中); *       3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次) * * 题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字 * 思路3：1.这里不能用异或了，但是还是考虑位运算思路; *       2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除， *         则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1 *       3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好 */public class Solution {    //题目1：找出唯一一个一个出现了一次的数字--&gt;所有数字异或    public static int findSingleNumber(int[] arr){        int res = 0;        for(int i: arr){            res ^= i;        }        return res;    }    /**     * 题目2：找出这两个只出现一次的数字--&gt;     * 1.所有数字异或;     * 2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);     * 3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)     */    public static int[] findSingleNumber2(int[] arr){        int tempRes = 0;        for(int i: arr){//1.将数组所有数字异或            tempRes ^= i;        }        int k=1;//2.找出tempRes从右往左首个1出现在第k位        while(tempRes!=0){            if((tempRes&amp;1) == 1){ //出现了首个1                break;            }            else{//还没出现首个1                k++;                tempRes = tempRes&gt;&gt;1;            }        }        int groupOne = 0;//3.将原数组数字分组，并在每个组中找出只出现一个的数字        int groupTwo = 0;        for(int i: arr){            int bit = (i&gt;&gt;(k-1)) &amp; 1; //该数的第k位是bit            if(bit==1){                groupOne ^= i;            }            else{                groupTwo ^= i;            }        }        return new int[]{groupOne, groupTwo};    }    /**     * 题目3：找出这两个只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字--&gt;     * 1.这里不能用异或了，但是还是考虑位运算思路;     * 2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，     *   则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1     * 3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好     */    public static int findSingleNumber3(int[] arr) {        int[] bits = new int[32]; //int类型4字节，32位        for(int number: arr){//将数组中所有数字的二进制表示的每一位都加起来，每一位的和存在bits数组中            for(int i=0; i&lt;32; ++i){ //从个位到第32位依次相加存储                bits[i] += (number&gt;&gt;i)&amp;1; //数字number的第i位上的数            }        }        int res = 0;        for(int i=0; i&lt;32; ++i) { //把bits每一位上的数%3，如果为0，则所求的数该位也为0，否则为1            res += ((bits[i]%3)&lt;&lt;i);        }        return res;    }    public static void main(String[] args){        int[] arr = {1,2,1,2,3};//找出一个出现一次的数字        int[] arr2 = {1,2,1,2,3,4}; //找出两次出现一次的数字        int[] arr3 = {1,2,1,1,2,5,2}; //找出两次出现一次的数字        System.out.println(findSingleNumber(arr));//找出一个出现一次的数字。out:3        System.out.println(findSingleNumber2(arr2)[0] + &quot; &quot; + findSingleNumber2(arr2)[1]);//找出两次出现一次的数字。out:3,4        System.out.println(findSingleNumber3(arr3));//找出这两个只出现一次的数字，其他都出现三次。out:5    }}</code></pre><p><a name="5"></a></p><h2 id="5-数组中出现次数超过一半的数字"><a href="#5-数组中出现次数超过一半的数字" class="headerlink" title="5.数组中出现次数超过一半的数字"></a>5.数组中出现次数超过一半的数字</h2><p>《剑指offer》p205、leetcode 169</p><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>思路：</p><p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p><p>法二_更简单高效的方法：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p><p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p><pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {    int len = array.length;    int middle = len/2;    int left = 0;    int right = len-1;    int index = partition(array, left, right, left);    while(index != middle){//如果不是中位数        if(index &lt; middle){//说明中位数在index的右边            left = index + 1;            index = partition(array, left, right, left);        }        else if(index &gt; middle){//说明中位数在index的左边            right = index - 1;            index = partition(array, left, right, left);        }    }    //现在array[index]是中位数了    int res = 0;    if(check(array, array[index])){//检查array[index]是否真的出现次数超过一半，不超过返回0        res = array[index];    }    return res;}public static int partition(int[] arr, int left, int right, int pivotIndex){    int pivot = arr[pivotIndex];    swap(arr, pivotIndex, right);    int storeIndex = left;    for(int i=left; i&lt;=right; i++){        if(arr[i] &lt; pivot){            swap(arr, i, storeIndex);            storeIndex++;        }    }    swap(arr, storeIndex, right);    return storeIndex;}public static boolean check(int[] arr, int key){//经过算法后求出的数，再次进行检查看看是否真的超过一半，不符合条件res=0    int times = 0;    for(int i=0; i&lt;arr.length; ++i){        if(arr[i] == key){            times++;        }    }    if(times &gt; (arr.length/2)){        return true;    }    return false;}public static void swap(int[] arr, int i, int j){    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p>法二：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p><pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {    if(array==null || array.length==0){        return 0;    }    if(array.length==1){        return array[0];    }    int times = 1;    int num = array[0];    for(int i=1; i&lt;array.length; ++i){        if(array[i]==num){            times++;        }        else{            times--;            if(times==0){                times = 1;                num = array[i];            }        }    }    if(times&gt;1){//一定是        return num;    }    if(times==1){//有可能不是，再重新检查该数出现次数是否超过数组长度一半，不超过返回0        int temp = 0;        for(int i=0; i&lt;array.length; ++i){            if(array[i]==num){                temp++;            }        }        if(temp &gt; (array.length)/2){            return num;        }    }    return 0;}public static void main(String[] args){    int[] array = new int[]{2,2,2,2,2,1,3,4,5};    System.out.println(MoreThanHalfNum_Solution(array));}</code></pre><p><a name="6"></a></p><h2 id="6-数组中出现次数超过1-3的数字"><a href="#6-数组中出现次数超过1-3的数字" class="headerlink" title="6.数组中出现次数超过1/3的数字"></a>6.数组中出现次数超过1/3的数字</h2><p>leetcode 229</p><p>题目：Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space.</p><p>给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)</p><pre><code>Input: [3,2,3]Output: [3]Input: [1,1,1,3,3,2,2,2]Output: [1,2]</code></pre><p>思路：每次从nums中拿出3个不一样的数作为一组，肯定会出现两种情况。一，nums被取空了，那么nums中每个数出现次数最多占总次数的1/3，不存在超过1/3的数字；二，还有剩余，这个情况就复杂了，有可能剩余多个，但是……但是，<strong>最多只可能剩余两种数</strong>。 为什么？ 3个不同的数凑一组才能删掉，所以不可能删掉超过1/3的数。所以超过1/3的数肯定被剩下来，但是，<strong>剩下来的俩数并不一定都是超过1/3的</strong>，这点额外注意。 很容易举个例子， 比如</p><p><code>1 1 1 1 1 2 2 3 3 4 4 5--最后剩1,4--&gt;只有1是结果</code></p><p>我们把原问题转换为如何快速高效的从数组中每次去掉3个不同的数，最后把剩下的两个不同的数保存起来，重新遍历数组判断即可。</p><p>代码实现：用a,b表示两种不同的数，用计数器cnta,cntb表示a,b不同的数出现的次数来计数，在遍历数组的过程中计数抵消，看他们俩最终还剩下多少个。</p><pre><code class="java">//给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)//思路：遍历数组，每次抵消三个不同的数，最后剩下的2个数重新遍历数组判断。public List&lt;Integer&gt; majorityElement(int[] nums) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    int a = nums[0];    int b = nums[0];//a,b存两种不同的数    int cnta = 0;    int cntb = 0;//cnta,cntb对a,b两种不同的数出现次数的计数，当计数为0时，重置a/b    for(int num: nums){//遍历字符串        if(a==num){            cnta++;            continue;        }        if(b==num){            cntb++;            continue;        }        if(cnta==0){//a的计数为0，重置a            a = num;            cnta = 1;            continue;        }        if(cntb==0){//b的计数为0，重置b            b = num;            cntb = 1;            continue;        }        cnta--;        cntb--;//当前的num和a,b都不同，则一起抵消    }    cnta = 0;    cntb = 0;    //最后剩下的有a,b,重新遍历数组查看是否次数超过1/3    for(int num: nums){        if(num==a){            cnta++;        }        else if(num==b){            cntb++;        }    }    if(cnta&gt;(nums.length)/3){            res.add(a);    }    if(cntb&gt;(nums.length)/3){        res.add(b);    }    return res;}</code></pre><p><a name="7"></a></p><h2 id="7-统计指定数字在排序数组中出现的次数"><a href="#7-统计指定数字在排序数组中出现的次数" class="headerlink" title="7.统计指定数字在排序数组中出现的次数"></a>7.统计指定数字在排序数组中出现的次数</h2><p>《剑指offer》p263、leetcode 34</p><p>题目：统计一个数字在排序数组中出现的次数。</p><p>思路：</p><p>因为数组排序，很明显要用二分查找。</p><p>法一(不可取)，最差时间o(n)。先二分查找k在数组array中的索引，然后从该索引处向左向右外扩，找出所有相等的数。</p><p>法二(更好的方法)：充分利用二分查找直接找到第一个k和最后一个k，二者索引相减即为出现的个数。时间o(logn)</p><p>什么时候是第一个k：找到的k的前面一个元素如果不等于k，则此时是第一个k</p><p>什么时候是最后一个k：找到的k的后面一个元素如果不等于k，则此时是第一个k</p><pre><code class="java">//统计指定数字在排序数组中出现的次数。思路：充分利用二分查找第一个k和最后一个k的位置，两者的区间长度即为所求次数public static int GetNumberOfK(int [] array , int k) {    if(array==null || array.length==0){        return 0;    }    //二分查找左边第一个k的位置    int left = getFirst(array, k);    int right = getLast(array, k);    if(left==-1 || right==-1){//数组中没有k        return 0;    }    if(left&lt;=right){        return right-left+1;    }    return 0;}//二分查找第一个k的位置public static int getFirst(int[] nums, int k){    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left + (right-left)/2;        if(nums[mid]==k){            if( (mid&gt;left&amp;&amp;nums[mid-1]!=k) || mid==left){//找到第一个k                return mid;            }            else{//不是第一个k，继续往左边找                right = mid-1;            }        }        else if(nums[mid]&lt;k){//k在右边            left = mid+1;        }        else{//k在左边            right = mid-1;        }    }    return -1;//没找到k，返回-1}//二分查找最后一个k的位置public static int getLast(int[] nums, int k){    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left + (right-left)/2;        if(nums[mid]==k){            if( (mid&lt;right&amp;&amp;nums[mid+1]!=k) || mid==right){//找到最后一个k                return mid;            }            else{//不是最后一个k，继续往右边找                left = mid+1;            }        }        else if(nums[mid]&lt;k){//k在右边            left = mid+1;        }        else{//k在左边            right = mid-1;        }    }    return -1;//没找到k，返回-1}public static void main(String[] args){    int[] nums = new int[]{1,2,3,4,5,5,5,5,5,5,5,7,8,11};//out:7    System.out.println(GetNumberOfK(nums, 5));}</code></pre><p><a name="8"></a></p><h2 id="8-二维数组中的查找"><a href="#8-二维数组中的查找" class="headerlink" title="8.二维数组中的查找"></a>8.二维数组中的查找</h2><p>《剑指offer》p44、leetcode74</p><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：从二维数组右上角开始查找，因为从右上角/左下角开始比较的话若不相等可以删除不符合条件的一行或者一列</p><p>以右上角为例，若相等则返回true；若target比右上角大，说明目标在其下面，则删除所在行；若target比右上角小，说明目标在其左侧，则删除所在列</p><p>以左上角为例，若target比左上角大，则不能缩小范围，因为右侧和下侧的元素都比左上角，右下角同理，pass！</p><pre><code class="java">public boolean Find(int target, int [][] array) {    if(array==null || array.length==0){        return false;    }    int m = array.length-1;    if(array[0].length==0){        return false;    }    int n = array[0].length-1;    int i = 0;    int j = n;    while(i&lt;=m &amp;&amp; j&gt;=0){        if(array[i][j] == target){            return true;        }        else if(target&lt;array[i][j]){            j--;        }        else{            i++;        }    }    return false;}</code></pre><p><a name="9"></a></p><h2 id="9-替换空格"><a href="#9-替换空格" class="headerlink" title="9.替换空格"></a>9.替换空格</h2><p>《剑指offer》p51</p><p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>思路：先遍历字符串计算空格出现次数，然后设置新数组大小，从后往前遍历数组，替换空格。</p><pre><code class="java">public class Solution {    public String replaceSpace(StringBuffer str) {        int cnt = 0;        for(int i=0; i&lt;str.length(); i++)        {            if(str.charAt(i)==&#39; &#39;)            {                cnt++;            }        }        int newLen = str.length() + cnt*2;        char[] newStr = new char[newLen];        int i = str.length()-1;        int j = newLen-1;        while(i&gt;=0){            if(str.charAt(i)==&#39; &#39;){                newStr[j--] = &#39;0&#39;;                newStr[j--] = &#39;2&#39;;                newStr[j--] = &#39;%&#39;;            }            else{                newStr[j--] = str.charAt(i);            }            i--;        }        return new String(newStr);    }}</code></pre><p><a name="10"></a></p><h2 id="10-Replace-Words–字典树"><a href="#10-Replace-Words–字典树" class="headerlink" title="10.Replace Words–字典树"></a>10.Replace Words–字典树</h2><p>LeetCode 648. Replace Words 字典树练习</p><p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with theroot forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p>Example 1:</p><pre><code>Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot;</code></pre><p>题意：用字典中存在的前缀代替句子中的单词，若有多个前缀可以表示单词，则选择最短的一个<br>​<br>暴力思路：1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根(换长度最小的那个); 2.将words数组重新组成sentence返回即可</p><pre><code class="java">class Solution {    public String replaceWords(List&lt;String&gt; dict, String sentence) {        //1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根        String[] words = sentence.split(&quot; &quot;);        for(int i=0; i&lt;words.length; ++i){            int min = Integer.MAX_VALUE;            for(String root: dict){                if(words[i].startsWith(root) &amp;&amp; root.length()&lt;min){                    words[i] = root;                }            }        }        //2.将words数组重新组成sentence返回即可        StringBuilder res = new StringBuilder();        for(int i=0; i&lt;words.length; ++i){            res.append(words[i] + &quot; &quot;);        }        return res.toString().trim();    }}</code></pre><p>优化思路(字典树):这道题给了我们一个前缀字典，又给了一个句子，让我们将句子中较长的单词换成其前缀(如果在前缀字典中存在的话)。我们对于句子中的一个长单词如何找前缀呢，是不是可以根据第一个字母来快速定位呢，比如cattle这个单词的首字母是c，那么我们在前缀字典中找所有开头是c的前缀，为了方便查找，我们<strong>将首字母相同的前缀都放到同一个数组中，总共需要26个数组</strong>，所以我们可以定义一个二维数组来装这些前缀。还有，我们希望短前缀在长前缀的前面，因为题目中要求用最短的前缀来替换单词，所以我们可以<strong>先按单词的长度来给所有的前缀排序</strong>，然后再依次加入对应的数组中，这样就可以保证短的前缀在前面。</p><p>提交显示暴力思路50ms，优化思路19ms，优化的还不错。</p><pre><code class="java">public static String replaceWords(List&lt;String&gt; dict, String sentence) {    //1.roots数组按长度排序    Collections.sort(dict);    //2.构建字典树，采用HashMap，用首字母索引，首字母相同的前缀都放到同一个数组中，总共需要26个数组    Map&lt;Integer, ArrayList&lt;String&gt;&gt; wordTree = new HashMap&lt;&gt;();    for(int i=0; i&lt;dict.size(); ++i){        int wordIndex =  dict.get(i).charAt(0)-&#39;a&#39;;        if(!wordTree.containsKey(wordIndex)){            wordTree.put(wordIndex, new ArrayList&lt;String&gt;());        }        wordTree.get(wordIndex).add(dict.get(i));    }    //3.将sentencesplit(&quot; &quot;)分成words单词数组，每个单词通过字典树进行前缀判断，有词根的换成词根    String[] words = sentence.split(&quot; &quot;);    for(int i=0; i&lt;words.length; ++i){        int wordIndex = words[i].charAt(0)-&#39;a&#39;;        if(wordTree.containsKey(wordIndex)){            for(int j=0; j&lt;wordTree.get(wordIndex).size(); ++j){                if(words[i].startsWith(wordTree.get(wordIndex).get(j))){                    words[i] = wordTree.get(wordIndex).get(j);                }            }        }    }    //4.将words数组重新组成sentence返回即可    StringBuilder res = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        res.append(words[i] + &quot; &quot;);    }    return res.toString().trim();}</code></pre><p><a name="11"></a></p><h2 id="11-Find-And-Replace-in-String"><a href="#11-Find-And-Replace-in-String" class="headerlink" title="11.Find And Replace in String"></a>11.Find And Replace in String</h2><p>LeetCode 833. Find And Replace in String</p><p>题目：To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p><p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing.</p><p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p><p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p><p>All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p><p>Example 1:</p><pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeebffff&quot;Explanation: &quot;a&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;.&quot;cd&quot; starts at index 2 in S, so it&#39;s replaced by &quot;ffff&quot;.</code></pre><p>Example 2:</p><pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeecd&quot;Explanation: &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. &quot;ec&quot; doesn&#39;t starts at index 2 in the original S, so we do nothing.</code></pre><p>题目大意：给了原始的字符串S，给出了要开始替换的位置indexes，判断S在indexes的位置向后是否能匹配sources中对应位置的元素，如果相等，则把S的该部分替换成targets对应的部分。</p><p>思路：</p><p>不可能直接对S进行替换操作的，因为那样直接改变了S的值和长度，影响以后的匹配操作。</p><p>而应该将原字符串S按照indexs拆分成几段子字符串，然后分别进行替换，最终拼接返回即可。同时应该从右往左处理原字符串，替换用replaceFirst()</p><p>将indexes按逆序排序，然后对S从右往左依次查找可替换的单词，如果出现在指定位置，则替换。由于indexes排序后，会变化，因此需要用map结构保存原来的索引。</p><pre><code class="java">public static String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {    if(S==null || S.length()==0){        return S;    }    //由于indexes排序后，会变化，因此需要用map结构保存原来的索引。    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:index[i] value:i    for(int i=0; i&lt;indexes.length; ++i){        map.put(indexes[i], i);    }    //将indexes按排序    Arrays.sort(indexes);    //将原字符串S按照indexs拆分成几段子字符串，然后分别进行判断    String[] words = new String[indexes.length+1];    //字符串从右往左处理，同时index也从最大到最小    for(int i=indexes.length-1; i&gt;=0; --i){        String last;//当前需要处理的子字符串，判断是否需要替换        if(i==indexes.length-1){            last = S.substring(indexes[i]);        }        else{            last = S.substring(indexes[i], indexes[i+1]);        }        int tempIndex = map.get(indexes[i]); //当前字符串对应的index        if(last.startsWith(sources[tempIndex])){            words[i+1] = last.replaceFirst(sources[tempIndex],targets[tempIndex]);        }        else{            words[i+1] = last;        }    }    words[0] = S.substring(0,indexes[0]).replaceFirst(sources[0],targets[0]);//最前面的字符串    //将替换完的words数组拼接成最终的字符串    StringBuilder res = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        res.append(words[i]);    }    return res.toString();}</code></pre><p><a name="12"></a></p><h2 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12.从尾到头打印链表"></a>12.从尾到头打印链表</h2><p>《剑指offer》p58.</p><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>思路：</p><p>法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可</p><p>法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可</p><p>法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可</p><p>法四：递归实现，从头遍历链表，但是递归实现</p><pre><code class="java">//法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ListNode p = listNode;    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    while(p!=null){        res.add(p.val);        p = p.next;    }    Collections.reverse(res);    return res;}//法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可public ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(listNode==null){        return res;    }    ListNode p = listNode;    ListNode cur = p.next;    p.next = null;    while(cur!=null){        ListNode temp = cur;        cur = cur.next;        temp.next = p;        p = temp;    }    while(p!=null){        res.add(p.val);        p = p.next;    }    return res;}//法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可public ArrayList&lt;Integer&gt; printListFromTailToHead3(ListNode listNode) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(listNode==null){        return res;    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    ListNode p = listNode;    while(p!=null){        stack.push(p.val);        p = p.next;    }    while(!stack.isEmpty()){        res.add(stack.pop());    }    return res;}//法四：递归实现，从头遍历链表，但是递归实现ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead4(ListNode listNode) {    if(listNode!=null){        printListFromTailToHead4(listNode.next);        res.add(listNode.val);    }    return res;}</code></pre><p><a name="13"></a></p><h2 id="13-反转链表-三道"><a href="#13-反转链表-三道" class="headerlink" title="13.反转链表(三道)"></a>13.反转链表(三道)</h2><h3 id="1-反转全部链表"><a href="#1-反转全部链表" class="headerlink" title="1.反转全部链表"></a>1.反转全部链表</h3><p>《剑指offer》p142、《左神》p40、leetcode206</p><p>题目：输入一个链表，反转链表后，输出新链表的表头。</p><p>思路：头插法</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {        if(head==null || head.next==null){            return head;        }        ListNode newHead = head;        head = head.next;        newHead.next = null; //这步别忘了        while(head!=null){            ListNode tempNode = head;            //原链表继续遍历下一个            head = head.next;            //头插法            tempNode.next = newHead;            newHead = tempNode;        }        return newHead;    }}</code></pre><h3 id="2-反转部分链表"><a href="#2-反转部分链表" class="headerlink" title="2.反转部分链表"></a>2.反转部分链表</h3><p>《左神》p42、leetcode92</p><p>题目：这道题目规定了要进行反转的位置区间。</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p>思路：我们要先<strong>添加一个哨兵</strong>，指向head节点（最后返回头指针的next即可）；然后一直往后访问，一直到要反转的节点的前一位停下来。</p><p>我们要<strong>记录下两个节点的位置</strong>：开始反转位置的节点的前一位、开始反转位置的节点。因为在反转后，开始反转的节点的前一个节点的next指针要指向反转的最后一个节点，开始反转的节点的next要指向反转的最后一个节点的后一个节点。</p><p>然后<strong>进行与上面一题同样的反转即可</strong>。</p><pre><code class="java">public ListNode reverseBetween(ListNode head, int m, int n) {    if(head==null || head.next==null || m&gt;=n || m&lt;=0){        return head;    }    //1.哨兵，这样不用考虑m==1从头反转的问题，都转化成从中间反转    ListNode guard = new ListNode(0);    guard.next = head;    ListNode p = guard;    //2..将p移到要反转部分的前一个节点，移动次数为m-1次    for(int i=1; i&lt;=m-1; ++i){        p = p.next;        if(p==null){//如果遍历完链表都没有加到m，则不需要反转            return head;        }    }    if(p.next==null || p.next.next==null){//需要反转的部分为空或者只有一个节点，则不需要反转        return head;    }    //3.保存反转部分的前一个节点    ListNode pre = p;    //4.反转部分链表(头插法)    p = p.next;    ListNode cur = p.next;    p.next=null;    ListNode last = p;//保存反转部分的最后一个节点    for(int i=m; i&lt;n; ++i){        ListNode temp = cur;        cur = cur.next;        temp.next = p;        p = temp;        if(cur==null){            break;        }    }    //5.拼接反转部分前，反转部分，反转部分后的链表    last.next = cur;    pre.next = p;    return guard.next;}</code></pre><h3 id="3-分组翻转链表"><a href="#3-分组翻转链表" class="headerlink" title="3.分组翻转链表"></a>3.分组翻转链表</h3><p>leetcode 25 Reverse Nodes in k-Group、《左神》68</p><p>题目：将链表的每k个节点逆序。给定一个单链表的头结点head，实现一个调整单链表的函数，使得每k个节点之间逆序，如果最后不管k个节点一组，则不调整最后几个节点。</p><p>Example:</p><pre><code>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></pre><p>思路：先遍历一次链表记录长度，然后分组进行翻转即可。</p><pre><code class="java">public ListNode reverseKGroup(ListNode head, int k) {    if(head==null || head.next==null || k&lt;2){        return head;    }    //1.遍历一遍链表记录链表长度    int len = 0;    ListNode p = head;    while(p!=null){        len++;        p = p.next;    }    //2.分组翻转链表    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode pre = guard;//缓存翻转后的尾节点指针    ListNode cur = guard.next;//哨兵    ListNode last = cur;//缓存翻转后的尾节点指针    while(len&gt;=k){//翻转这么多次        len -= k;        int tempK = k;        while(tempK!=0){//每次翻转k个节点            ListNode temp = cur;            cur = cur.next;            temp.next = pre.next;//头插法            pre.next = temp;            tempK--;        }        last.next = cur;//翻转后的链表尾部连接到需要反转部分的下一个节点        pre = last;        last = cur;    }    return guard.next;}</code></pre><p><a name="14"></a></p><h2 id="14-根据前序-中序遍历数组来重建二叉树"><a href="#14-根据前序-中序遍历数组来重建二叉树" class="headerlink" title="14.根据前序+中序遍历数组来重建二叉树"></a>14.根据前序+中序遍历数组来重建二叉树</h2><p>《剑指offer》p62、leetcode105</p><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：在函数recon中，先根据前序遍历数组的第一个数字创建根节点，之后在中序遍历数组中找到根节点的位置，这样就能确定左、右子树节点的数量。在前序遍历和中序遍历数组中划分了左、右子树节点的值之后，就可以递归地调用函数recon去分别构建它的左、右子树。</p><pre><code class="java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) { val = x; }}public class Solution {    public TreeNode buildTree(int[] preorder, int[] inorder) {        if(preorder==null || preorder.length==0){            return null;        }        return recon(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);    }    //递归重建二叉树    public TreeNode recon(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd){        if(preStart&gt;preEnd || inStart&gt;inEnd){            return null;        }        TreeNode root = new TreeNode(preorder[preStart]);//前序遍历第一个节点为根节点        int rootIndex = findRootIndex(inorder, inStart, inEnd, root.val);//前序遍历的根节点在中序遍历数组的位置索引        int leftCnt = rootIndex-inStart;//左子树节点的个数        root.left = recon(preorder, preStart+1, preStart+leftCnt, inorder, inStart, rootIndex-1);        root.right = recon(preorder, preStart+leftCnt+1, preEnd, inorder, rootIndex+1, inEnd);        return root;    }    //找到根节点在中序遍历中的位置    public int findRootIndex(int[] order, int start, int end, int root){        int index = -1;        for(int i=start; i&lt;=end; ++i){            if(order[i]==root){                index = i;            }        }        return index;    }}</code></pre><p><a name="15"></a></p><h2 id="15-二叉树的下一个节点"><a href="#15-二叉树的下一个节点" class="headerlink" title="15.二叉树的下一个节点"></a>15.二叉树的下一个节点</h2><p>《剑指offer》p65.</p><p>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p>思路：这个节点可以分为三种情况<br>​    </p><blockquote><p>1.该节点有右子树：下一个节点就是它的右子树中最左子节点</p><p>2.该节点没有右子树且是父节点的左子节点：下一个节点就是它的父节点</p><p>3.该节点没有右子树且是父节点的右子节点：沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点</p></blockquote><pre><code class="java">class TreeLinkNode {    int val;    TreeLinkNode left = null;    TreeLinkNode right = null;    TreeLinkNode next = null;    TreeLinkNode(int val) {        this.val = val;    }}public class Solution {    public TreeLinkNode GetNext(TreeLinkNode pNode)    {        if(pNode == null){            return null;        }        //如果该节点有右子树，返回其右子树中最左的子节点        if(pNode.right != null){            pNode = pNode.right;            while(pNode.left != null){                pNode = pNode.left;            }            return pNode;        }        //如果该节点没有右子树        while(pNode.next != null){            //该节点是父节点的左子节点，返回父节点            if(pNode.next.left== pNode){                return pNode.next;            }            //该节点是父节点的右子节点，沿着指向父节点的指针一直向上遍历，            // 直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点            pNode = pNode.next;        }        //如果第3中情况下一直向上遍历到根节点，则没有要找的下一个节点，返回null        return null;    }}</code></pre><p><a name="16"></a></p><h2 id="16-Populating-Next-Right-Pointers-in-Each-Node"><a href="#16-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="16.Populating Next Right Pointers in Each Node"></a>16.Populating Next Right Pointers in Each Node</h2><p>leetcode 116.</p><p>题目：Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><p>题目大意：将满二叉树每个节点的next指针赋值，每个节点的next指针指向同一层的下一个节点，要求空间复杂度是O(1)。本题的前提是给定的二叉树是满二叉树，即所有的叶子节点都在同一层。举例如下</p><p>原始：</p><pre><code>     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><p>思路：如果有下一层的话，为下一层的子节点的next指针赋值。每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器，并且不用递归，循环层即可完成</p><pre><code class="java">public void connect(TreeLinkNode root){    TreeLinkNode pRoot = root;    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点    while(pRoot!=null){//层的循环        guard.next=null;//哨兵，指向下一层的第一个节点        TreeLinkNode cur = guard;        if(pRoot.left!=null) {//如果有下层的话            while(pRoot!=null){//依次为下一层的每个节点next指针                cur.next = pRoot.left;                cur.next.next = pRoot.right;                cur = cur.next.next;                pRoot = pRoot.next;            }        }        pRoot = guard.next;//进入下一层的第一个节点    }}</code></pre><p><a name="17"></a></p><h2 id="17-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#17-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="17.Populating Next Right Pointers in Each Node II"></a>17.Populating Next Right Pointers in Each Node II</h2><p>leetcode 117.Populating Next Right Pointers in Each Node</p><p>题目：本题要求和上面一样，不同的是这里给定的二叉树不一定是满二叉树。You may only use constant extra space</p><p>原始：</p><pre><code>     1   /  \  2    3 / \    \4   5    7</code></pre><p>变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><p>思路：因为可能不是满二叉树而是任意二叉树，所以下一层的第一个节点需要手动寻找，我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器</p><pre><code class="java">public void connect(TreeLinkNode root){    TreeLinkNode pRoot = root;    //我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个哨兵，代表第一个节点    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点    while(pRoot!=null){        guard.next=null;//哨兵，指向下一层的第一个节点        TreeLinkNode cur = guard;        while(pRoot!=null){//依次为下一层的节点next指针赋值            if(pRoot.left!=null){                cur.next = pRoot.left;                cur = cur.next;            }            if(pRoot.right!=null){                cur.next = pRoot.right;                cur = cur.next;            }            pRoot = pRoot.next;        }        pRoot = guard.next;//进入下一层(下一层的root从下一层的第一个节点guard.next开始)    }}</code></pre><p><a name="18"></a></p><h2 id="18-两个栈实现队列"><a href="#18-两个栈实现队列" class="headerlink" title="18.两个栈实现队列"></a>18.两个栈实现队列</h2><p>《剑指offer》p68、leetcode232、《左神》5</p><p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><pre><code class="java">import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();    //入队    public void push(int node) {        stack1.push(node);    }    //出队    public int pop() {        if(stack2.empty()){            while(!stack1.empty()){                stack2.push(stack1.pop());            }        }        return stack2.pop();    }}</code></pre><p><a name="19"></a></p><h2 id="19-两个队列实现栈"><a href="#19-两个队列实现栈" class="headerlink" title="19.两个队列实现栈"></a>19.两个队列实现栈</h2><p>《剑指offer》p71、leetcode225</p><p>题目：两个队列实现栈</p><pre><code class="java">class MyStack {    Queue&lt;Integer&gt; que1;    Queue&lt;Integer&gt; que2;    /** Initialize your data structure here. */    public MyStack() {        que1 = new LinkedList&lt;&gt;();        que2 = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        if(!que1.isEmpty()){            que1.offer(x);        }        else{            que2.offer(x);        }    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        while(!que1.isEmpty()){            int temp = que1.poll();            if(que1.isEmpty()){                return temp;            }            else{                que2.offer(temp);            }        }        while(!que2.isEmpty()){            int temp = que2.poll();            if(que2.isEmpty()){                return temp;            }            else{                que1.offer(temp);            }        }        return -1;    }    /** Get the top element. */    public int top() {        while(!que1.isEmpty()){            int temp = que1.poll();            que2.offer(temp);            if(que1.isEmpty()){                return temp;            }        }        while(!que2.isEmpty()){            int temp = que2.poll();            que1.offer(temp);            if(que2.isEmpty()){                return temp;            }        }        return -1;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return que1.isEmpty() &amp;&amp; que2.isEmpty();    }}</code></pre><p><a name="20"></a></p><h2 id="20-斐波那契数列-三道"><a href="#20-斐波那契数列-三道" class="headerlink" title="20.斐波那契数列(三道)"></a>20.斐波那契数列(三道)</h2><pre><code>斐波那契数列--《剑指offer》p75 青蛙跳台阶--《剑指offer》p77、leetcode 70变态跳台阶--牛客网 </code></pre><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h3><p>《剑指offer》p75</p><p>题目：大家都知道斐波那契数列f(n)=f(n-1)+f(n-2)，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><p>思路：动态规划问题。解法：自上而下递归分析，自下而上循环实现。</p><pre><code class="java">public static int Fibonacci(int n) {    if(n==0){        return 0;    }    if(n==1){        return 1;    }    int n1 = 0;    int n2 = 1;    for(int i=2; i&lt;=n; ++i){        int temp = n1+n2;        n1 = n2;        n2 = temp;    }    return n2;}</code></pre><h3 id="2-青蛙跳台阶"><a href="#2-青蛙跳台阶" class="headerlink" title="2.青蛙跳台阶"></a>2.青蛙跳台阶</h3><p>《剑指offer》p77、leetcode 70</p><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p><p>思路：就是斐波那切数列</p><pre><code class="java">public int JumpFloor(int target) {    if(target==1){        return 1;    }    if(target==2){        return 2;    }    int n1 = 1;    int n2 = 2;    for(int i=3; i&lt;=target; ++i){        int temp = n1 + n2;        n1 = n2;        n2 = temp;    }    return n2;}</code></pre><h3 id="3-变态跳台阶"><a href="#3-变态跳台阶" class="headerlink" title="3.变态跳台阶"></a>3.变态跳台阶</h3><p>牛客网上的</p><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：动态规划分析：f(n)=f(n-1)+f(n-2)+…f(1)+1，因此需要数组来缓存之前的值，但其实不需要数组，直接用变量来缓存即可，即f(n)=之前的和+1。</p><pre><code class="java">public int JumpFloorII(int target) {    if(target==1){        return 1;    }    if(target==2){        return 2;    }    int sumTemp = 3;//缓存之前的和    int resTemp = 0;    for(int i=3; i&lt;=target; ++i){        resTemp = sumTemp+1;//当前的结果值        sumTemp += resTemp; //把当前的结果值加到缓存和中    }    return resTemp;}</code></pre><p><a name="21"></a></p><h2 id="21-斐波那契数列变种-两道"><a href="#21-斐波那契数列变种-两道" class="headerlink" title="21.斐波那契数列变种(两道)"></a>21.斐波那契数列变种(两道)</h2><pre><code>Length of Longest Fibonacci Subsequence--leetcode 873 Split Array into Fibonacci Sequence--leetcode842 </code></pre><h3 id="1-Length-of-Longest-Fibonacci-Subsequence"><a href="#1-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="1.Length of Longest Fibonacci Subsequence"></a>1.Length of Longest Fibonacci Subsequence</h3><p>leetcode 873</p><p>题目：给定一个严格递增的正整数数组形成序列 A ，找到A中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p><p>子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列</p><p>Example 1:</p><pre><code>Input: [1,2,3,4,5,6,7,8]Output: 5Explanation:The longest subsequence that is fibonacci-like: [1,2,3,5,8].</code></pre><p>思路：动态规划问题。二维dp问题。</p><p>使用一维DP解决不了这个问题，因为一维DP只保存了到某个为止的最长斐波那契数列，但是新的数字到来之后能不能满足之前的费布拉奇数列是未知的。所以使用二维DP。</p><p>dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。</p><p>核心方程：dp[j][k]=dp[i][j]+1</p><p>条件是 A[i] + A[j] = A[k]</p><p>这个算法的时间复杂度是O(n^2)，空间复杂度是O(n^2).</p><pre><code class="java">//二维dp问题。dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。//核心方程：dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]public static int lenLongestFibSubseq(int[] A) {    if(A==null || A.length==0){        return 0;    }    int m = A.length;    int[][] dp = new int[m][m];//dp[i][j]表示以A[i]、A[j]结尾的斐波那契数列长度，初始化为2    for(int i=0; i&lt;m; i++){        for(int j=i+1; j&lt;m; ++j){            dp[i][j] = 2;        }    }    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//map存放A[]数组便于下面查找。key:a[i], value:i    for(int i=0; i&lt;A.length; ++i){        map.put(A[i], i);    }    //dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]    int res = 0;    for(int j=0; j&lt;m; j++){        for(int k=j+1; k&lt;m; ++k){            int a_i = A[k]-A[j];            if(a_i&lt;A[j] &amp;&amp; map.containsKey(a_i)){                dp[j][k] = Math.max(dp[j][k], dp[map.get(a_i)][j]+1);                res = Math.max(res, dp[j][k]);            }        }    }    return res;}</code></pre><h3 id="2-Split-Array-into-Fibonacci-Sequence"><a href="#2-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="2.Split Array into Fibonacci Sequence"></a>2.Split Array into Fibonacci Sequence</h3><p>leetcode 842、与leetcode 306类似</p><p>题目：给出了一个有0-9数字组成的纯数字字符串。判断能否组成斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。最终要返回的是任何一个组合即可。</p><p>Example 1:</p><pre><code>Input: &quot;123456579&quot;Output: [123,456,579]</code></pre><p>思路:回溯法。本题和下面的刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p><p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p><p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p><p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p><p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p><p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p><p>本题需要把斐波那契数列的各个数字存起来，同时还要注意要防止int溢出</p><pre><code class="java">public List&lt;Integer&gt; splitIntoFibonacci(String S) {    int L = S.length();    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();    for(int i=1; i&lt;=(L-1)/2; ++i){//第一个数的长度为[1,(L-1)/2]        String s1 = S.substring(0,i);//第一个数        if(S.startsWith(&quot;0&quot;) &amp;&amp; s1.length()&gt;1){//第一个数长度超过2起始位不能为0            break;        }        Long num1 = Long.valueOf(s1);        if(num1&gt;Integer.MAX_VALUE){//防止int溢出            break;        }        for(int j=i+1;j&lt;=L-1&amp;&amp;(L-j)&gt;=(j-i)&amp;&amp;(L-j)&gt;=i; ++j){//第三个数大于等于第一、第二个数            String s2 = S.substring(i,j);//第二个数            if(S.charAt(i)==&#39;0&#39; &amp;&amp; s2.length()&gt;1){//第二个数长度超过2起始位不能为0                break;            }            Long num2 = Long.valueOf(s2);            if(num2&gt;Integer.MAX_VALUE){//防止int溢出                break;            }            if(isValid(S.substring(j), num1, num2, res)){//进行斐波那契判断                return res;            }        }    }    res.clear();    return res;}public boolean isValid(String S, long num1, long num2, List&lt;Integer&gt; temp){    if(S.equals(&quot;&quot;)){//递归结束        temp.add((int) num1);        temp.add((int) num2);        return true;    }    long sum = num1 + num2;    if(sum&gt;Integer.MAX_VALUE){//防止int溢出        return false;    }    String sumStr = &quot;&quot; + sum;    if(sumStr.length()&gt;1 &amp;&amp; S.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0        return false;//剪枝，回溯点    }    if(S.startsWith(sumStr)){        temp.add((int) num1);        return isValid(S.substring(sumStr.length()), num2, sum, temp);//递归判断    }else{        temp.clear();        return false;    }}</code></pre><p><a name="22"></a></p><h2 id="22-Additive-Number"><a href="#22-Additive-Number" class="headerlink" title="22.Additive Number"></a>22.Additive Number</h2><p>leetcode 306</p><p>题目：给出了一个有0-9数字组成的纯数字字符串。判断它能不能组成所谓的“加法数字”，即斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。</p><p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><pre><code>Input: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8Input: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.1 + 99 = 100, 99 + 100 = 199</code></pre><p>思路:回溯法。刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p><p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p><p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p><p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p><p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p><p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p><pre><code class="java">//回溯法问题。关键在于确定前两个数即可。//三个数的长度: 第一个数,[0,i)，长度为i；第二个数,[i,j)长度为j-i; 第三个数(和):[j,L-1],长度L-j//三个数的长度最长的范围：第一个数长度上限:x=(L-1)/2; 第二个数长度下限：y=x，第三个数长度下限: ypublic static boolean isAdditiveNumber(String num) {    int L = num.length();    for(int i=1; i&lt;=(L-1)/2; ++i){//i从1起，第一个数长度至少为1        if(num.startsWith(&quot;0&quot;) &amp;&amp; i&gt;1){            break;//第一个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环        }        for(int j=i+1; j&lt;=L-1 &amp;&amp; (L-j)&gt;=i &amp;&amp; (L-j)&gt;=(j-i); ++j){//第三个数长度不小于第一个数，第三个数长度不小于第二个数            if(num.charAt(i)==&#39;0&#39; &amp;&amp; j-i&gt;1){                break;//第二个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环            }            long num1 = Long.valueOf(num.substring(0, i));//第一个数            long num2 = Long.valueOf(num.substring(i, j));//第二个数            if(isAdditive(num.substring(j), num1, num2)){                return true;//找到满足斐波那契条件的一个划分序列            }        }    }    return false;}public static boolean isAdditive(String num, long num1, long num2){    if(num.equals(&quot;&quot;)){        return true; //递归结束，回溯点    }    long sum = num1+num2;    String sumStr = &quot;&quot; + sum;    int sumLen = sumStr.length();    if(sumLen&gt;1 &amp;&amp; num.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0        return false;//剪枝，回溯点    }    if(num.startsWith(sumStr)){//如果和在字符串中，则进行下一次递归        return isAdditive(num.substring(sumLen), num2, sum);    }    return false;}public static void main(String[] args){    String num = &quot;123&quot;;    System.out.println(isAdditiveNumber(num));}</code></pre><p><a name="23"></a></p><h2 id="23-旋转数组的最小数字-三道"><a href="#23-旋转数组的最小数字-三道" class="headerlink" title="23.旋转数组的最小数字(三道)"></a>23.旋转数组的最小数字(三道)</h2><pre><code>《剑指offer》p82Find Minimum in Rotated Sorted Array--leetcode153Find Minimum in Rotated Sorted Array 2--leetcode154</code></pre><h3 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="1.旋转数组的最小数字"></a>1.旋转数组的最小数字</h3><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>普通二分查找思路：顺序解法o(n)，从头到尾遍历数组一次，我们就能找出最小的数字。但本题部分排序，排序的题优先考虑二分查找，因此采用二分查找的双指针的思路，o(logn)。</p><p><strong>两个指针代表两大阵营</strong>(原数组/旋转的那部分数组)，最终会相邻，第二个指针指向的刚好是最小的元素</p><pre><code class="java">//这里是部分排序的数组，考虑二分查找public static int minNumberInRotateArray(int [] array) {    if(array==null){        return 0;    }    int len = array.length;    if(len==0){        return 0;    }    if(len==1){        return array[0];    }    int left = 0;    int right = len-1;    while(left&lt;right){//二分查找        //结束条件：两个指针最终会相邻，代表两大阵营(原数组/旋转的那部分数组)，第二个指针指向的刚好是最小的元素        if(left+1==right){//结束条件            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况                return nums[right];            }else{                return nums[0];            }        }        int mid = (left+right)/2;        //特殊情况，当left、right、mid对应的三个数相等时，无法判断最小的数位于哪一边，因此要顺序查找        if(array[mid]==array[left]&amp;&amp;array[mid]==array[right]){            return search(array,left, right);        }        if(array[mid]&gt;=array[left]){//最小值在右半边            left = mid;        }        else if(array[mid]&lt;=array[right]){//最小值在左半边            right = mid;        }    }    return array[left];}public static int search(int[] array, int left, int right){    for(int i=left+1; i&lt;=right; ++i){        if(array[i]&lt;array[i-1]){//顺序查找，注意这里也不是完全遍历，而是第一个比之前小的数就是所求            return array[i];        }    }    return array[left];}</code></pre><p>牛客网答案区很干练的二分查找思路：(仅供参考一般想不到，还是用上面自己想的即可)</p><pre><code>采用二分法解答这个问题，mid = low + (high - low)/2需要考虑三种情况：(1)array[mid] &gt; array[high]:出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。low = mid + 1(2)array[mid] == array[high]:出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ，high = high - 1(3)array[mid] &lt; array[high]:出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。high = mid注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字比如 array = [4,6]array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;如果high = mid - 1，就会产生错误， 因此high = mid但情形(1)中low = mid + 1就不会错误</code></pre><p>代码：</p><pre><code class="java">public class Solution {    public int minNumberInRotateArray(int [] array) {        int low = 0 ; int high = array.length - 1;           while(low &lt; high){            int mid = low + (high - low) / 2;                    if(array[mid] &gt; array[high]){                low = mid + 1;            }else if(array[mid] == array[high]){                high = high - 1;            }else{                high = mid;            }           }        return array[low];    }}</code></pre><h3 id="2-Find-Minimum-in-Rotated-Sorted-Array-2"><a href="#2-Find-Minimum-in-Rotated-Sorted-Array-2" class="headerlink" title="2.Find Minimum in Rotated Sorted Array 2"></a>2.Find Minimum in Rotated Sorted Array 2</h3><p>leetcode154</p><p>题目：和153一样，这里新增数组可以有重复数字，如[1,3,3,3]</p><p>思路：思路还是一样，就是需要考虑重复的问题，改动如下：</p><pre><code class="java">public static int findMin(int[] nums) {    int len = nums.length;    if(len==1){        return nums[0];    }    //left、right代表原数组、旋转数组两大阵营，结束条件是相邻    int left = 0;    int right = nums.length-1;    while(left&lt;right){        int mid = (left+right)/2;        if(left+1==right){//结束条件            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况                return nums[right];            }else{                return nums[0];            }        }        if(nums[mid]==nums[left]&amp;&amp; nums[mid]==nums[right]){            return search(nums);        }        else if(nums[mid]&gt;=nums[left]){//在右半边            left = mid;        }        else if(nums[mid]&lt;=nums[right]){//在左半边            right = mid;        }    }    return nums[left];}public static int search(int[] array){    int min = array[0];    for(int i=1; i&lt;array.length; ++i){        min = Math.min(min, array[i]);//顺序查找，注意这里必须完全全部遍历    }    return min;}</code></pre><p><a name="24"></a></p><h2 id="24-矩阵中的路径"><a href="#24-矩阵中的路径" class="headerlink" title="24.矩阵中的路径"></a>24.矩阵中的路径</h2><p>《剑指offer》p89、leetcode 79</p><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><pre><code>a b c es f c sa d e e</code></pre><p>思路：二维矩阵中路径查找问题通常用回溯法。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法可以看成蛮力法的升级版。</p><pre><code class="java">public static boolean hasPath(char[] matrix, int rows, int cols, char[] str){    if(str==null){        return true;    }    if(matrix==null || matrix.length&lt;str.length){        return false;    }    //路径查找中，不能重复进入相同的格子，因此需要设置标记矩阵，初始为false    boolean[] visited = new boolean[rows*cols];    for(int i=0; i&lt;rows; ++i){        for(int j=0; j&lt;cols; ++j){            int index = i*cols+j;            if(matrix[index]==str[0]){//如果第一个字符匹配，则开始回溯法匹配路径                if(isPath(matrix,rows,cols,i,j,str,0, visited)){//匹配成功                    return true;                }            }        }    }    return false;}public static boolean isPath(char[] matrix, int rows, int cols, int i, int j, char[] str, int strIndex, boolean[] visited){    if(strIndex==str.length){        return true;//查找完成，找到路径的结束条件    }    int index = i*cols+j;    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[index]==true){        return false;//查找到边界外或已经访问过，false    }    if(matrix[index]==str[strIndex]){//如果当前字符匹配，则开始回溯法匹配路径        visited[index] = true;        //上下左右回溯法查找        if(isPath(matrix,rows,cols,i-1,j,str,strIndex+1, visited)                ||isPath(matrix,rows,cols,i+1,j,str,strIndex+1,visited)                ||isPath(matrix,rows,cols,i,j-1,str,strIndex+1,visited)                ||isPath(matrix,rows,cols,i,j+1,str,strIndex+1,visited)){            return true;        }    }    visited[index] = false;//回溯    return false;}</code></pre><p>leetcode79的代码：</p><pre><code class="java">public static boolean exist(char[][] board, String word) {    if(board==null || board.length==0 || word==null || word.length()==0){        return false;    }    int m = board.length;    int n = board[0].length;    if((m*n)&lt;word.length()){        return false;    }    boolean[][] visited = new boolean[m][n];//避免重复访问的标记数组，初始为false    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(board[i][j]==word.charAt(0)){                if(isPath(board, m, n, i, j, word, 0, visited))                    return true;            }        }    }    return false;}public static boolean isPath(char[][] board, int m, int n, int i, int j, String word, int strIndex, boolean[][] visited){    if(strIndex==word.length()){        return true;//查找完成，结束条件    }    if(i&lt;0 || j&lt;0 || i&gt;=m || j&gt;=n || visited[i][j]==true || board[i][j]!=word.charAt(strIndex)){        return false;//剪枝，错误条件:访问越界或已经访问过或当前字符不匹配    }    visited[i][j] = true;    if(isPath(board, m, n, i-1, j, word, strIndex+1, visited)||            isPath(board, m, n, i+1, j, word, strIndex+1, visited)||            isPath(board, m, n, i, j-1, word, strIndex+1, visited)||            isPath(board, m, n, i, j+1, word, strIndex+1, visited)){        return true;    }    visited[i][j] = false;//回溯    return false;}</code></pre><p><a name="25"></a></p><h2 id="25-机器人的运动范围"><a href="#25-机器人的运动范围" class="headerlink" title="25.机器人的运动范围"></a>25.机器人的运动范围</h2><p>《剑指offer》p92.</p><p>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：通常物体或人在二维矩阵运动这类问题够可以用回溯法解决。</p><pre><code class="java">public int movingCount(int threshold, int rows, int cols){    int[] res = new int[]{0};//最多可到达的格子数，存成数组便于参数传递修改    boolean[][] visited = new boolean[rows][cols];//记录访问过的标记位数组，初始化为false    return isPath(rows, cols, 0, 0, visited, res, threshold);}//回溯法矩阵路径查找，返回能到达格子的个数public static int isPath(int rows, int cols, int i, int j, boolean[][] visited, int[] res, int k){    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[i][j]==true || (digitSum(i)+digitSum(j))&gt;k){        return res[0];//剪枝的结束条件:访问越界或已经访问过或行列数位和大于k    }    visited[i][j] = true;    res[0]++;    int resTemp;    resTemp = Math.max(isPath(rows,cols,i-1,j,visited,res,k), res[0]);    resTemp = Math.max(isPath(rows,cols,i+1,j,visited,res,k), resTemp);    resTemp = Math.max(isPath(rows,cols,i,j-1,visited,res,k), resTemp);    resTemp = Math.max(isPath(rows,cols,i,j+1,visited,res,k), resTemp);    return resTemp;}//一个数字的数位和public static int digitSum(int num){    int sum = 0;    while(num!=0){        sum += (num%10);        num/=10;    }    return sum;}</code></pre><p><a name="26"></a></p><h2 id="26-Unique-Paths-两道"><a href="#26-Unique-Paths-两道" class="headerlink" title="26.Unique Paths(两道)"></a>26.Unique Paths(两道)</h2><h3 id="1-Unique-Paths"><a href="#1-Unique-Paths" class="headerlink" title="1.Unique Paths"></a>1.Unique Paths</h3><p>leetcode 62 Unique Paths</p><p>题目：给定m*n的矩阵，机器人从左上走到右下，每次只能向右或向下，How many possible unique paths are there?</p><p>思路：dp问题，dp[i][j]表示走至当前格子时的unique paths数。</p><p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p><p>dp问题，自上而下分析上述方程，自下而上循环解决</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePaths(int m, int n) {    int[][] dp = new int[m][n];//dp[i][j]表示走至当前格子时的unique paths数    dp[0][0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i==0){//第一行的dp[0][j]=1                dp[i][j] = 1;            }            else{                if(j==0){//每行的第一个dp[i][0]=dp[i-1][0]                    dp[i][j] = dp[i-1][j];                }                else{//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]                    dp[i][j] = dp[i-1][j] + dp[i][j-1];                }            }        }    }    return dp[m-1][n-1];}</code></pre><p><strong>优化:</strong>上述方法时间o(m<em>n)、空间o(m</em>n)，其实只用o(n)的空间即可，对每行来说只缓存上一行的dp即可</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePaths(int m, int n) {    if(m==1 || n==1){        return 1;    }    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数，初始第一行的dp[j]=1    dp[0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=1; j&lt;n; ++j){//直接从第1列开始就行了，第0列不用考虑            if(i==0){//初始第一行的dp[j]=1                dp[j] = 1;            }            else{                dp[j] = dp[j-1] + dp[j];//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]            }        }    }    return dp[n-1];}</code></pre><h3 id="2-Unique-Paths-2"><a href="#2-Unique-Paths-2" class="headerlink" title="2.Unique Paths 2"></a>2.Unique Paths 2</h3><p>leetcode 63 Unique Paths 2</p><p>题目：和Unique Paths一样，左上到右下，每次只能向右或者向下，但是新增了障碍物条件，Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>example:</p><pre><code>Input:[  [0,0,0],  [0,1,0],  [0,0,0]]Output: 2</code></pre><p>思路：还是一样的。dp问题，用了优化后思路，dp[j]缓存上一行的unique paths数</p><p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p><p>dp问题，自上而下分析上述方程，自下而上循环解决</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePathsWithObstacles(int[][] obstacleGrid) {    int m = obstacleGrid.length;    int n = obstacleGrid[0].length;    if(obstacleGrid[0][0]==1){//如果起始点是障碍物        return 0;    }    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数    dp[0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i==0){//初始第一行的dp[j]=1                if(obstacleGrid[i][j]!=1){                    if(j&gt;0){                        dp[j] = dp[j-1];                    }                }                else{                    dp[j] = 0;//有障碍物，此路不通                }            }            else{//其他行                if(obstacleGrid[i][j]!=1){                    if(j&gt;0){                        dp[j] = dp[j-1] + dp[j];                    }                }                else{                    dp[j] = 0;//有障碍物，此路不通                }            }        }    }    return dp[n-1];}</code></pre><p><a name="27"></a></p><h2 id="27-剪绳子"><a href="#27-剪绳子" class="headerlink" title="27.剪绳子"></a>27.剪绳子</h2><p>《剑指offer》p96.</p><p>题目：给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]* k[1] * … *k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>思路：</p><blockquote><p>问题是求最优解；</p><p>整体的问题的最优解是依赖各个子问题的最优解；</p><p>子问题之间还有互相重叠的更小的子问题；</p><p>为避免子问题的重复计算，我们存储子问题的最优解。从上往下分析问题，从下往上求解问题。</p></blockquote><p>上面的几个条件可以看出，属于动态规划问题。</p><p>dp方程：<code>f(n) = max(f(i)*f(n-i))</code></p><pre><code class="java">public static int maxProduct(int n){    if(n==2){        return 1;    }    if(n==3){        return 2;    }    int[] res = new int[n+1];    res[1] = 1;    res[2] = 2;    res[3] = 3;    for(int i=4; i&lt;=n; ++i){        for(int j=1; j&lt;=(i/2); ++j){            res[i] = Math.max(res[j]*res[i-j], res[i]);//f(n)=max(f(i)*f(n-i))        }    }    return res[n];}</code></pre><p><a name="28"></a></p><h2 id="28-不用加减乘除做加法"><a href="#28-不用加减乘除做加法" class="headerlink" title="28.不用加减乘除做加法"></a>28.不用加减乘除做加法</h2><p>牛客网、leetcode 371</p><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p>思路：首先看十进制是如何做的： 5+7=12，三步走 </p><blockquote><p>第一步：相加各位的值，不算进位，得到2。 </p></blockquote><blockquote><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p></blockquote><blockquote><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p></blockquote><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p><blockquote><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p></blockquote><blockquote><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p></blockquote><blockquote><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 </p></blockquote><p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><pre><code class="java">public int Add(int num1,int num2) {    int temp;    while(num2!=0){        temp = num1^num2;//加        num2 = (num1&amp;num2)&lt;&lt;1;//进位        num1 = temp;    }    return num1;}</code></pre><p><a name="29"></a></p><h2 id="29-Two-Sum"><a href="#29-Two-Sum" class="headerlink" title="29.Two Sum"></a>29.Two Sum</h2><p>leetcode 1</p><p>题目：给定数组(非有序)和target，找到nums[i]+nums[j]==target的i、j，假定给定条件一定会有一个解</p><p>Example:</p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p>思路1：暴力解法，时间o(n2)，空间o(1)–38ms</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    int[] res = new int[2];    for(int i=0; i&lt;nums.length-1; ++i){        for(int j=i+1; j&lt;nums.length; ++j){            if( (nums[i] + nums[j]) == target ){                res[0] = i;                res[1] = j;            }        }    }    return res;}</code></pre><p>思路2：只遍历一次数组，辅助map，temp=target-nums[i],看map中是否有temp，有则返回两者索引即可，没有将当前nums[i]存入map，继续遍历。时间o(n)，空间o(n)–5ms</p><pre><code class="java">public static int[] twoSum(int[] nums, int target) {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:nums[i]; value:i    for(int i=0; i&lt;nums.length; ++i){        int temp = target-nums[i];        if(!map.containsKey(temp)){            map.put(nums[i], i);        }        else{            return new int[]{map.get(temp), i};        }    }    return new int[]{0,0};}</code></pre><p><a name="30"></a></p><h2 id="30-二进制中1的个数"><a href="#30-二进制中1的个数" class="headerlink" title="30.二进制中1的个数"></a>30.二进制中1的个数</h2><p>《剑指offer》p100、leetcode191 Number of 1 Bits</p><p>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>本题超级技巧：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong></p><p>思路：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>，通过这个小技巧，我们只要循环判断n=n&amp;(n-1)是否为0，即可统计1的个数。整数中有多少个1，则循环多少次。</p><p>有了这个思路，可以轻松解以下相关题目。位运算相关题目</p><p>用一条语句判断一个整数是不是2的整数次方。</p><p><code>if(n&amp;(n-1)==0) return true;</code></p><p>输入两个整数m,n,计算需要改变m的二进制表示中的多少位才能得到n？<br>​<br>​<code>int x=m^n; return NumberOf1(x);</code></p><p>解法一：从尾部到最高位(0到32位)，依次找1。不好</p><pre><code class="java">public static int NumberOf2(int n) {//从尾部到最高位(0到32位)，依次找1    int res = 0;    int temp = 1;    int cnt = Integer.toBinaryString(n).length();//返回二进制的位数，这样不用暴力的写32位了    while(cnt!=0){        if((n&amp;temp)==temp){            res++;        }        temp=temp&lt;&lt;1;        cnt--;    }    return res;}</code></pre><p>解法二：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>。每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)</p><pre><code class="java">public static int NumberOf1(int n) {    int res = 0;    while(n!=0){        n=(n-1)&amp;n; //每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)        res++;    }    return res;}</code></pre><p><a name="31"></a></p><h2 id="31-数值的整数次方"><a href="#31-数值的整数次方" class="headerlink" title="31.数值的整数次方"></a>31.数值的整数次方</h2><p>《剑指offer》p110、leetcode 50</p><p>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>思路：记得考虑base==0与exponent&lt;0的情况。解法三更为优化，递归实现将exponent二分下去减少乘法运算次数。判断一个整数为奇数偶数，这里把%运算换成位运算，效率更高（二进制最低位如果为1则为奇数，为0则为偶数）。</p><p><strong>超级知识点</strong>：注意MIN_VALUE取反的情况。在JDK中，整型类型是有范围的 -2147483648～2147483647（-2^31-2^31-1），最大值为Integer.MAX_VALUE，即2147483647，最小值为Integer.MIN_VALUE -2147483648。</p><p>Integer.MIN_VALUE取反或者取绝对值呢仍为Integer.MIN_VALUE，因为绝对值2147483648超过Integer.MAX_VALUE 2147483647。</p><p><strong>因此有如下重要结论：</strong><br>​<br>​    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE<br>​    Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</p><p>解法一：无耻解法2333</p><pre><code class="java">public static double Power(double base, int exponent) {    return Math.pow(base, exponent);}</code></pre><p>解法二：逐个base相乘即可</p><pre><code class="java">public static double Power(double base, int exponent) {    double res = 1;    boolean positive = true;    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE    if(exponent==Integer.MIN_VALUE){        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不ååå行，必须为偶数参与二分)    }    if(exponent&lt;0){        positive = false;    }    exponent = Math.abs(exponent);    while(exponent!=0){        exponent--;        res*=base;    }    return positive?res:(1/res);}</code></pre><p>解法三，效率更高：</p><pre><code class="java">//a^n = a^(n/2)*a^(n/2)public static double Power(double base, int exponent) {    double res = 1;    boolean positive = true;//exponent正负的标记位    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE    if(exponent==Integer.MIN_VALUE){        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不行，必须为偶数参与二分)    }    if(exponent&lt;0){        positive = false;        exponent = -exponent;    }    while(exponent!=0){        if((exponent&amp;1)==1){//exponent是奇数            res*=base;            exponent--;        }else{//exponent是偶数，二分，减少乘法次数，效率更高            base*=base;            exponent/=2;        }    }    return positive?res:(1/res);}public static void main(String[] args){    System.out.println(Power(2, -2147483648));}</code></pre><p><a name="32"></a></p><h2 id="32-打印从1到最大的n位数"><a href="#32-打印从1到最大的n位数" class="headerlink" title="32.打印从1到最大的n位数"></a>32.打印从1到最大的n位数</h2><p>《剑指offer》p114</p><p>题目：打印从1到最大的n位数（本题是大数问题，当n位数很多时，只能用其他的数据结构来存储我们的非常大的数字）</p><p>思路：使用数组，采用数字全排列的方法。如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。当然打印的时候，我们应该不输出左边的0</p><p>解法一：递归实现全排列，顺序打印（代码比较简单，但可能会栈溢出）</p><pre><code class="java">public class Hello{    public static void main(String[] args){        printOneToNBit(3);    }    //打印从1到最大的n位数，就是一个n个数的全排列，用递归实现    static void printOneToNBit(int n){        int[] number = new int[n]; //n位的数组存放数字的全排列        for(int i=0; i&lt;10; ++i){            number[0] = i;            OneToNBit(number, n, 0);        }    }    //递归实现数字全排列    static void OneToNBit(int[] number, int n, int index){        //递归结束条件，已经完成一个数字全排列，打印出来        if(index == n-1){            printNumber(number);            return;        }        index++;        for(int i=0; i&lt;10; ++i){            number[index] = i;            OneToNBit(number, n, index);        }    }    //打印一个数组排列，左边的0都不输出    static void printNumber(int[] number){        boolean notFirst = false;        for(int i=0; i&lt;number.length; ++i){            if(number[i]!=0){                notFirst = true;            }            if(notFirst){                System.out.print(number[i]);            }        }        System.out.println();    }}</code></pre><p>解法二：字符串存数字，采用循环，不断加1。这个思路在两个数相加（大数问题）等题目中可以用到。</p><pre><code class="java">//打印从1到最大的n位数public static void printOneToNBit(int n){    //大数问题，用字符串来存数字    StringBuilder num = new StringBuilder();    for(int i=0; i&lt;n; ++i){        num.append(&quot;0&quot;);    }    while(!addOne(num)){        printNum(num);//字符串每次加1，然后打印,直到n位的最大数    }}//字符串每次加1，然后打印,直到n位的最大数public static boolean addOne(StringBuilder num){    int cnt = 0;//前一位的进位    for(int i=num.length()-1; i&gt;=0; --i){        int temp = num.charAt(i)-&#39;0&#39;+cnt;//第i位上的数字        if(i==num.length()-1){//个位加1            temp++;        }        if(temp==10){//如果有进位，操作如下            if(i==0){//如果当前是最高位且有进位，说明已经到达是最大数，return true                return true;            }            num.setCharAt(i, &#39;0&#39;);//进位后当前位为0            cnt = 1;//进位1        }        else{//如果没进位            num.setCharAt(i, (char)(&#39;0&#39;+temp));            break;//没有进位了，跳出循环即可        }    }    return false;}//打印数字，左边的0不打印public static void printNum(StringBuilder num){    boolean leftCnt = true;    for(int i=0; i&lt;num.length(); ++i){        char temp = num.charAt(i);        if(temp!=&#39;0&#39;) {            leftCnt = false;        }        if(!leftCnt){            System.out.print(temp);        }    }    System.out.println();}public static void main(String[] args){    printOneToNBit(3);}</code></pre><p><a name="33"></a></p><h2 id="33-删除链表中重复的节点-两道"><a href="#33-删除链表中重复的节点-两道" class="headerlink" title="33.删除链表中重复的节点(两道)"></a>33.删除链表中重复的节点(两道)</h2><pre><code>1.Remove Duplicates from Sorted List((保留一个重复节点)---leetcode832.Remove Duplicates from Sorted List 2(不保留重复节点)---《剑指offer》p122、leetcode82</code></pre><h3 id="1-Remove-Duplicates-from-Sorted-List"><a href="#1-Remove-Duplicates-from-Sorted-List" class="headerlink" title="1.Remove Duplicates from Sorted List"></a>1.Remove Duplicates from Sorted List</h3><p>leetcode 83</p><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点保留一个，返回链表头指针。</p><p>Example:</p><pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>代码：</p><pre><code class="java">public ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode cur = head;    while(cur.next!=null){        if(cur.next.val==cur.val){            cur.next = cur.next.next;        }else{            cur = cur.next;        }    }    return head;}</code></pre><h3 id="2-Remove-Duplicates-from-Sorted-List-II"><a href="#2-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="2.Remove Duplicates from Sorted List II"></a>2.Remove Duplicates from Sorted List II</h3><p>《剑指offer》p122、leetcode82</p><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>思路：</p><blockquote><p>1.需要两个指针，一个指向前一个节点pre，另一个指向当前节点p。如果遇到相等的节点，p向后移动，pre不动，存下此时相等数值tempVal方便后面的比较，直到遇到p和p.next不相等，pre就可以指向当前的p。</p><p>2.注意：链表开头可能就开始有重复的节点，所以设置一个哨兵guard(0)，</p></blockquote><pre><code class="java">public static  ListNode deleteDuplication(ListNode pHead){    //链表为空或只有一个节点，返回pHead    if(pHead==null || pHead.next==null){        return pHead;    }    //设置哨兵    ListNode guard = new ListNode(0);    guard.next = pHead;    ListNode pre = guard;//重复节点的前一个节点    ListNode cur = guard.next; //用于遍历的节点    //遍历链表    while(cur!=null){        if(cur.next!=null &amp;&amp; cur.next.val==cur.val){//后一节点==当前节点            int temp = cur.val;//存储重复的值，用于后边比较            while(cur!=null &amp;&amp; cur.val==temp){//如果重复                cur = cur.next;            }            pre.next = cur;        }        else{//后一节点!=当前节点            pre = pre.next;            cur = cur.next;        }    }    return guard.next;}</code></pre><p><a name="34"></a></p><h2 id="34-正则表达式匹配"><a href="#34-正则表达式匹配" class="headerlink" title="34.正则表达式匹配"></a>34.正则表达式匹配</h2><p>《剑指offer》p124、leetcode 10</p><p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。*表示前面字符0~无穷个，.表示任意一个字符。要求全部，匹配，不是部分匹配。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p>思路：二维DP问题。这道题的核心是分析’<em>‘，DP[i][j]代表计算str[:i]与patten[:j]匹不匹配.最终要得到的结果就是dp[s.length()][p.length()]，转移方程如下(时间复杂度O(m\</em>n)，空间复杂度O(n)):</p><pre><code>dp[i][j] = dp[i - 1][j - 1], 如果s[i] == p[j] || p[j] == &#39;.&#39;=dp[i][j - 2], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] != p[j - 1](只能匹配0次)=dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] == p[j - 1](匹配0\1\多次)返回：dp[s.length()][p.length()]</code></pre><p>代码：</p><pre><code class="java">//正则匹配. *。思路：二维DP。public boolean isMatch(String s, String p) {    if(s == null || p == null) return false;    boolean[][] dp = new boolean[s.length()+1][p.length()+1];    dp[0][0] = true;    for(int i = 0; i &lt; p.length(); i++){        if (p.charAt(i) == &#39;*&#39; &amp;&amp; dp[0][i-1]) {            dp[0][i+1] = true;        }    }    for(int i = 0; i &lt; s.length(); i++){        for(int j = 0; j &lt; p.length(); j++){            if(s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;){                dp[i+1][j+1] = dp[i][j];            }            if(p.charAt(j) == &#39;*&#39;){                if(s.charAt(i) != p.charAt(j-1) &amp;&amp; p.charAt(j-1) != &#39;.&#39;){                    dp[i+1][j+1] = dp[i+1][j-1];                }else{                    dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];                }            }        }    }    return dp[s.length()][p.length()];}public static void main(String[] args){    char[] str = new char[]{&#39;a&#39;,&#39;a&#39;,&#39;a&#39;};    char[] pattern = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;*&#39;, &#39;a&#39;, &#39;c&#39;, &#39;*&#39;, &#39;a&#39;};    char[] str2 = new char[]{&#39;a&#39;,&#39;b&#39;};    char[] pattern2 = new char[]{&#39;.&#39;,&#39;*&#39;,&#39;c&#39;};    String s = &quot;ab&quot;;    String p = &quot;.*c&quot;;//这对测试用例解决了一个大bug，很好    System.out.println(isMatch(s,p));}</code></pre><p><a name="35"></a></p><h2 id="35-表示数值的字符串"><a href="#35-表示数值的字符串" class="headerlink" title="35.表示数值的字符串"></a>35.表示数值的字符串</h2><p>《剑指offer》p127、leetcode 65</p><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><p>思路：+A.Be+C，对字符串分别判断A、B、C部分是否存在且是否正确，都正确则返回true。注意边界条件：</p><p>1.整数部分判断，整数部分可以没有，但没有则必须：</p><pre><code>有小数部分，小数点+小数部分--&gt;  -.123正确, -.错误 没有小数点，也没有小数部分--&gt;  -正确</code></pre><p>2.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)</p><p>3.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)</p><pre><code class="java">public class Solution{    //+A.Be+C    public static boolean isNumeric(char[] str) {        if(str==null || str.length==0){            return false;        }        //遍历字符串        int index = 0;        //1.正负号判断        if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){            index++;        }        //2.整数部分判断(整数部分可以没有 但没有则必须要有小数部分，-.123正确, -.错误)        boolean num = false;//是否有整数部分        int indexTemp = readNum(str, index);        if(indexTemp&gt;index){//有整数部分            num = true;        }        index = indexTemp;        //3.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)        if(index&lt;str.length &amp;&amp; str[index]==&#39;.&#39;){            index++;            indexTemp = readNum(str, index);            if(!num &amp;&amp; indexTemp==index){//小数部分前面如果没有整数则必须要有小数部分                return false;            }            index = indexTemp;            num = true;        }        //4.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)        if(index&lt;str.length &amp;&amp; (str[index]==&#39;e&#39;||str[index]==&#39;E&#39;) ){            if(!num){//e部分前面没有数字，false (e9错误)                return false;            }            index++;            if(index==str.length){//有e但没有后面的整数部分，false                return false;            }            if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){                index++;            }            indexTemp = readNum(str, index);            if(indexTemp==index){//有e但没有后面的整数部分，false                return false;            }            index = indexTemp;        }        if(index!=str.length){//如果都判断完了，字符串还有字符，false            return false;        }        return true;    }    //遍历读取数字部分，返回不是数字的索引    public static int readNum(char[] str, int index){        while(index&lt;str.length){            int temp = str[index]-&#39;0&#39;;            if(temp&lt;0 || temp&gt;9){//不是数字                return index;            }            else{//是数字                index++;            }        }        return index;    }    public static void main(String[] args){        String s1 = &quot;.5&quot;;//Expected:true        String s2 = &quot;.&quot;;//Expected:false        String s = &quot;100.&quot;;//Expected:true        String s4 = &quot;-&quot;;//Expected:true        System.out.println(isNumeric(s4.trim().toCharArray()));    }}</code></pre><p><a name="36"></a></p><h2 id="36-调整数组顺序使奇数位于偶数前面-3道"><a href="#36-调整数组顺序使奇数位于偶数前面-3道" class="headerlink" title="36.调整数组顺序使奇数位于偶数前面(3道)"></a>36.调整数组顺序使奇数位于偶数前面(3道)</h2><pre><code>《剑指offer》p129(需要保持顺序不变)leetcode 905(不用保持顺序)leetcode 328(调整链表的奇偶顺序)</code></pre><h3 id="《剑指offer》p129-需要保持顺序不变"><a href="#《剑指offer》p129-需要保持顺序不变" class="headerlink" title="《剑指offer》p129(需要保持顺序不变)"></a>《剑指offer》p129(需要保持顺序不变)</h3><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>思路：遍历一遍数组，记下奇数偶数个数；建立新数组temp后，再遍历一遍原数组，奇数偶数分开放到新数组temp中；将新数组temp的值赋给原数组array。时间o(n)，空间o(n)</p><pre><code class="java">public static void reOrderArray(int [] array) {    if(array==null || array.length&lt;2){        return;    }    int cntOdd = 0;//记录奇数个数    for(int i: array){//遍历一遍数组，记下奇数偶数个数        if((i&amp;1)==1){            cntOdd++;        }    }    int oddIndex = 0;//奇数index    int evenIndex = cntOdd;//偶数index    int[] tempArray = new int[array.length];    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，奇数偶数分开放到新数组temp中        if((array[i]&amp;1)== 1){            tempArray[oddIndex++] = array[i];        }        else{            tempArray[evenIndex++] = array[i];        }    }    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，将新数组temp的值赋给原数组array        array[i] = tempArray[i];    }}</code></pre><h3 id="Sort-Array-By-Parity"><a href="#Sort-Array-By-Parity" class="headerlink" title="Sort Array By Parity"></a>Sort Array By Parity</h3><p>leetcode 905</p><p>题目：偶数在前，奇数在后，不用保持顺序</p><p>Example :</p><pre><code>Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</code></pre><p>思路：既然不用保持顺序，那么就不用空间o(n)的辅助了，思路：遍历一遍数组，两个指针变量，partition思想</p><pre><code class="java">//偶数在前，奇数在后，不用保持顺序。思路：遍历一遍数组，两个指针变量，partition思想public static int[] sortArrayByParity(int[] A) {    if(A==null || A.length&lt;2){        return A;    }    int storeEven = 0;//遍历一遍数组，把偶数放在前面。storeEven左边都是偶数    for(int i=0; i&lt;A.length; ++i){        if((A[i]&amp;1)==0){            swap(A, storeEven++, i);        }    }    return A;}public static void swap(int[] A, int i, int j){    int temp = A[i];    A[i] = A[j];    A[j] = temp;}</code></pre><h3 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h3><p>leetcode 328</p><p>题目：Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>题目大意：奇数号节点在前，偶数号节点在后，同时要求时间o(n)，空间o(1)</p><p>Example 1:</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL    </code></pre><p>Example 2:</p><pre><code>Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p>思路：拆分成两个链表，奇数号链表、偶数号链表，最后再合成即可</p><pre><code class="java">public ListNode oddEvenList(ListNode head) {    if(head==null || head.next==null || head.next.next==null){        return head;    }    //奇数号链表    ListNode oddHead = head;    ListNode oddP = oddHead;    //偶数号链表    ListNode evenHead = head.next;    ListNode evenP = evenHead;    //遍历并拆分原链表    ListNode cur = oddP.next.next;    oddP.next = null;    evenP.next = null;    ListNode temp;    while(cur!=null &amp;&amp; cur.next!=null){        //奇数号节点        temp = cur;        cur = cur.next;        oddP.next = temp;        oddP = oddP.next;        oddP.next = null;        //偶数号节点        temp = cur;        cur = cur.next;        evenP.next = temp;        evenP = evenP.next;        evenP.next = null;    }    if(cur!=null){//如果还剩一个奇数号节点        oddP.next = cur;        oddP = oddP.next;        oddP.next = null;    }    //连接奇偶两个链表    oddP.next = evenHead;    return oddHead;}</code></pre><p><a name="37"></a></p><h2 id="37-链表中倒数第k个结点-两道"><a href="#37-链表中倒数第k个结点-两道" class="headerlink" title="37.链表中倒数第k个结点(两道)"></a>37.链表中倒数第k个结点(两道)</h2><pre><code>《剑指offer》p134--返回倒数第k个结点《左神》p35==leetcode19--删除倒数第k个结点</code></pre><h3 id="1-返回倒数第k个结点"><a href="#1-返回倒数第k个结点" class="headerlink" title="1.返回倒数第k个结点"></a>1.返回倒数第k个结点</h3><p>《剑指offer》p134</p><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：双指针，遍历一遍链表即可。时间o(n),空间o(1)</p><pre><code class="java">public static ListNode FindKthToTail(ListNode head,int k) {    if(head==null || k&lt;=0){        return null;    }    ListNode right = head;//先出发，走k-1个节点    ListNode left = head;//后出发，直到right.next为null时left即为所求    //1.right先走k-1个节点    while(k!=1){        right = right.next;        if(right==null){            return null;//链表的节点数都不够k个，更没有倒数第k个节点了        }        k--;    }    //2.left、right一起走，直到right.next==null    while(right.next!=null){        left = left.next;        right = right.next;    }    return left;}</code></pre><h3 id="2-删除倒数第k个节点"><a href="#2-删除倒数第k个节点" class="headerlink" title="2.删除倒数第k个节点"></a>2.删除倒数第k个节点</h3><p>《左神》35==leetcode19，思路差不多，删除时应该首先遍历到倒数第k+1个节点，且需要设置哨兵</p><pre><code class="java">//删除倒数第n个节点，则需要找到倒数第n+1个节点，需要设置哨兵public ListNode removeNthFromEnd(ListNode head, int n) {    if(head==null || n&lt;=0){        return null;    }    //1.设置哨兵    ListNode guard = new ListNode(0);    guard.next = head;    //2.找到倒数第n+1个节点    ListNode right = guard;//先出发，走n-1个节点    ListNode left = guard;//后出发，直到right.next为null时left即为所求    //1.right先走n个节点    while(n!=0){        right = right.next;        n--;    }    //2.left、right一起走，直到right.next==null，此时left指向倒数第n+1个节点    while(right.next!=null){        left = left.next;        right = right.next;    }    //3.删除倒数第k个节点    left.next = left.next.next;    return guard.next;}</code></pre><p><a name="38"></a></p><h2 id="38-判断链表是否有环-两道"><a href="#38-判断链表是否有环-两道" class="headerlink" title="38.判断链表是否有环(两道)"></a>38.判断链表是否有环(两道)</h2><h3 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1.判断链表是否有环"></a>1.判断链表是否有环</h3><p>leetcode 141</p><p>题目：Given a linked list, determine if it has a cycle in it.</p><p>思路：每次fast走两步，low走一步，如果两者相遇则有环，如果遇到null则无环</p><pre><code class="java">public boolean hasCycle(ListNode head) {    if(head==null){        return false;    }    //判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环    ListNode right = head;//走两步    ListNode left = head;//走一步    while(right!=null &amp;&amp; right.next!=null){        right = right.next.next;        left = left.next;        if(right==left){//如果相遇，则有环            return true;        }    }    return false;}</code></pre><h3 id="2-判断链表是否有环，有则返回环的入口结点"><a href="#2-判断链表是否有环，有则返回环的入口结点" class="headerlink" title="2.判断链表是否有环，有则返回环的入口结点"></a>2.判断链表是否有环，有则返回环的入口结点</h3><p>《剑指offer》p139、leetcode 142</p><p>题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>思路：</p><blockquote><p>1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</p><p>如果有环：前后指针相遇的地方一定在环中，此时遍历这个环计算环的节点数k，之后从头遍历链表，前指针比后指针多走k步，前后指针再次相遇时即为为环的入口节点</p></blockquote><pre><code class="java">class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}//给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。public ListNode EntryNodeOfLoop(ListNode pHead){    if(pHead==null){        return null;    }    //1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环    ListNode right = pHead;//走两步    ListNode left = pHead;//走一步    boolean haveCycle = false; //是否有环    while(right!=null &amp;&amp; right.next!=null){        right = right.next.next;        left = left.next;        if(right==left){//如果相遇，则有环            haveCycle = true;            break;        }    }    if(!haveCycle){//如果没环，返回null        return null;    }    //2.有环，找出环的入口节点。    //  思路：2.1遍历环计算环中节点个数k个；    //       2.2从头遍历链表，两个指针，一个先走k，两个一起走直到相遇即为入口节点    //2.1遍历环计算环中节点个数k个    int cycleNum = 1; //环中节点个数    while(right.next!=left){        cycleNum++;        right = right.next;    }    //2.2从头遍历链表，两个指针，一个先走cycleNum-1个节点，两个一起走直到相遇时left即为入口节点    right = pHead;    left = pHead;    while(cycleNum!=1){//right先走cycleNum-1个节点        right = right.next;        cycleNum--;    }    while(right.next!=left){//right、left两个一起走，直到相遇时的left节点即为所求        right = right.next;        left = left.next;    }    return left;}</code></pre><p><a name="39"></a></p><h2 id="39-两个单链表相交的第一个公共节点-2道"><a href="#39-两个单链表相交的第一个公共节点-2道" class="headerlink" title="39.两个单链表相交的第一个公共节点(2道)"></a>39.两个单链表相交的第一个公共节点(2道)</h2><pre><code>两个链表的第一个公共节点(无环)--《剑指offer》p253、leetcode 160两个链表的第一个公共节点(可能有环，需自己判断)--《左神》62，掌握这一道题就够了</code></pre><h3 id="1-两个链表的第一个公共节点-无环"><a href="#1-两个链表的第一个公共节点-无环" class="headerlink" title="1.两个链表的第一个公共节点(无环)"></a>1.两个链表的第一个公共节点(无环)</h3><p>《剑指offer》p253、leetcode 160</p><p>题目：输入两个链表，链表无环，找出它们的第一个公共结点。如果不相交返回null</p><p>思路：</p><p>法一：因为要从两个链表的尾部往前一一判断，因此需要借助两个栈的辅助。java栈的实现可以用LinkedList。时间o(m+n)，空间o(m+n)</p><p>法二(更简单的办法)：链表长度差。首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到第一个相同的结点就是他们的第一个公共结点。时间o(m+n)，空间o(1)</p><pre><code class="java">//返回两个无环链表相交的第一个节点，如果不相交返回nullpublic static ListNode FindFirstNoCycleCommonNode(ListNode head1, ListNode head2){    if(head1==null || head2==null){        return null;    }    //1.计算两个链表的长度    int len1 = 1;    int len2 = 1;    ListNode p1 = head1;    ListNode p2 = head2;    while(p1.next!=null){        len1++;        p1 = p1.next;    }    while(p2.next!=null){        len2++;        p2 = p2.next;    }    if(p1!=p2){//两个链表的最后一个节点不相同，说明不相交        return null;    }    //2.计算长度差k，让长链表先走k步    ListNode longList = len1&gt;=len2?head1:head2;    ListNode shortList = longList==head1?head2:head1;    int k = Math.abs(len1-len2);    while(k!=0){        longList = longList.next;        k--;    }    //3.两个链表一起走，直到找到相交的第一个节点    while(longList!=null &amp;&amp; shortList!=null){        if(longList==shortList){            return longList;        }        longList = longList.next;        shortList = shortList.next;    }    return null;//不相交}</code></pre><h3 id="2-两个链表的第一个公共节点-可能有环，需自己判断"><a href="#2-两个链表的第一个公共节点-可能有环，需自己判断" class="headerlink" title="2.两个链表的第一个公共节点(可能有环，需自己判断)"></a>2.两个链表的第一个公共节点(可能有环，需自己判断)</h3><p>《左神》62，掌握这一道题就够了</p><p>题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null</p><p>思路：</p><p>1.判断两个链表是否有环</p><pre><code>1.1 若一个链表有环，另一个链表无环，则不可能相交，返回null1.2 都无环则判断两个无环链表的第一个公共节点，没有返回null</code></pre><p>2.若有环，判断两个有环链表的第一个公共节点。</p><pre><code>2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null</code></pre><p>代码：</p><pre><code class="java">class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}public class Solution{    /**     * 题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null     * 思路：     *   1.判断两个链表是否有环，都无环则判断两个无环链表的第一个公共节点，没有返回null     *   2.判断两个有环链表的第一个公共节点。     *     2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)     *     2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null     */    public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) {        if(head1==null || head2==null){            return null;        }        ListNode beginNodeOfCycle1 = hasCycle(head1);//链表head1是否有环，无环返回null，有环返回入口节点        ListNode beginNodeOfCycle2 = hasCycle(head2);//链表head2是否有环，无环返回null，有环返回入口节点        //1.两个链表都无环，判断两个无环链表的第一个公共节点，没有返回null        if (beginNodeOfCycle1==null &amp;&amp; beginNodeOfCycle2==null) {            return noCycleCommonNode(head1, head2);        }        //2.两个链表都有环        if (beginNodeOfCycle1!=null &amp;&amp; beginNodeOfCycle2!=null) {            //2.1beginNodeOfCycle1==beginNodeOfCycle2,交点在发生在环前,与无环链表公共节点求法类似(长度差，分别先后走找交点)            if(beginNodeOfCycle1==beginNodeOfCycle2){                ListNode p1 = head1;                ListNode p2 = head2;                int len1 = 0;                int len2 = 0;                while(p1!=beginNodeOfCycle1){                    len1++;                    p1 = p1.next;                }                while(p2!=beginNodeOfCycle2){                    len2++;                    p2 = p2.next;                }                ListNode longHead = len1&gt;=len2 ? head1 : head2;                ListNode shortHead = longHead==head1 ? head2 : head1;                int k = Math.abs(len1-len2);                while(k!=0){//长链表先走k步                    longHead = longHead.next;                    k--;                }                while(longHead!=beginNodeOfCycle1 &amp;&amp; shortHead!=beginNodeOfCycle2){//两个链表一起走                    if(longHead==shortHead){//找到公共节点                        return longHead;                    }                    longHead = longHead.next;                    shortHead = shortHead.next;                }            }            //2.2beginNodeOfCycle11=beginNodeOfCycle2,交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null            else{                while(beginNodeOfCycle1.next!=beginNodeOfCycle1){                    beginNodeOfCycle1 = beginNodeOfCycle1.next;                    if(beginNodeOfCycle1==beginNodeOfCycle2){//环中找到了第一个公共节点，返回                        return beginNodeOfCycle1;                    }                }                return null;//环中没有公共节点，即两个有环链表独立不相交的            }        }        //一个链表有环，一个链表无环，返回null        return null;    }    //判断一个链表是否有环，没环返回null，如果有环返回入口节点    public ListNode hasCycle(ListNode pHead){        ListNode p1 = pHead;//每次走两步        ListNode p2 = pHead;//每次走一步        boolean hasCycle = false;        while(p2.next!=null &amp;&amp; p1.next.next!=null){            p2 = p2.next.next;            p1 = p1.next;            if(p1==p2){                hasCycle = true;//两个指针相遇则有环                break;            }        }        if(hasCycle){//链表有环，返回入口节点            //1.计算环的节点个数            ListNode temp = p1;            int k = 1;            while(p1.next!=temp){                k++;                p1 = p1.next;            }            //2.right指针从链表头先走k步            ListNode right = pHead;            ListNode left = pHead;            while(k!=0){                right = right.next;                k--;            }            //3.left从头和right一起走，直到相遇            while(left!=right){                left = left.next;                right = right.next;            }            return left;//找到入口节点并返回        }        return null;//链表无环，返回null    }    //判断两个无环链表的第一个公共节点，没有则返回null    public ListNode noCycleCommonNode(ListNode head1, ListNode head2){        //长度差，一个先走k步，然后同时走，看是否有公共节点        if(head1==null || head2==null){            return null;        }        ListNode p1 = head1;        ListNode p2 = head2;        int len1 = 1;        int len2 = 1;        while(p1.next!=null){            len1++;            p1 = p1.next;        }        while(p2.next!=null){            len2++;            p2 = p2.next;        }        if(p1!=p2){//两个链表的最后一个节点不等，则没有公共节点，返回null            return null;        }        ListNode longHead = len1&gt;=len2 ? head1 : head2;        ListNode shortHead = longHead==head1 ? head2 : head1;        int k = Math.abs(len1-len2);        while(k!=0){//长链表先走k步            longHead = longHead.next;            k--;        }        while(longHead!=null &amp;&amp; shortHead!=null){//两个链表一起走            if(longHead==shortHead){//找到公共节点                return longHead;            }            longHead = longHead.next;            shortHead = shortHead.next;        }        return null;//没有公共节点，返回null    }}</code></pre><p><a name="40"></a></p><h2 id="40-合并两个排序的链表"><a href="#40-合并两个排序的链表" class="headerlink" title="40.合并两个排序的链表"></a>40.合并两个排序的链表</h2><p>《剑指offer》p145、leetcode21、《左神》84</p><p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>思路：正常的遍历两个链表结点，每次将较小的节点插到新链表的尾部即可。设置哨兵</p><pre><code class="java">//合并两个有序的链表，设置一个哨兵public ListNode Merge(ListNode list1,ListNode list2) {    ListNode guard = new ListNode(0);    ListNode p = guard;    ListNode temp;    while(list1!=null &amp;&amp; list2!=null){        if(list1.val&lt;=list2.val){            temp = list1;            list1 = list1.next;        }        else{            temp = list2;            list2 = list2.next;        }        temp.next = null;        p.next = temp;        p = p.next;    }    if(list1!=null){        p.next = list1;    }    if(list2!=null){        p.next = list2;    }    return guard.next;}</code></pre><p><a name="41"></a></p><h2 id="41-树的子结构"><a href="#41-树的子结构" class="headerlink" title="41.树的子结构"></a>41.树的子结构</h2><p>《剑指offer》p148、leetcode 572</p><p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>思路：分为两步。第一步，先序遍历树A，在树A中找到和树B的根节点值相同的节点R；第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构</p><pre><code class="java">class TreeNode {     int val = 0;     TreeNode left = null;     TreeNode right = null;     public TreeNode(int val) {        this.val = val;     }}//两个二叉树A、B，判断B是否是A的子结构。思路：先序遍历A，找到与B的根节点相同的节点，判断子结构是否相同public boolean HasSubtree(TreeNode root1,TreeNode root2) {    if(root1==null || root2==null){        return false;    }    if(root1.val==root2.val){        if(isSame(root1, root2)){            return true;        }    }    return HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);}public boolean isSame(TreeNode root1, TreeNode root2){    if(root2==null){        return true;    }    if(root1==null){        return false;    }    if(root1.val==root2.val){        return isSame(root1.left, root2.left) &amp;&amp; isSame(root1.right, root2.right);    }    return false;}</code></pre><p><a name="42"></a></p><h2 id="42-二叉树的翻转-镜像-与对称-2道"><a href="#42-二叉树的翻转-镜像-与对称-2道" class="headerlink" title="42.二叉树的翻转(镜像)与对称(2道)"></a>42.二叉树的翻转(镜像)与对称(2道)</h2><pre><code>《剑指offer》p157--二叉树的翻转(转换成镜像二叉树)leetcode 101、《剑指offer》p159--判断二叉树是否是对称</code></pre><h3 id="1-二叉树的翻转-镜像"><a href="#1-二叉树的翻转-镜像" class="headerlink" title="1.二叉树的翻转(镜像)"></a>1.二叉树的翻转(镜像)</h3><p>《剑指offer》p157</p><p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>思路：前序遍历树的每一个结点，对每个节点的左右子树互换，递归下去即可。</p><pre><code class="java">//操作给定的二叉树，将其变换为源二叉树的镜像。思路：左右子树互换，递归下去即可public void Mirror(TreeNode root) {    if(root==null){        return;    }    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;    Mirror(root.left);    Mirror(root.right);}</code></pre><h3 id="2-对称的二叉树"><a href="#2-对称的二叉树" class="headerlink" title="2.对称的二叉树"></a>2.对称的二叉树</h3><p>《剑指offer》p159、leetcode 101 </p><p>题目：判断一颗二叉树是不是对称的</p><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>思路：根左右与根右左的递归判断即可。</p><p>从根开始，先判断其左右孩子，如果都不存在则为true</p><p>如果只有一个为空或者两个指向的val值不同则为false</p><p>当根的左右孩子节点相同时，再判断其左孩子的左孩子和右孩子的右孩子、左孩子的右孩子和右孩子的左孩子</p><pre><code class="java">//判断一颗二叉树是不是对称的。思路：根左右与根右左的递归判断即可public boolean isSymmetrical(TreeNode pRoot){    if(pRoot==null){        return true;    }    if(pRoot.left==null &amp;&amp; pRoot.right==null){        return true;    }    if(pRoot.left!=null &amp;&amp; pRoot.right!=null){        return isSymmetricalDetail(pRoot.left, pRoot.right);    }    return false;}public boolean isSymmetricalDetail(TreeNode root1, TreeNode root2){    if(root1==null &amp;&amp; root2==null){        return true;    }    if(root1==null || root2==null){        return false;    }    if(root1.val==root2.val){        return isSymmetricalDetail(root1.left, root2.right) &amp;&amp; isSymmetricalDetail(root1.right, root2.left);    }    return false;}</code></pre><p><a name="43"></a></p><h2 id="43-顺时针打印矩阵"><a href="#43-顺时针打印矩阵" class="headerlink" title="43.顺时针打印矩阵"></a>43.顺时针打印矩阵</h2><p>《剑指offer》p161、leetcode 54 spiral Matrix(螺旋矩阵)</p><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p>思路：先定义好打印一圈的函数，然后根据矩阵大小确定需要打印几圈。</p><pre><code class="java">import java.util.ArrayList;public class Solution{    //顺时针打印矩阵。思路：先定义打印一圈的函数，再确定打印几圈    public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if(matrix==null){            return res;        }        int m = matrix.length;        int n = matrix[0].length;        int startI = 0;        int startJ = 0;        int endI = m-1;        int endJ = n-1;        int cycleNum = (int)Math.ceil((double)Math.min(m,n)/2);//一共打印cycleNum圈        while(cycleNum!=0){//循环打印cycleNum圈            printOneCycle(matrix, startI, startJ, endI, endJ, res);            startI++;            startJ++;            endI--;            endJ--;            cycleNum--;        }        return res;    }    //定义打印一圈的函数。限定一圈的边界需要两个参数，圈的左上角元素和右下角元素的坐标    public static void printOneCycle(int[][] matrix, int startI, int startJ, int endI, int endJ, ArrayList&lt;Integer&gt; res){        //1.打印圈的上边，每圈都有        int temp = startJ;        while(temp&lt;=endJ) {            res.add(matrix[startI][temp]);            temp++;        }        //2.打印圈的右边，必须两行以上        temp = startI+1;        while(endI&gt;startI &amp;&amp; temp&lt;=endI){            res.add(matrix[temp][endJ]);            temp++;        }        //3.打印圈的下边，必须两行以上、两列以上        temp = endJ-1;        while(endI&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;=startJ){            res.add(matrix[endI][temp]);            temp--;        }        //4.打印圈的左边，必须三行以上、两列以上        temp = endI - 1;        while(endI-1&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;startI){            res.add(matrix[temp][startJ]);            temp--;        }    }    public static void main(String[] args){        int[][] matrix = new int[][]{{1,2,3,4},                                    {5,6,7,8},                                    {9,10,11,12},                                    {13,14,15,16}};        System.out.println(printMatrix(matrix));    }}</code></pre><p><a name="44"></a></p><h2 id="44-包含min函数的栈"><a href="#44-包含min函数的栈" class="headerlink" title="44.包含min函数的栈"></a>44.包含min函数的栈</h2><p>《剑指offer》p165、leetcode155</p><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））</p><p>思路：如果只用一个元素保存最小的元素，那么当最小的元素被弹出后，就没有办法得到剩余元素中最下的元素。因此引入辅助栈，每次将最小元素（之前的最小元素和新压入的元素两者的较小者）都保存起来放到辅助栈里。</p><pre><code class="java">import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();    Stack&lt;Integer&gt; minStk = new Stack&lt;&gt;(); //辅助栈，每次push时都压入当前最小值（node与minStk栈顶元素中的较小者）    public void push(int node) {        stk.push(node);        if(minStk.empty() || node &lt; minStk.peek()){            minStk.push(node);        }        else{            minStk.push(minStk.peek());        }    }    public void pop() {        stk.pop();        minStk.pop();    }    public int top() {        return stk.peek();    }    public int min() {        return minStk.peek();    }}</code></pre><p><a name="45"></a></p><h2 id="45-栈的压入、弹出序列"><a href="#45-栈的压入、弹出序列" class="headerlink" title="45.栈的压入、弹出序列"></a>45.栈的压入、弹出序列</h2><p>《剑指offer》p168、leetcode 946</p><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>思路：借助一个辅助栈来模拟入栈弹栈过程。每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环（直到出栈序列遍历完返回true）；如果不等：入栈后面的数字（直到入栈序列遍历完还没找到则false）</p><pre><code class="java">//每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环；如果不等：入栈后面的数字public static boolean IsPopOrder(int [] pushA,int [] popA) {    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    int len = pushA.length;    int pushAIndex = 0;    int popAIndex = 0;    while(popAIndex&lt;len){        if(stack.isEmpty() || popA[popAIndex]!=stack.peek()){            if(pushAIndex==len){ //直到入栈序列遍历完还没找到则false                return false;            }            stack.push(pushA[pushAIndex]);            pushAIndex++;        }else{            if(!stack.isEmpty()){                stack.pop();                popAIndex++;            }        }    }    return true;//直到出栈序列遍历完返回true}</code></pre><p><a name="46"></a></p><h2 id="46-二叉树的层序遍历-3道"><a href="#46-二叉树的层序遍历-3道" class="headerlink" title="46.二叉树的层序遍历(3道)"></a>46.二叉树的层序遍历(3道)</h2><pre><code>二叉树的层序遍历--《剑指offer》p171二叉树的层序遍历，按行打印--《剑指offer》p174、leetcode 102、leetcode107二叉树的层序遍历，之字形按行打印--《剑指offer》p176、leetcode 103</code></pre><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h3><p>《剑指offer》p171</p><p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路：借助队列实现层序遍历</p><pre><code class="java">//二叉树的层序遍历。思路：辅助队列public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        res.add(temp.val);        if(temp.left!=null){            queue.offer(temp.left);        }        if(temp.right!=null){            queue.offer(temp.right);        }    }    return res;}</code></pre><h3 id="2-二叉树的层序遍历，按行打印"><a href="#2-二叉树的层序遍历，按行打印" class="headerlink" title="2.二叉树的层序遍历，按行打印"></a>2.二叉树的层序遍历，按行打印</h3><p>《剑指offer》p174、leetcode 102、leetcode107</p><p>题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数。</p><pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCntArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(pRoot==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(pRoot);    int curCnt = 1;    int nextCnt = 0;    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        resTemp.add(temp.val);        curCnt--;        if(temp.left!=null){            queue.offer(temp.left);            nextCnt++;        }        if(temp.right!=null){            queue.offer(temp.right);            nextCnt++;        }        if(curCnt==0){            res.add(resTemp);            resTemp = new ArrayList&lt;&gt;();            curCnt = nextCnt;            nextCnt = 0;        }    }    return res;}</code></pre><h3 id="3-二叉树的层序遍历，之字形按行打印"><a href="#3-二叉树的层序遍历，之字形按行打印" class="headerlink" title="3.二叉树的层序遍历，之字形按行打印"></a>3.二叉树的层序遍历，之字形按行打印</h3><p>《剑指offer》p176、leetcode 103</p><p>题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数；且辅助奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)</p><pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCntArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(pRoot==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(pRoot);    int curCnt = 1;    int nextCnt = 0;    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();    boolean odd = true; //奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        resTemp.add(temp.val);        curCnt--;        if(temp.left!=null){            queue.offer(temp.left);            nextCnt++;        }        if(temp.right!=null){            queue.offer(temp.right);            nextCnt++;        }        if(curCnt==0){            if(!odd){//当前行是偶数行，从右往左，reverse下                Collections.reverse(resTemp);            }            res.add(resTemp);            resTemp = new ArrayList&lt;&gt;();            curCnt = nextCnt;            nextCnt = 0;            odd = !odd;//下一行的奇偶是!odd        }    }    return res;}</code></pre><p><a name="47"></a></p><h2 id="47-递归与非递归实现二叉树前序、中序、后序遍历"><a href="#47-递归与非递归实现二叉树前序、中序、后序遍历" class="headerlink" title="47.递归与非递归实现二叉树前序、中序、后序遍历"></a>47.递归与非递归实现二叉树前序、中序、后序遍历</h2><p>《左神》88、 leetcode144、94、145</p><p>题目：递归与非递归实现二叉树前序、中序、后序遍历</p><h3 id="1-前序："><a href="#1-前序：" class="headerlink" title="1.前序："></a>1.前序：</h3><pre><code class="java">//递归实现前序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {    if(root==null){        return res;    }    res.add(root.val);    if(root.left!=null){        res = preorderTraversal(root.left);    }    if(root.right!=null){        res = preorderTraversal(root.right);    }    return res;}//非递归实现前序遍历public List&lt;Integer&gt; preorderTraversal(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            res.add(temp.val);//压栈之前先访问            stack.push(temp);            temp = temp.left;        }        else{            temp = stack.pop().right;        }    }    return res;}</code></pre><h3 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h3><pre><code class="java">//递归实现中序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {    if(root==null){        return res;    }    if(root.left!=null){        res = inorderTraversal(root.left);    }    res.add(root.val);    if(root.right!=null){        res = inorderTraversal(root.right);    }    return res;}​//非递归实现中序遍历public List&lt;Integer&gt; inorderTraversal(TreeNode root) {     List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){         return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            stack.push(temp);            temp = temp.left;        }        else{            temp = stack.pop();            res.add(temp.val);            temp = temp.right;        }    }    return res;}</code></pre><p>​    </p><h3 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h3><pre><code class="java">//递归实现后序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root){    if(root==null){        return res;    }    if(root.left!=null){        res = postorderTraversal(root.left);    }    if(root.right!=null){        res = postorderTraversal(root.right);    }    res.add(root.val);    return res;}//非递归实现后序遍历。思路：1.根右左压栈，利用中间栈output来存储逆后序遍历的结果 + 2.最后再一起输出即可public List&lt;Integer&gt; postorderTraversal(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈,存根节点    Stack&lt;TreeNode&gt; output = new Stack&lt;&gt;();//还需要一个辅助栈来存储逆后序遍历的结果    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            stack.push(temp);            output.push(temp);            temp = temp.right;        }        else{            temp = stack.pop().left;        }    }    while(!output.isEmpty()){        res.add(output.pop().val);    }    return res;}</code></pre><p><a name="48"></a></p><h2 id="48-判断数组是否为二叉搜索树的后续遍历序列"><a href="#48-判断数组是否为二叉搜索树的后续遍历序列" class="headerlink" title="48.判断数组是否为二叉搜索树的后续遍历序列"></a>48.判断数组是否为二叉搜索树的后续遍历序列</h2><p>《剑指offer》p179.</p><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>思路：后序遍历序列是左右根，所以先取数组中最后一个数，作为根节点。</p><pre><code>1.找根2.找根左右的左右分界线(从左往右第一个比根大的即为右)3.右可以没有，如果有右，则右中不含比根小的，否则false4.递归判断下去</code></pre><p>代码：</p><pre><code class="java">//题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果,假设输入的数组的任意两个数字都互不相同。/** * 思路： *   1.找根 *   2.找根左右的左右分界线(从左往右第一个比根大的即为➡右) *   3.右可以没有，如果有右，则右中不含比根小的，否则false *   4.递归判断下去 */​    public boolean VerifySquenceOfBST(int [] sequence) {​        if(sequence==null || sequence.length==0){​            return false;​        }​        if(sequence.length==1){​            return true;​        }​        return VerifySquenceOfBSTDetail(sequence, 0, sequence.length-1);​    }​    public boolean VerifySquenceOfBSTDetail(int[] sequence, int start, int end){​        if(start&gt;end){​            return false;​        }​        if(start==end){​            return true;​        }​        //1.找根​        int root = sequence[end];​​        //2.找左右分界线​        int rightIndex = start;​        int temp = start;​        while(temp&lt;end){​            if(sequence[temp]&gt;root){//第一个比root大的节点即为右​                rightIndex = temp;​                break;​            }​            temp++;​        }​        if(temp==end){//只有左，没有右，则递归判断左即可​            return VerifySquenceOfBSTDetail(sequence, start, end-1);​        }​    //3.有右，则右中不能含比根小的，否则返回false    temp = rightIndex;    while(temp&lt;end){        if(sequence[temp]&lt;root){//右中含比根小的，返回false            return false;        }        temp++;    }    //4.递归判断左、右序列即可    if(rightIndex==start){//只有左，没有右，递归判断右即可        return VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);    }    else{//有左有右        return VerifySquenceOfBSTDetail(sequence, start, rightIndex-1) &amp;&amp; VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);    }}</code></pre><p><a name="49"></a></p><h2 id="49-二叉树中和为指定值的路径-2道"><a href="#49-二叉树中和为指定值的路径-2道" class="headerlink" title="49.二叉树中和为指定值的路径(2道)"></a>49.二叉树中和为指定值的路径(2道)</h2><pre><code>leetcode 112--二叉树中和为指定值的一条路径《剑指offer》p182、leetcode 113--二叉树中和为指定值的所有路径(回溯法)</code></pre><h3 id="1-Path-Sum"><a href="#1-Path-Sum" class="headerlink" title="1.Path Sum"></a>1.Path Sum</h3><p>leetcode 112</p><p>题目：二叉树中和为指定值的一条路径。</p><p>思路：正常递归遍历即可。</p><pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的一条路径。List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();public boolean hasPathSum(TreeNode root, int sum) {    if(root==null){        return false;    }    sum -= root.val;    if(root.left==null &amp;&amp; root.right==null &amp;&amp; sum==0){//当前节点为叶节点且路径和==sum，true        return true;    }    return hasPathSum(root.left,sum) || hasPathSum(root.right, sum);}</code></pre><h3 id="2-Path-Sum-2"><a href="#2-Path-Sum-2" class="headerlink" title="2.Path Sum 2"></a>2.Path Sum 2</h3><p>《剑指offer》p182、leetcode 113</p><p>题目：二叉树中和为指定值的所有路径。输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p>思路：回溯法。遍历树每一条到叶子节点的路径，找寻符合条件的路径。到叶子节点如果还没有找到路径，就要回退到父节点继续寻找，依次类推。</p><pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的所有路径。思路：递归+回溯法ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//存放所有路径ArrayList&lt;Integer&gt; tempPath = new ArrayList&lt;&gt;();//存放当前路径public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {    if(root==null){        return res;    }    target -= root.val;    tempPath.add(root.val);    if(root.left==null &amp;&amp; root.right==null &amp;&amp; target==0){//当前节点是叶节点且路径和==target，满足条件        res.add(new ArrayList&lt;&gt;(tempPath));    }    FindPath(root.left, target);    FindPath(root.right, target);    tempPath.remove(tempPath.size()-1);//回溯点    return res;}</code></pre><p><a name="50"></a></p><h2 id="50-复杂链表的复制"><a href="#50-复杂链表的复制" class="headerlink" title="50.复杂链表的复制"></a>50.复杂链表的复制</h2><p>《剑指offer》p187、《左神》56、leetcode138</p><p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p>思路：分而治之，复杂问题分成小问题一一解决。时间o(n) 空间o(1)<br>1、遍历链表并复制结点，复制的结点在相应节点之后：a-&gt;b-&gt;c-&gt;d-&gt;e为a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’-&gt;d-&gt;d’-&gt;e-&gt;e’<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p><pre><code class="java">class RandomListNode {    public int label;    public RandomListNode next, random;    public RandomListNode(int x) {        this.label = x;    }};public class Solution2 {    public RandomListNode copyRandomList(RandomListNode head) {        if(head==null){            return null;        }        RandomListNode p = head;        //1.遍历链表，复制节点        while(p!=null){            RandomListNode newNode = new RandomListNode(p.label);            newNode.next = p.next;            p.next = newNode;            p = p.next.next;        }        //2.遍历链表，复制random指针        p = head;        while(p!=null){            if(p.random!=null){                p.next.random = p.random.next;            }            p = p.next.next;        }        //3.拆分链表，将复制链表拆出来        p = pHead;        RandomListNode newHead = new RandomListNode(0);//新链表的哨兵        RandomListNode newP = newHead;        while(p!=null){            RandomListNode temp = p.next;            p.next = p.next.next;            temp.next = null;            newP.next = temp;            newP = newP.next;            p = p.next;        }    return newHead.next;    }}</code></pre><p><a name="51"></a></p><h2 id="51-二叉搜索树与双向链表-两道"><a href="#51-二叉搜索树与双向链表-两道" class="headerlink" title="51.二叉搜索树与双向链表(两道)"></a>51.二叉搜索树与双向链表(两道)</h2><h3 id="1-二叉搜索树转双向链表"><a href="#1-二叉搜索树转双向链表" class="headerlink" title="1.二叉搜索树转双向链表"></a>1.二叉搜索树转双向链表</h3><p>《剑指offer》p191、leetcode426、《左神》74</p><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>思路：中序遍历+记录有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序，因此需要辅助保存当前链表最后一个节点。</p><pre><code class="java">class TreeNode {    public int val;    public TreeNode left;    public TreeNode right;    public TreeNode(int x){        val = x;        this.left = null;        this.right = null;    }}public class Solution2 {    public TreeNode Convert(TreeNode root){        if(root==null){            return null;        }        TreeNode lastPointer = null;//当前有序双向链表的最后一个节点        lastPointer = ConvertDetail(lastPointer, root);        while(lastPointer.left!=null){            lastPointer = lastPointer.left;        }        return lastPointer;    }    //中序遍历，返回当前有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序的了    private TreeNode ConvertDetail(TreeNode lastPointer, TreeNode root){        if(root==null){            return lastPointer;        }        if(root.left!=null){            lastPointer = ConvertDetail(lastPointer, root.left);        }        root.left = lastPointer;        if(lastPointer!=null){            lastPointer.right = root;        }        lastPointer = root;        if(root.right!=null){            lastPointer = ConvertDetail(lastPointer, root.right);        }        return lastPointer;    }}</code></pre><h3 id="2-有序数组转平衡二叉树"><a href="#2-有序数组转平衡二叉树" class="headerlink" title="2.有序数组转平衡二叉树"></a>2.有序数组转平衡二叉树</h3><p>leetcode 108</p><p>题目：Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>思路：数组中间的数做root，递归二分即可。</p><pre><code class="java">//有序数组转成平衡二叉树。思路：数组中间的数做root，递归二分即可public TreeNode sortedArrayToBST(int[] nums) {    if(nums==null || nums.length==0){        return null;    }    return sortedArrayToBSTDetail(nums, 0, nums.length-1);}public TreeNode sortedArrayToBSTDetail(int[] nums, int start, int end){    if(start&lt;0 || end&gt;=nums.length || start&gt;end){        return null;    }    int mid = (start+end)/2;    TreeNode root = new TreeNode(nums[mid]);    root.left = sortedArrayToBSTDetail(nums, start, mid-1);    root.right = sortedArrayToBSTDetail(nums, mid+1, end);    return root;}</code></pre><p><a name="52"></a></p><h2 id="52-序列化二叉树"><a href="#52-序列化二叉树" class="headerlink" title="52.序列化二叉树"></a>52.序列化二叉树</h2><p>《剑指offer》p194、leetcode 297(序列化反序列化二叉树）、leetcode 449(序列化反序列化平衡二叉树)</p><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>思路：序列化：前序遍历，遇到子节点为空用”$”代替；反序列化：按照前序遍历序列化的顺序进行反推。</p><pre><code class="java">//请实现两个函数，分别用来序列化和反序列化二叉树//1.序列化：前序遍历，遇到空节点为空用&quot;null&quot;代替public String serialize(TreeNode root) {    StringBuilder res = new StringBuilder();    serializeDetail(root, res);    return res.toString();}//这样分开的话，递归的时候不用保存全局变量res，防止二叉树太深导致的递归栈溢出public void serializeDetail(TreeNode root, StringBuilder res){    if(root==null){        res.append(&quot;null,&quot;);        return;    }    res.append(root.val + &quot;,&quot;);    serializeDetail(root.left, res);    serializeDetail(root.right, res);}//2.反序列化：按照前序遍历序列化的顺序进行反推,将String转成ArrayList&lt;String&gt;方便删除同时节省空间public TreeNode deserialize(String data) {    if(data==null || data.length()==0){        return null;    }    String[] str = data.split(&quot;,&quot;);    ArrayList&lt;String&gt; strr = new ArrayList&lt;&gt;(Arrays.asList(str));    return deserializeDetail(strr);}public TreeNode deserializeDetail(ArrayList&lt;String&gt; strr){    if(strr.size()==0){        return null;    }    String temp = strr.get(0);    strr.remove(0);    if(temp.equals(&quot;null&quot;)){        return null;    }    TreeNode root = new TreeNode(Integer.valueOf(temp));    root.left = deserializeDetail(strr);    root.right = deserializeDetail(strr);    return root;}</code></pre><p><a name="53"></a></p><h2 id="53-全排列-组合问题-五道"><a href="#53-全排列-组合问题-五道" class="headerlink" title="53.全排列/组合问题(五道)"></a>53.全排列/组合问题(五道)</h2><pre><code>1.字符串的全排列(abc,acb...)--《剑指offer》p1972.无重复数字的全排列--leetcode 463.有重复数字的全排列--leetcode 474.八皇后问题--《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)5.字符串s1的全排列是否在s2字符串中--leetcode 567</code></pre><h3 id="1-字符串的全排列"><a href="#1-字符串的全排列" class="headerlink" title="1.字符串的全排列"></a>1.字符串的全排列</h3><p>《剑指offer》p197</p><p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><p>例如输入字符串abc，则打印由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。注意aac aac只能有一个，需要过滤重复</p><p>思路：递归。我们求整个字符串的排列，可以看成两步：首先求出所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换……</p><pre><code class="java">//字符串的全排列public ArrayList&lt;String&gt; Permutation(String str) {    ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();    if(str==null || str.length()==0){        return res;    }    PermutationDetail(res, str.toCharArray(), 0);    Collections.sort(res);//最后排序一下，按字典序输出    return res;}public void PermutationDetail(ArrayList&lt;String&gt; res, char[] str, int index){    if(index==str.length){//递归出口        String temp = String.valueOf(str);        if(!res.contains(temp)){//过滤重复            res.add(String.valueOf(str));        }        return;    }    for(int i=index; i&lt;str.length; ++i){        swap(str, i, index);//每次递归将index位置字符与后面所有字符进行分别交换        PermutationDetail(res, str, index+1);//当前位置交换后进行下一位上的排列递归        swap(str, i, index);    }}public void swap(char[] str, int i, int j){    char temp = str[i];    str[i] = str[j];    str[j] = temp;}</code></pre><h3 id="2-无重复数字的全排列"><a href="#2-无重复数字的全排列" class="headerlink" title="2.无重复数字的全排列"></a>2.无重复数字的全排列</h3><p>leetcode 46</p><p>题目：和字符串的全排列一样，换汤不换药。给定一个无重复数字的序列，返回这些数所能排列出所有序列。</p><pre><code>Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p>代码：</p><pre><code class="java">//数字的全排列public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    permuteDetail(res, nums, 0);    return res;}public void permuteDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        Integer[] temp = new Integer[nums.length];        for(int i= 0;i&lt;nums.length;i++){            temp[i]= nums[i];//int-&gt;Integer        }        res.add(Arrays.asList(temp));    }    for(int i=index; i&lt;nums.length; ++i){        swap(nums, i, index);//每次递归将index位置字符与后面所有字符进行分别交换        permuteDetail(res, nums, index+1);//当前位置交换后进行下一位上的排列递归        swap(nums, i, index);    }}public void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}</code></pre><h3 id="3-有重复数字的全排列"><a href="#3-有重复数字的全排列" class="headerlink" title="3.有重复数字的全排列"></a>3.有重复数字的全排列</h3><p>leetcode 47</p><p>题目：给定一个有重复数字的序列，返回这些数所能排列出所有序列。注意需要把重复的全排列给过滤掉</p><p>思路：有重复的数字的全排列。为了过滤重复，对于同一个值，只交换一次，否则跳过。为了保证这一点，辅助<strong>hash表</strong>来过滤重复的元素，如果重复则跳过不交换即可。</p><pre><code class="java">//有重复数组的全排列。需要过滤重复，思路：用hash即可，不用排序public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    permuteUniqueDetail(res, nums, 0);    return res;}public void permuteUniqueDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        Integer[] itg = new Integer[nums.length];        for(int i=0; i&lt;nums.length; ++i){//int-&gt;Integer            itg[i] = nums[i];        }        List&lt;Integer&gt; temp = Arrays.asList(itg);        res.add(temp);    }    Set&lt;Integer&gt; used = new HashSet&lt;&gt;();//hashSet记录已经访问过的数，避免重复排列    for(int i=index; i&lt;nums.length; ++i){        if(used.add(nums[i])){//对于同一个值，只交换一次，否则跳过。            swap(nums, index, i);            permuteUniqueDetail(res, nums, index+1);            swap(nums, index, i);        }    }}public void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}</code></pre><h3 id="4-八皇后问题"><a href="#4-八皇后问题" class="headerlink" title="4.八皇后问题"></a>4.八皇后问题</h3><p>《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)</p><p>题目：在n*n的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角斜线上。下图中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请求出总共有多少种摆法或者输出八皇后摆法。</p><p>思路：八皇后问题(不能同一行、列、对角线)。<strong>思路：转化为数字的全排列问题。总体思路: 0-n全排列的总数 - check(全排列出现同时在对角线上的)。</strong></p><p>详细思路：八个皇后的任意两个不能处在同一行，那么这肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把ColumnIndex的八个数字分别用0-7初始化，接下来我们要做的事情就是对数组ColumnIndex做全排列。由于我们是用不同的数字初始化数组中的数字，因此任意两个皇后肯定不同列。我们只需要判断得到的每一个排列对应的八个皇后是不是在同一对角斜线上，也就是数组的两个下标i和j，是不是i-j==ColumnIndex[i]-Column[j]或者j-i==ColumnIndex[i]-ColumnIndex[j]。</p><pre><code class="java">//八皇后问题(不能同一行、列、对角线)。思路：转化为数字的全排列问题：76548321-&gt;皇后分别在：第一行的7，第二行的6...public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    if(n&lt;1){        return res;    }    int[] nums = new int[n];//将八皇后问题转成不重复数字全排列问题    for(int i=0; i&lt;n; ++i){//0-n个数字全排列之前初始化        nums[i] = i;    }    solveNQueensDetail(res, nums, 0);//全排列并且判断是否满足八皇后，满足的排列存入结果    return res;}//全排列并判断是否满足八皇后(不能出现在同一对角线)public static void solveNQueensDetail(List&lt;List&lt;String&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        if(!check(nums)){//不满足八皇后(同一对角线)            return;        }        List&lt;String&gt; tempList = new ArrayList&lt;&gt;();        for(int i=0; i&lt;nums.length; ++i){//将八皇后排列转成输出格式--&gt;..Q.            StringBuilder sb = new StringBuilder();            int cnt = nums[i];            int ct = 0;            while(ct&lt;cnt){                sb.append(&quot;.&quot;);                ct++;            }            sb.append(&quot;Q&quot;);            ct++;            while(ct&lt;nums.length){                sb.append(&quot;.&quot;);                ct++;            }            tempList.add(sb.toString());        }        res.add(tempList);        return;    }    for(int i=index; i&lt;nums.length; ++i){        swap(nums, index, i);        solveNQueensDetail(res, nums, index+1);        swap(nums, index, i);    }}public static void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}//判断是否同一对角线public static boolean check(int[] nums){//检查一种排列是否出现在同一对角线，是则不是八皇后排列    for(int i=0; i&lt;nums.length-1; ++i){        for (int j=i+1; j&lt;nums.length; ++j){            if( Math.abs(i-j)==Math.abs(nums[i]-nums[j]) ){                return false;            }        }    }    return true;}</code></pre><h3 id="5-字符串s1的全排列是否在s2字符串中"><a href="#5-字符串s1的全排列是否在s2字符串中" class="headerlink" title="5.字符串s1的全排列是否在s2字符串中"></a>5.字符串s1的全排列是否在s2字符串中</h3><p>leetcode 567 Permutation in String</p><p>题目：Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><pre><code>Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;Output:TrueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;).</code></pre><p>思路：</p><p>方法1：最简单最暴力的方法其实就是找到s1的所有<strong>全排列</strong>，然后在s2中查找是否这些全排列字符串在s2中。但是这种方法<strong>耗时太大，会导致超时</strong>。</p><p>方法2：<strong>滑动窗口</strong><br>其实不需要找到s1的全排列，因为我们只需要考虑s2中是否包含s1中同样个数的字符，并且这些字符是连在一起的就行了。因此，我们可以使用一个滑动窗口，在s2上滑动。在这个滑动窗口中的字符及其个数是否刚好等于s1中的字符及其个数，此外滑动窗口保证了这些字符是连在一起的。</p><p>具体思路：辅助两个map键值对来模拟滑动窗口中的字符情况，由于都是小写字母，不用map，直接用int[26]来模拟map即可</p><p>注意：判断两个数组是否相等<code>Arrays.equals(int[] num1, int[] num2);</code></p><pre><code class="java">public static boolean checkInclusion(String s1, String s2) {    if(s1==null || s1.length()==0){        return true;    }    if(s2==null || s2.length()==0 || s1.length()&gt;s2.length()){        return false;    }    int[] map1 = new int[26];//s1的字符键值对    int[] map2 = new int[26];//s2上滑动窗口的字符键值对    for(int i=0; i&lt;s1.length(); ++i){//记录s1的字符map        map1[s1.charAt(i)-&#39;a&#39;]++;    }    for(int i=0; i&lt;s2.length(); ++i){//遍历s2，滑动窗口        map2[s2.charAt(i)-&#39;a&#39;]++;        if((i+1)&gt;=s1.length()){//滑动窗口            if(Arrays.equals(map1, map2)){//如果两个map包含的字符一样，则找到了s2中的s1的全排列                return true;            }            else{//否则，滑动窗口map2删除最左边的元素                map2[s2.charAt(i-s1.length()+1)-&#39;a&#39;]--;            }        }    }    return false;}</code></pre><p><a name="54"></a></p><h2 id="54-打印出给定字符串中字符的所有组合"><a href="#54-打印出给定字符串中字符的所有组合" class="headerlink" title="54.打印出给定字符串中字符的所有组合"></a>54.打印出给定字符串中字符的所有组合</h2><p>题目：”abc”-&gt;打印a,b,c,ab,ac,bc,abc</p><p>思路：在字符串位置的index到chs.length()-1中找number个数，组合成字符串放在list中，每次递归到chs[index]字符时，都有两种选择：</p><p>1.放进组合，在begin+1到chs.length()-1中找number-1个数；</p><p>2.不放进组合，在begin+1到chs.length()-1中找number个数</p><pre><code class="java">public static void combine(char[] chs){    if(chs==null || chs.length==0){        return;    }    if(chs.length==1){        System.out.println(chs[0]);    }    List&lt;Character&gt; tempList = new ArrayList&lt;&gt;();    for(int i=1; i&lt;=chs.length; ++i){//组合数字的个数[1~chs.length]        combineDetail(chs, i, 0, tempList);    }}//从index开始找combineNum个数字的组合，并打印public static void combineDetail(char[] chs, int combineNum, int index, List&lt;Character&gt; tempList){    if(combineNum==0){ //找到一种number个字符的组合，将list-&gt;String打印出来并回溯        System.out.println(tempList.toString());        return;    }    if(index==chs.length){//递归出口: 找完number个字符的所有组合，返回        return;    }    //当前位置的数字放进组合，则往后需要找combineNum-1个数    tempList.add(chs[index]);    combineDetail(chs, combineNum-1, index+1, tempList);    //当前位置的数字不放进组合，则往后需要找combineNum个数    tempList.remove(Character.valueOf(chs[index]));//回溯    combineDetail(chs, combineNum, index+1, tempList);}public static void main(String[] args) {    char[] nums = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};    combine(nums);}out:[a][b][c][a, b][a, c][b, c][a, b, c]</code></pre><p><a name="55"></a></p><h2 id="55-大-小根堆–优先队列实现-两道"><a href="#55-大-小根堆–优先队列实现-两道" class="headerlink" title="55.大/小根堆–优先队列实现(两道)"></a>55.大/小根堆–优先队列实现(两道)</h2><pre><code>找出数组中最小的k个数(优先队列大根堆)--《剑指offer》p209找出数组中第k大的数(优先队列小根堆)--leetcode 215</code></pre><p>注：java优先队列默认小根堆</p><h3 id="1-找出数组中最小的k个数-优先队列大根堆"><a href="#1-找出数组中最小的k个数-优先队列大根堆" class="headerlink" title="1.找出数组中最小的k个数(优先队列大根堆)"></a>1.找出数组中最小的k个数(优先队列大根堆)</h3><p>《剑指offer》p209</p><p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><p>思路：辅助一个k长的优先队列大根堆，遍历数组的同时每次用大根堆替换k长容器的值(适合海量不能修改数组的数据)—&gt;o(nlogk)。<strong>大根堆的实现用优先队列大根堆</strong></p><pre><code class="java">//找出数组中最小的k个数(优先队列大根堆)。思路：用优先队列的大根堆。时间o(nlogk)，空间o(k)public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {    if(input==null || input.length==0 || k&lt;1 || k&gt;input.length){        return new ArrayList&lt;&gt;();    }    //由于java默认小根堆，所以定义一个k长的大根堆    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return o2 - o1;        }    });    for (int i=0; i&lt;input.length; ++i){        if(i&lt;k){            queue.offer(input[i]);        }        else{            if(queue.peek()&gt;input[i]){//把大的数都出堆，留下最小的k个数                queue.poll();                queue.offer(input[i]);            }        }    }    return new ArrayList&lt;&gt;(queue);//treeSet-&gt;ArrayList&lt;Integer&gt;}</code></pre><h3 id="2-找出数组中第k大的数-优先队列小根堆"><a href="#2-找出数组中第k大的数-优先队列小根堆" class="headerlink" title="2.找出数组中第k大的数(优先队列小根堆)"></a>2.找出数组中第k大的数(优先队列小根堆)</h3><p>leetcode 215 Kth Largest Element in an Array</p><p>题目：Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p>Example 1:</p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p>思路：辅助用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)</p><pre><code class="java">//返回数组中第k大的数,k总是有效的。思路：用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)public int findKthLargest(int[] nums, int k) {    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();//默认小根堆    for (int i=0; i&lt;nums.length; ++i){        if(i&lt;k){            queue.offer(nums[i]);        }        else{            if(queue.peek()&lt;nums[i]){//注意这里要比较一下，不满足就不用出堆                queue.poll();                queue.offer(nums[i]);            }        }    }    return queue.poll();}</code></pre><p><a name="56"></a></p><h2 id="56-数据流中的中位数"><a href="#56-数据流中的中位数" class="headerlink" title="56.数据流中的中位数"></a>56.数据流中的中位数</h2><p>《剑指offer》p209、leetcode 295</p><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><p>思路：对于数据流，对应的就是在线算法了，一道很经典的题目就是在1亿个数中找到最大的前100个数，这是一道堆应用题，找最大的前100个数，那么我们就创建一个大小为100的最小化堆，每来一个元素就与堆顶元素比较，因为堆顶元素是目前前100大数中的最小数，前来的元素如果比该元素大，那么就把原来的堆顶替换掉。那么对于这一道题呢？如果单纯的把所有元素放到一个数组里，每次查找中位数最快也要O(n)，综合下来是O(n^2)的复杂度。<br>我们可以利用上面例子中的想法：动态查找考虑堆，中位数左边的数比它小，右边的数比它大。故用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器，因为要找中位数所以也要保证两边容器的数据个数差不超过1。</p><p>java堆的实现用优先队列</p><pre><code class="java">import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class Solution {    //左边的大根堆，存比中位数小的数    private Queue&lt;Integer&gt; bigHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return o2-o1;        }    });    //右边的小根堆，存比中位数大的数    private Queue&lt;Integer&gt; smallHeap = new PriorityQueue&lt;&gt;();    //优先放左边的大根堆，左边的大根堆与右边的小根堆的size只能差1    public void Insert(Integer num) {        if( bigHeap.size()==smallHeap.size() ){//放左边大根堆            if(!smallHeap.isEmpty() &amp;&amp; smallHeap.peek()&lt;num) {//如果num比右边的小根堆的peek大，应该交换下放到右边                bigHeap.offer(smallHeap.poll());                smallHeap.offer(num);            }else{                bigHeap.offer(num);            }        }        else if( bigHeap.size()&gt;smallHeap.size() ){//放右边小根堆            if(bigHeap.peek()&gt;num){//如果num比左边的大根堆的peek小，应该交换下放到左边                smallHeap.offer(bigHeap.poll());                bigHeap.offer(num);            }else{                smallHeap.offer(num);            }        }    }    public Double GetMedian() {        if( bigHeap.size()&gt;smallHeap.size() ){            return (double)bigHeap.peek();        }        else{            return  ((double)bigHeap.peek() + (double)smallHeap.peek()) / 2;        }    }    public static void main(String[] args){        Solution s = new Solution();        int[] nums = new int[]{5,2,3,4,1,6,7,0,8};        for(int i=0; i&lt;nums.length; ++i){            s.Insert(nums[i]);        }        System.out.println(s.GetMedian());    }}</code></pre><p><a name="57"></a></p><h2 id="57-数组中最大连续子序列的和"><a href="#57-数组中最大连续子序列的和" class="headerlink" title="57.数组中最大连续子序列的和"></a>57.数组中最大连续子序列的和</h2><p>《剑指offer》p218、leetcode 53</p><p>题目：给一个数组，返回它的最大连续子序列的和</p><p>思路：</p><p>法一：动态规划。DP[i]表示以i结尾的数组，目前最大连续子序列的和是DP[i]。递推公式：DP[i] = max{DP[i-1] + A[i],A[i]}</p><p>法二：更高效。动态规划需要额外数组存，所以本题改进不用额外的空间，直接<strong>辅助两个变量遍历一遍数组即可</strong>。两个变量：tempMax记录数组中每一段和大于0的连续子数组，整个数组有很多个这样的tempMax；最后的resultMax是这些tempMax最大的</p><pre><code class="java">//有负数的数组中，连续子序列的最大和为多少。思路：辅助两个变量，resMax,tempMax，当tempMax&lt;=0时，tempMax=0public int FindGreatestSumOfSubArray(int[] array) {    int resMax = array[0];    int tempMax = 0;    for(int i=0; i&lt;array.length; ++i){        tempMax += array[i];        resMax = Math.max(resMax, tempMax);        if(tempMax&lt;=0){//当tempMax&lt;=0，那当前这段连续子数组就不要了，tempMax重置为0            tempMax = 0;        }    }    return resMax;}</code></pre><p><a name="58"></a></p><h2 id="58-1到n整数中1出现的次数"><a href="#58-1到n整数中1出现的次数" class="headerlink" title="58.1到n整数中1出现的次数"></a>58.1到n整数中1出现的次数</h2><p>《剑指offer》p221、leetcode 233</p><p>题目：求1 到 n 中1出现的次数。e.g.1~13的整数中1出现的次数：1、10、11、12、13因此共出现5次</p><p>思路：按位进行讨论计算。对数字的每一位单独拿出讨论，按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可。</p><p><strong>计算规则：</strong></p><pre><code>​若weight为0，则1出现次数为round*base若weight为1，则1出现次数为round*base+former+1​若weight大于1，则1出现次数为round*base+base​​```详细请参考[从1到n整数中1出现的次数：O(logn)算法](https://blog.csdn.net/yi_afly/article/details/52012593)​```java//求出1到n出现1的次数。思路：按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可public static int NumberOf1Between1AndN_Solution(int n) {    int res = 0;    int round = n;    int weight;    int former;    int base = 1;    while(round!=0){        weight = round%10;        round /= 10;        former = n%base;        res += round*base;//res += weight*base        if(weight==1){//res += former + 1            res += former + 1;        }        else if(weight&gt;1){//res += base            res += base;        }        base *= 10;    }    return res;}</code></pre><p><a name="59"></a></p><h2 id="59-正整数序列中的第n个数字"><a href="#59-正整数序列中的第n个数字" class="headerlink" title="59.正整数序列中的第n个数字"></a>59.正整数序列中的第n个数字</h2><p>《剑指offer》p221、leetcode 400</p><p>题目：在整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n个数字，n是正数且在32为整形范围内(n &lt; 231)。e.g.第5位是5，第13位是1</p><p>思路：一位数0-9数字在序列中占10位，两位数10-99数字在序列中占2<em>90=180位，三位数100-999有3</em>900=2700位。当n=1001时，n-10-180=811&gt;0 &amp;&amp; n-10-180-2700&lt;0，且811=3*270+1，说明第n位在三位数的100之后第270个数字即370的中间一位，即7。</p><pre><code class="java">//正整数序列中的第n个数字。思路：public static int findNthDigit(int n) {    if(n&lt;10){        return n;    }    int digitLen = 2; //当前区间的位数，如：10~99的2    int start = 10; //当前区间的起始数，如：10~99的10    int base = 90; //当前区间的所有位数，如10~99的90    n -= 9;    while(n!=0){        int objectNum = (int)Math.ceil((double)n/digitLen) + start -1;//定位到了目标数字        if(objectNum&lt;(start*10)){//目标数字就在当前区间,这样判断是为了防止int溢出            int loc = n%digitLen; //定位到目标数字的第几位，从左往右            if(loc==0){                loc = digitLen-1;            }            else{                loc = loc-1;            }            String num = String.valueOf(objectNum);            return num.charAt(loc)-&#39;0&#39;;        }        else{//目标数字在下一个区间            n -= (base*digitLen);            digitLen++;            start *= 10;            base *= 10;        }    }    return -1;}</code></pre><p><a name="60"></a></p><h2 id="60-把数组排成最小的数"><a href="#60-把数组排成最小的数" class="headerlink" title="60.把数组排成最小的数"></a>60.把数组排成最小的数</h2><p>《剑指offer》p227、leetcode 179</p><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>注意：</p><p>我们要判断一个数字的最高位上的数字，故最方便的方法是：数字转成字符串。</p><p>且数字拼接过程很可能大数溢出int类型，更要用字符串拼接比较</p><p>思路：</p><p><strong>1.先把数组中的整数转换成字符串，2.然后用compareTo中定义比较规则，3.并根据该规则调用库函数sort()排序，4.最后把排序后数字字符串依次打印出来即为所求最小的数字。时间复杂度就是排序的时间复杂度o(nlogn)</strong></p><pre><code class="java">//把数组排成最小的数public static String PrintMinNumber(int [] numbers) {    //1.int[] --&gt; String[]    String[] strings = new String[numbers.length];    for(int i=0; i&lt;numbers.length; ++i){        strings[i] = numbers[i]+&quot;&quot;;    }    //2.定义字符串排序的比较规则    Comparator&lt;String&gt; com = new Comparator&lt;String&gt;() {        @Override        public int compare(String o1, String o2) {            String s1 = o1 + o2;            String s2 = o2 + o1;            return s1.compareTo(s2);        }    };    //3.对String[]排序    Arrays.sort(strings, com);    //4.拼接字符串    StringBuilder sb = new StringBuilder();    for(int i=0; i&lt;strings.length; ++i){        sb.append(strings[i]);    }    if(sb.charAt(0)==&#39;0&#39;){//&quot;0000&quot;--&gt;&quot;0&quot;        return &quot;0&quot;;    }    return sb.toString();}</code></pre><p><a name="61"></a></p><h2 id="61-求把一个数字翻译成不同字符串的个数-DP"><a href="#61-求把一个数字翻译成不同字符串的个数-DP" class="headerlink" title="61.求把一个数字翻译成不同字符串的个数(DP)"></a>61.求把一个数字翻译成不同字符串的个数(DP)</h2><p>《剑指offer》p231、leetcode 91</p><p>题目: 求把数字翻译成字符串的个数。0-&gt;a,1-&gt;b…11-&gt;l,25-&gt;z。求一个数字有多少种不同的翻译方法。e.g.258-&gt;2,58、25,8</p><p>题目分析：这道题要求解码方法，跟之前那道 Climbing Stairs 爬梯子问题 非常的相似，但是还有一些其他的限制条件，比如说一位数时不能为0，两位数不能大于26，其十位上的数也不能为0，除去这些限制条件，跟爬梯子基本没啥区别，也勉强算特殊的斐波那契数列，当然需要用动态规划DP来解。</p><p>思路：DP问题。f(i)为第i位开始到最右边结束的数字的翻译个数。–&gt;动态规划题，解题分析步骤如下。</p><p><strong>1.从左往右DP分析</strong>：定义f(i)为从i至字符串s最右边结束的不同字符串的个数，因此所求为f(0)。<strong>f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)</strong></p><p><strong>2.详细的DP方程：</strong> f(i) = </p><pre><code>0,   s[i]==‘0’f(i+2),   s[i+1]==‘0’ &amp;&amp; (s[i]==‘1’ || s[i]==‘2’)0,   s[i+1]==‘0’ &amp;&amp; (else)f(i+1)+f(i+2),   s[i+1]!=&#39;0&#39; &amp;&amp; s[i]==‘1’ || （s[i]==‘2’ &amp;&amp; s[i+1]-‘0’&lt;=6)f(i+1),     s[i+1]!=&#39;0&#39; &amp;&amp; (else)</code></pre><p>且递归结束条件为:</p><pre><code>i==s.length  return 1;s[i]==&#39;0&#39;  return 0;</code></pre><p><strong>3.从右往左循环实现</strong> 递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题</p><p>代码一：按dp方程直接翻译的递归代码</p><pre><code class="java">//求把一个数字翻译成不同字符串的个数public static int numDecodings(String s) {    if(s==null || s.length()==0){        return 0;    }    return numDecodingsDetail(s.toCharArray(), 0);}//从右往左，每次递归表示从String s中的index至最右边字符串结束，可翻译成不同字符串的个数//f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)public static int numDecodingsDetail(char[] chs, int index){    if(index&lt;chs.length &amp;&amp; chs[index]==&#39;0&#39;){        return 0;    }    if(index&lt;chs.length-1){        if(chs[index+1]==&#39;0&#39;){//后一个为0，必须与后一个连成字母，不满足为0            if(chs[index]==&#39;1&#39; || chs[index]==&#39;2&#39;){//与后一个连成字母                return numDecodingsDetail(chs,index+2);            }            else{//匹配错误，返回0                return 0;            }        }        else{//后一个不为0，可以不与后一个连成字母，同时如果连成字母需要判断            if(chs[index]==&#39;1&#39; || (chs[index]==&#39;2&#39; &amp;&amp; chs[index+1]&lt;=&#39;6&#39;)){//自成一派+与后一个连成字母                return numDecodingsDetail(chs, index+1) + numDecodingsDetail(chs,index+2);            }            else {//不能与后一个连成字母，只能自成一派                return numDecodingsDetail(chs, index+1);            }        }    }    return 1;//index==chs.length 递归结束}代码二：递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题（这个代码是按照剑指offer的题目来的，A-0,Z-25）//求把一个数字翻译成不同字符串的个数public static int numDecodings(String s) {    if(s==null || s.length()==0){        return 0;    }    //1.把数字每一位拆分，存到数组中    char[] chs = s.toCharArray();    //2.从右往左，res[]存放动态规划循环计算的每一个f(i)结果，最后要返回的是res[0]    int[] res = new int[chs.length];    //每次计算f(i)时的临时计数器    int tempCount = 0;    for(int i=chs.length-1; i&gt;=0; --i){//从右往左循环计算        if(i==chs.length-1) {            tempCount = 1; //如果是最右边的数字时，初始化翻译个数=1        }        else{//f(i) = f(i+1)            tempCount = res[i+1];        }        //f(i) = f(i+1) + g(i,i+1)*f(i+2)        if(i&lt;chs.length-1){//判断后一个字母的情况            int temp = Integer.parseInt(&quot;&quot;+chs[i]+chs[i+1]);            if(temp&gt;=10 &amp;&amp; temp&lt;=25){//可以连成字母                if((i+2)&lt;chs.length){                    tempCount += res[i+2];//f(i+1)+f(i+2)                }                else{                    tempCount += 1;                }            }        }        res[i] = tempCount;    }    return res[0];}</code></pre><p><a name="62"></a></p><h2 id="62-礼物的最大价值"><a href="#62-礼物的最大价值" class="headerlink" title="62.礼物的最大价值"></a>62.礼物的最大价值</h2><p>《剑指offer》p233、leetcode 64</p><p>题目：礼物的最大价值。</p><p>在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。</p><p>从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。</p><p>例如，对于如下棋盘：</p><pre><code>1*  10  3  812*  2  9  65*  *7  4  113  7*  16*  5*</code></pre><p>res = 1+12+5+7+7+16+5 = 53</p><p>思路：</p><p>典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)</p><p>递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</p><p>循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</p><pre><code class="java">/** 题目：礼物的最大价值。 * 在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。 * 从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。 * 例如，对于如下棋盘： *      1*    10   3    8        12*   2    9    6        5*    *7    4    11        3    7*    16*   5*    res = 1+12+5+7+7+16+5 = 53 思路：    典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)    递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]    循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1] */public class Solution{    public static void main(String[] args){        int[][] gift = {{1,10,3,8},{12,2,9,6},{5,7,4,11},{3,7,16,5}};        System.out.println(maxValue(gift, 4, 4)); //out:53    }    public static int maxValue(int[][] gift, int m, int n){        /**         * @Description: m*n大小的棋盘gift[][]         * 递归分析f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]         * 循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]         */        if(gift==null || m&lt;=0 || n&lt;=0){            return 0;        }        int[][] maxValue = new int[m][n];        for(int i=0; i&lt;m; ++i){ //从左上往右下进行循环计算            for(int j=0; j&lt;n; ++j){                int temp = 0;                if((i-1)&gt;=0){                    temp = Math.max(temp, maxValue[i-1][j]);                }                if((j-1)&gt;=0){                    temp = Math.max(temp, maxValue[i][j-1]);                }                maxValue[i][j] = temp + gift[i][j];            }        }        return maxValue[m-1][n-1];    }}</code></pre><p>优化改进空间复杂度，使用一维数组<br>•题目中可知，坐标(i,j)的最大礼物价值仅仅取决于坐标为(i-1,j)和(i,j-1)两个格子；<br>•因此第i-2行以上的最大价值没有必要保存下来。<br>•使用一维数组保存，数组的长度为gift的列数：(0…j-1)保存的是(i,0)…(i,j-1)的最大价值；(j…cols-1)保存的是(i-1,j)…(i-1,cols-1)的最大价值。即：数组前j个数字分别是当前第i行前j个格子的maxvule,而之后的数字分别保存前面第i-1行n-j个格子的maxVlue。</p><pre><code class="java">//leetcode 64 Minimum Path Sum的代码，一样的public int minPathSum(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int m = grid.length;    int n = grid[0].length;    int[] min = new int[n];//辅助一维数组，数组的长度为grid的列数    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i == 0){//第一行                if(j==0){//第一列                    min[j] = grid[i][j];                }                else {                    min[j] = grid[i][j] + min[j-1];                }            }            else{//后面几行                if(j==0){//第一列                    min[j] = min[j] + grid[i][j];                }                else{                    min[j] = Math.min(min[j-1], min[j]) + grid[i][j];                }            }        }    }    return min[n-1];}</code></pre><p><a name="63"></a></p><h2 id="63-最长不含重复字符的子字符串长度"><a href="#63-最长不含重复字符的子字符串长度" class="headerlink" title="63.最长不含重复字符的子字符串长度"></a>63.最长不含重复字符的子字符串长度</h2><p>《剑指offer》p236、leetcode 3</p><p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p><p>思路：</p><p>不重复子串可能有多个，而最长不重复子串长度只有一个唯一的值。</p><p><strong>遍历一遍字符串，同时借助辅助hashMap</strong>记录字符是否出现及上一次出现的位置。时间o(n)，空间o(n)</p><p>三个变量：</p><p>int resMax = 0; //记录最长的不重复字符子串的长度</p><p>int tempMax = 0; //记录当前不重复字符子串的长度</p><p>int startIndex = 0; //记录当前不重复字符子串的开始位置，初始化为0</p><pre><code class="java">//Longest Substring Without Repeating Characters最长不含重复字符的子字符串长度//思路：遍历一遍字符串，辅助hashMap存字符是否出现过或上一次出现的位置。时间o(n), 空间o(n)public int lengthOfLongestSubstring(String s) {    if(s==null || s.length()==0){        return 0;    }    if(s.length()==1){        return 1;    }    int resMax = 0;//最终返回的最大长度    int tempMax = 0;//当前的最大长度    int startIndex = 0;//当前最大长度的起始位置    //1.辅助hashMap存字符是否出现过或上一次出现的位置    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();    //2.遍历一遍字符串    for(int i=0; i&lt;s.length(); ++i){        char temp = s.charAt(i);        //如果字符没出现过或字符上一次出现的位置在startIndex的前面，那么当前字符有效，计算更新相应长度即可        if(!hashMap.containsKey(temp) || hashMap.get(temp)&lt;startIndex){            tempMax = i-startIndex+1;            resMax = Math.max(tempMax, resMax);        }else{//当前字符重复了            startIndex = hashMap.get(temp)+1; //下次的startIndex为重复字符上一次出现位置的下一个位置        }        hashMap.put(temp, i);//不管重复与否，都要更新字符出现的位置    }    return resMax;}</code></pre><p><a name="64"></a></p><h2 id="64-丑数-两道"><a href="#64-丑数-两道" class="headerlink" title="64.丑数(两道)"></a>64.丑数(两道)</h2><pre><code>判断一个数是否为丑数--leetcode 263求第N个丑数是几--《剑指offer》p240</code></pre><h3 id="1-判断一个数是否为丑数"><a href="#1-判断一个数是否为丑数" class="headerlink" title="1.判断一个数是否为丑数"></a>1.判断一个数是否为丑数</h3><p>leetcode 263</p><p>题目：给定一个数，判断是否为丑数(丑数定义:只含因子2、3、5的正数，1也算丑数)</p><pre><code>Input: 6Output: trueExplanation: 6 = 2 × 3</code></pre><p>思路：就正常判断因子即可。</p><pre><code class="java">//判断一个数是否为丑数public boolean isUgly(int num) {    if(num&lt;1) {        return false;    }    if(num==1){        return true;    }    while(num%2==0){        num /= 2;    }    while(num%3==0){        num /= 3;    }    while(num%5==0){        num /= 5;    }    if(num==1){        return true;    }    return false;}</code></pre><h3 id="2-求第N个丑数是几"><a href="#2-求第N个丑数是几" class="headerlink" title="2.求第N个丑数是几"></a>2.求第N个丑数是几</h3><p>《剑指offer》p240</p><p>题目：把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p>思路：</p><p>空间换时间。丑数一定是丑数<em>2/</em>3/*5得来的，直接用数组存下1到index的丑数</p><p>关键是怎么保证每一个丑数的大小顺序的–&gt;三个变量：index2、index3、index5</p><p>每次该放下一个丑数时，三个变量分别记录了当前可以<em>2/</em>3/*5的最小的丑数位置</p><p>每次分别对这三个位置上的丑数<em>2</em>3*5后找出最小的一个，即为当前的丑数，之后更新三个变量即可</p><pre><code class="java">//丑数public static int GetUglyNumber_Solution(int index) {    if(index&lt;=0){        return 0;    }    if(index==1){        return 1;    }    int[] res = new int[index+1];//存1到index的丑数，返回res[index]    res[1] = 1;    int index2 = 1;    int index3 = 1;    int index5 = 1;    for(int i=2; i&lt;=index; ++i){        res[i] = min(res[index2]*2, res[index3]*3, res[index5]*5);//该放res[i]丑数了，找三个中最小的        while(res[index2]*2&lt;=res[i]){//更新三个变量            index2++;        }        while(res[index3]*3&lt;=res[i]){            index3++;        }        while(res[index5]*5&lt;=res[i]){            index5++;        }    }    return res[index];}public static int min(int a, int b, int c){    int temp = a&lt;b ? a : b;    return temp&lt;c ? temp : c;}</code></pre><p><a name="65"></a></p><h2 id="65-第一个只出现一次的字符"><a href="#65-第一个只出现一次的字符" class="headerlink" title="65.第一个只出现一次的字符"></a>65.第一个只出现一次的字符</h2><pre><code>第一个只出现一次的字符(数组)--《剑指offer》p243、leetcode 387第一个只出现一次的字符(字符流)--《剑指offer》p247</code></pre><p>题目：给定数组或是输入一个字符流，返回第一个只出现一次的的字符位置。在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p><pre><code>e.g.输入&quot;abaccdeff&quot; --&gt; 则输出&#39;b&#39;</code></pre><p>思路：不管是数组还是字符流，都用这个思路。<strong>遍历一遍str，辅助hashMap，value记录字符出现第一次的位置，若字符重复出现，则value记录-1。最后再遍历一遍hashMap，找除了-1之外的最小value即可所求</strong>。时间o(n)，空间o(256)</p><p>数据是数组的代码：</p><pre><code class="java">//给定数组的代码，字符流的情况一样的。思路：遍历一遍str，辅助hashMap记录字符出现的位置，再遍历一遍hashMap即可。时间o(n)，空间o(256)public int firstUniqChar(String str) {    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();//key:字符，value:字符出现一次value为上次出现的位置，字符出现多次value存-1    //1.遍历字符串,辅助hashMap记录字符出现的位置    for(int i=0; i&lt;str.length(); ++i){        char temp = str.charAt(i);        if(!hashMap.containsKey(temp)){//字符只出现一次，存出现的位置            hashMap.put(temp,i);        }        else{//字符出现多次，存-1            hashMap.put(temp, -1);        }    }    //2.遍历hashMap来找第一次只出现一次的字符    int res = Integer.MAX_VALUE;    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){        if(entry.getValue()!=-1){            res = Math.min(res, entry.getValue());//找最小的只出现一次的字符位置        }    }    return res==Integer.MAX_VALUE ? -1 : res;}数据是字符流的代码：public class Solution{    private int[] chIndex;    private static int cnt = 0; //计数当前输入到第几个数了，初始为0    public Solution(){        chIndex = new int[256];//初始化哈希数组，每个字符都未出现，    }    //Insert one char from stringstream    public void Insert(char ch){        cnt++;        if(chIndex[ch]==0) {//之前未出现过，则更新值为当前位置，说明出现了第一次            chIndex[ch] = cnt;        }        else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2            chIndex[ch] = -1;        }    }    //return the first appearence once char in current stringstream    public char FirstAppearingOnce(){        int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置        char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符        for(int i=0; i&lt;256; ++i){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)            if(chIndex[i]&gt;0 &amp;&amp; chIndex[i]&lt;minIndex){                minIndex = chIndex[i];                resChar = (char)i;            }        }        return resChar;    }}</code></pre><p>当然，本题中hashMap可以用256的数组，也可以用hashMap</p><pre><code class="java">private HashMap&lt;Character, Integer&gt; hashMap;private static int cnt = 0; //计数当前输入到第几个数了，初始为0public Solution(){    hashMap = new HashMap&lt;&gt;();}//Insert one char from stringstreampublic void Insert(char ch){    cnt++;    if(!hashMap.containsKey(ch)) {//之前未出现过，则更新值为当前位置，说明出现了第一次        hashMap.put(ch, cnt);    }    else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2        hashMap.put(ch, -1);    }}//return the first appearence once char in current stringstreampublic char FirstAppearingOnce(){    int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置    char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)        if(entry.getValue()!=-1 &amp;&amp; entry.getValue()&lt;minIndex){            minIndex = entry.getValue();            resChar = entry.getKey();        }    }    return resChar;}</code></pre><p><a name="66"></a></p><h2 id="66-归并排序相关-3道"><a href="#66-归并排序相关-3道" class="headerlink" title="66.归并排序相关(3道)"></a>66.归并排序相关(3道)</h2><pre><code>数组的归并排序数组中的逆序对个数(2道)--《剑指offer》p249、leetcode 493单链表的归并排序--leetcode 148</code></pre><h3 id="1-数组的归并排序"><a href="#1-数组的归并排序" class="headerlink" title="1.数组的归并排序"></a>1.数组的归并排序</h3><p>经典的归并排序算法，时间o(nlog)，空间o(n)</p><p>来源<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p><pre><code class="java">import java.util.Arrays;public class Solution {    //归并排序。思路：分而治之，先分后治,辅助数组temp[]    public static void mergeSort(int[] nums){        if(nums==null || nums.length&lt;2){            return;        }        int[] temp = new int[nums.length]; //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        mergeSortDetail(nums, 0, nums.length-1, temp);    }    //分    private static void mergeSortDetail(int[] nums, int left, int right, int[] temp){        if(left&lt;right){//一个数字不用merge，只有两个以上才merge            int mid = (left+right)/2;            mergeSortDetail(nums, left, mid, temp);//左边归并排序，使得左子序列有序            mergeSortDetail(nums, mid+1, right, temp);//右边归并排序，使得右子序列有序            merge(nums, left, mid, right, temp);//将两个有序子数组合并操作        }    }    //治    private static void merge(int[] nums, int left, int mid, int right, int[] temp){        int tempIndex = 0;//temp数组的当前位置        int i = left; //左序列的索引        int j = mid+1; //右序列的索引        while(i&lt;=mid &amp;&amp; j&lt;=right){//将左、右序列的元素有序的放进temp数组中            temp[tempIndex++] = nums[i]&lt;=nums[j] ? nums[i++] : nums[j++];        }        while(i&lt;=mid){//将左边剩余元素填充进temp中            temp[tempIndex++] = nums[i++];        }        while(j&lt;=right){//将右边剩余元素填充进temp中            temp[tempIndex++] = nums[j++];        }        //将temp中的元素全部拷贝到nums原数组中        tempIndex = 0;        while(left&lt;=right){            nums[left++] = temp[tempIndex++];        }    }    public static void main(String []args){        int[] nums = {9,8,7,6,5,4,3,2,1};        mergeSort(nums);        System.out.println(Arrays.toString(nums));    }}</code></pre><h3 id="2-数组中的逆序对-2道"><a href="#2-数组中的逆序对-2道" class="headerlink" title="2.数组中的逆序对(2道)"></a>2.数组中的逆序对(2道)</h3><pre><code>《剑指offer》p249Reverse Pairs--leetcode 493 </code></pre><h4 id="2-1-求出数组中逆序对的个数"><a href="#2-1-求出数组中逆序对的个数" class="headerlink" title="2.1 求出数组中逆序对的个数"></a>2.1 求出数组中逆序对的个数</h4><p>《剑指offer》p249</p><p>思路：用归并排序思想，在归并排序的过程中计数逆序对。时间o(nlogn)，空间o(n)，稳定。先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数（也就是逆序数），这三个过程加起来就是整体的逆序数目了。</p><p>注意:归并排序merge过程中的<strong>从右往左排序的巧妙思想</strong>！</p><pre><code class="java">//数组中逆序对的总数。思路：归并排序思想// 先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数public static int InversePairs(int [] array) {    if(array==null || array.length&lt;2){        return 0;    }    int[] temp = new int[array.length];    return InversePairsDetail(array, 0, array.length-1, temp)%1000000007;}public static int InversePairsDetail(int[] array, int left, int right, int[] temp){    int res = 0;    if(left&lt;right){        int mid = (left+right)/2;        res += InversePairsDetail(array, left, mid, temp);//左边的逆序数        res += InversePairsDetail(array, mid+1, right, temp);//右边的逆序数        res += merge(array, left, mid, right, temp);//左边与右边的逆序数    }    return res%1000000007;}public static int merge(int[] array, int left, int mid, int right, int[] temp){    int res = 0;    int i = mid;//左序列指针，从右往左    int j = right;//右序列指针，从右往左    int tempIndex = right;//临时数组指针，从右往左    while(i&gt;=left &amp;&amp; j&gt;mid){        if(array[i]&gt;array[j]){//是一个逆序对，且前面的比后面的大，又找到很多个逆序对            temp[tempIndex--] = array[i--];            res += (j-mid);//又找到很多个逆序对            res %= 1000000007;        }        else{            temp[tempIndex--] = array[j--];        }    }    while(i&gt;=left){//前面的数组还有        temp[tempIndex--] = array[i--];    }    while(j&gt;mid){//后面的数组还有        temp[tempIndex--] = array[j--];    }    tempIndex = right; //最后还是要完成排序    while(left&lt;=right){        array[right--] = temp[tempIndex--];    }    return res%1000000007;}</code></pre><h4 id="2-2-Reverse-Pairs"><a href="#2-2-Reverse-Pairs" class="headerlink" title="2.2 Reverse Pairs"></a>2.2 Reverse Pairs</h4><p>leetcode 493 </p><p>题目：和上面的逆序数有点不一样，Given an array nums, we call (i, j) an important reverse pair if i &lt; j and <strong>nums[i] &gt; 2*nums[j].</strong></p><pre><code>Input: [1,3,2,3,1]Output: 2</code></pre><p>思路：还是逆序对的归并排序思想，只不过找逆序对的算法不同，因此简要修改判断即可</p><pre><code class="java">//数组中逆序对的总数。思路：归并排序思想//先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数public int reversePairs(int[] nums) {    if(nums==null || nums.length&lt;2){        return 0;    }    int[] temp = new int[nums.length];    return InversePairsDetail(nums, 0, nums.length-1, temp);}public int InversePairsDetail(int[] array, int left, int right, int[] temp){    int res = 0;    if(left&lt;right){        int mid = (left+right)/2;        res += InversePairsDetail(array, left, mid, temp);//左边排序，且计算左边的逆序对个数        res += InversePairsDetail(array, mid+1, right, temp);//右边排序，且计算右边的逆序对个数        //merge左右两边排序前，计算左右两边的逆序对个数        for (int i = left, j = mid+1; i &lt;= mid &amp;&amp; j &lt;= right;){            if (array[i] &gt; (long) array[j] * 2){//long必须有                res += mid - i + 1;                j++;            }            else i++;        }        merge(array, left, mid, right, temp);//左右两边归并排序    }    return res;}//正常的左右两边归并排序public void merge(int[] array, int left, int mid, int right, int[] temp){    int i = mid;//左序列指针，从右往左    int j = right;//右序列指针，从右往左    int tempIndex = right;//临时数组指针，从右往左    while(i&gt;=left &amp;&amp; j&gt;mid){        if(array[i]&gt;array[j]){            temp[tempIndex--] = array[i--];        }        else{            temp[tempIndex--] = array[j--];        }    }    while(i&gt;=left){//前面的数组还有        temp[tempIndex--] = array[i--];    }    while(j&gt;mid){//后面的数组还有        temp[tempIndex--] = array[j--];    }    tempIndex = right; //最后还是要完成排序    while(left&lt;=right){        array[right--] = temp[tempIndex--];    }}</code></pre><h3 id="3-单链表的归并排序"><a href="#3-单链表的归并排序" class="headerlink" title="3.单链表的归并排序"></a>3.单链表的归并排序</h3><p>leetcode 148 </p><p>见 <a href="#93.0">93.0单链表的归并排序</a></p><p><a name="67"></a></p><h2 id="67-二叉搜索树的第k小节点-中序遍历"><a href="#67-二叉搜索树的第k小节点-中序遍历" class="headerlink" title="67.二叉搜索树的第k小节点(中序遍历)"></a>67.二叉搜索树的第k小节点(中序遍历)</h2><p>《剑指offer》p269、leetcode 230</p><p>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p><p>思路：中序遍历即可。时间o(n)，空间o(1)</p><pre><code class="java">//二叉搜索树中第k小节点。将k存到数组中便于修改传参，对二叉树中序遍历判断即可 TreeNode KthNode(TreeNode pRoot, int k){    if(pRoot==null || k&lt;1){        return null;    }    int[] ks = new int[1];    ks[0] = k;    return KthNodeDetail(pRoot, ks);}TreeNode KthNodeDetail(TreeNode pRoot, int[] ks){    TreeNode res = null;    if(pRoot.left!=null){        res = KthNodeDetail(pRoot.left, ks);    }    if(res!=null){        return res;    }    ks[0]--;    if(ks[0]==0){        return pRoot;    }    if(pRoot.right!=null){        res = KthNodeDetail(pRoot.right, ks);    }    return res;}</code></pre><p><a name="68"></a></p><h2 id="68-二叉树的深度-两道"><a href="#68-二叉树的深度-两道" class="headerlink" title="68.二叉树的深度(两道)"></a>68.二叉树的深度(两道)</h2><pre><code>    求二叉树的深度--leetcode104    判断是否为平衡二叉树--leetcode110</code></pre><h3 id="1-求二叉树的深度"><a href="#1-求二叉树的深度" class="headerlink" title="1.求二叉树的深度"></a>1.求二叉树的深度</h3><p>leetcode104、《剑指offer》p271</p><p>思路：递归</p><pre><code class="java">public int treeDepth(TreeNode head){    if(head==null){        return 0;    }    return Math.max( treeDepth(head.left)+1, treeDepth(head.right)+1 );}</code></pre><h3 id="2-判断是否为平衡二叉树"><a href="#2-判断是否为平衡二叉树" class="headerlink" title="2.判断是否为平衡二叉树"></a>2.判断是否为平衡二叉树</h3><p>leetcode110、《剑指offer》p271</p><p>题目：给一个二叉树，判断是否为平衡二叉树</p><p>思路1：遍历树，对每一个节点进行判断是否满足平衡树的条件—&gt;递归重复判断计算，不可取</p><pre><code class="java">//判断是否为平衡二叉树public boolean IsBalanced_Solution(TreeNode root) {    if(root==null){        return true;    }    int left = getDepth(root.left);    int right = getDepth(root.right);    if(Math.abs(left-right)&lt;2){        return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);    }    return false;}//求二叉树的深度public int getDepth(TreeNode root){    if(root==null){        return 0;    }    return 1 + Math.max(getDepth(root.left), getDepth(root.right));}</code></pre><p>思路2：后序遍历(左右根)，从下往上依次判断每个节点是否满足平衡二叉树的条件。这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算—&gt;可取</p><pre><code class="java">//判断是否为平衡二叉树。好的方法:后序遍历(左右根),从下往上依次判断每个节点是否满足平衡二叉树的条件。// 这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算public boolean IsBalanced_Solution(TreeNode root) {    if(root==null){        return true;    }    if(IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)){        int left = getDepth(root.left);        int right = getDepth(root.right);        if(Math.abs(left-right)&lt;2){            return true;        }    }    return false;}//求二叉树的深度public int getDepth(TreeNode root){    if(root==null){        return 0;    }    return 1 + Math.max(getDepth(root.left), getDepth(root.right));}</code></pre><p><a name="69"></a></p><h2 id="69-数组中和为s的数字-四道"><a href="#69-数组中和为s的数字-四道" class="headerlink" title="69.数组中和为s的数字(四道)"></a>69.数组中和为s的数字(四道)</h2><pre><code>数组中和为s的两个数字(有序数组)--《剑指offer》p280数组中和为s的两个数字(无序数组)--leetcode 1打印出和为s的所有连续正数序列--《剑指offer》p280求和为s的所有连续正数序列的总数(转化为找因子的思想)--leetcode 829</code></pre><h3 id="1-数组中和为s的两个数字-有序数组"><a href="#1-数组中和为s的两个数字-有序数组" class="headerlink" title="1.数组中和为s的两个数字(有序数组)"></a>1.数组中和为s的两个数字(有序数组)</h3><p>《剑指offer》p280</p><p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>思路：从数组两端向中间扫，时间o(n)，空间o(1)，当然因为有序可以加一点二分的思想减少比较次数。</p><pre><code class="java">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    int resMax = Integer.MAX_VALUE;    int left = 0;    int right = array.length-1;    //left、right往中间扫    while(left&lt;right){        int mid = left + (right-left)/2;        if(array[mid]&gt;=sum){//二分判断，需要往左边找            right = mid - 1;            continue;        }        int temp = array[left] + array[right];        if(temp==sum){            if(array[left]*array[right]&lt;resMax){//看是否乘积最小                resMax = array[left]*array[right];                if(!res.isEmpty()){                    res.clear();                }                res.add(array[left]);                res.add(array[right]);            }        }        if(temp &lt; sum){//左边的数++            left++;        }        else{//右边的数--            right--;        }    }    return res;}</code></pre><h3 id="2-数组中和为s的两个数字-无序数组"><a href="#2-数组中和为s的两个数字-无序数组" class="headerlink" title="2.数组中和为s的两个数字(无序数组)"></a>2.数组中和为s的两个数字(无序数组)</h3><p>leetcode 1</p><p>题目：Given an array of integers(无序), return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>思路：因为数组无序，因此需要辅助map，时间o(n)，空间o(n)</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        int temp = target - nums[i];        if(map.containsKey(temp)){           return new int[]{map.get(temp), i};        }        map.put(nums[i], i);    }    return new int[]{0,0};}</code></pre><h3 id="3-打印出和为s的所有连续正数序列"><a href="#3-打印出和为s的所有连续正数序列" class="headerlink" title="3.打印出和为s的所有连续正数序列"></a>3.打印出和为s的所有连续正数序列</h3><p>《剑指offer》p280、leetcode 829</p><p>输入一个整数s，打印出所有和为s的连续正数序列(至少含有两个数)</p><p>如：输入15，1+2+3+4+5=4+5+6=7+8=15，因此输出{1,2,3,4,5},{4,5,6},{7,8}三个序列</p><p>思路：</p><p>思路：</p><pre><code>    从递增数组中两个和为s的数得到启示，设置两个变量，一个记录当前序列的最小的数small，一个记录当前序列的最大的数big。    初始化small=0,big=1    若是当前的正数序列之和小于S，big++    若是当前的正数序列之和大于S，small++    因为和为s的序列至少包括两个数，所以small要小于等于s的一半</code></pre><p>代码：</p><pre><code class="java">//和为s的连续整数序列public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(sum&lt;3){        return res;    }    int small = 1;    int big = 2;    int tempRes = small+big;//当前序列的和    ArrayList&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();//缓存当前序列    tempList.add(small);    tempList.add(big);    while(small &lt;= sum/2){//至少两个数的和为sum，所以small不能超过sum的一半        if(tempRes&lt;=sum){            if(tempRes==sum){                res.add(new ArrayList&lt;&gt;(tempList));            }            big++;            tempRes += big;            tempList.add(big);        }        else if(tempRes&gt;sum){            tempRes-=small;            tempList.remove((Object)small);            small++;        }    }    return res;}</code></pre><h3 id="4-求和为s的所有连续正数序列的总数-转化为找因子的思想"><a href="#4-求和为s的所有连续正数序列的总数-转化为找因子的思想" class="headerlink" title="4.求和为s的所有连续正数序列的总数(转化为找因子的思想)"></a>4.求和为s的所有连续正数序列的总数(转化为找因子的思想)</h3><p>leetcode 829</p><p>题目：Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? 和为s的连续整数序列一共有多少种。和为s的连续整数序列一共有多少种，题目中N特别大，o(n)会超时，因此必须o(logn)。</p><pre><code>    Input: 5    Output: 2    Explanation: 5 = 5 = 2 + 3</code></pre><p>思路：变型求和公式转化问题，时间o(logn)，空间o(1)。</p><p>详细思路： 连续数列的求和公式–&gt;（n1+n2)*(n2-n1+1)=2*N，(n1&lt;n2)，其中(n1+n2)和(n2-n1+1)一定要是2*N的因子，因此<strong>转化成求2*N的因子的问题</strong>，将时间复杂度控制在了O(logn)</p><pre><code class="java">public int consecutiveNumbersSum(int N) {    int res = 1;//一共有res种方法，本身也算一种，因此初始为1    int target = 2*N;    int index = (int)Math.sqrt(target);    for(int i=2; i&lt;=index; ++i){//从2遍历到index找target的因子，直接优化到了o(logn)        if(target%i==0){//i是target的一个因子            //两元一次方程解出n1、n2，注意n1&lt;n2            int n2 = (i+target/i-1)/2;            int n1 = target/i-n2;            if(n1&lt;n2 &amp;&amp; (n1 + n2)*(n2 - n1 + 1)==target){//找到一个从n1~n2的连续序列和为s                res++;            }        }    }    return res;}</code></pre><p><a name="70"></a></p><h2 id="70-翻转字符串-两道"><a href="#70-翻转字符串-两道" class="headerlink" title="70.翻转字符串(两道)"></a>70.翻转字符串(两道)</h2><pre><code>    给定一句话，翻转这句话的单词顺序(单词不变)--《剑指offer》p284、leetcode 151    左旋转字符串(abcXYZdef循环左移3位--&gt;XYZdefabc)--《剑指offer》p284</code></pre><h3 id="1-翻转一句话的单词顺序-单词不变"><a href="#1-翻转一句话的单词顺序-单词不变" class="headerlink" title="1.翻转一句话的单词顺序(单词不变)"></a>1.翻转一句话的单词顺序(单词不变)</h3><p>《剑指offer》p284、leetcode 151</p><p>题目：给定一句话，翻转这句话的单词顺序(单词不变)</p><p>思路：先split(“ “)成数组，再反着拼装即可。时间o(n)，空间o(n)</p><pre><code class="java">public String reverseWords(String s) {    String[] strs = s.split(&quot; &quot;);    StringBuilder res = new StringBuilder();    for(int i=strs.length-1; i&gt;=0; --i){        if(strs[i].equals(&quot;&quot;)){            continue;        }        res.append(strs[i] + &quot; &quot;);    }    return res.toString().trim();}</code></pre><h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2.左旋转字符串"></a>2.左旋转字符串</h3><p>《剑指offer》p284</p><p>题目：左旋转字符串(abcXYZdef循环左移3位–&gt;XYZdefabc)</p><p>思路1(不可取): 用substring()函数拼接即可，当然substring()会依赖辅助空间。</p><pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabcpublic static String LeftRotateString(String str,int n) {    if(n&lt;1 || str==null || str.length()&lt;2){        return str;    }    return str.substring(n) + str.substring(0,n);}</code></pre><p>思路2(可取): 当不能用substring()去依赖辅助空间时，直接在原字符串上修改。分成需要移位的左边和剩下右边的两部分，<strong>先将这两部分分别翻转，然后再整个翻转即可</strong>。时间o(n)，空间o(1)</p><pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabcpublic static String LeftRotateString(String str,int n) {    if(n&lt;1 || str==null || str.length()&lt;2){        return str;    }    char[] chs = str.toCharArray();    reverse(chs, 0, n-1);    reverse(chs, n, chs.length-1);    reverse(chs,0,chs.length-1);    return String.valueOf(chs);}//翻转一个字符串：首尾向中间扫，字符互换即可private static void reverse(char[] str, int start, int end){    if(start&gt;=end){        return;    }    while(start&lt;end){        char temp = str[start];        str[start] = str[end];        str[end] = temp;        start++;        end--;    }}</code></pre><p><a name="71"></a></p><h2 id="71-滑动窗口最大值-双端队列"><a href="#71-滑动窗口最大值-双端队列" class="headerlink" title="71.滑动窗口最大值(双端队列)"></a>71.滑动窗口最大值(双端队列)</h2><p>《剑指offer》p288、《左神》19、leetcode239</p><p>题目：滑动窗口的最大值。给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。如{2,3,4,2,6,2,5,1}及滑动窗口的大小3，最大值分别为{4,4,6,6,6,5}</p><p>思路：双端队列。滑动窗口先进先出因此借助双端队列，使用队列保存数组的下标，从头遍历数组，根据如下规则进行入队、出队：  </p><pre><code>0. 如果队列为空，则当前数字入队列1. 如果当前数字大于队列尾，则删除队列尾，然后当前数字入队列2. 如果当前数字小于等于队列尾，则当前数字入队列3. 如果队列头超出滑动窗口范围，则删除队列头4. 这样能始终保证队头为当前的最大值5. 时间o(n)，空间o(k)</code></pre><p>代码：</p><pre><code>//滑动窗口最大值--&gt;双端队列public static int[] maxSlidingWindow(int[] nums, int k) {    if(nums==null || nums.length==0 || k&lt;1 || k&gt;nums.length){        return new int[0];    }    int[] res = new int[nums.length-k+1];//滑动窗口最大值    int resCnt = 0;    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();//双端队列,存的不是数组元素，而是下标，便于判断滑动窗口位置    for (int i=0; i&lt;nums.length; ++i){//遍历数组        if(!deque.isEmpty() &amp;&amp; deque.getFirst()+k==i){//进行滑动窗口:双端队列的头部已经不在窗口中，头部出队            deque.pollFirst();        }        while(!deque.isEmpty() &amp;&amp; nums[i]&gt;nums[deque.getLast()]){//如果当前数比双端队列的尾部大，则一直pollLast，直到当前数比尾部小或相等            deque.pollLast();        }        deque.offerLast(i);        if(i+1&gt;=k){//存储当前窗口最大值            res[resCnt++] = nums[deque.getFirst()];        }    }    return res;}</code></pre><p><a name="72"></a></p><h2 id="72-打印n个骰子所有可能的点数和及概率"><a href="#72-打印n个骰子所有可能的点数和及概率" class="headerlink" title="72.打印n个骰子所有可能的点数和及概率"></a>72.打印n个骰子所有可能的点数和及概率</h2><p>《剑指offer》p294.</p><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s，输入n，打印出s的所有可能的值出现的概率。示例如下(n=2)：</p><pre><code>2个骰子，点数和为2出现的概率为: 0.0277777777777777762个骰子，点数和为3出现的概率为: 0.055555555555555552个骰子，点数和为4出现的概率为: 0.083333333333333332个骰子，点数和为5出现的概率为: 0.1111111111111111...</code></pre><p>递归思路：</p><pre><code class="python">def getsumcount(self, number, summ):    if number &lt; 1 or summ &lt; number or summ &gt; 6 * number:        return 0    if number == 1:        return 1    resCount = 0    resCount = self.getsumcount(number-1, summ-1)+self.getsumcount(number-1, summ-2)+self.getsumcount(number-1, summ-3)+self.getsumcount(number-1, summ-4)+self.getsumcount(number-1, summ-5)+self.getsumcount(number-1, summ-6)    return resCountdef po(self, number):    total = pow(6, number)    for i in range(number, 6*number+1):        res = self.getsumcount(number, i)        ratio = res/total        print(i, ratio)</code></pre><p>循环思路：<strong>先算所有出现的点数和及出现次数，再算概率(出现次数/6^number)。一个一个骰子往上加，辅助两个数组交替着存所有出现的点数和为n的出现次数，resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</strong></p><p>详细思路(可以不看了，初学看)：n个骰子的总点数，最小为n，最大为6n，n个骰子出现的所有点数排列的个数为6^n。我们先统计每一个点数和出现的次数，定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组的第s-n个元素里;然后把每一个点数和出现的次数除以6^n，就能求出每个点数和出现的概率。因此本题重点是统计每一个点数和出现的次数，不难发现这是一种递归的思路，自下而上循环实现,从1个骰子开始，每次加一个骰子计算。用两个数组来存储骰子点数和的每一种出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的综合，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</p><p>代码:</p><pre><code class="java">//n个骰子的所有出现的点数和及概率。思路：两个数组存所有出现的点数和及出现次数，再算概率。//详细思路:一个一个骰子往上加，点数和为n的出现次数resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]public static void printSumRatio(int number){    if(number&lt;1){        return;    }    //1.辅助两个数组并初始化    int[][] res = new int[2][6*number+1];//定义两个数组，交换着统计number个骰子所有可能的点数和出现的次数，数组长度为6*n+1    int resFlag = 0;//交换数组的标志位    for(int i=1; i&lt;=6; ++i){//当1个骰子时，初始化res数组        res[resFlag][i] = 1;    }    //2.交换着使用两个数组，统计number个骰子所有点数和出现的次数    for(int i=2; i&lt;=number; ++i){//一个一个骰子往上加        for(int j=1; j&lt;i; ++j){//当有i个骰子时，[1,i)的点数和为0，全部清空            res[1-resFlag][j] = 0;        }        for(int j=i; j&lt;=6*i; ++j){//当有i个骰子时,给[i,6*i]赋值            for(int k=1; k&lt;=6&amp;&amp;j&gt;k; ++k){                res[1-resFlag][j] += res[resFlag][j-k];//resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]            }        }        resFlag = 1-resFlag;//交换数组，改变flag    }    //3.计算并打印number个骰子所有可能的点数和及概率    double totalCount = Math.pow(6, number);//number个骰子出现的不同情况的总次数为6^n次方    for(int i=number; i&lt;=6*number; ++i){        double ratio = (double)res[resFlag][i]/totalCount;//点数和为res[i]的概率        System.out.println(number + &quot;个骰子，点数和为&quot; + i + &quot;出现的概率为&quot; + ratio);    }}public static void main(String[] args){    printSumRatio(2);    //out:    //2个骰子，点数和为2出现的概率为0.027777777777777776    //2个骰子，点数和为3出现的概率为0.05555555555555555    //2个骰子，点数和为4出现的概率为0.08333333333333333    //2个骰子，点数和为5出现的概率为0.1111111111111111    //2个骰子，点数和为6出现的概率为0.1388888888888889    //2个骰子，点数和为7出现的概率为0.16666666666666666    //2个骰子，点数和为8出现的概率为0.1388888888888889    //2个骰子，点数和为9出现的概率为0.1111111111111111    //2个骰子，点数和为10出现的概率为0.08333333333333333    //2个骰子，点数和为11出现的概率为0.05555555555555555    //2个骰子，点数和为12出现的概率为0.027777777777777776}</code></pre><p><a name="73"></a></p><h2 id="73-扑克牌中的顺子-2道"><a href="#73-扑克牌中的顺子-2道" class="headerlink" title="73.扑克牌中的顺子(2道)"></a>73.扑克牌中的顺子(2道)</h2><pre><code>整个数组是否为一个顺子(同时有大小王)--《剑指offer》p298.整个数组分组后每组都要为顺子--leetcode 846</code></pre><h3 id="1-整个数组是否为一个顺子-同时有大小王"><a href="#1-整个数组是否为一个顺子-同时有大小王" class="headerlink" title="1.整个数组是否为一个顺子(同时有大小王)"></a>1.整个数组是否为一个顺子(同时有大小王)</h3><p>《剑指offer》p298.</p><p>题目：扑克牌中的顺子：从扑克牌中随机抽5张牌,判断是不是顺子(即这5张牌是不是连续的)。2-10为数字本身，A为1，J、Q、K 为11、12、13，大小王可以看成任意的数字(解题时可以看成0)。</p><p>思路：</p><pre><code>0.定义长度为numbers的数组(这里不限于解决5张,判断numbers张牌是否为顺子);1.数组排序；2.统计数组中0的个数;3.统计排序后数组相邻数字间的空缺数(eg数字57间空缺1);4.2、3两步统计的0个数大于等于空缺数--&gt;顺子，否则不是顺子</code></pre><p>代码：</p><pre><code class="java">//判断扑克牌顺子(2张及以上连续),大小王0可以代表任意牌。思路：数组排序,记录大小王的个数，遍历数组判断是否为顺子即可public static boolean isContinuous(int [] numbers) {    if(numbers==null || numbers.length&gt;13 || numbers.length&lt;2){        return false;    }    //1.数组排序    Arrays.sort(numbers);    //2.记录大小王的个数并判断是否为顺子    int superCnt = 0;//记录大小王的个数    int superCntCopy = 0;//保存大小王个数    for(int i=0; i&lt;numbers.length-1; ++i){        if(numbers[i]==0){//是大小王            superCnt++;            superCntCopy++;        }        else if(numbers[i]==numbers[i+1]){//相等，即出现对儿，不是顺子            return false;        }        else if(numbers[i]+1==numbers[i+1]){//连续            continue;        }        else if(numbers[i]+1!=numbers[i+1]){//遇到不连续的牌，看看能不能凑个王            if( (numbers[i+1]-numbers[i]-1) &lt;= superCnt ){//可以用王凑                superCnt -= (numbers[i+1]-numbers[i]-1);            }else{//不够王了                return false;            }        }    }    //3.王太多还剩下几张王，放在牌头与牌尾后还剩下王，则不是顺子    if(superCnt&gt;0 &amp;&amp; superCnt&gt;(numbers[superCntCopy]-numbers[numbers.length-1]+12)){        return false;    }    return true;}</code></pre><h3 id="2-整个数组分组后每组都要为顺子"><a href="#2-整个数组分组后每组都要为顺子" class="headerlink" title="2.整个数组分组后每组都要为顺子"></a>2.整个数组分组后每组都要为顺子</h3><p>leetcode 846</p><p>题目：Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.</p><pre><code>Input: hand = [1,2,3,6,2,3,4,7,8], W = 3Output: trueExplanation: Alice&#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</code></pre><p>思路：1.hand长度不能整除W，false;2.hand排序;3.由于[1,2,3],[2,3,4]也可以，需要<strong>辅助数组缓存访问标记</strong>用于后续判断;4.遍历数组一组一组进行判断</p><pre><code class="java">public boolean isNStraightHand(int[] hand, int W) {    //1.hand长度不能整除W，false    if(hand==null || hand.length==0 || W&lt;1 || W&gt;hand.length || hand.length%W!=0){        return false;    }    //2.hand排序    Arrays.sort(hand);    //3.辅助数组缓存访问标记用于后续判断    boolean[] visited = new boolean[hand.length];    //4.遍历数组一组一组进行判断    int cnt = W;    for(int i=0; i&lt;hand.length; ++i){        if(!visited[i]){//如果没有被访问过之前，以此为新group的起始位置开始寻找一个group            visited[i] = true;            int left = i;            int right = i+1;            while(cnt!=1){//寻找一个group                if(right&gt;=hand.length){//找完了hand都没凑成一个group,false                    return false;                }                if(!visited[right]){                    if(hand[left]+1&lt;hand[right]){//断层太大，不可能连续了，false                        return false;                    }                    else if(hand[left]+1==hand[right]){//前后连续                        visited[right] = true;                        left = right;                        cnt--;                    }                }                right++;            }            //找完了一个group，重置cnt            cnt = W;        }    }    return true;//找完了所有group，没有返回false说明都符合条件,true}</code></pre><p><a name="74"></a></p><h2 id="74-圆圈中剩下的数-约瑟夫环问题"><a href="#74-圆圈中剩下的数-约瑟夫环问题" class="headerlink" title="74.圆圈中剩下的数(约瑟夫环问题)"></a>74.圆圈中剩下的数(约瑟夫环问题)</h2><p>《剑指offer》p300、《左神》43、leetcode 292</p><p>题目：圆圈中最后剩下的数字。0,1…n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字，求出这个圆圈里剩下的最后一个数字。e.g n=5([0,1,2,3,4]),m=3,out:3</p><p>思路1：用<strong>双端队列</strong>模拟这个循环环的问题，每排除一个数需要m步运算，n个数就需要O(mn)，空间复杂度为O(n)</p><pre><code class="java">//圆圈中剩下的数。思路:用双端队列模拟这个过程，时间o(nm),空间o(n)public static int LastRemaining_Solution(int n, int m) {    if(m&lt;1 || n&lt;1){        return -1;    }    if(n==1){        return 1;    }    //1.辅助o(n)双端队列    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    for(int i=0; i&lt;n; ++i){        deque.offerLast(i);    }    //2.模拟弹出过程,直到双端队列中剩下一个数为止    int cnt = m;    while(deque.size()&gt;1){        cnt--;        if(cnt==0){//弹出一个数，重置cnt            deque.pollFirst();            cnt = m;        }        else{            deque.offerLast(deque.pollFirst());        }    }    return deque.pollFirst();}</code></pre><p>思路2(更好)：分析这个题的数学规律，直接求解:<code>f(n,m)=[(f(n-1,m)+m]%n</code>，时间o(n)，空间o(1)。</p><pre><code class="java">//f(n,m)=[(f(n-1,m)+m]%n//f(n,m)=0(n=1);f(n,m)=[(f(n-1,m)+m)%n](n&gt;1)public int LastRemaining_Solution(int n, int m) {    if(m&lt;1 || n&lt;1){        return -1;    }    int res = 0;    for(int i=2; i&lt;=n; ++i){        res = (res+m)%i;    }    return res;}</code></pre><p><a name="75"></a></p><h2 id="75-股票的最大利润问题-四道"><a href="#75-股票的最大利润问题-四道" class="headerlink" title="75.股票的最大利润问题(四道)"></a>75.股票的最大利润问题(四道)</h2><pre><code>只允许买卖一次股票，求最大收益--《剑指offer》p304、leetcode 121允许多次买卖，求最大收益--《剑指offer》p304、leetcode 122只允许买卖两次股票，求最大收益--leetcode 123只允许买卖k次股票，求最大收益--leetcode 188</code></pre><h3 id="1-只允许买卖一次股票，求最大收益"><a href="#1-只允许买卖一次股票，求最大收益" class="headerlink" title="1.只允许买卖一次股票，求最大收益"></a>1.只允许买卖一次股票，求最大收益</h3><p>《剑指offer》p304</p><p>题目：只允许买卖一次股票，求最大收益</p><p>思路：以当前股票为基准，找到之前的最小值，用来更新最大利润。时间o(n)</p><pre><code class="java">//股票的最大利润，只允许买卖一次股票，求最大收益。思路:两个变量即可，每天都尝试卖一次，不断更新最大利润。时间o(n),空间o(1)public int maxProfit(int[] prices) {    if(prices==null || prices.length&lt;2){        return 0;    }    int min = prices[0];//存之前最小的股价    int resMax = 0; //存最大的利润    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润        resMax = Math.max(resMax, prices[i]-min);        if(prices[i]&lt;min){            min = prices[i];        }    }    return resMax;}</code></pre><h3 id="2-允许多次买卖，求最大收益"><a href="#2-允许多次买卖，求最大收益" class="headerlink" title="2.允许多次买卖，求最大收益"></a>2.允许多次买卖，求最大收益</h3><p>《剑指offer》p304、leetcode 122</p><p>题目：允许多次买卖，求最大收益</p><p>思路：每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)</p><pre><code class="java">//股票的最大利润，允许多次买卖，求最大收益。思路:每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)public int maxProfit(int[] prices) {    if(prices==null || prices.length&lt;2){        return 0;    }    int resMax = 0; //存最大的利润    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润        int temp = prices[i]-prices[i-1];        if(temp&gt;0){            resMax += temp;        }    }    return resMax;}</code></pre><h3 id="3-只允许买卖两次股票，求最大收益"><a href="#3-只允许买卖两次股票，求最大收益" class="headerlink" title="3.只允许买卖两次股票，求最大收益"></a>3.只允许买卖两次股票，求最大收益</h3><p>leetcode 123</p><p>题目：只允许买卖两次股票，求最大收益</p><p>思路：3、4两题可以用DP解决，但是这里用更巧妙的方法，直接看第4题即可，本题的解法就是第4题的k=2</p><h3 id="4-只允许买卖k次股票，求最大收益"><a href="#4-只允许买卖k次股票，求最大收益" class="headerlink" title="4.只允许买卖k次股票，求最大收益"></a>4.只允许买卖k次股票，求最大收益</h3><p>leetcode 188</p><p>题目：只允许买卖k次股票，求最大收益</p><p>思路：3、4两题都用二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益。</p><pre><code class="java">//k次买卖的最大股票收益。思路：二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益public int maxProfit(int k, int[] prices) {    int len = prices.length;    if (k &gt;= len / 2) return quickSolve(prices);//可以最多次买卖，求最大收益即可    int[][] t = new int[k + 1][len];    for (int i = 1; i &lt;= k; i++) {        int tmpMax =  -prices[0];//tmpMax就是自己的钱包，就是当前的收益        for (int j = 1; j &lt; len; j++) {            t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);//卖            tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);//买        }    }    return t[k][len - 1];}//允许多次买卖，把所有的收益都加起来即可private int quickSolve(int[] prices) {    int len = prices.length, profit = 0;    for (int i = 1; i &lt; len; i++)        // as long as there is a price gap, we gain a profit.        if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];    return profit;}</code></pre><p><a name="76"></a></p><h2 id="76-求1-2-3-…-n"><a href="#76-求1-2-3-…-n" class="headerlink" title="76.求1+2+3+…+n"></a>76.求1+2+3+…+n</h2><p>《剑指offer》p307.</p><p>题目：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>思路：递归。</p><p>这里可以通过递归的方式进行计算，<strong>但是很疑问的地方在于如何结束递归</strong><br>​<br>这里可以有多种的方式，基本方向是采用逻辑与或的方式来计算，</p><p><strong>用或运算通过n==0来短路，这样在n=0的时候不需要计算递归的值</strong></p><pre><code class="java">public static int Sum_Solution(int n) {    int res = 0;    boolean b = n==0 || (res=n+Sum_Solution(n-1))&gt;0;    return res;}</code></pre><p><a name="77"></a></p><h2 id="77-构建乘积数组"><a href="#77-构建乘积数组" class="headerlink" title="77.构建乘积数组"></a>77.构建乘积数组</h2><p>《剑指offer》p312、leetcode 238</p><p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],</p><p>其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p><p>思路1(不可取)：如果没有不能使用除法的限制,可以用公式B[i]=A[0]*A[1]*…..*A[n-1]/A[i]表示,使用除法时要特别注意A[i]等于0的情况。时间o(n)，空间o(1)，但是这里不能用除法</p><p>思路2(不可取)：现在要求不能使用除法，一个直观的解法是用连乘n-1个数字得到B[i]，时间o(n^2)</p><p>思路3(可取)：辅助一个数组temp[]的思想(但这里就用B做辅助数组)，时间o(n),空间o(1)</p><p>1.先从后往前存储(temp[i]=A[i]*A[i+1]*…A[length-1])，此时先将B[]看成辅助数组temp[]</p><p>2.再从前往后计算(tempRes=A[0],B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]…)</p><p>代码：</p><pre><code class="java">public int[] multiply(int[] A) {    if(A==null || A.length==0){        return new int[0];    }    int[] B = new int[A.length];//存放结果，但从后往前计算时先将B看成辅助数组    //1.1.先从后往前存储(temp[i]=A[i]*A[i+1]*...A[length-1])，此时先将B[]看成辅助数组    B[A.length-1] = A[A.length-1];    for(int i=A.length-2; i&gt;=0; i--){        B[i] = B[i+1] * A[i];    }    //2.再从前往后计算(tempRes=1,B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]...)    int tempRes = 1;    for(int i=0; i&lt;A.length-1; ++i){        B[i] = tempRes * B[i+1];        tempRes *= A[i];    }    B[A.length-1] = tempRes;//最后一个元素    return B;}</code></pre><p><a name="78"></a></p><h2 id="78-普通二叉树中两个节点的最低公共祖先"><a href="#78-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="78.普通二叉树中两个节点的最低公共祖先"></a>78.普通二叉树中两个节点的最低公共祖先</h2><p>《剑指offer》p326、leetcode 236</p><p>题目：普通二叉树中两个节点的最低公共祖先</p><p>思路1(不可取)：从root开始寻找</p><p>如果当前节点的左子节点是两个节点的祖先(应该继续对左子节点判断)</p><p>如果当前节点的右子节点是两个节点的祖先(应该继续对右子节点判断)</p><p>当前结点不同时为两个结点的祖先(一边一个)，即为最低公共祖先</p><p>这种方法自上而下重复遍历，不太好</p><pre><code class="java">class TreeNode {    int val;    TreeNode left = null;    TreeNode right = null;    TreeNode(int val) {        this.val = val;    }}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if (hasNode(root.left, p) &amp;&amp; hasNode(root.left, q)) {        return lowestCommonAncestor(root.left, p, q);    } else if (hasNode(root.right, p) &amp;&amp; hasNode(root.right, q)) {        return lowestCommonAncestor(root.right, p, q);    }    return root;}//遍历以root为根的树，判断是否含有节点ppublic boolean hasNode(TreeNode root, TreeNode p) {    if (root == null) {        return false;    }    if (root == p) {        return true;    }    return hasNode(root.left, p) || hasNode(root.right, p);}</code></pre><p>思路2(可取)：遍历两次树，分别找出从root到两个节点的路径(用两个List存下来)，变成求两个list中的最后一个公共结点</p><pre><code class="java">//普通二叉树中两个节点的最低公共祖先public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q){    if(root==null || p==null || q==null){        return null;    }    ArrayList&lt;TreeNode&gt; arrayListP = new ArrayList&lt;&gt;();    ArrayList&lt;TreeNode&gt; arrayListQ = new ArrayList&lt;&gt;();//两个List存路径    if(!findPath(root,p,arrayListP) || !findPath(root,q,arrayListQ)){//没找到p、q        return null;    }    int index = 0;    while(index&lt;arrayListP.size() &amp;&amp; index&lt;arrayListQ.size()){//对两个路径list找最后一个公共节点        if(arrayListP.get(index)!=arrayListQ.get(index)){            break;        }        index++;    }    return index==0 ? root: arrayListP.get(index-1);}//遍历二叉树，找root到target节点的路径(路径存在res中)，如果没找到target返回truepublic boolean findPath(TreeNode root, TreeNode target, ArrayList&lt;TreeNode&gt; res){    if(root==null){        return false;    }    res.add(root);    if(root==target){        return true;    }    if (findPath(root.left, target, res) || findPath(root.right, target, res)){        return true;    }    res.remove(res.size()-1);//回溯    return false;}</code></pre><p><a name="79"></a></p><h2 id="79-把字符串转换成整数"><a href="#79-把字符串转换成整数" class="headerlink" title="79.把字符串转换成整数"></a>79.把字符串转换成整数</h2><p>《剑指offer》p318、leetcode 8</p><p>题目：把字符串(包括数字字母符号,可以为空)转换成整数，不符合条件返回0。<br>即实现Integer.valueOf(string)的功能，要求不能使用字符串转换整数的库函数</p><p>思路：字符串转换成数组，res用long，从前往后遍历即可，本题核心是对以下情况的处理</p><p>要点：</p><pre><code>1.字母判断2.溢出3.正负号</code></pre><p>代码：</p><pre><code class="java">public int myAtoi(String str){    if(str==null || str.trim().length()==0){        return 0;    }    char[] chs = str.trim().toCharArray();//转换成数组    boolean isPositive = true;//正负号    int index = 0;    long res = 0;    if(chs[index]==&#39;+&#39; || chs[index]==&#39;-&#39;){        isPositive = chs[index]==&#39;-&#39; ? false : true;        index++;    }    while(index&lt;chs.length){        int temp = chs[index]-&#39;0&#39;;        if(temp&lt;0||temp&gt;9){//是否是数字判断            return 0;//这里在leetoce中应该为break，题目要求有一点点不一样        }        res = res*10L + (long)temp;        index++;        if(isPositive==true){//溢出判断            if(res&gt;Integer.MAX_VALUE){                return Integer.MAX_VALUE;            }        }        else{            if(res*(-1L)&lt;Integer.MIN_VALUE){                return Integer.MIN_VALUE;            }        }    }    return isPositive==true ? (int)res : (int)res*(-1);//正负号判断}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客系统搭建过程</title>
      <link href="/2018/02/22/build-hexo/"/>
      <url>/2018/02/22/build-hexo/</url>
      
        <content type="html"><![CDATA[<p>搭建Hexo博客的经验贴，便于日后查看，也希望新手少走弯路</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说道技术博客，最开始在csdn上记录技术学习笔记较多，坚持时间较长。后来也迁移副本至博客园，可能先入为主的原因，并没有持续同步更新，不久便把博客园删了。后来入坑jekyll、Hexo等开源博客，后来因为考研的原因也都草草收场。博客系统虽搁置一边但笔记还在不断积累，懒出天际的我直接md文档保存在本地，待嫁的深闺文章越积越多。毕业前的新冠疫情来得突然，趁寒假闲来无事刚好把博客这个烂摊子理一理。</p><p>花了两周左右完成了gitee+hexo的博客系统，可一键发布并备份，随时随地无缝编辑博客。hexo好处多多，不用自己架服务器，同时主题样式可选种类较多，开源且稳定，最开始用的时候用github管理，后来由于各种原因墙内访问越来越慢（你懂），迁移至gitee托管，访问速度提升不少。</p><p>现将搭建过程记录如文，便于日后查看，也希望新手少走弯路。</p><p>这里附上我的博客，欢迎交流：<a href="https://braincao.cn/">https://braincao.cn/</a></p><h1 id="一、先搭建-建立博客系统"><a href="#一、先搭建-建立博客系统" class="headerlink" title="一、先搭建-建立博客系统"></a>一、先搭建-建立博客系统</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>到<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>官网下载node.js并安装</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>自行百度安装</p><h2 id="本地建立hexo系统"><a href="#本地建立hexo系统" class="headerlink" title="本地建立hexo系统"></a>本地建立hexo系统</h2><p>安装hexo：</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>本地创建自己的blog目录，如HexoBlog，在该目录下进行Hexo初始化：</p><pre><code>hexo init HexoBlogcd ~/HexoBlog/npm install</code></pre><h2 id="远程建立gitee上的hexo系统"><a href="#远程建立gitee上的hexo系统" class="headerlink" title="远程建立gitee上的hexo系统"></a>远程建立gitee上的hexo系统</h2><p>用Gitee Pages建立gitee远程博客仓库。</p><ol><li><p>码云注册并建立名为hexoblog的仓库（使用readme初始化项目）</p></li><li><p>通过 <code>hexoblog项目-&gt;Service-&gt;Gitee Pages服务</code> 建立博客仓库，它会自动生成博客地址，下文会介绍自定义域名绑定博客地址</p></li><li><p>添加ssh key：将本地的id_rsa.pub添加到gitee个人中心的ssh key中。为什么要添加ssh key？ 原因：后续想用git方式通过ssh与远程仓库连接，快捷一些，但为了安全起见，需要公密钥的方式来连接。本地设置gitglobal的user.name user.email，生成一个基于如user.email的ssh key，它是一对私钥和公钥，私钥自己保存别动它，把ssh key中的公钥添加到github官网自己账号中，这样就可以用自己设备很方便的连接至自己的github并享受其服务。如有多台设备，可以每台设备生成一对ssh key，并将多个公钥添加github账号中即可，这样就可以实现多台设备无缝连接，便于移动办公。</p></li><li><p>在_config.yml中配置博客url、远程Git：</p></li></ol><pre><code># 配置错误会出现主题样式展示错误url: https://braincao.cnroot: /# 发布deploy:  type: git  repo: git@gitee.com:username/repo.git  branch: master# 全局搜索search:  path: search.xml  field: post</code></pre><h2 id="发布博客到gitee"><a href="#发布博客到gitee" class="headerlink" title="发布博客到gitee"></a>发布博客到gitee</h2><p>安装Hexo必备插件：</p><pre><code>npm install hexo-deployer-git --save #hexo通过git发布npm install hexo-wordcount --save #文章统计字数npm install hexo-generator-search --save #全局搜索</code></pre><p>输入命令发布博客，首次发布需要在shell中输入账号和密码:</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>github会发布后会自动更新博客页面，码云将此功能变为人民币玩家功能，因此发布后需要在码云仓库中手动update才能更新博客</p><h2 id="附常用hexo命令"><a href="#附常用hexo命令" class="headerlink" title="附常用hexo命令"></a>附常用hexo命令</h2><pre><code>hexo clean #清除public静态页面缓存（如果有）hexo new page &quot;pageName&quot; #新建页面hexo help  # 查看帮助hexo version  #查看Hexo的版本hexo new &quot;postName&quot; #新建文章简写:hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #本地服务，http://localhost:4000预览hexo d == hexo deploy #部署至github仓库完成博客发布hexo n page &#39;about&#39; #建立导航栏菜单，如about关于页面</code></pre><h1 id="二、后装修-个性化配置"><a href="#二、后装修-个性化配置" class="headerlink" title="二、后装修-个性化配置"></a>二、后装修-个性化配置</h1><p>个性化配置主要包括站点配置与主题配置，跟着<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官方文档</a>、每个主题的官方指导走就行。第三方功能包括但不限于：首页全文阅读、站内搜索、访问人数、字数统计、打赏功能、gitalk评论、404页面、RSS、sitemap</p><p>下面仅以3-hexo为例，罗列下我的个性化配置。</p><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>Hexo系统有很多主题，较为主流的如Next主题，本文采用3-hexo主题。</p><pre><code>git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>在根目录的站点配置文件配置主题即可</p><pre><code>theme: 3-hexo</code></pre><p>这里注意3-hexo主题有个坑，配置时还需在主题配置文件中更改根目录：</p><pre><code>#如果博客放置位置不是根目录，则可以通过配置此路径解决静态文件路径错误问题#比如访问地址为 yelog.org/blog 那就需要配置为 blog_path: /blog 才能正常访问blog_path: /hexoblog #记得改这里，初始是/</code></pre><h2 id="主题-站点配置文件个性化修改"><a href="#主题-站点配置文件个性化修改" class="headerlink" title="主题/站点配置文件个性化修改"></a>主题/站点配置文件个性化修改</h2><p>先更改能看懂的，如作者、头像、github/邮箱地址、评论、友情链接、打赏二维码、置顶、评论(gitalk)等，看不懂的先别改。</p><p>这里有个点，3-hexo有自己的语法高亮，因此需把hexo站点高亮关了</p><pre><code>highlight:  enable: false  #true改成false</code></pre><h2 id="文章分类-amp-md头部"><a href="#文章分类-amp-md头部" class="headerlink" title="文章分类 &amp; md头部"></a>文章分类 &amp; md头部</h2><p>写md时直接分类即可，另外3-hexo原生支持多级分类（在主题配置文件中有详细介绍），具体的md头部如下：</p><pre><code>---title: 剑指offer刷题date: 2018-09-21 17:32:47updated: 2020-02-19 14:36:48categories:    - 算法刷题tags:    - 剑指offer刷题top: 1originUrl: https://zhuanlan.zhihu.com/p/28987530---</code></pre><p>如果博文中有图片，就在csdn上编辑，得到图片网链，导出md后同步至mac md上，最后再从mac md源进行全网同步</p><p>有的主题首页只显示文章的简介(全文阅读)：在md文章中的合适位置添加 &lt; !–more–&gt; 标签即可，之前的文字都会写在首页文章名称下面的简介里</p><h2 id="关于、相册等导航栏菜单建立"><a href="#关于、相册等导航栏菜单建立" class="headerlink" title="关于、相册等导航栏菜单建立"></a>关于、相册等导航栏菜单建立</h2><p>Hexo里，默认的导航菜单只有Home和Archives两项，还需自行添加其他导航栏菜单</p><pre><code>hexo n page &#39;about&#39;</code></pre><p>这样就建立了source/about文件夹，然后在主题配置文件中：</p><pre><code>menu:  Home: /  About: /about  #注意3-hexo主题这里需要改成hexoblog/about</code></pre><p>在menu中加了一项设置About: /about，前面部分是显示名称，后面部分是访问路径，即source/about中的index.md，就是想要访问About时的页面。同理，还可添加别的菜单，如  <code>Archives: /archives</code>、<code>Photo: /photo</code>等</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>gitee pages 会自动生成hexo博客地址，可正常访问，如果有自定义域名需要则要进行如下操作。</p><ol><li><p>阿里云购买域名、购买云解析dns服务，再购买免费的DVssl安全证书</p></li><li><p>在云解析dns服务中配置域名解析：添加CNAME，记录值为<code>gitee.gitee.io</code></p></li><li><p>在本地hexo根目录的source文件夹中新建CNAME文件，里面写自定义的域名<code>braincao.cn</code>，然后<code>hexo clean &amp; hexo g &amp; hexo d</code></p></li><li><p>在gitee的page service中添加自定义域名 braincao.cn，再把已买好的ssl证书上传，即可生成<code>https://braincao.cn</code>的博客地址</p></li></ol><p>这样就可以通过自定义域名访问博客地址了，自定义域名的好处可以不透漏gitee项目地址，通过阿里云有负载均衡等付费服务，访问延时更低</p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>Hexo博客是静态托管的，所有的原始md博文都保存在本地，本地md文件如果丢失的话就四大皆空了，因此需要每次发布博文的同时在托管仓库进行md文件备份。</p><p>备份的好处有两个。首先，防止本地md丢失，留一份在远程；其次，如果换台电脑，可以从远程仓库将博客系统与原始md文件都clone到本地，这样可以随时随地无缝地写博客。</p><p>具体的备份思路为：</p><ul><li>同一个hexo托管仓库，两个分支master、hexo</li><li>平时本地默认hexo分支，包含原始md博文、hexo系统</li><li>hexo站点配置中将deploy分支设置为master，将静态网页发布至origin/master</li><li>在本地bash中用配置alias：</li></ul><pre><code>function hexogdb() {hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;post new md&quot; &amp;&amp; git push &amp;&amp; git pull</code></pre><p>如此，当每次本地在hexo分支下写完md文件，直接 <code>hexogdb</code> 即可一键完成渲染、发布、备份。</p><p>其他备份方案：</p><ul><li>使用 <code>hexo-git-backup</code> 插件备份Hexo博客</li><li>自行新建repo专门对本地md文件、hexo博客系统进行备份</li></ul><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，已基本完成Hexo博客系统搭建，剩下需要做的就是内容产出了。每次产出md博文后，<code>hexogdb</code> 一键完成发布与备份。</p><p>本人做博客的初衷是沉淀技术知识、记录成长轨迹同时及时分享反馈。同样，每当入门一个全新的领域如能看到同行前辈分享的完整学习贴也会感激万分，这种正向反馈给我坚持技术分享的动力。技术之路无穷尽，希望在这条充满挑战的路上，我们都会收获属于自己的那份成就感。</p>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> gitee </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
