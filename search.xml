<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《指数基金投资指南》学习笔记</title>
      <link href="/2020/03/05/fund-bank-screw/"/>
      <url>/2020/03/05/fund-bank-screw/</url>
      
        <content type="html"><![CDATA[<p>本文档是银行螺丝钉的《指数基金投资指南》学习笔记，适合小白入门学习基金使用</p><a id="more"></a><h2 id="第一章-给基金新手的建议"><a href="#第一章-给基金新手的建议" class="headerlink" title="第一章 给基金新手的建议"></a>第一章 给基金新手的建议</h2><h3 id="1-1-想成为富人，你得攒资产"><a href="#1-1-想成为富人，你得攒资产" class="headerlink" title="1.1 想成为富人，你得攒资产"></a>1.1 想成为富人，你得攒资产</h3><p>在消费上更务实一些，就可以省下更多的钱用于投资，更快地走上“钱生钱”的道路，如此这样，做投资才会越来越轻松，才会更快地实现财富自由</p><h3 id="1-2-找到长期收益率最高的资产"><a href="#1-2-找到长期收益率最高的资产" class="headerlink" title="1.2 找到长期收益率最高的资产"></a>1.2 找到长期收益率最高的资产</h3><p>资产分两种：</p><ul><li>能产生现金流的资产（债券、股票、房地产租金、银行理财、P2P理财等）</li><li>不能产生现金流的资产（黄金、纪念币、纪念钞）</li></ul><p>这两种资产的价格驱动因素不同：</p><ul><li>能产生现金流的资产的价格—取于现金流的大小和稳定性，同样4%利率，大银行更稳定</li><li>不能产生现金流的资产的价格—取决于供求关系（盛世珠宝、乱世黄金）</li></ul><p><strong>长期收益率最高的资产</strong>：能产生现金流的资产通常比不能产生现金流的资产长期收益更高；能产生现金流的资产中，现金流越高，长期收益更高。</p><h3 id="1-3-看收益，更要看风险"><a href="#1-3-看收益，更要看风险" class="headerlink" title="1.3 看收益，更要看风险"></a>1.3 看收益，更要看风险</h3><p>一切不合理的高收益基本都是金融骗局，股神也就23%复合利率</p><h3 id="1-4-复利的威力"><a href="#1-4-复利的威力" class="headerlink" title="1.4 复利的威力"></a>1.4 复利的威力</h3><p>爱因斯坦说过，复利是世界上第八大奇迹！</p><h3 id="1-5-最适合上班族的基金——指数基金"><a href="#1-5-最适合上班族的基金——指数基金" class="headerlink" title="1.5 最适合上班族的基金——指数基金"></a>1.5 最适合上班族的基金——指数基金</h3><p>股票基金就是一揽子的股票，加起来也有上千只。而指数基金也是特殊的股票基金，市面上指数基金也有100多只</p><h3 id="1-6-怎么买指数基金—认准ETF完事，不开户的话就买ETF联结"><a href="#1-6-怎么买指数基金—认准ETF完事，不开户的话就买ETF联结" class="headerlink" title="1.6 怎么买指数基金—认准ETF完事，不开户的话就买ETF联结"></a>1.6 怎么买指数基金—认准ETF完事，不开户的话就买ETF联结</h3><p>指数基金可以根据购买渠道分：交易所外交易基金，和交易所内交易基金</p><p>交易所外交易基金（申赎方式）：银行柜台、支付宝、天天基金等申赎目标基金，到账时间长（5个工作日），交易费用千分之1</p><p><strong>交易所内交易基金即ETF（买卖交易方式）</strong>：需开股票账户才能购买，交易费用和股票接近，到账快（下个工作日），无需申购费和赎回费仅有交易费一般在万分之5以下，管理费也比场外交易低，ETF的长期收益更好</p><p>而<strong>ETF联接基金</strong>：不用开户，基金公司替场外投资者将90%以上的资产购买ETF基金，投资于ETF基金的基金</p><p>具体的细节还要看这篇知乎：<a href="https://www.zhihu.com/question/21443356" target="_blank" rel="noopener">如何购买ETF基金</a></p><h2 id="第二章-了解指数"><a href="#第二章-了解指数" class="headerlink" title="第二章 了解指数"></a>第二章 了解指数</h2><p>中国：上证、深证、中证、沪深</p><p>美国：纳斯达克指数、标普500指数、道琼斯指数</p><p>香港：恒生指数、H股指数</p><p>世界知名：摩根斯坦利指数公司开发的MSCI系列指数</p><h3 id="2-3-为什么有钱人偏爱指数基金？"><a href="#2-3-为什么有钱人偏爱指数基金？" class="headerlink" title="2.3 为什么有钱人偏爱指数基金？"></a>2.3 为什么有钱人偏爱指数基金？</h3><p>指数的一些特性:</p><ul><li>平均性：加权平均，体现整体情况</li><li>永续性、被动性、周期性：指数会周而复始地在低估和高估之间波动。所以不用担心等不到低估的买入机会或高估的卖出机会。只要股市还存在，你就永远都不必担心指数基金会倒闭破产，也不必担心它会弄虚作假伪造盈利。所以如果我们想为自己的一生，构建一个长达几十年的投资计划，指数基金就是非常好的选择了。</li><li>低风险：却能避免很多个股的风险</li></ul><p>指数的被动性，让我们可以摒弃人性的恐惧与贪婪；指数的永续性，让我们遭受本金永久性损失的可能性大大降低；指数的周期性，给我们提供了源源不断的买入和卖出机会；指数具备个股的特性，让我们可以用价值投资策略去分析它，同时避免一些风险</p><p>因此，考虑到10年以上仍旧可以战胜指数的投资者比例不到5%，投资指数基金对于缺少能力圈的投资者来说还是可以接受的</p><h2 id="第三章-了解指数基金"><a href="#第三章-了解指数基金" class="headerlink" title="第三章 了解指数基金"></a>第三章 了解指数基金</h2><h3 id="3-1-什么是指数基金？—是按照一定的规则选出了一篮子的股票"><a href="#3-1-什么是指数基金？—是按照一定的规则选出了一篮子的股票" class="headerlink" title="3.1 什么是指数基金？—是按照一定的规则选出了一篮子的股票"></a>3.1 什么是指数基金？—是按照一定的规则选出了一篮子的股票</h3><p>例如，不同家基金公司都有追踪沪深300指数的ETF基金</p><h3 id="3-2-指数基金的误差"><a href="#3-2-指数基金的误差" class="headerlink" title="3.2 指数基金的误差"></a>3.2 指数基金的误差</h3><p>指数只是一个数学公式，而购买指数基金要首选大基金公司经过长时间运营的指数基金，才能较为准确的拟合目标指数，实现预期盈利</p><p>绝大多数长期运行的指数基金，其长期收益高于指数的收益。原因是指数大多不考虑成分股的分红，而指数基金会把收到的分红攒一攒，定期以现金的形式分红，在长期复利作用下，跟指数之间的差距会越来越大</p><p>ETF基金也有一些隐藏的风险：基金始终未满仓，导致基金与指数运作误差大；跨境指数基金存在汇率风险，没有对冲等等。操作这些基金的时候，需要留出更大的安全空间。例如H股ETF，它就有10%以上的现金没有投资，同时也有汇率风险，所以，在投资它的时候就要预留出更大的安全空间</p><p>避免风险的要点：</p><p>首选大基金公司，尽量避免上市未满一年的基金，或者有长时间拖延建仓的恶性基金公司，汇率风险—跨境指数基金的汇率风险，不同渠道的指数基金导致的管理费用不同（一般场内基金比场外基金的费率低，误差更小）</p><h3 id="3-3-宽基指数基金：最稳健的指数基金"><a href="#3-3-宽基指数基金：最稳健的指数基金" class="headerlink" title="3.3 宽基指数基金：最稳健的指数基金"></a>3.3 宽基指数基金：最稳健的指数基金</h3><p>行业指数：</p><ul><li>与宽基指数对应的是行业指数，分为一级行业、二级行业等，例如能源，这属于一级行业；石油行业就属于能源下面的二级行业，石油开采行业就更加细分，属于三级行业。行业细分到极限就是个股。</li></ul><p>宽基指数：</p><ul><li><p>如果指数包括10只以上股票，单个成分股权重不超过30%，权重最大的5个股票累计权重不超过指数的60%，并且成分股日均交易额超过5000万美元，同时包含的行业种类要多。那这个指数可以称为宽基指数。</p><p>  宽基指数的最大优势：包括了各行各业，盈利远比单一成分股更加稳定。成分股越多，覆盖行业越多，分配越均匀，宽基指数的盈利也就越稳健</p><p>  例如沪深300包括300只股票，基本覆盖了各行各业    </p><h2 id="第四章-指数基金的估值"><a href="#第四章-指数基金的估值" class="headerlink" title="第四章 指数基金的估值"></a>第四章 指数基金的估值</h2></li></ul><h3 id="4-1-什么是估值？"><a href="#4-1-什么是估值？" class="headerlink" title="4.1 什么是估值？"></a>4.1 什么是估值？</h3><p>对于股票来说，有实际波动的市场交易价，也有从资产盈利角度、资产价值角度的估值</p><p>最常见的股票估值有三个：<strong>市盈率（PE）、市净率（PB）、股息率</strong></p><h3 id="4-2-衡量盈利的溢价：市盈率"><a href="#4-2-衡量盈利的溢价：市盈率" class="headerlink" title="4.2 衡量盈利的溢价：市盈率"></a>4.2 衡量盈利的溢价：市盈率</h3><p>市盈率的定义是：公司市值/公司盈利（即PE=P/E，其中P代表公司市值，E代表公司盈利）。最具参考意义的是静态市盈率（取用公司上一年度的净利润）</p><p><strong>市盈率反映了我们愿意为获取一元的净利润付出多少代价</strong></p><p>例如某个公司的市盈率是10，就代表我们愿意为这个公司的1元盈利付出10元。</p><h3 id="4-3-衡量净资产的溢价：市净率"><a href="#4-3-衡量净资产的溢价：市净率" class="headerlink" title="4.3 衡量净资产的溢价：市净率"></a>4.3 衡量净资产的溢价：市净率</h3><p>市净率指的是每股股价与每股净资产的比率，也就是我们说的账面价值。</p><p>净资产通俗来说就是资产减去负债，它代表全体股东共同享有的权益。具体的计算在上市公司的年报中都有。净资产这个财务指标比盈利要更加稳定。而且大多数公司净资产都是稳定增加的，大都可以计算市净率。</p><p><strong>净资产收益率ROE</strong>：即净利润除以净资产，ROE越高的企业，资产运作效率越高，市净率也就越高。</p><p>如果一个企业主要靠无形资产来经营，像律师事务所、广告服务公司、互联网公司，那市净率就没有多少参考价值了。</p><p>企业的资产大多是比较容易衡量价值的并且长期保值的资产，例如工厂、土地、铁路、存货等，这样的企业，很适合用市净率。如果周期股的资产主要是有形资产，并且资产长期保值，那这个周期股就很适合用市净率估值。</p><p>像证券、航空、航运、能源等都很适合用市净率估值。所以一些周期性的行业指数基金，适合用市净率来估值；如果宽基指数基金遇到了短期的经济危机，盈利不稳定，也可<br>以用市净率来辅助估值。</p><h3 id="4-4-到手的真金白银：股息率"><a href="#4-4-到手的真金白银：股息率" class="headerlink" title="4.4 到手的真金白银：股息率"></a>4.4 到手的真金白银：股息率</h3><p><strong>股息是投资者不减少所持有的股权资产，就可以直接分享企业业绩增长的最佳方式。</strong></p><p>股息率与分红率：</p><ul><li>股息率是企业过去一年现金派息额除以公司的总市值。</li><li>而分红率是企业过去一年的现金派息额除以公司的总净利润</li><li>分红率一般是公司预先就设置好了，并且连续多年都不会有什么改变。例如工商银行等，分红率都在50%，即会把过去一年的净利润的50%，以现金形式派息。</li><li>而股息率则会随着股价波动：股价越低，股息率就越高。</li></ul><p>股息有什么用：</p><ul><li><p>普通人买股票只是享受到低买高卖带来的收益，而一家公司的净利润分红一般享受不到。如果一家公司发展很好，净利润很多但股价没涨，那么我们无法享受这种红利，那么股息则可以将公司的业绩增长映射到投资者的现金收益上，你无须出售手里的股权，就可以获取不断增长的现金流。</p><p>  如果以获取股息为目的，持有工商银行的股票，每股分红从2007年的0.16元，上涨到了今年的2.55元。股息收益大幅上涨，与业绩上涨同步。</p><p>  还有一个好处就是，国家控股很过国企但是很少会出售该国企的股票，那么国家享受收益的方法就是提高公司的分红率，从而每年获得高额股息。</p><p>  <strong>股息是一个长期持有股权资产，同时享受现金流收益的好方法。通过长时间持有高股息股票资产组合</strong>，你可以无须关注股价涨跌，通过收获越来越高的现金分红轻松实现财务自由。这是长期投资股票类资产最好的收益方式，我们再也无须为波动的股价而忐忑不安，每年收取稳定增长的现金分红。</p></li></ul><h3 id="4-5-指数基金的估值怎么查？"><a href="#4-5-指数基金的估值怎么查？" class="headerlink" title="4.5 指数基金的估值怎么查？"></a>4.5 指数基金的估值怎么查？</h3><p>股票基金包括的是一篮子股票，因此本质上股票基金也是一只特殊的股票。所以股票的估值方法也适用于股票基金，但自行计算股票基金的估值很麻烦，大多数股票基金都没有计算估值。</p><p>但指数基金通常有估值，怎么查：</p><ul><li>1.雪球螺丝钉：每个交易日的晚上会公布当天收盘后的指数基金市盈率与市净率估值</li><li>2.<a href="http://www.csindex.com.cn/" target="_blank" rel="noopener">中证指数官网</a></li><li>3.<a href="http://www.swsindex.com/" target="_blank" rel="noopener">申万历史数据</a></li></ul><h2 id="第五章-当下追踪的指数基金"><a href="#第五章-当下追踪的指数基金" class="headerlink" title="第五章 当下追踪的指数基金"></a>第五章 当下追踪的指数基金</h2><p>沪深300代表蓝筹，中证500代表中小股，上证50代表超大蓝筹。这三者中，上证50的估值是最低的，但ROE是最高的（主要原因也是因为银行股）。</p><p>H股指数：主要是国内大型国企在香港上市的H股，主要成分股与上证50的成分股类似，基本可以看作对标。</p><p>上证50与H股指数很相近，这两个指数谁更低估谁就更有投资价值。估值的标准就是市盈率：</p><ul><li>上证50诞生于2004年初，从1000点起步，到2015年11月25日收盘的指数是2459点，上涨了145.9%。</li><li>同时期H股指数从3832点上涨到今天的10127点，上涨了164.2%，大幅高于上证50指数。</li></ul><p>恒生指数：代表的是港股的蓝筹股，从香港交易所的所有上市公司中，选出50家规模最大、流动性最好的公司组成，用来反映香港股市的整体水平，恒生指数也非常注重流<br>动性。这点上，恒生指数的定位和沪深300有些类似，不过没有沪深300的成分股多。恒生指数是一个老牌优秀指数。它收益稳定，估值分布合理，平均股息率也比A股高很多。</p><p>他推荐华夏公司的恒生ETF（159920），但是我买不买还要再分析下</p><p><strong>红利指数</strong>：采用高股息策略。挑选了上证交易所过去两年现金分红最高、市值最大、流动性最好的50只股票。一般A股分红高的股票大多是一些成熟行业的蓝筹股，所以可以把红利指数看作是一个蓝筹股指数。市场上追踪红利指数的ETF是上证红利ETF（510880），也是我投资时间最长的一只基金了。</p><p>指数基金严格追踪指数，所以现金分红会影响基金的追踪。基金会把股票分红积累起来，攒一攒后再分红。这点上红利ETF做得不错，基本做到了每年现金分红。如果考虑长期持有拿现金分红，可以考虑红利ETF，是不错的长期<strong>养老品种</strong>。</p><p>道琼斯指数：我们都知道，美国股市的历史比A股长很多。在美股有一个最著名的指数，叫道琼斯指数。道琼斯指数成立于1884年，由当时美国影响力最大的12只股票组成，最初只有40多点，在随后的一百多年里，道琼斯指数经历了第一次、第二次世界大战，经历了石油危机金融危机，从40多点慢慢涨到了17000多点，上涨了足足400多倍，现在是30支成分股。</p><h2 id="第六章-怎么投资指数基金"><a href="#第六章-怎么投资指数基金" class="headerlink" title="第六章 怎么投资指数基金?"></a>第六章 怎么投资指数基金?</h2><p>如果我们在2007年大牛市的时候投资沪深300，恐怕我们到现在仍然没有解套。所以说在投资指数基金的时候，也是需要正确的策略的。</p><h3 id="6-3-格雷厄姆的估值方法：盈利收益率"><a href="#6-3-格雷厄姆的估值方法：盈利收益率" class="headerlink" title="6.3 格雷厄姆的估值方法：盈利收益率"></a>6.3 格雷厄姆的估值方法：盈利收益率</h3><p><strong>盈利收益率</strong>=股票盈利/股票市值，是市盈率的倒数。</p><p>例如一个股票的每股盈利为1元，当前股价为8元，那这个股票的盈利收益率就是1/8，也就是12.5%</p><p>盈利收益率这种表达方式，让我们可以方便地将指数基金与债券利率、其他指数基金的盈利收益率、房地产的租售比、银行理财的年收益率等等横向比较，从而选出最值得投资的一类。</p><p>简单说，盈利收益率就是让我们把股票看作一种特殊的债券，盈利收益率就是这只债券的利率。</p><h3 id="6-4-两个指标买对指数基金（什么时候买）"><a href="#6-4-两个指标买对指数基金（什么时候买）" class="headerlink" title="6.4 两个指标买对指数基金（什么时候买）"></a>6.4 两个指标买对指数基金（什么时候买）</h3><p>格雷厄姆用盈利收益率去买股票的两个标准，如果满足下面两个条件，他就去买股票：</p><ul><li>盈利收益率要大于10%；</li><li>盈利收益率要在国债利率的两倍以上。</li></ul><p>同理，符合这两个要求的指数基金，就可以纳入我们的买入候选中。只有当“<strong>盈利收益率大于10%，并且盈利收益率大于国债利率的两倍以上</strong>”时，我们才会去考虑这个指数基金。</p><p><strong>在不同的资产大类之间比较收益</strong>：股票并不总是最好的选择，例如你小区有个停车位出售，你盘算了一下，可以花20万买下这个停车位，一年能收到3万租金，租售比就是15%。和10PE的股票指数相比，指数的盈利你是无法直接获得的，但是租金可以，所以停车位如果能够找到稳定的租客，是具备明显优势的。</p><p>例如，某年5月份的时候，沪深300指数的市盈率在20倍左右，换算成盈利收益率只有5%，远远小于国债利率的两倍，按照格雷厄姆的标准，在这个时候是不应该买沪深300指数基金的。</p><p><strong>盈利越稳定的品种，越适合用市盈率来估值，这点也适用于盈利收益率</strong>。大部分的宽基指数，盈利都比成分股稳定得多，适合用盈利收益率来衡量估值。如果成长性也相近，那就可以互相比较盈利收益率来发掘投资价值。大多数国家的股市指数都适合用格雷厄姆的这套方法，例如标普、纳斯达克、沪深300、MSCI中国指数、上证50、H股指数、红利指数······</p><p>PS：盈利收益率也有其局限性，它的分母是盈利，盈利是一个会计结果。对于像医药、新兴消费这种行业的公司，很多还处于高速扩张期，大部分利润都会用于再投资。所以市盈率会很高，盈利收益率很低，出现一定的失真。对于这些行业的指数，需要用别的指标来衡量。</p><h3 id="6-5-获利时，什么时候卖出？（什么时候卖）"><a href="#6-5-获利时，什么时候卖出？（什么时候卖）" class="headerlink" title="6.5 获利时，什么时候卖出？（什么时候卖）"></a>6.5 获利时，什么时候卖出？（什么时候卖）</h3><p>所以什么时候该卖出股票基金，取决于“<strong>投资者所能找到的最大无风险收益率</strong>”，并没有一个普适的标准。</p><p>例如如果我们可以找到6%的长期每年稳定现金流收益产品，而沪深300指数上涨到了20PE。我们就可以将这两个产品进行比较：一方面是高风险、收益率5%的沪深300指数，而另一方面是低风险，收益率6%的稳定现金流收益产品。我们该选择哪一个就一目了然了。</p><h2 id="第七章-定投的方法"><a href="#第七章-定投的方法" class="headerlink" title="第七章 定投的方法"></a>第七章 定投的方法</h2><p>定投的好处：</p><ul><li>对于年轻上班族，手里没有多少积蓄，那么，定投就是最好的策略了</li><li>每个月我会强制性地留存出一定量的资金用于定投，相当于强制储蓄，避免乱花钱；与此同时，定投还可以分散投资风险，避免一次性买入估值过高的股票。只要我们每次定投，都符合第六章中所说的买入标准，那么长时间坚持下来，总体也是在低估值买入的。</li></ul><h3 id="7-1-定投秘籍大公开"><a href="#7-1-定投秘籍大公开" class="headerlink" title="7.1 定投秘籍大公开"></a>7.1 定投秘籍大公开</h3><p>投资从频率和金额上，可以分为四种：<strong>定期定额投资</strong>、定期不定额投资、不定期定额投资和不定期不定额投资。</p><p>没有水平且容易心态不稳，我们最好是定期定投：无论买还是卖，都按照预先设置好的时间，并且间隔时间大致相等。</p><p>工资发下来的第二天，从工资中拿出一部分进行投资。这样基本做到了以月为间隔来定投。无论市场短期如何暴涨暴跌，我都会等到每个月的那一天，再去判断买什么、卖什么。这样就避免了主观情绪的干扰。</p><h3 id="7-2-定期不定额投资—让收益最大化"><a href="#7-2-定期不定额投资—让收益最大化" class="headerlink" title="7.2 定期不定额投资—让收益最大化"></a>7.2 定期不定额投资—让收益最大化</h3><p>由于通货膨胀、指数上涨导致每期买入的股份缩水；短期股指的波动导致每期投资价值略有不同</p><p>因此：<br>    定期、但定投的金额逐渐提升，这样的年复合收益率会更高，要保证投入的额度与指数基金的盈利增长速度<br>接近。<br>    越是低估，定投对应的那一期的额度越要增加</p><h2 id="第八章-构建属于自己的定投计划"><a href="#第八章-构建属于自己的定投计划" class="headerlink" title="第八章 构建属于自己的定投计划"></a>第八章 构建属于自己的定投计划</h2><h3 id="8-0-核心知识"><a href="#8-0-核心知识" class="headerlink" title="8.0 核心知识"></a>8.0 核心知识</h3><p><strong>什么时候买：</strong>只有当“盈利收益率大于10%，并且盈利收益率大于国债利率的两倍以上”时，我们才会去考虑这个指数基金。换句话说，我们只会从符合这两条标准的指数基金中去挑选。这就解决了“买什么”的问题。</p><p><strong>什么时候卖：</strong>“只有当我们能够找到比股票盈利收益率更高的稳健品种（其他基金、车位、房子）时，我们才会考虑卖出股票”。这就方便了我们在股票和其他资产大类之间横向比较，选择当下最佳的资产大类，解决了“卖什么”这个问题。</p><p>如何买：<strong>定期不定额投资</strong></p><h3 id="8-1-梳理自己的需求"><a href="#8-1-梳理自己的需求" class="headerlink" title="8.1 梳理自己的需求"></a>8.1 梳理自己的需求</h3><p>构建一个长期的定投计划：未来1年要用的钱，不应该那来投资股票这类资产；只有这笔钱在未来10年以上都不用，才可投资。</p><h3 id="8-2-梳理自己的现金流"><a href="#8-2-梳理自己的现金流" class="headerlink" title="8.2 梳理自己的现金流"></a>8.2 梳理自己的现金流</h3><p>上班族最常见的收入就是工资，用记账app记录每个月的开支，日常不必要的支出可以减少：例如抽烟喝酒的支出可以控制一下，像买书学习锻炼身体等方面的支出可以不变。额度较高的不必要消费可以为你节省下不小的现金流。</p><p>用每月工资减去日常必要开销后的现金流，做长期定投计划</p><h3 id="8-3-找到当下适合投资的基金"><a href="#8-3-找到当下适合投资的基金" class="headerlink" title="8.3 找到当下适合投资的基金"></a>8.3 找到当下适合投资的基金</h3><p>用“盈利收益率”法去选指数基金即可。</p><p>盈利收益率要大于10%；盈利收益率要大于国债利率的两倍以上。<br>当前我国十年期国债利率也不过3.1%，两倍就是6.2%。所以我们只需要找盈利收益率大于10%的指数基金即可。盈利收益率是市盈率的倒数，盈利收益率大于10%，意味着市盈率要小于10。我们介绍过指数的估值该如何查询。大家可以直接看我的雪球主页就可以查到。</p><p>当前满足条件的ETF指数基金有三只，分别是H股ETF，红利ETF，和恒生ETF。这三只基金各自有各自的特点。恒生覆盖的行业更广泛，盈利更稳定；H股指数的估值更低；红利指数的现金分红更稳定。这三只都挺符合长期定投的要求。这就需要针对我们的需求来选择合适的基金了。</p><p>如果没有特殊要求，我们可以选H股指数；如果不想承担更高的股价波动，可以选择盈利更稳定的恒生指数；如果想未来依靠基金的分红来更好的生活，那么每年都会分红的红利指数是更好的选择。</p><h3 id="8-4-构建自己的定投计划"><a href="#8-4-构建自己的定投计划" class="headerlink" title="8.4 构建自己的定投计划"></a>8.4 构建自己的定投计划</h3><p>选好了基金，开始定期不定额的投资。</p><p>假如我们当下每个月能拿出1000元用于定投而不会影响正常生活。那<strong>之后每个月需要将定投的金额增加1%</strong>。这样可以避免通货膨胀和基金盈利上涨导致的定投份额下降。</p><p>同时，如果基金短期里下跌，我们可以根据估值提升当月买入的金额，这样可以在更便宜的时候买入更多的基金。结合下面这个公式：</p><p>例如我从2015年12月份开始第一次定投恒生指数，初始金额1000元。到了2016年5月份，是我定投的第六个月份，市盈率PE下跌到了8。那我2016年5月份应该定投的资金是：</p><p>如果在持有过程中，我们发现了一个年收益率能达到6%的低风险理财产品，我们可以在16倍PE的时候卖出恒生指数基金，卖出的钱转为买6%的低风险理财产品。</p><h3 id="8-5-将定投计划落在纸面上，坚定不移地执行"><a href="#8-5-将定投计划落在纸面上，坚定不移地执行" class="headerlink" title="8.5 将定投计划落在纸面上，坚定不移地执行"></a>8.5 将定投计划落在纸面上，坚定不移地执行</h3><h3 id="8-6-做好定投记录，方便监督管理"><a href="#8-6-做好定投记录，方便监督管理" class="headerlink" title="8.6 做好定投记录，方便监督管理"></a>8.6 做好定投记录，方便监督管理</h3><p>我们还要做好定投记录，方便日后进行复盘，监督检查自己是否正确地执行了计划。这里贴一个我过去一年半的定投记录，给大家一个参考。</p><p>记录下自己买入的日期、品种、操作、价格，对应的市盈率和盈利收益率估值，方便以后查看。</p><h2 id="第十章-长期投资的心理建设"><a href="#第十章-长期投资的心理建设" class="headerlink" title="第十章 长期投资的心理建设"></a>第十章 长期投资的心理建设</h2><p>方法并不难，核心就是<strong>每次都在指数基金处于低估值的时候才定投，在正常估值的时候持有，在高估的时候卖出，如此循环往复</strong>。</p><p>例如沪深300和恒生指数，它们的主要估值集中在10—18PE，低于10PE就是低估区域，不断买入；10—18PE持有，18PE以上分批卖出。</p><p>因为我们是长期定投，而低估值投资指数基金收益来自两部分：一个是低买高卖的估值差，另一个是在持有的这段时间里盈利的增长。短期里的收益主要是估值差带来的，<strong>长期收益主要是盈利增长带来的。因此在这期间，不要止盈止损且要拥抱下跌，</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术外 </category>
          
          <category> 投资理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里云oss做博客图床</title>
      <link href="/2020/02/29/oss-img-bed/"/>
      <url>/2020/02/29/oss-img-bed/</url>
      
        <content type="html"><![CDATA[<p>使用阿里云oss做博客图床，稳定且成本低，一劳永逸。</p><a id="more"></a><h2 id="什么是oss"><a href="#什么是oss" class="headerlink" title="什么是oss"></a>什么是oss</h2><p>oss(Object Storage Service)是可以储存任何文件的，并提供多节点数据分发的服务，当然也可以用作稳定且专业的图床。</p><p>阿里云oss特点：</p><ul><li><p>一个可以进行上传、下载文件资源等操作，并可文件资源可管理的云存储服务器。</p></li><li><p>拥有可针对第三方用户分配RAM(子账号)，针对临时用户的STS模式的权限管理</p></li><li><p>一个提供用户权限、文件操作、日志管理的多功能管理平台</p></li></ul><h2 id="为何要用阿里云oss做图床？"><a href="#为何要用阿里云oss做图床？" class="headerlink" title="为何要用阿里云oss做图床？"></a>为何要用阿里云oss做图床？</h2><ul><li><p>免费且专业的图床：SM.MS等，但不稳定</p></li><li><p>免费但不专业的图床：qq空间相册、CSDN、gitee等，但有限制外链的风险</p></li><li><p>收费且专业的图床：七牛云、Chevereto，必须要有备案域名，备案必须有主机—&gt;需要一台服务器，成本太高，不可行</p></li><li><p>收费但比较便宜，也专业的图床：阿里云oss，存储空间一年7元，计量收费每月5GB免费，稳定、便宜，一劳永逸</p></li></ul><h2 id="开通阿里云oss"><a href="#开通阿里云oss" class="headerlink" title="开通阿里云oss"></a>开通阿里云oss</h2><p>首先开通阿里云、购买存储空间，流量包不用买，计量收费就行</p><p>然后进行oss控制台创建存储空间（bucket)，读写权限公共读</p><p>然后创建专门管理oss的用户并设置权限，总账号有AccessKey ID、 Access Key Secret ID，但拥有全部权限，因此最好创建只有oss管理权限的用户：</p><pre><code>在RAM访问控制台新建用户(名字如oss-user)，并勾选控制台密码登录、编程访问对oss-user设置AliyunOSSFullAccess权限记录下oss-user用户的AccessKey ID、 Access Key Secret ID用于后续登录oss与管理</code></pre><p>对已经建好的bucket绑定用户域名（自己已经注册的域名），并在域名解析服务中建好解析。如<code>img.yourdomain -&gt; yourbucketname.oss-cn-hongkong.aliyuncs.com</code></p><p>在oss控制台下载ossbrowser上传工具，登录步骤如下：</p><pre><code>先对oss服务endpoint：cname，https://img.yourdomainAccessKeyId、AccessKeySecret：使用oss-user用户登录预设OSS路径：oss://bucketname</code></pre><p>除了阿里云官方的ossbrowser，还有一款比较好上传工具：<a href="https://github.com/gee1k/uPic/releases" target="_blank" rel="noopener">uPic</a></p><p>至此，可以通过ossbrowser进行oss云存储服务的上传下载文件了，但要需要下列细化操作。</p><h2 id="阿里云oss费用"><a href="#阿里云oss费用" class="headerlink" title="阿里云oss费用"></a>阿里云oss费用</h2><p>存储空间：买了40GB，一年，7.2元。</p><p>流量：没买包年，我的bucket区域在香港，香港计量每个月都有0-5GB免费，超过0.72元/GB。且上传文件没费，只针对浏览、下载数据的流量收费。</p><p>oss只用作图床的话存储空间绝对够用，只是流量5GB以内还是有点悬的，因此需要做图片时需要压缩，同时要做好防盗链。</p><h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h2><p><a href="https://tinyjpg.com/" target="_blank" rel="noopener">图片压缩网站</a></p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p>由于OSS是按使用量收费的服务，为了减少存储于OSS的数据被其他人盗链而产生额外费用，因此需要防盗链。</p><p>通过控制台为bucket设置Referer字段的白名单、设置是否允许Referer字段为空的请求访问。</p><p>设置 OSS 白名单：这里设置为自己网站域名<a href="http://www.domain，即在header请求头中，Referer" target="_blank" rel="noopener">www.domain，即在header请求头中，Referer</a> 为<a href="http://www.domain的网站，才能允许访问，否则直接拒" target="_blank" rel="noopener">www.domain的网站，才能允许访问，否则直接拒</a></p><p>是否允许空Referer：允许为空，这样博客编辑中也能显示</p><h2 id="博客图片使用步骤"><a href="#博客图片使用步骤" class="headerlink" title="博客图片使用步骤"></a>博客图片使用步骤</h2><p><a href="https://tinyjpg.com/" target="_blank" rel="noopener">图片压缩</a> -&gt; uPic上传(压缩10%) -&gt; 在md中粘贴引用链接</p>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考认知</title>
      <link href="/2020/02/28/thinking-cognition/"/>
      <url>/2020/02/28/thinking-cognition/</url>
      
        <content type="html"><![CDATA[<p>思考认知方面螺旋上升过程的进修笔记</p><a id="more"></a><h1 id="结构化思维"><a href="#结构化思维" class="headerlink" title="结构化思维"></a>结构化思维</h1><p>以下总结主要参考知乎的这篇:<a href="https://zhuanlan.zhihu.com/p/45492055" target="_blank" rel="noopener">金字塔原理的结构化思维</a></p><p>结构化思考的步骤:</p><p>第一步：明确目的，找到分解角度</p><p>第二步：按MECE原则，组成金字塔结构</p><p>方式 1：自上而下「使用演绎法」设计结构(金字塔顶层的分类比较重要)</p><p>方式 2：自下而上「使用归纳法」提炼结构(头脑风暴+归纳)</p><p>第三步：调整结构，给出方案</p><p><strong>结构化思维的进阶技巧–平面切割法</strong></p><p>1.法一：如果我们能找到一件事情中，既对立、又统一的两面，我们就可以在一张纸上一条线，将他们彼此分开，组合成一个对立统一体，而他们两者也一定是MECE的，如此可以在一张纸张分出多条线</p><p>2.法二：依赖于已有的轮子，更快速。如商业模式的商业模式画布、思维更缜密的5W2H结构等</p><h1 id="如何提高思考能力"><a href="#如何提高思考能力" class="headerlink" title="如何提高思考能力"></a>如何提高思考能力</h1><p>首先要搞清楚<strong>学习的真正目的</strong>是什么，目的不是为了学习完成(就像高考结束后扔书)，而是<strong>为了更高效的解决问题！</strong></p><p>如果学习的目标变成了解决问题，那么学习就变成了过程，知识就变成了解决问题的要素。那么知识是如何帮助你解决问题的？</p><p><code>学习知识--提高思考质量--解决问题的效率</code></p><p>因此，<strong>学习的真正目的，是为了提高思考质量</strong>！参考小时候学习的乘法口诀，现在遇到7*8我们不会用加法一个一个去数，而是直接得出答案。</p><p>好了，观念转变过来后，我们来看看<strong>对一件事的思考，具体经历了哪些步骤：</strong></p><p>1.<strong>连接相关背景知识</strong>。我们首先会根据问题，在自己的知识库中搜索相关的背景知识，可以是概念，方法论，或者别人的经验，或者自己的所见所闻的信息，也可以是其他行业的知识…</p><p>总之，在这个过程中，大脑中会冒出很多与问题相关的各种信息。</p><p>如果能连接到的背景信息很少，我们就无法有效的思考，甚至都不能理解题目的意思…</p><p>而你掌握的背景知识越多，可用于思考的要素就越多，最终给出的方案也会越全面。当别人还在理解问题的时候，你可能已经连接到一个方法论，并开始侃侃而谈了…</p><p>2.<strong>梳理这些背景知识</strong>。想到的这些背景知识可能会很零碎，你需要结合问题，把他们重新排列组合一下，梳理成一条完整的信息，形成最终的结论。</p>]]></content>
      
      
      <categories>
          
          <category> 技术外 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算法心得总结</title>
      <link href="/2020/02/27/normal-algorithms-summary/"/>
      <url>/2020/02/27/normal-algorithms-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="心得目录"><a href="#心得目录" class="headerlink" title="心得目录"></a>心得目录</h1><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">二分查找</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">矩阵原地转置</a></td></tr></tbody></table><h1 id="算法心得"><a href="#算法心得" class="headerlink" title="算法心得"></a>算法心得</h1><p><a name="1"></a></p><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h2><ul><li><p>有序数组考虑二分</p></li><li><p>二维矩阵中路径查找问题通常用回溯法。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。</p></li><li><p>对int型整数，注意MIN越界问题</p><pre><code>  MIN_VALUE取反还是MIN_VALUE  MAX_VALUE+1=MIN_VALUE  [−2^31,  2^31 − 1]</code></pre></li></ul><pre><code class="java">//二分查找boolean find(int[] nums, int key){    int left = 0;    int right = nums.length-1;    // 这里必须是&lt;=    while(left&lt;=right){        int mid = (left + right) / 2;        if(key==nums[mid]){            return true;        }        if(key&lt;nums[mid]){            right = mid - 1;        }        else{            left = mid + 1;        }    }    return false;}</code></pre><p><a name="2"></a></p><h2 id="2-矩阵原地转置"><a href="#2-矩阵原地转置" class="headerlink" title="2.矩阵原地转置"></a>2.矩阵原地转置</h2><pre><code class="c++">#include &lt;iostream&gt;using namespace std;//二维数组原地转置   注意是原地转置void zhuanzhi(int a[4][4]){    for(int i=0;i&lt;4;i++)    {        for(int j=i+1;j&lt;4;j++)        {            //交换两个数            swap(a[i][j],a[j][i]);        }    }}int main(){    int test[4][4]={        {1,2,3,4},        {1,2,3,4},        {5,6,7,8},        {0,0,0,0}    };    zhuanzhi(test);    //输出转置后的数组    for(int i=0;i&lt;4;i++)    {        for(int j=0;j&lt;4;j++)        {            cout&lt;&lt;test[i][j]&lt;&lt;&quot; &quot;;        }        cout&lt;&lt;endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研二找工作过程总结</title>
      <link href="/2020/02/23/master-seek-job/"/>
      <url>/2020/02/23/master-seek-job/</url>
      
        <content type="html"><![CDATA[<p>本博文记录研二春招实习、秋招找工作的阶段经历。</p><a id="more"></a><h2 id="春招实习"><a href="#春招实习" class="headerlink" title="春招实习"></a>春招实习</h2><p>当初并没有采取北邮普遍的广撒网策略，对自己有较为清晰的目标定位同时精力也是有限的，面试再多家拿再多offer最后也都只能去一家，所以只投了几家大厂。最后的结果是拿到腾讯、阿里、华为三家offer后，思考这三家基本涵盖了我的目标base、目标公司与目标岗位，只需要在这三家选择就可以了，因此没有再继续投别的公司，之前投过的有面试也宛然拒绝了。</p><p>时过一年再回忆不免有些不记得，把能想起来的罗列如下：</p><pre><code>春招实习投递：腾讯、阿里、头条、360、华为、百度、邮储、建行、招行等春招实习offer：    腾讯，teg部门，c++，base深圳总部    华为，it&amp;cloud部门，c++，base深圳总部    阿里，蚂蚁金服-金融核心平台-支付交换组，java，base杭州总部    招行，fintech，base深圳总行</code></pre><p>腾讯阿里两个offer到手后，其他的基本不考虑了。两个offer比较起来各有优势与弊端，腾讯teg清水衙门，非业务部门，做集团的技术支撑，技术发展没的说，但个人认为腾讯主要以产品为主，不做产品意味着部门旱涝保收且对上游业务嗅觉不足，长远来看光做技术也不行，毕竟技术永远在为业务服务；蚂蚁金服这边是支付核心，我眼中的阿里每年的双11如果没有高并发的支付技术支撑是不可能大放异彩的，同时缺点是杭州整体互联网氛围没有深圳好，为数不多的几家大厂很有可能本土一言堂等。在两家中间纠结了几天，最后选择了阿里，也宛然拒绝了腾讯的hr小姐姐。总体来说，腾讯阿里两个offer各有利弊，特点鲜明，最终的选择也是结合了自身的规划与对未来的预期，选择没有对错，既然已定，那就义无反顾，勇往直前。</p><p>之后暑期就去阿里实习了。在主管和师兄师姐的带领下，完成了两三个项目，其中一个项目是完整跟下来，最后上线了两个项目，在最后转正答辩中有幸顺利转正，拿到了秋招offer。</p><h2 id="秋招找工作"><a href="#秋招找工作" class="headerlink" title="秋招找工作"></a>秋招找工作</h2><p>坦白说在阿里转正拿到offer后，回学校我一份简历也没有投过，这在北邮秋招求职季中绝对算是一股清流。除阿里之外，正式拿到的还有招行、华为，以下简单介绍我的秋招经历。</p><pre><code>秋招投递：没有投递秋招offer：    阿里，蚂蚁金服-金融核心平台-支付交换组，java，base杭州总部    招行，信息技术部，行员编制，base深圳总行    华为，it&amp;cloud部门，15级且有股票，业务方向随我选，主管推荐做分布式存储，c++，base成都杭州随我选</code></pre><p>我在研一对自己未来的规划是毕业后去深圳发展。之前去过几次，喜欢海边，同时深圳是一个年轻的城市，还曾专门让表哥带我去了腾讯总部和招行总部看了看，当时想着有一天我能来这两家的任何一家工作就好了，没想到最后有幸实现了自己的愿望但都没去，计划总是赶不上变化。</p><p>深圳相对熟悉一些，但对杭州是完全陌生并且之前也没有考虑过，自从拿到阿里的实习offer后，我就一直在关注杭州与深圳两个城市，从楼市、人才发展、未来潜力等方面综合对比着看，具体的结论我就不说了，每个人各有所志，各有所属，最后在以上三个方面来说我选择了杭州与阿里，并且我深知我选择杭州的原生驱动力，这样以后也就不会瞻前顾后或心生懊悔。</p><p>至于为什么没有投base在北京的，正常来讲北邮情侣男的去互联网女的拿户口，但我不考虑留北京，因此也就一份也没有投。北京到底好不好，各种辛酸也只有真正留北京的职场人才能理解。在北京求学8年，虽然是学生，但我深知毕业后在北京的工作生活我自己的状况，志不在此难以强求，还是为北京舒缓人口压力做些贡献吧。</p><p>也正因如此，秋招看了看移动、华为、网易等杭州其他公司与岗位，比较来看还是想去阿里之后也就没有再投。至于北京、成都、深圳、青海（我在青海长大，回青海可以直接现场面试后进编）等其他城市，有面试的联系我也都基本没去。</p><p>这其中，华为、招行的都去了。招行7月就给offer了，当时在杭州实习还没有转正，考虑求稳冒着1万的违约金还是签了。华为的面试后隔了几天给了offer，让带着三方现场签，去现场后发现别的同学是坐在大厅等待叫号前台面谈薪资，我是被主管带到单间单独谈，后来得知笔试面试比较突出，给了博士级15级，大概的待遇是15级加股票，base杭州成都都可以，方向按自己兴趣选。坦白说我当时心动了，觉得华为比较看重我，主管和我谈了4个小时，谈(苦)笑(口)风(婆)生(心)，感受到了头一回被当成人才的feel，并不是说其他公司不看重，但对华为来说万物皆客户，华为在为让客户满意舒服这件事上不得不说是有独有的实力的，更何况就招聘来说我是华为想招的预期未来当火车头的苦力呢。总结下华为这个offer就是一切都完美，但就是更想去阿里，也许是阿里更难进的原因吧（面试了5轮+转正答辩）。anyway，最后留了主管微信，最后宛然拒绝了，再次感谢华为的重视，以后力挺华为。</p><p>最后在10月三方发下来的第一时间和阿里签了三方，秋招结束。一年的奔波与不安到此结束，落袋为安，希望今后做个合格的不给阿里丢脸的阿里人、蚂蚁人。</p><h2 id="女朋友的秋招"><a href="#女朋友的秋招" class="headerlink" title="女朋友的秋招"></a>女朋友的秋招</h2><p>我算是北邮比较幸运的，春招实习与秋招找工作的过程都还算顺利，这一年更多的是陪女朋友一起找，通过回忆记录如下。</p><p>先说春招，具体如下：</p><pre><code>春招实习投递：腾讯、阿里、头条、360、华为、百度、邮储、建行、招行等春招实习offer：    华为，it&amp;cloud部门，c++，base成都    百度，手百内容生态部，测试，base北京    百度，度小满，测试，base北京    招行，fintech，base深圳总行最后在百度度小满、百度手百都有实习</code></pre><p>秋招她投的比较多，这在我们的计划之内，当时想着既然我定了去杭州，那她就只投base在杭州的，国企事业单位的话也只投浙江省公司或是杭州市公司。</p><p>具体的秋招如下表，说明一下该表是当时随应聘过程记录的，后来基本定了去杭州招银科技后也都没有再更新，即使base在杭州的确定不想去的也都没去面试，保留该表的意义在于能还原当时投递、笔试、面试了哪些家公司，毕竟几个月奔波的时光是值得今后回忆的。</p><h5 id="应聘进度"><a href="#应聘进度" class="headerlink" title="应聘进度"></a>应聘进度</h5><table><thead><tr><th align="left">公司</th><th align="left">网申地址</th><th align="left">岗位</th><th align="left">投递结果</th><th align="left">宣讲</th><th align="left">笔试</th><th align="left">面试</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">招商银行总行</td><td align="left"><a href="http://career.cloud.cmbchina.com/index.html#jobList?id=96574F8D-C7ED-4772-AE7C-BAC896D190C1" target="_blank" rel="noopener">官网地址</a></td><td align="left">信息技术部</td><td align="left">已签两方</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">两个人都签了，违约金1万<br />管培生竞赛没参加，直接被捞起进入提前批面试并通过</td></tr><tr><td align="left">移动杭研</td><td align="left"><a href="https://job.10086.cn/personal/campus/" target="_blank" rel="noopener">官网地址</a></td><td align="left">软件开发工程师<br />云计算研发工程师</td><td align="left">已投</td><td align="left">09-29 <br />19：00<br /><a href="http://live.51job.com/watch/3681456" target="_blank" rel="noopener">空中宣讲</a></td><td align="left">11-2，没去</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">光大银行</td><td align="left"><a href="http://campus.51job.com/cebbank/jobs.htm" target="_blank" rel="noopener">官网地址</a></td><td align="left">杭州分行信息科技岗</td><td align="left">已投</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">华为</td><td align="left"><a href="http://career.huawei.com/reccampportal/portal4_index.html#!portal/usercenter4/recruitmentProgress/recruitmentProgress.html" target="_blank" rel="noopener">官网地址</a></td><td align="left">杭州测试工程师</td><td align="left">已投<br />现场面试<br />没有offer</td><td align="left"></td><td align="left"></td><td align="left">10-14 <br/>9：45 中央硬件工程院部门-测试工程师</td><td align="left"></td></tr><tr><td align="left">网易<br /></td><td align="left"><a href="https://campus.163.com/app/personal/interview" target="_blank" rel="noopener">官网地址</a></td><td align="left">网易严选测试开发工程师</td><td align="left">已投<br />测评完成<br />笔试完成<br /><em>笔试未通过</em></td><td align="left"></td><td align="left">09-21 15：00-17：00<br /></td><td align="left"></td><td align="left">单选10题；编程4题；问答2题<br />编程50%、30%、0、0</td></tr><tr><td align="left">中国电信</td><td align="left"><a href="https://job.bupt.edu.cn/recruitment.2.ff8080816b9d4f8b016d0424843131eb.html" target="_blank" rel="noopener">北邮就业网公告</a></td><td align="left">1、浙江省公司（本部）—IT运营（含优培生）（企业信息化部）<br />2、杭州分公司 —IT运营<br />3、四川省公司–IT研发<br />4、四川省公司–互联网金融平台开发</td><td align="left">已投<br />测评完成<br />不去了</td><td align="left">10月9日 <br />14:00—15:30 <br />科学会堂<br />分公司见面会<br />10月9日 <br />15:30—18:00 <br />体育馆</td><td align="left">10-27北邮3-333</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">中国联通</td><td align="left"><a href="https://zglt2020.zhaopin.com/careers.html" target="_blank" rel="noopener">官网地址</a></td><td align="left">1、浙江省公司互联网产品开发<br />2、浙江省分公司java工程师<br />3、联通网络技术研究院 软件开发工程师</td><td align="left">已投<br />测评完成<br />风评太差初面没有去</td><td align="left">10月10日 <br />14:00—15:30 科学会堂 <br />分公司见面会<br />10月10日 15:30—18:00 <br />体育馆</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">工商银行</td><td align="left"><a href="https://campus.icbc.com.cn/icbc/campus/default.htm" target="_blank" rel="noopener">官网地址</a></td><td align="left">1、 软件开发中心(杭州)–java开发<br />2、软件开发中心(杭州)–java测试<br />3、杭州金融研修学院–业务类-信息科技</td><td align="left">已投<br />测评完成<br />笔试通过<br />面试完成等结果</td><td align="left">9月20日 18:30-20:30 <br />3-335</td><td align="left">10-13 14：00 北林</td><td align="left">10-24上午8：50研发中心面试</td><td align="left"></td></tr><tr><td align="left">中信银行</td><td align="left"><a href="https://job.citicbank.com/" target="_blank" rel="noopener">官网地址</a></td><td align="left">杭州分行本部–信息科技岗</td><td align="left">已投</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">浙商银行</td><td align="left"><a href="https://zp.czbank.com.cn/zpweb/planController/gotoIndex.mvc?pageType=1" target="_blank" rel="noopener">官网地址</a></td><td align="left">总行机关岗位（杭州）</td><td align="left">已投<br />测评完成<br />笔试完成</td><td align="left">9.17<br />北航</td><td align="left">10-25下午</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">新华三</td><td align="left"><a href="https://h3c.zhiye.com/Campus" target="_blank" rel="noopener">官网地址</a></td><td align="left">1、测试工程师（杭州）<br />2、软件工程师（杭州）</td><td align="left">已投<br />笔试放弃</td><td align="left"></td><td align="left">09-21 9：00-10：30 <br />北科逸夫楼105<br /></td><td align="left"></td><td align="left">缺席没去，睡过头了</td></tr><tr><td align="left">银联</td><td align="left"><a href="https://join.unionpay.com/wt/unionpayhr/web/index/campus" target="_blank" rel="noopener">官网地址</a></td><td align="left">1、浙江分公司–技术开发<br />2、浙江分公司–产品支持</td><td align="left">已投<br />笔试完成</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">招银网络科技</td><td align="left"><a href="https://cmbnt.cmbchina.com/2020campus/index.html" target="_blank" rel="noopener">官网地址</a></td><td align="left">测试开发工程师（杭州）</td><td align="left">已投<br />笔试完成<br />一面通过<br />现场三面<br />资格审查<br />offer</td><td align="left"></td><td align="left">09-24   15:00–17:30</td><td align="left">09-27 21：56 电话一面<br />10-11 16：40现场面试</td><td align="left">给offer，已签三方</td></tr><tr><td align="left">思科</td><td align="left"><a href="http://campus.51job.com/cisco2020/template/position-software.html" target="_blank" rel="noopener">官网地址</a></td><td align="left">1、信息技术中心-供应链管理-软件研发工程师(测试研发类)-杭州-硕士<br />2、信息技术中心-供应链管理-软件研发工程师(研发类)-杭州-硕士</td><td align="left">已投<br />笔试完成<br />一面通过<br />二面等结果中</td><td align="left">09-23 19：00-21：00</td><td align="left"></td><td align="left">10-08 10：30-11：00 视频面试<br />10-14 16：00 视频二面</td><td align="left">hr，李女士<br/>给offer没签</td></tr><tr><td align="left">浙江省银保监局</td><td align="left"><a href="http://bm.scs.gov.cn/pp/gkweb/core/web/ui/business/person/person_home.html" target="_blank" rel="noopener">官网地址</a></td><td align="left">已经报名<br />资格审查通过</td><td align="left"></td><td align="left"></td><td align="left">11.23-11.24</td><td align="left"></td><td align="left">银保监局：<br />10%经济金融基础知识、<br />80%专业知识、<br />10%英语<br />国考：<br />公布时间：10.15<br />考试时间：11.23、11.24<br />浙江省考：<br />公告时间：4.9<br />报名时间：4.16<br />笔试时间：5.19<br />银保监计算机类考试侧重考察信息技术理论与实务，包括信息系统架构、软件工程与项目管理、数据库与数据挖掘分析、网络技术及应用、信息安全及信息科技风险管理等；<br/>笔试出分后没进面试</td></tr><tr><td align="left">浙江省交通投资集团有限公司</td><td align="left"><a href="http://www.cncico.com/recruit.html?nid=1&category=7212&id=5752817" target="_blank" rel="noopener">官网地址</a></td><td align="left">信息技术管培生</td><td align="left">已投</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">农业发展银行</td><td align="left"><a href="http://adbc.zhaopin.com/" target="_blank" rel="noopener">招聘官网</a></td><td align="left">浙江省分公司–信息技术岗位</td><td align="left">已投</td><td align="left"></td><td align="left">11-3 9：00</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">国家开发银行</td><td align="left"><a href="http://job.cdb.com.cn/" target="_blank" rel="noopener">招聘官网</a></td><td align="left">1、浙江分行信息科技岗<br />2、浙江分行研究规划岗</td><td align="left">已投</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">在<a href="https://xiaoyuan.zhaopin.com/Home/Resumes/UserResume" target="_blank" rel="noopener">校园招聘</a>查看报考</td></tr><tr><td align="left">中国建设银行浙江分行</td><td align="left"><a href="http://job.ccb.com/ccbjob/cn/job/index.jsp" target="_blank" rel="noopener">招聘官网</a></td><td align="left">1、浙江省分行浙江省分行本部 - 科技类专项人才<br />2、浙江省分行浙江省杭州市余杭支行 - 管理培训生</td><td align="left">已投<br />宣讲初面通过</td><td align="left"></td><td align="left">11-3笔试</td><td align="left">10-15 11：00 北邮学活初面</td><td align="left"></td></tr><tr><td align="left">海康威视</td><td align="left"><a href="http://campus.hikvision.com/campus?r=&p=&c=3301&d=&k=#jlt" target="_blank" rel="noopener">招聘简介</a></td><td align="left">测试工程师</td><td align="left">已投<br />笔试缺席</td><td align="left"></td><td align="left">笔试缺席</td><td align="left"></td><td align="left">笔试忘记了</td></tr><tr><td align="left">人民银行</td><td align="left"><a href="http://zhaopin.pbc.gov.cn/ryzp/admin/user.jsp?t=1570861635298" target="_blank" rel="noopener">招聘系统</a></td><td align="left">杭州分行–计算机</td><td align="left">已投<br />资格审查通过<br />确认考试</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">🇺🇸</td></tr><tr><td align="left">杭州银行</td><td align="left"><a href="https://campus.liepin.com/emailnotice/showlist/?xycompId=170901" target="_blank" rel="noopener">投递记录</a></td><td align="left">总行信息技术培训生</td><td align="left">已投<br />不去了</td><td align="left"></td><td align="left">10-27 <br/>10:00-11:30 北京市海淀区北洼路89号北京经济管理学校培训学校勤奋楼5层多媒体教室9</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">中国铁塔-浙江杭州</td><td align="left"><a href="http://zhaopin.chinatowercom.cn/Portal/Apply/Index" target="_blank" rel="noopener">投递记录</a></td><td align="left">技术经理-浙江杭州</td><td align="left">已投</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><p>最后她的秋招offer如下：</p><pre><code>秋招投递：投递情况如上秋招offer：    招行，信息技术部，行员编制，base深圳总行    招银科技，测试开发工程师，base杭州    百度，手百移动生态质量部，测试开发工程师，base北京    tplink，测试开发工程师，base杭州</code></pre><p>最后女朋友也在10月和招银科技签了三方。</p><p>总结来说，北邮研究生这个牌子还是不错的，主流互联网、银行、国企事业单位都还比较认可，其他的就看自己能力了。春招实习、秋招找工作的阶段经历已经结束，接下来希望能顺利毕业吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术外 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Braincao&#39;s Blog</title>
      <link href="/2020/02/21/blog-index/"/>
      <url>/2020/02/21/blog-index/</url>
      
        <content type="html"><![CDATA[<h2 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h2><p>本博客主要记录技术相关的学习笔记与总结，少量包含阶段性节点的成长轨迹与人生思索。它不像微信收藏那样碎片化，也不像商业博文太过公开，它是可自由控制且更为专业性的私人空间。</p><p>所有博文中，绝大多数为原创或有自我沉淀部分，价值高低个人不做评判，因为分享的同时也在收获自己。</p><p>由于第三方评论插件安全性不足，关闭了评论功能，如需联系我请查看关于页面。当然，本博主随时可接受金钱勾引，在每页最下方点击神奇按钮即可启动资本关怀，这是我最大的动力。</p><h2 id="实时统计"><a href="#实时统计" class="headerlink" title="实时统计"></a>实时统计</h2><p>截至目前，本人已写 <code class="article_number"></code> 篇文章， 共 <code class="site_word_count"></code> 字，</p><p>本站访问人数：<code class="site_uv"></code>人次 ， 访问量：<code class="site_pv"></code>次</p><h2 id="博客功能"><a href="#博客功能" class="headerlink" title="博客功能"></a>博客功能</h2><ul><li>搜索支持文章标题、标签(#标签)、全文搜索(in:)</li><li>pad/手机等移动端适配</li><li>页面全局vim式快捷键，快捷键说明如下</li></ul><table><thead><tr><th align="center">key</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">s/S</td><td align="center">全屏/取消全屏</td></tr><tr><td align="center">w/W</td><td align="center">显示/关闭文章目录</td></tr><tr><td align="center">gg/GG</td><td align="center">到页顶</td></tr><tr><td align="center">shift+G/g</td><td align="center">到页尾</td></tr><tr><td align="center">j/J</td><td align="center">向下滑动</td></tr><tr><td align="center">k/K</td><td align="center">向上滑动</td></tr><tr><td align="center">i/I</td><td align="center">启动搜索</td></tr><tr><td align="center">ESC</td><td align="center">若搜索框有内容，清除内容； 若搜索框无内容，取消搜索</td></tr><tr><td align="center">上</td><td align="center">向上选择文章</td></tr><tr><td align="center">下</td><td align="center">向下选择文章</td></tr><tr><td align="center">回车</td><td align="center">打开当前选中的文章，默认打开第一个</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速github访问速度</title>
      <link href="/2020/02/20/github-hosts/"/>
      <url>/2020/02/20/github-hosts/</url>
      
        <content type="html"><![CDATA[<p>通过修改hosts，解决github访问慢及加载不出头像问题</p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>github访问慢及加载不出头像问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>在<a href="https://www.ipaddress.com/" target="_blank" rel="noopener">https://www.ipaddress.com/</a>网站查下列域名对应的IP地址，如果同一个域名有好几个ip，那就ping一下选个速度最快的。</p><p>修改hosts，<code>sudo vi /etc/hosts</code>，添加下面域名解析，再刷新dns：<code>sudo killall -HUP mDNSResponder</code></p><pre><code>#解决git clone 速度慢的问题,这个不要动192.30.253.112 github.com151.101.185.194 github.global.ssl.fastly.net#下面的实时查192.30.253.119 gist.github.com199.232.28.133 assets-cdn.github.com199.232.28.133 raw.githubusercontent.com199.232.28.133 gist.githubusercontent.com199.232.28.133 cloud.githubusercontent.com199.232.28.133 camo.githubusercontent.com199.232.28.133 avatars0.githubusercontent.com199.232.28.133 avatars1.githubusercontent.com199.232.28.133 avatars2.githubusercontent.com199.232.28.133 avatars3.githubusercontent.com199.232.28.133 avatars4.githubusercontent.com199.232.28.133 avatars5.githubusercontent.com199.232.28.133 avatars6.githubusercontent.com199.232.28.133 avatars7.githubusercontent.com199.232.28.133 avatars8.githubusercontent.com#解决浏览器下载master-zip包的问题140.82.113.10 codeload.github.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hosts </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基金定投</title>
      <link href="/2020/01/20/fund-investment/"/>
      <url>/2020/01/20/fund-investment/</url>
      
        <content type="html"><![CDATA[<p>基金定投相关知识点、我的选基与定投</p><a id="more"></a><h1 id="一、基金知识点"><a href="#一、基金知识点" class="headerlink" title="一、基金知识点"></a>一、基金知识点</h1><h2 id="沪深300，沪深300ETF，沪深300ETF联接的区别"><a href="#沪深300，沪深300ETF，沪深300ETF联接的区别" class="headerlink" title="沪深300，沪深300ETF，沪深300ETF联接的区别"></a>沪深300，沪深300ETF，沪深300ETF联接的区别</h2><p>沪深300是一个指数，沪深300ETF、沪深300ETF联接是两个基金，一个场内，一个场外</p><p>ETF（exchange traded fund）交易型开放式指数基金，场内的</p><p>沪深300ETF是以沪深300指数为标的在一级市场申赎/二级市场买卖的交易型开放性指数基金，投资者可以在ETF二级市场交易价格与基金单位净值之间存在差价时进行交易。</p><p>沪深300ETF联接基金通过投资沪深300ETF紧密跟踪标的指数的表现，因此基金净值会因沪深300ETF净值波动而产生波动，投资沪深300ETF指数基金的基金</p><p>沪深300ETF是场内基金，在场内交易，跟买卖股票一样，涨跌是跟踪沪深300指数的；沪深300ETF联接基金是场外基金，通俗点就是在场外交易的沪深300ETF指数基金</p><p>沪深300ETF申赎时必须先在二级市场买齐沪深300相应比例的成分股，然后换取ETF；赎回的也是成分股，想变现就卖出这些股票，这样的申赎方式让基金经理省去了现金购买股票以及应付赎回卖出股票的环节，能始终保持高仓位，因此跟踪指数更精准，一般仓位都在90%以上</p><p>ETF在场内买卖，在场内场外都可以申赎，场内门槛低，开户即可；但场外门槛极高，几十万以上。为解决场外申赎门槛，沪深300ETF联接诞生</p><p>如果是流动性比较好的知名指数，又不怕开股票一笔一笔投资麻烦，可选择ETF进行场内申赎/买卖，费用低，无需申购费和赎回费仅有交易费一般在万分之5以下，管理费也比场外交易低，ETF的长期收益更好</p><p>如果流动性不好，又怕麻烦，就选择普通指数基金或者ETF链接基金场外申赎，可以设置定投；如果想套利，可选择LOF，费用略高</p><p><strong>结论：</strong></p><ul><li><strong>场内就买卖ETF，和买股票一样（场内申赎太麻烦），就按净值买卖ETF即可，需自己每月盘中交易</strong></li><li><strong>场外就申赎ETF链接</strong></li><li><strong>看看二者管理费啥的差距，差别不大的话还是场外通过支付宝买ETF链接进行申赎，长期比较省心</strong></li></ul><h2 id="各项费用"><a href="#各项费用" class="headerlink" title="各项费用"></a>各项费用</h2><p>股市的费用主要有：<strong>交易佣金、印花税、过户费、管理费、托管费；申购费、赎回费</strong></p><p>印花税：是股票交易非常重要的一个税种，交易额的千分之一，买股票不收，卖股票收，目前场内基金不需要交印花税</p><p>托管费管理费：这两项费用会直接从基金净值中扣。管理费是基金公司重要利润来源，0.5%；托管费是交给基金的托管方的，银行啥的，0.15%</p><p>由于ETF是在投资者之间交易的，因此，<strong>它没有申购费和赎回费</strong>，也不需要像买卖股票那样要缴纳印花税，像上海证券交易所还会对本所上市的股票征收一笔<strong>过户费</strong>，这在ETF买卖中也是没有这项费用的。</p><p><strong>结论：</strong></p><ul><li><p><strong>指数基金无论场内还是场外，管理费和托管费都要交的，会从基金净值中扣。</strong></p></li><li><p><strong>场内基金收：交易佣金(万2.5*2) + 管理费(1%) + 托管费(0.2%)=万125左右，如果没有管理费就万5</strong></p></li><li><p><strong>场外基金如果不是C类基金，收：申购费(0.1-0.2%) + 赎回费(0.5%) + 管理费(1%) + 托管费(0.2%)=万190</strong></p></li><li><p><strong>C类基金适合频繁申赎的朋友，会收取约0.4-0.6%的销售服务费。</strong></p></li><li><p><strong>定投的话选场外基金最好，不嫌麻烦就场内买卖etf自己定投，相对手续费低一些（万6与万185的差距）</strong></p></li></ul><h2 id="买卖场内ETF步骤"><a href="#买卖场内ETF步骤" class="headerlink" title="买卖场内ETF步骤"></a>买卖场内ETF步骤</h2><p>买卖方法很简单，就像买卖股票一样，进入券商提供的交易软件，或者手机交易APP，先把心目中要买卖的ETF代码输入到搜索框，找到后点击买入，输入要买的份额（最低100份，以100的整数倍增加购买份额）然后选择按你的指定价格交易委托买入，也可以选择按当前正在交易的市价来委托买入。</p><h2 id="ETF种类"><a href="#ETF种类" class="headerlink" title="ETF种类"></a>ETF种类</h2><p>按照基础资产的不同：ETF基金可以分为白银ETF、黄金ETF、跨境ETF，国内ETF等。</p><p>根据投资方法的不同：ETF可以分为指数基金和积极管理型基金，国外绝大多数ETF是指数基金。目前国内推出的ETF也是指数基金。</p><p>根据投资对象的不同：ETF可以分为股票基金和债券基金，其中以股票基金为主。</p><p>根据投资区域的不同：ETF可以分为单一国家（或市场）基金和区域性基金，其中以单一国家基金为主。</p><p>根据投资风格的不同：ETF可以分为市场基准指数基金、行业指数基金和风格指数基金（如成长型、价值型、大盘、中盘、小盘）等，其中以市场基准指数基金为主</p><p>其中<strong>货币ETF、债券ETF、黄金ETF、跨境ETF</strong>是可以实现<strong>T+0</strong>买卖的，其他境内A股ETF在T日买入<strong>T+1日</strong>才可卖出。</p><h2 id="黄金ETF"><a href="#黄金ETF" class="headerlink" title="黄金ETF"></a>黄金ETF</h2><p>优点：</p><ul><li><p>费率低。黄金ETF买卖只收<strong>券商佣金</strong>，大约在万分之三左右，费率比与黄金价格挂钩的纸黄金低，纸黄金的手续费是每克0.7-0.8元，以当前金价换算大概是千分之2.5左右，即万25。</p></li><li><p>投资门槛低。黄金ETF从1手起卖，1手=100份额=1克，现价大约300元不到。</p></li><li><p>黄金ETF实行<strong>T+0</strong>制度，当天可以买入卖出。</p></li></ul><p>缺点：</p><ul><li><p>黄金ETF的缺点就是交易时间较短。黄金ETF只能在A股开市期间交易，但黄金的交易时间是24小时的。所以黄金ETF在第二天开市时将直接反映闭市期间的黄金走势，价格容易出现跳空。</p></li><li><p>其实也不用担心跳空。因为黄金上涨的最大动力——全球经济不景气+全球政治不稳定依然存在并将长期存在，所以黄金上涨的预期并不会很快消失，<strong>任何下跌都是买入的机会</strong>。</p></li></ul><h2 id="基金前端与后端的区别"><a href="#基金前端与后端的区别" class="headerlink" title="基金前端与后端的区别"></a>基金前端与后端的区别</h2><p>前端：申购基金时：直接扣除手续费。如：基金申购手续费为1%，申购1000元，申购成功后，基金金额变为990元，亏损1%。</p><p>后端：申购基金时：不扣费。在赎回基金时，一次性扣除和申购费和赎回费用。 （出来混的，总是要还滴！）</p><h2 id="基金净值"><a href="#基金净值" class="headerlink" title="基金净值"></a>基金净值</h2><p>单位净值：</p><ul><li>该基金当天的价格，每一份基金多少钱。对于开放式基金来说，基金公司一般会每天公布该基金的单位净值。对于封闭式基金，一般会每周公布一次基金单位净值。</li><li>基金净值=净资产/基金发行分数=(基金总资产-总负债)/基金发行份数。总资产指基金拥有的所有资产，包括股票、债券、银行存款和其他有价证券等；总负债指基金运作及融资时所形成的负债，包括应付给他人的各项费用、应付资金利息等；基金单位总数是指当时发行在外的基金单位的总量</li><li>指数基金的净值高低对横向投资价值比较影响不大，因为1元的基金背后有市值1元的股票，2元的基金背后有市值2元的股票；而纵向来看，可通过查看同一个基金买卖时的净值差异看出此只基金的收益如何</li></ul><p>累计净值：</p><ul><li>累计净值=单位净值+基金成立后累计单位派息金额</li><li><strong>将分红加回单位净值，但不作为再投资进行复利计算（现金分红）</strong></li><li>举例来说，某基金5月25日的单位净值和累计单位净值分别为1.8元和2.64元。到8月12日，单位净值上涨0.07元，涨幅为0.07/1.8=3.8%；累计单位净值也上涨0.07元，但涨幅为0.07/2.64=2.7%。</li><li>很明显，<strong>累计单位净值增长率</strong>是默认投资人现金分红后只将“单位净值”再投资，从而计算出的净值累计涨幅；而实际上，相当一部分基民会采用红利再投资方式，这部分回报并没有反映到累计净值里面。因此，这就引入了<strong>复权净值</strong>的概念。</li></ul><p>复权净值：</p><ul><li><strong>将分红加回单位净值，并作为再投资进行复利计算（红利再投资）</strong></li><li><strong>复权单位净值增长率</strong>将“单位净值+分红”再投资进行复利计算。</li><li><strong>基金复权净值能比较真实地反映基金的业绩</strong>，基金公司、第三方评价机构等机构计算基金业绩回报时，都是看基金的复权净值增长率，而不是累计净值增长率。</li></ul><table><thead><tr><th align="center">时间</th><th align="center">事件</th><th align="center">单位净值</th><th align="center">累计净值</th><th align="center">复权净值</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">D1</td><td align="center">期初</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="left"></td></tr><tr><td align="center">D2</td><td align="center">分红0.1</td><td align="center">0.9</td><td align="center">1</td><td align="center">1</td><td align="left">累计和复权净值不随分红而变动</td></tr><tr><td align="center">D3</td><td align="center">上涨10%</td><td align="center">0.99</td><td align="center">1.09</td><td align="center">1.1</td><td align="left">累计净值变动金额<br>复权净值变动比例</td></tr></tbody></table><h2 id="股票估值"><a href="#股票估值" class="headerlink" title="股票估值"></a>股票估值</h2><p>最常见的股票估值有四个：市盈率（PE）、市净率（PB）、(ROE)、股息率，分别是基金贵不贵、风险大不大、(回报高不高)、分红大不大</p><p>PE是用的最多的估值，大部分行业周期性属性不强，且盈利相对稳定，PE是对静态指数最好的评价；PB主要适用于周期性行业指数，例如钢铁行业通常在高PE,低PB时买入</p><p><img src="https://img.braincao.cn/blogimg/1583403079.jpg" alt="1583403079"></p><h2 id="基金估值"><a href="#基金估值" class="headerlink" title="基金估值"></a>基金估值</h2><p>净值=市值，而一只基金的估值主要从<strong>市盈率</strong>等指标来看该基金处于低估/高估期，基金估值指标可看<strong>指数公司的官网数据分析、雪球螺丝钉、支付宝的指数红绿灯</strong></p><p>判断指数基金估值高低的方法：</p><p>1.盈利收益率要大于10%（PE10以下）；盈利收益率要大于国债利率的两倍以上。</p><p>2.从市盈率估值历史分位数看看当前估值与历史近10年，近5年，近1年1/4，1/2, 1/4分位数的距离来判断系统性的估值是否处于低位，并以此测算其估值是否具有弹性。</p><p>指数估值历史百分位：就是把A股历史上最低估值和最高估值从0到100排序，看现在的估值在什么位置，位置低说明未来上升空间大，目前指数被低估。这个说法在成熟的资本市场是有参考意义的，但是A股过去粗狂性增长今后不复存在，并且也还不成熟，所以还是要谨慎</p><h2 id="几种市盈率"><a href="#几种市盈率" class="headerlink" title="几种市盈率"></a>几种市盈率</h2><p>静态市盈率LYR，Last Year Ratio，以当前总市值，除以去年一年的总净利润。</p><p>滚动市盈率TTM，Trailing Twelve Months，以当前总市值，除以前面四个季度的总净利润。</p><p>动态市盈率是指以当前总市值，除以预估今年全年的总净利润。</p><h2 id="分红除权，指数躺枪"><a href="#分红除权，指数躺枪" class="headerlink" title="分红除权，指数躺枪"></a>分红除权，指数躺枪</h2><p>指数默认是不考虑分红的那部分钱的。我们平时看到的上证50、沪深300、恒生、H股指数等等，都是把每年的分红排除在外的指数</p><p>例如建设银行，每年78月给持股股东分红，分红前股价是5.01元，分红后股价变成4.7元。持有建设银行的H股指数，之前按照5.01元计算点数，之后按照4.7元计算点数，自然也会下跌</p><p>总结：指数默认不考虑分红，分红除权导致股价下跌，从而带动指数下跌；而指数基金能收到现金分红，收到的现金分红会先放在基金净值里，所以净值不会因为除权下跌（即累计净值不变）</p><p>全收益指数：考虑了分红的指数</p><h2 id="基金经理投资风格"><a href="#基金经理投资风格" class="headerlink" title="基金经理投资风格"></a>基金经理投资风格</h2><p>据肖志刚，基于基金经理投资风格4个维度的排列组合，可产生如下16种投资风格：</p><p><img src="https://img.braincao.cn/blogimg/1583241386.png" alt="1583241386"></p><ul><li><p>基金经理擅长精选个股，精选板块等，而不擅长大类资产配置等仓位控制，因此往往在大牛市时基金经理跑不赢指数，而在牛市前与熊市时能跑赢指数。</p><p>  方法论：要在熊市或牛市来临前多关注基金，自己进行仓位合理配置，然后借牛市落袋为安比较好</p></li><li><p>正确理解基金经理投资风格：牛市时应该与指数多偏离，增加风险获得更高收益，甚至可以追涨杀跌；而熊市时应该更为均衡，降低风险，高抛低吸。</p><p>  方法论：<strong>牛市</strong>时可以选<strong>风险比较大</strong>的基金；<strong>熊市</strong>时就<strong>长期持有更为稳</strong>妥的基金</p></li></ul><h2 id="如何挑选基金"><a href="#如何挑选基金" class="headerlink" title="如何挑选基金"></a>如何挑选基金</h2><p>用“盈利收益率”法去选指数基金：<strong>盈利收益率大于10%，且盈利收益率大于国债利率的两倍以上</strong>，同时看官网数据看<strong>历史分位数</strong>，将所有的合适的基金作为备选。之后通过选基流程依次筛选，留下最后的选基进行定投。</p><ul><li><p>1.选好的宽基(如沪深300+中证500)、优秀行业基金(房地产、银行、非银行金融、医药、消费、基建)</p></li><li><p>2.估值。宏观估计牛市熊市：看市场整体估值、巴菲特指标（70%-120%）；微观基金估值：钉大每日指数基金估值、复权净值；盈利收益率大于10%，且盈利收益率大于国债利率的两倍以上</p></li><li><p>3.第一梯队的主流基金公司：南方、嘉实、华夏、广发、富国、国泰、易方达</p></li><li><p>4.基金规模2亿+、基金自成立时间5年+、基金经理从业时间10年+、本基金管理时间3年+、本基金业绩，隔段时间要看是否换经理</p></li><li><p>5.天天基金网上该基金的跟踪误差（0.15%~2%以下）、天天基金网上该基金的换手率（200%以下）</p></li><li><p>6.最后看一眼综合费率，综合几家app来看用支付宝就行</p></li></ul><h2 id="定投策略"><a href="#定投策略" class="headerlink" title="定投策略"></a>定投策略</h2><p>构建<strong>5年</strong>左右的长期定投计划，将未来5年用不到的钱拿来投资。定投目标是希望5年后，手里持有的基金资产，可以为自己提供平均每个月1000以上的额外收益。</p><p>用工资的30-50%定投，先投30%，剩下的20%择机买或不买。控制在<strong>5只</strong>基金左右，<strong>每只基金每个月1000元</strong>。每天<strong>记账</strong>，减少不合理消费，增加合理消费（学习投资锻炼等）。</p><p>定投建议选择<strong>购买场外基</strong>金，省心；定投不止损，但是要<strong>止盈</strong>，不然容易成为杨白劳；也<strong>不能“断供”</strong>，否则前功尽弃，要将定投计划落在纸面上（定投记录表），坚定不移地执行</p><p>选好了基金，开始长期定投，高位少买，低位多买，每月定投一次指数基金；定期不定额，以大盘3000位分界线，盈利阈值到了就卖、回落10%止盈，28xx-29xx越低越多买，越高越少买，30xx-31xx陆续卖掉。重复上述步骤。想好预期收益就行，300年化应该不会高于15%，50更低。</p><p><strong>什么时候买</strong>：当一只基金“盈利收益率大于10%，且盈利收益率大于国债利率的两倍以上”时，我们才考虑购买该基金，或备选的基金到了购买时机</p><p><strong>什么时候卖</strong>：当我们能够找到比该基金盈利收益率更高的稳健品种（其他基金、车位、房子）时，我们考虑卖出，这就方便了在所有资产配置中横向比较，选择当下最佳的资产大类；或者择机止盈，当复合年化收益率10~20%（复合年化收益率=月IRR^12-1），考虑卖出如何买：定期不定额投资</p><p>不管是高点买入还是低点进入，只要<strong>盈利超过20%</strong>，就获利了结；跌幅超过20%，则将定投金额增加1倍，待获利20%，就获利了结；如此周而复始。</p><p>具体<strong>定期不定额</strong>的投资方法如下：</p><p>假如我们当下每个月能拿出每只基金1000元用于定投而不会影响正常生活。那之后每个月需要将定投的金额增加1%。这样可以避免通货膨胀和基金盈利上涨导致的定投份额下降。</p><p>同时，如果基金短期里下跌，我们可以根据估值提升当月买入的金额，这样可以在更便宜的时候买入更多的基金。结合下面这个公式：</p><p><img src="https://img.braincao.cn/blogimg/1583401614.png" alt="1583401614"></p><p>例如我从2015年12月份开始第一次定投恒生指数，初始金额1000元。到了2016年5月份，是我定投的第六个月份，市盈率PE下跌到了8。那我2016年5月份应该定投的资金是：</p><p><img src="https://img.braincao.cn/blogimg/1583401635.png" alt="1583401635"></p><p>如果在持有过程中，我们发现了一个年收益率能达到6%的低风险理财产品，我们可以在16倍PE的时候卖出恒生指数基金，卖出的钱转为买6%的低风险理财产品。</p><h1 id="二、我的选基与定投"><a href="#二、我的选基与定投" class="headerlink" title="二、我的选基与定投"></a>二、我的选基与定投</h1><h2 id="我的选基"><a href="#我的选基" class="headerlink" title="我的选基"></a>我的选基</h2><p><img src="https://img.braincao.cn/blogimg/1583246186.png" alt="1583246186"></p><h2 id="定投记录"><a href="#定投记录" class="headerlink" title="定投记录"></a>定投记录</h2><p><img src="https://img.braincao.cn/blogimg/1583250890.png" alt="1583250890"></p><h2 id="其他备选基金"><a href="#其他备选基金" class="headerlink" title="其他备选基金"></a>其他备选基金</h2><p>恒生覆盖的行业更广泛，盈利更稳定；H股指数的估值更低；红利指数的现金分红更稳定。这三只都挺符合长期定投的要求。</p><p>恒生指数必须买<br>恒生国企：融创中国、招商银行</p><p>参考的2年仓位布置：</p><blockquote><p>不推荐买货币基金。</p><p>不如40%股票基金组合（五只），60%债券基金组合（五只）。</p><p>两年时间：股票基金预期收益率三分之一的可能性赔10%，三分之一可能性赚15%，三分之一可能性赚25%。债券基金收益率6%。</p></blockquote><p>如果有50万闲置资金的话，如何做投资：</p><blockquote><p>A股指数（上证50，沪深300等），QDII指数（标普500，纳斯达克100等），纯债债基，QDII债基，黄金ETF均匀配置就差不多了，再加上一定量的货基做机动。</p><p>14到19五年的股市环境变化：14年10沪指2500点左右，仅用八个月，到15年6月5100，然后15年股灾熔断毛衣站到18年底的2400，到最近来回挣扎在3000点的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术外 </category>
          
          <category> 投资理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程编程例子</title>
      <link href="/2019/10/01/multithread-programming-demo/"/>
      <url>/2019/10/01/multithread-programming-demo/</url>
      
        <content type="html"><![CDATA[<p>本博文记录多线程编程的几个案例，包含了常见的几种多线程编程套路。</p><a id="more"></a><h1 id="1-四个线程计算1到100的求和"><a href="#1-四个线程计算1到100的求和" class="headerlink" title="1.四个线程计算1到100的求和"></a>1.四个线程计算1到100的求和</h1><p>1.依次调用thread.join()，主线程输出结果。注意：sum为共享变量，访问共享变量时，用synchronized同步</p><pre><code class="java">public class ThreadTest {    private static Object LOCK = new Object();    private static int sum = 0;    public static void main(String[] args) throws InterruptedException {        ThreadTest threadTest = new ThreadTest();        Thread t1 = threadTest.new ThreadSum(1,25);        Thread t2 = threadTest.new ThreadSum(26,50);        Thread t3 = threadTest.new ThreadSum(51,75);        Thread t4 = threadTest.new ThreadSum(76,100);        t1.start();        t2.start();        t3.start();        t4.start();        t1.join();        t2.join();        t3.join();        t4.join();        System.out.println(&quot;totalSum: &quot; + sum);    }    class ThreadSum extends Thread{        private int begin;        private int end;        public ThreadSum(int begin, int end){            this.begin = begin;            this.end = end;        }        @Override        public void run() {            try {                Thread.sleep(100);//便于测试            } catch (InterruptedException e) {                e.printStackTrace();            }            synchronized (LOCK){                for(int i=begin; i&lt;=end; ++i){                    sum += i;                }                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + sum);            }        }    }}out:Thread-1: 950Thread-0: 1275Thread-3: 3475Thread-2: 5050totalSum: 5050</code></pre><p>2.子线程执行完调用countdownlatch.countdown()，主线程调用countdownlatc.await() 等待子线程执行完成，输出结果。 注意：sum为共享变量，访问共享变量时，用synchronized同步</p><pre><code class="java">public class ThreadTest {    private static Object LOCK = new Object();    private static int sum = 0;    private static CountDownLatch countDownLatch = new CountDownLatch(4);    public static void main(String[] args) throws InterruptedException {        ThreadTest threadTest = new ThreadTest();        Thread t1 = threadTest.new ThreadSum(1,25);        Thread t2 = threadTest.new ThreadSum(26,50);        Thread t3 = threadTest.new ThreadSum(51,75);        Thread t4 = threadTest.new ThreadSum(76,100);        t1.start();        t2.start();        t3.start();        t4.start();        countDownLatch.await();        System.out.println(&quot;totalSum: &quot; + sum);    }    class ThreadSum extends Thread{        private int begin;        private int end;        public ThreadSum(int begin, int end){            this.begin = begin;            this.end = end;        }        @Override        public void run() {            try {                Thread.sleep(100);//便于测试            } catch (InterruptedException e) {                e.printStackTrace();            }            synchronized (LOCK){                for(int i=begin; i&lt;=end; ++i){                    sum += i;                }                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + sum);            }            countDownLatch.countDown();        }    }}</code></pre><p>3.线程池</p><pre><code class="java">public class ThreadTest {    private static Object LOCK = new Object();    private static int sum = 0;    private static CountDownLatch countDownLatch = new CountDownLatch(4);    public static void main(String[] args) throws InterruptedException {        ThreadTest threadTest = new ThreadTest();        ExecutorService pool = Executors.newFixedThreadPool(4);        for(int i=1; i&lt;=76; i+=25){            pool.execute(threadTest.new ThreadSum(i, i+24));        }        countDownLatch.await();        pool.shutdown();        System.out.println(&quot;totalSum: &quot; + sum);    }    class ThreadSum extends Thread{        private int begin;        private int end;        public ThreadSum(int begin, int end){            this.begin = begin;            this.end = end;        }        @Override        public void run() {            try {                Thread.sleep(100);//便于测试            } catch (InterruptedException e) {                e.printStackTrace();            }            synchronized (LOCK){                for(int i=begin; i&lt;=end; ++i){                    sum += i;                }                System.out.println(Thread.currentThread().getName() + &quot;: &quot; + sum);            }            countDownLatch.countDown();        }    }}</code></pre><p>4.使用ExecutorService、Callable、Future实现有返回结果的线程</p><pre><code class="java">public class ThreadTest {    private static List&lt;Future&gt; futureList = new ArrayList&lt;&gt;();    public static void main(String[] args) throws InterruptedException, ExecutionException {        ThreadTest threadTest = new ThreadTest();        ExecutorService pool = Executors.newFixedThreadPool(4);        for(int i=1; i&lt;=76; i+=25){            ThreadCallSum threadCallSum = threadTest.new ThreadCallSum(i, i+24);            Future future = pool.submit(threadCallSum);            futureList.add(future);        }        pool.shutdown();        int sum = 0;        for(Future&lt;Integer&gt; future: futureList){            sum += future.get();        }        System.out.println(&quot;totalSum: &quot; + sum);    }    class ThreadCallSum implements Callable&lt;Integer&gt;{        private int begin;        private int end;        private int sum = 0;        public ThreadCallSum(int begin, int end){            this.begin = begin;            this.end = end;        }        @Override        public Integer call() throws InterruptedException {            Thread.sleep(100);            for(int i=begin; i&lt;=end; ++i){                sum += i;            }            System.out.println(Thread.currentThread().getName() + &quot;: &quot; + sum);            return sum;        }    }}out:pool-1-thread-2: 950pool-1-thread-4: 2200pool-1-thread-1: 325pool-1-thread-3: 1575totalSum: 5050</code></pre><h1 id="2-三个线程打印一个1-100的数组，要求P1-1，P2-2，P3-3，P1-4的形式"><a href="#2-三个线程打印一个1-100的数组，要求P1-1，P2-2，P3-3，P1-4的形式" class="headerlink" title="2.三个线程打印一个1-100的数组，要求P1=1，P2=2，P3=3，P1=4的形式"></a>2.三个线程打印一个1-100的数组，要求P1=1，P2=2，P3=3，P1=4的形式</h1><pre><code class="java">public class ThreadTest {    private static volatile int count = 1;    private static Object object = new Object();    public static void main(String[] args) {        ThreadTest threadTest = new ThreadTest();        ExecutorService pool = Executors.newFixedThreadPool(3);        while (count &lt;= 100) {            pool.execute(threadTest.new ThreadCnt());        }        pool.shutdown();    }    class ThreadCnt extends Thread {        public void run() {            if(count&lt;=100) {                synchronized (object) {                    if (count % 3 == 1 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-1&quot;)) {                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count);                        count++;                    } else if (count % 3 == 2 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-2&quot;)) {                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count);                        count++;                    } else if (count % 3 == 0 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-3&quot;)) {                        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + count);                        count++;                    }                }            }        }    }}out:pool-1-thread-1: 1pool-1-thread-2: 2pool-1-thread-3: 3pool-1-thread-1: 4pool-1-thread-2: 5</code></pre><h1 id="3-java多线程-2个线程-交替打印0-100的奇偶数"><a href="#3-java多线程-2个线程-交替打印0-100的奇偶数" class="headerlink" title="3.java多线程(2个线程)交替打印0-100的奇偶数"></a>3.java多线程(2个线程)交替打印0-100的奇偶数</h1><p>用到了notify、wait机制</p><pre><code class="java">public class ThreadTest extends Thread{    public static void main(String[] args) {        ThreadTest threadTest = new ThreadTest();        Thread t1 = threadTest.new ThreadOdd();        Thread t2 = threadTest.new ThreadEven();        t1.start();        t2.start();    }    private synchronized void print(String str ,int i){        notify();        System.out.println(str + &quot;: &quot; + i);        try {            if(i==100){//100次的时候要唤醒全部，否则循环结束不了                notifyAll();            }            else{                wait();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }    class ThreadOdd extends Thread{        public void run(){            for(int i=1; i&lt;=100; i+=2){                print(Thread.currentThread().getName(), i);            }        }    }    class ThreadEven extends Thread{        public void run(){            for(int i=2; i&lt;=100; i+=2){                print(Thread.currentThread().getName(), i);            }        }    }}out:...t1: 97t2: 98t1: 99t2: 100</code></pre><h1 id="4-三个线程循环打印1-100，每个线程每次打印3个数"><a href="#4-三个线程循环打印1-100，每个线程每次打印3个数" class="headerlink" title="4.三个线程循环打印1-100，每个线程每次打印3个数"></a>4.三个线程循环打印1-100，每个线程每次打印3个数</h1><p>1.用线程池</p><pre><code class="java">import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;class ThreadTest{    private static volatile int count = 1;    private static volatile int threadCnt = 1;    private static Object object = new Object();    public static void main(String[] args) {        ThreadTest threadTest = new ThreadTest();        ExecutorService pool = Executors.newFixedThreadPool(3);        while(count&lt;=100){            pool.execute(threadTest.new ThreadCnt());        }        pool.shutdown();    }    class ThreadCnt extends Thread{        public void print(){            System.out.print(Thread.currentThread().getName() + &quot;:&quot;);            int k = 3;            while(count&lt;=100 &amp;&amp; k!=0){                System.out.print(&quot; &quot; + count);                count++;                k--;            }            System.out.println();            threadCnt++;        }        public void run(){            if(count&lt;=100) {                synchronized (object) {                    if(count&lt;=100) {//double-check                        if (threadCnt % 3 == 1 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-1&quot;)) {                            print();                        } else if (threadCnt % 3 == 2 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-2&quot;)) {                            print();                        } else if (threadCnt % 3 == 0 &amp;&amp; Thread.currentThread().getName().contains(&quot;thread-3&quot;)) {                            print();                        }                    }                }            }        }    }}</code></pre><p>2.用notify、wait–&gt;这个注释的很好，强推看代码！！</p><pre><code class="java">class ThreadTest{    private static volatile int count = 1;//打印的count    private static volatile int countC = 0;//线程计数:保证依次打印的顺序    private static Object object = new Object();    public static void main(String[] args) {        ThreadTest threadTest = new ThreadTest();        Thread t1 = threadTest.new ThreadCnt(0);//每个线程分配id号，便于依次打印时与countC比较        Thread t2 = threadTest.new ThreadCnt(1);        Thread t3 = threadTest.new ThreadCnt(2);        t1.setName(&quot;t1&quot;);        t2.setName(&quot;t2&quot;);        t3.setName(&quot;t3&quot;);        t1.start();        t2.start();        t3.start();    }    class ThreadCnt extends Thread{//这里的ThreadCnt类前加不加static都可以，因为锁的是ThreadCnt.class！！        private int id;        public ThreadCnt(int id){            this.id = id;        }        public void run(){            while(count&lt;=100){                synchronized (object){//这里锁ThreadCnt.class、ThreadTest.class、object都可以！！                    if(count&lt;=100) {//double-check                        if (countC % 3 == id) {//通过id保证线程依次打印                            object.notifyAll();//这里的notifyAll()、wait()的object类对象必须与上面的synchronized里的对象保持一致！！                            System.out.print(Thread.currentThread().getName() + &quot;:&quot;);                            int k = 3;                            while (count &lt;= 100 &amp;&amp; k != 0) {                                System.out.print(&quot; &quot; + count);                                count++;                                k--;                            }                            System.out.println();                            countC++;                        }                        else{                            try {                                object.wait();                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                        }                    }                }            }        }    }}</code></pre><h1 id="5-java实现生产者消费者模式"><a href="#5-java实现生产者消费者模式" class="headerlink" title="5.java实现生产者消费者模式"></a>5.java实现生产者消费者模式</h1><p>1.notify/wait实现</p><pre><code class="java">import java.util.LinkedList;import java.util.Queue;/** * @FileName: ProAndCus * @Author: braincao * @Date: 2019/3/21 14:39 * @Description: java实现生产者消费者模式(notify/wait实现) */public class ProAndCus {    private Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    private int queMaxLen = 10;    private static Object object = new Object();    private static volatile int dataCnt = 0;//生产的物品，为了测试，这里规定生产者最多能生产10个(1-10)    public static void main(String[] args) {        ProAndCus proAndCus = new ProAndCus();        Thread p1 = proAndCus.new Pro();        Thread p2 = proAndCus.new Pro();        Thread p3 = proAndCus.new Pro();        Thread p4 = proAndCus.new Pro();        Thread c1 = proAndCus.new Cus();        Thread c2 = proAndCus.new Cus();        Thread c3 = proAndCus.new Cus();        Thread c4 = proAndCus.new Cus();        p1.setName(&quot;p1--&quot;);        p2.setName(&quot;p2--&quot;);        p3.setName(&quot;p3--&quot;);        p4.setName(&quot;p4--&quot;);        c1.setName(&quot;c1--&quot;);        c2.setName(&quot;c2--&quot;);        c3.setName(&quot;c3--&quot;);        c4.setName(&quot;c4--&quot;);        p1.start();        p2.start();        p3.start();        p4.start();        c1.start();        c2.start();        c3.start();        c4.start();    }    class Pro extends Thread{        public void run(){            try {                while (dataCnt&lt;10) {                    Thread.sleep(100);                    synchronized (object) {                        if (queue.size() &gt;= queMaxLen) {                            object.wait();                        }                        if(dataCnt&lt;10){                            dataCnt++;                            queue.offer(dataCnt);                            System.out.println(Thread.currentThread().getName() + &quot;生产：&quot; + dataCnt);                        }                        object.notifyAll();                    }                }            }catch (Exception e){                e.printStackTrace();            }        }    }    class Cus extends Thread{        public void run(){            try {                while (true) {                    Thread.sleep(100);                    synchronized (object) {                        if(queue.isEmpty()) {                            if(dataCnt&lt;10){                                object.wait();                            }                            else{                                break;                            }                        }                        else{                            System.out.println(Thread.currentThread().getName() + &quot;消费：&quot; + queue.poll());                        }                        object.notifyAll();                    }                }            }catch (Exception e){                e.printStackTrace();            }        }    }}</code></pre><p>2.阻塞队列实现</p><pre><code class="java">import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingQueue;//使用阻塞队列BlockingQueue解决生产者消费者public class BlockingQueueConsumerProducer {    private static volatile int dataCnt = 0;    private static BlockingQueue&lt;Integer&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(10);    public static void main(String[] args) {        BlockingQueueConsumerProducer cp = new BlockingQueueConsumerProducer();        //生产者线程        Pro p1 = cp.new Pro();        Pro p2 = cp.new Pro();        p1.setName(&quot;p1&quot;);        p2.setName(&quot;p2&quot;);        //消费者线程        Cus c1 = cp.new Cus();        Cus c2 = cp.new Cus();        Cus c3 = cp.new Cus();        Cus c4 = cp.new Cus();        Cus c5 = cp.new Cus();        c1.setName(&quot;c1&quot;);        c2.setName(&quot;c2&quot;);        c3.setName(&quot;c3&quot;);        c4.setName(&quot;c4&quot;);        c5.setName(&quot;c5&quot;);        p1.start();        p2.start();        c1.start();        c2.start();        c3.start();        c4.start();        c5.start();    }    /**     * 消费者线程     * @author tangzhijing     *     */    class Cus extends Thread {        public void run() {            try {                while (true) {                    Thread.sleep((long) (1000 * Math.random()));                    if(!blockingQueue.isEmpty()){                        System.out.println(Thread.currentThread().getName() + &quot;消费了：&quot; + blockingQueue.poll());                    }                }            }            catch (Exception e){                e.printStackTrace();            }        }    }    /**     * 生产者线程     * @author tangzhijing     *     */    class Pro extends Thread{        public void run() {            try {                while (true) {                    Thread.sleep((long) (1000 * Math.random()));                    dataCnt++;                    blockingQueue.offer(dataCnt);                    System.out.println(Thread.currentThread().getName() + &quot;生产了：&quot; + dataCnt);                }            }            catch (Exception e){                e.printStackTrace();            }        }    }}</code></pre><h1 id="6-猴子偷桃抢着进行"><a href="#6-猴子偷桃抢着进行" class="headerlink" title="6.猴子偷桃抢着进行"></a>6.猴子偷桃抢着进行</h1><p>一个拿2个，一个拿3个，共有9个</p><pre><code class="java">public class Apple {    public static volatile int clientTotal = 9;//共有9个苹果    //同时并发执行的线程数:两个猴子各一个线程    public static void main(String[] args){        Thread monkeyOne = new Thread(new Runnable() {            @Override            public void run() {                while(clientTotal&gt;=2){                    synchronized (Apple.class) {                        if (clientTotal &gt;= 2) {//double-check                            clientTotal -= 2;                            System.out.println(&quot;A猴子拿了2个，还剩:&quot; + clientTotal + &quot;个&quot;);                        }                    }                    try {                        Thread.sleep(100);//为了测试期间，这里加个sleep                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        Thread monkeyTwo = new Thread(new Runnable() {            @Override            public void run() {                while(clientTotal&gt;=3){                    synchronized (Apple.class) {                        if (clientTotal &gt;= 3) {                            clientTotal -= 3;                            System.out.println(&quot;B猴子拿了3个，还剩:&quot; + clientTotal + &quot;个&quot;);                        }                    }                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }        });        monkeyOne.start();        monkeyTwo.start();    }}</code></pre><h1 id="6-猴子偷桃交替进行"><a href="#6-猴子偷桃交替进行" class="headerlink" title="6.猴子偷桃交替进行"></a>6.猴子偷桃交替进行</h1><pre><code class="java">public class Apple {    public static volatile int clientTotal = 9;//共有9个苹果    public static Object object = new Object();    //同时并发执行的线程数:两个猴子各一个线程    public static void main(String[] args){        Apple apple = new Apple();        Thread t1 = apple.new ThreadMOne();        Thread t2 = apple.new ThreadMTwo();        t1.start();        t2.start();    }    class ThreadMOne extends Thread{        public void run(){            try {                while(clientTotal&gt;=2){                    Thread.sleep(100);                    synchronized (object) {                        object.notify();                        if(clientTotal&lt;2){                            break;                        }                        clientTotal -= 2;                        System.out.println(&quot;A猴子拿了2个，还剩:&quot; + clientTotal + &quot;个&quot;);                        if(clientTotal&lt;3){                            break;                        }                        object.wait();                    }                }            }            catch (Exception e){                e.printStackTrace();            }        }    }    class ThreadMTwo extends Thread{        public void run(){            try {                while(clientTotal&gt;=3){                    Thread.sleep(100);                    synchronized (object) {                        object.notify();                        if(clientTotal&lt;3){                            break;                        }                        clientTotal -= 3;                        System.out.println(&quot;B猴子拿了3个，还剩:&quot; + clientTotal + &quot;个&quot;);                        if(clientTotal&lt;3){                            break;                        }                        object.wait();                    }                }            }            catch (Exception e){                e.printStackTrace();            }        }    }}out:A猴子拿了2个，还剩:7个B猴子拿了3个，还剩:4个A猴子拿了2个，还剩:2个</code></pre>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研二面试题目</title>
      <link href="/2019/10/01/postgraduate-interview-questions/"/>
      <url>/2019/10/01/postgraduate-interview-questions/</url>
      
        <content type="html"><![CDATA[<p>本博文记录研二春招实习、秋招找工作阶段经历过的几家面试题目。</p><a id="more"></a><h1 id="360春招三道编程题"><a href="#360春招三道编程题" class="headerlink" title="360春招三道编程题"></a>360春招三道编程题</h1><h2 id="1-分金子"><a href="#1-分金子" class="headerlink" title="1.分金子"></a>1.分金子</h2><p>题目：A、B两伙马贼意外地在一片沙漠中发现了一处金矿，双方都想独占金矿，但各自的实力都不足以吞下对方，经过谈判后，双方同意用一个公平的方式来处理这片金矿。处理的规则如下：他们把整个金矿分成n段，由A、B开始轮流从最左端或最右端占据一段，直到分完为止。 </p><p>马贼A想提前知道他们能分到多少金子，因此请你帮忙计算他们最后各自拥有多少金子?（两伙马贼均会采取对己方有利的策略）</p><p>具体的看 <a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3863&konwledgeId=42" target="_blank" rel="noopener">原题及解析连接</a></p><p>思路：动态规划dp[][]。dp[i][j] = sum[j]-sum[i-1]-Math.min(dp[i+1][j],dp[i][j-1]);</p><pre><code class="java">import java.io.*;import java.util.*;public class Main{        public static void main(String args[]){        Scanner cin = new Scanner(System.in);        int t = cin.nextInt();        for(int times=1; times&lt;=t;++times){            int k = cin.nextInt();            int[] nums = new int[k];            for(int i=0; i&lt;k; ++i){                nums[i] = cin.nextInt();            }            int[] res = compute(nums, k);            System.out.printf(&quot;Case #%d: %d %d\n&quot;, times, res[0], res[1]);        }    }    public static int[] compute(int[] nums, int n){        int[][] dp = new int[n+1][n+1];        int[] sum = new int[n+1];        for(int i=1; i&lt;=n; ++i){            dp[i][i] = nums[i-1];            sum[i] = sum[i-1] + nums[i-1];        }        for(int i=n-1; i&gt;0; --i){            for(int j=i+1; j&lt;=n; ++j){                dp[i][j] = sum[j]-sum[i-1]-Math.min(dp[i+1][j],dp[i][j-1]);            }        }        return new int[]{dp[1][n], sum[n]-dp[1][n]};    }}</code></pre><h2 id="2-剪气球串"><a href="#2-剪气球串" class="headerlink" title="2.剪气球串"></a>2.剪气球串</h2><p>题目：本题题意可以抽象成一个数学的表述，即一个长度为n的数组，每一个数的范围是1到9，现在我们需要将这个数组分成多个连续子数组，保证每个子数组内数字均不相同，问一共有多少种满足要求的分法。</p><p>具体的看 <a href="http://exercise.acmcoder.com/online/online_judge_answer_pdf?ques_id=3862&konwledgeId=42" target="_blank" rel="noopener">原题及解析连接</a></p><p>思路：这题需要用到动态规划进行求解，我们不妨记一个数组dp[i]，表示这个数组前i个数组成的数组可以有多少种分法，数组初始全为0，特别的dp[0]初始为1。那么在计算dp[i+1]时，我们需要考虑第i+1个数可以和前面哪些数分到一起组成连续的子数组，比如第i+1个数可以和第i个数组成一组，但不能和第i-1个数分到一组，那么dp[i+1]=dp[i]+dp[i-1]</p><pre><code class="java">import java.io.*;import java.util.*;public class Main{        public static void main(String args[]){        Scanner cin = new Scanner(System.in);        while(cin.hasNext()){            int n = cin.nextInt();            int[] nums = new int[n];            for(int i=0; i&lt;n; ++i){                nums[i] = cin.nextInt();            }            int[] dp = new int[n+1];            dp[0] = 1;            for(int i=1; i&lt;=n; ++i){                int[] cnt = new int[10];                for(int j=i-1; j&gt;=0; j--){                    cnt[nums[j]]++;                    if(cnt[nums[j]]&gt;1){                        break;                    }                    dp[i] = (dp[i] + dp[j])%1000000007;                }            }            System.out.println(dp[n]);        }    }}</code></pre><h2 id="3-跑步"><a href="#3-跑步" class="headerlink" title="3.跑步"></a>3.跑步</h2><p>题目：小明同学喜欢体育锻炼，他常常去操场上跑步。跑道是一个圆形，在本题中，我们认为跑道是一个半径为R的圆形，设圆心的坐标为原点(0,0)。</p><p>小明跑步的起点坐标为(R,0)，他沿着圆形跑道跑步，而且一直沿着一个方向跑步。回到家后，他查看了自己的计步器，计步器显示他跑步的总路程为L。</p><p>小明想知道自己结束跑步时的坐标，但是他忘记自己是沿着顺时针方向还是逆时针方向跑的了。他想知道在这两种情况下的答案分别是多少。</p><p>具体的看 <a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3861&konwledgeId=42" target="_blank" rel="noopener">原题及解析连接</a></p><p>思路：根据跑步总长L，先计算绕着圆心转动角度θ=L/r，之后顺时针x=cosθ<em>r,y=-sinθ\</em>r，逆时针同理。</p><pre><code class="java">import java.io.*;import java.util.*;public class Main{    public static void main(String args[]){        Scanner cin = new Scanner(System.in);        int l, r;        l = cin.nextInt();        r = cin.nextInt();        double threta = l*1.0/r;        System.out.printf( &quot;%.3f %.3f\n&quot;, (Math.cos(threta)*r), (-Math.sin(threta)*r));        System.out.printf( &quot;%.3f %.3f\n&quot;, (Math.cos(threta)*r), (Math.sin(threta)*r));    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>金融小知识</title>
      <link href="/2019/05/08/financial-tips/"/>
      <url>/2019/05/08/financial-tips/</url>
      
        <content type="html"><![CDATA[<p>金融学习中的一些金融小知识笔记</p><a id="more"></a><h2 id="强推"><a href="#强推" class="headerlink" title="强推"></a>强推</h2><p><a href="https://www.zhihu.com/question/288287043/answer/582430178" target="_blank" rel="noopener">有哪些金融领域的现象或事实，没有一定金融学知识的人不会相信，或者不能理解？</a></p><h2 id="1-CFA"><a href="#1-CFA" class="headerlink" title="1.CFA"></a>1.CFA</h2><p>CFA 1级代表了金融本科的毕业水平</p><p>CFA 2级代表了实务操作中需要具备的金融知识</p><p>CFA 3级故弄玄虚到了一个境界，80%的内容考完后这辈子都用不到</p><h2 id="2-三种贷款还款方式"><a href="#2-三种贷款还款方式" class="headerlink" title="2.三种贷款还款方式"></a>2.三种贷款还款方式</h2><p>等额本息，就是每个月还款额相同，但是月供里面，利息开始还得多，本金还得少，后续利息还得少，本金还得多，整体每个月还款额度相同。</p><p>等额本金，是每个月还的本金一样多，利息最开始还的多，后续还的少。</p><p>等本等息，也是每个月还款额相同，但是月供里面，每个月还的本金一样，利息也一样。</p><ul><li><p>等额本息</p><p>  如果知道<strong>月还款额和贷款本金</strong>，用这个公式可以解出月利率，再把月利率乘以12，就是真实年利率。当然，等额本息是最难弄懂的。</p><p>  令：Q=(1+月利率)^还款期数</p><p>  每月还款额=月利率*Q/(Q-1) * 贷款本金</p><p>  总还款额=每月还款额*还款期数</p></li></ul><ul><li><p>等额本金</p><p>  每月还款的本金是不变的，总本金越来越少，后续的利息就越还越少了。这个是比较简单的。</p><p>  每月还款额=每月还款本金+每月还款利息</p><p>  每月还款本金=贷款本金/还款月数</p><p>  每月还款利息=贷款本金余额*贷款月利率(贷款月利率=年利率/12)</p><p>  贷款本金余额=贷款总额-已还款月数*每月还款本金</p></li></ul><ul><li><p>等本等息–信用卡分期</p><p>  大概：真实年利率=名义月利率×12×12÷6.5</p><p>  准确：真实年利率=名义月利率 x 12 x 2 x 分期月数÷(分期月数+1)</p></li></ul><p><strong>怎么算出来的？</strong></p><p>比如：刷了1万元，分12期，月利率0.75%。每期还本金：833.33元，利息：75元。</p><p>还款第一个833占用了1/12年，还款第二个833占用了2/12年，第三个833占用了3/12年……第12个833占用了12/12年。</p><p>一年内实际占用本金=（1/12+2/12+3/12+……+11/12+12/12）x833.33=6.5x833.33</p><p>真实利率=（实际支付利息）÷（一年内实际占用的本金）=(75x12)÷（6.5x833.33）=（75÷833.33）x12÷6.5=（75÷10000）x12x12÷6.5=分期月利率x12x12÷6.5=16.6%</p><h2 id="3-风口与风口周期"><a href="#3-风口与风口周期" class="headerlink" title="3.风口与风口周期"></a>3.风口与风口周期</h2><p>做符合周期的事情，在周期内做有效的探索</p><p>对90后而言，比如08开始的电商。10大规模开始的互联网创业。12的天猫。14的微商和跨境 15、16的房地产，14到16年的日本代购，17、18年的日本民宿，17、18年开始的大规模的一带一路。</p><h2 id="现金流的重要性"><a href="#现金流的重要性" class="headerlink" title="现金流的重要性"></a>现金流的重要性</h2><p>1.穷人：jobs-&gt;贷款买房、车(负债)–&gt;升职加薪，交更多的税，换更多的债–&gt;看上去有车有房、名牌小资–&gt;实际穷人，负债累累，无休止的工作</p><p>2.富人：三种资产(自己公司、股票证券投资、不动产)，实现财务自由</p><h2 id="止损"><a href="#止损" class="headerlink" title="止损"></a>止损</h2><p>具体到战术上如何止损：</p><p>一，亏损额度达到总资金的5%，无论任何理由和借口，都无条件的止损；</p><p>二，行情不好，且走势对我不利时，立即止损；</p><p>三，走势看不懂，且对我不利时，立即止损；</p><p>四，买入股票后，没有实现预期，逐步止损；</p><p>五，时间止损，买入后长时间没有行情，逐步止损；</p><p>六，买股的理由不存在了、发生了变化、被澄清，逐步止损；</p><p>七，个股亏损额超过30%，无论任何理由和借口，无条件的止损。</p><p>我的止损主要是按照这七条，而且只要具备其中之一者就立即止损。对我而言，止损是刚性的，到了止损位置我就执行，不管它第二天会不会反弹，不管当时行情是否变暖，我先把止损做了再说。至于止损错了，股票又反弹了怎么办？我再买上就是了。止损是一回事，再买入是另外一回事，它俩是两个独立的逻辑，是两笔独立的操作，它们不能互相抵消。我这样做的目的就是贯彻我的止损永远正确的思想，把止损变成一种习惯。</p>]]></content>
      
      
      <categories>
          
          <category> 技术外 </category>
          
          <category> 投资理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 投资理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java并发</title>
      <link href="/2019/01/16/java-concurrency/"/>
      <url>/2019/01/16/java-concurrency/</url>
      
        <content type="html"><![CDATA[<p>此文档为java并发的学习总结</p><a id="more"></a><h1 id="java并发总结图"><a href="#java并发总结图" class="headerlink" title="java并发总结图"></a>java并发总结图</h1><p><img src="https://img.braincao.cn/blogimg/1583506462.jpg" alt="1583506462"></p><h1 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h1><h2 id="并发模拟–工具"><a href="#并发模拟–工具" class="headerlink" title="并发模拟–工具"></a>并发模拟–工具</h2><p>postman–http请求模拟，也可以进行简单的并发测试</p><p>AB(apacheBench)–并发测试(只有命令行，没有图形界面)</p><p>jMeter–压力测试，并AB更强大，实际用的更多(有图形界面)</p><h2 id="并发模拟–代码"><a href="#并发模拟–代码" class="headerlink" title="并发模拟–代码"></a>并发模拟–代码</h2><p>CountDownLatch–阻塞线程并保证线程在某种特定条件下继续执行</p><p>Semaphore–阻塞线程并控制同一时间的并发量</p><p>CountDownLatch+Semaphore通常与线程池一起使用</p><pre><code class="java">package com.mmall.concurrency;import com.mmall.concurrency.annoations.NotThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@NotThreadSafepublic class ConcurrencyTest {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    public static int count = 0;    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool(); //线程池        final Semaphore semaphore = new Semaphore(threadTotal); //阻塞线程并控制同一时间的并发量        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);//阻塞线程并保证线程在某种特定条件下继续执行        for (int i = 0; i &lt; clientTotal ; i++) {            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    add();                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;count:{}&quot;, count);    }    private static void add() {        count++;    }}</code></pre><h2 id="线程安全性的原子性"><a href="#线程安全性的原子性" class="headerlink" title="线程安全性的原子性"></a>线程安全性的原子性</h2><p>线程安全性的几种原子性–对比：</p><pre><code>1.Atomic: 竞争激烈时能维持常态，比Lock性能好; 只能同步一个值2.synchronized: 不可中断锁，适合竞争不激烈，可读性好3.Lock: 可中断锁，多样化同步，竞争激烈时维持常态</code></pre><h3 id="1-原子性–Atomic包实现线程安全"><a href="#1-原子性–Atomic包实现线程安全" class="headerlink" title="1.原子性–Atomic包实现线程安全"></a>1.原子性–Atomic包实现线程安全</h3><p>java中的atomic包实现原子性，atomic包内部是通过CAS来实现原子性的。CAS：CompareAndSwap</p><p>1.AtomicXXX: CAS、Unsafe.compareAndSwapInt</p><p>2.AtomicLong与LongAdder</p><p>有了AtomicInteger，进一步有了AtomicLong，再进一步有了LongAdder，需要LongAdder的原因如下：</p><p>CAS底层实现是一个死循环，直到主存和工作内存数据相同才修改，否则一直循环，这个在有时候可能修改失败的概率很大，影响性能，那么LongAdder的优点就是利用AtomicLong，JVM会把int拆分成多个cell，最后合并cell即可，将单点的atomic压力分散成多个cell的压力。</p><p>3.AtomicReference、AtomicIntegerFieldUpdater</p><p>AtomicReference中的compareAndSet()方法参数分别代表:expectedValue、updateValue，如果是expectedValue则更新为updateValue</p><p>AtomicIntegerFieldUpdater中的字段必须使用volatile</p><p>4.AtomicStampedReference：解决CAS的ABA问题</p><p>CAS的ABA问题：其他线程将A改为B又改回A，当前线程读A没有影响，但是这不符合设计要求了，因此我们将每个线程的修改操作都附一个版本号Stamp，此A非彼A，这样解决了ABA问题</p><h3 id="2-原子性–锁实现线程安全"><a href="#2-原子性–锁实现线程安全" class="headerlink" title="2.原子性–锁实现线程安全"></a>2.原子性–锁实现线程安全</h3><p>JDK中锁的实现有两种方法：</p><pre><code>1.synchronized: 依赖JVM2.Lock: 依赖特殊的cpu指令，代码层面实现，J.U.C的AQS组件中的ReentrantLock</code></pre><p>synchronized实现线程安全(着重介绍)</p><p>四种synchronized的修饰用法及作用范围，一定注意其作用范围</p><pre><code>1.修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；2.修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；3.修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；4.修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象</code></pre><p>示例：</p><pre><code class="java">// 修饰一个代码块public void test1(int j) {    synchronized (this) {        for (int i = 0; i &lt; 10; i++) {            log.info(&quot;test1 {} - {}&quot;, j, i);        }    }}// 修饰一个方法public synchronized void test2(int j) {    for (int i = 0; i &lt; 10; i++) {        log.info(&quot;test2 {} - {}&quot;, j, i);    }}// 修饰一个类public static void test1(int j) {    synchronized (SynchronizedExample2.class) {        for (int i = 0; i &lt; 10; i++) {            log.info(&quot;test1 {} - {}&quot;, j, i);        }    }}// 修饰一个静态方法public static synchronized void test2(int j) {    for (int i = 0; i &lt; 10; i++) {        log.info(&quot;test2 {} - {}&quot;, j, i);    }}//测试public static void main(String[] args) {    SynchronizedExample1 example1 = new SynchronizedExample1();    SynchronizedExample1 example2 = new SynchronizedExample1();    ExecutorService executorService = Executors.newCachedThreadPool();//线程池    executorService.execute(() -&gt; {        example1.test2(1);    });    executorService.execute(() -&gt; {        example2.test2(2);    });}</code></pre><p>使用synchronized保证线程安全的实例:</p><pre><code class="java">package com.mmall.concurrency.example.count;import com.mmall.concurrency.annoations.ThreadSafe;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;@Slf4j@ThreadSafepublic class CountExample3 {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    public static int count = 0;    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal ; i++) {            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    add();                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;count:{}&quot;, count);    }    //这里加了synchronized就线程安全了，使用简单容易    private synchronized static void add() {        count++;    }}</code></pre><h2 id="线程安全性的可见性"><a href="#线程安全性的可见性" class="headerlink" title="线程安全性的可见性"></a>线程安全性的可见性</h2><p>什么是线程间的可见性？ </p><p>一个线程对共享变量值的修改，能够及时的被其他线程看到。</p><p>什么是共享变量？ </p><p>如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</p><p>导致共享变量在线程间不可见的原因：</p><pre><code>1.线程的交叉执行 2.重排序结合线程交叉执行 3.共享变量更新后的值没有在工作内存与主内存间及时更新 </code></pre><p>java语言层面支持的可见性实现方式有两种：</p><pre><code>1.synchronized 2.volatile</code></pre><p>1.synchronized的可见性：</p><p>JMM关于synchronized的两条规定： 这样简单使用synchronized就可以实现线程安全了</p><pre><code>1.线程解锁前（退出synchronized代码块之前），必须把共享变量的最新值刷新到主内存中，也就是说线程退出synchronized代码块值后，主内存中保存的共享变量的值已经是最新的了 2.线程加锁时（进入synchronized代码块之后），将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 两者结合：线程解锁前对共享变量的修改在下次加锁时对其他线程可见 </code></pre><p>2.volatile的可见性：</p><p>volatile能够保证volatile变量的可见性。</p><p>volatile如何实现内存可见性？</p><p>深入来说：通过加入<strong>内存屏障</strong>和<strong>禁止重排序优化</strong>来实现的。具体如下:</p><pre><code>1.对volatile变量执行写操作时，会在写操作后加入一条store屏障指令 2.对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 通俗的讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。线程写volatile变量的过程： 1.改变线程工作内存中volatile变量副本的值 2.将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程： 1.从主内存中读取volatile变量的最新值到线程的工作内存中 2.从工作内存中读取volatile变量的副本</code></pre><p>注意：<strong>volatile保证可见性，但是不保证原子性</strong>，实例如下(线程不安全)</p><pre><code class="java">public class  CountExample4 {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    //加了volatile但是还是线程不安全    public static volatile int count = 0;    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal ; i++) {            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    add();                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;count:{}&quot;, count);    }    private static void add() {        count++;        // 1、可见性：count读是最新的        // 2、+1  但是这里两个线程都对count=5进行+1，再写，原子性不保证了        // 3、可见性：count写是最新的    }}</code></pre><p>synchronized和volatile的比较 </p><pre><code>1.volatile不需要加锁，比synchronized更轻量级，不会阻塞线程 2.从内存可见性角度讲，volatile读操作=进入synchronized代码块（加锁），volatile写操作=退出synchronized代码块（解锁） 3.synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，不能保证原子性</code></pre><h2 id="线程安全性的有序性"><a href="#线程安全性的有序性" class="headerlink" title="线程安全性的有序性"></a>线程安全性的有序性</h2><p>有序性是指程序在执行的时候，程序的代码执行顺序和语句的顺序是一致的。</p><p>为什么会出现不一致的情况呢？</p><p>这是由于重排序的缘故。在Java内存模型中，允许编译器和处理器对<strong>指令进行重排序</strong>，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>解决方法：happens-before原则</p><h2 id="发布对象"><a href="#发布对象" class="headerlink" title="发布对象"></a>发布对象</h2><p>有时，我们会发现线程可以通过public方法获取的成员变量的引用进行修改，这样发布对象的话就是线程不安全的，如下：</p><pre><code class="java">public class UnsafePublish {    private String[] states = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};    public String[] getStates() {        return states;    }    public static void main(String[] args) {        UnsafePublish unsafePublish = new UnsafePublish();        log.info(&quot;{}&quot;, Arrays.toString(unsafePublish.getStates()));//out:[a,b,c]        //我们会发现线程可以通过public方法获取的成员变量的引用进行修改，这是不安全的        unsafePublish.getStates()[0] = &quot;d&quot;;        log.info(&quot;{}&quot;, Arrays.toString(unsafePublish.getStates()));//out:[d,b,c]    }}</code></pre><h2 id="单例模式（四种常用方法）"><a href="#单例模式（四种常用方法）" class="headerlink" title="单例模式（四种常用方法）"></a>单例模式（四种常用方法）</h2><p>1.饿汉式</p><pre><code class="java">/** * 饿汉模式 * 单例实例在类装载时进行创建 */@ThreadSafepublic class SingletonExample2 {    // 私有构造函数    private SingletonExample2() {    }    // 单例对象    private static SingletonExample2 instance = new SingletonExample2();    // 静态的工厂方法    public static SingletonExample2 getInstance() {        return instance;    }}</code></pre><p>2.懒汉式(double-check)</p><p>但是注意：double-check还是线程不安全（指令重排序的问题）–解决：volatile或者枚举</p><pre><code class="java">/** * 懒汉模式 -&gt; double-check单例模式 * 单例实例在第一次使用时进行创建 */@NotThreadSafepublic class SingletonExample4 {    // 私有构造函数    private SingletonExample4() {    }    // 1、memory = allocate() 分配对象的内存空间    // 2、ctorInstance() 初始化对象    // 3、instance = memory 设置instance指向刚分配的内存    // JVM和cpu优化，发生了指令重排，因此不是线程安全    // 1、memory = allocate() 分配对象的内存空间    // 3、instance = memory 设置instance指向刚分配的内存    // 2、ctorInstance() 初始化对象    // 单例对象    private static SingletonExample4 instance = null;    // 静态的工厂方法    public static SingletonExample4 getInstance() {        if (instance == null) { // 双重检测机制        // B            synchronized (SingletonExample4.class) { // 同步锁                if (instance == null) {                    instance = new SingletonExample4(); // A - 3                }            }        }        return instance;    }}</code></pre><p>3.枚举模式(最线程安全):</p><pre><code class="java">/** * 枚举模式：最安全 */@ThreadSafe@Recommend 推荐使用public class SingletonExample7 {    // 私有构造函数    private SingletonExample7() {    }    public static SingletonExample7 getInstance() {        return Singleton.INSTANCE.getInstance();    }    private enum Singleton {        INSTANCE;        private SingletonExample7 singleton;        // JVM保证这个方法绝对只调用一次        Singleton() {//在枚举的构造方法中创建对象            singleton = new SingletonExample7();        }        public SingletonExample7 getInstance() {            return singleton;        }    }}</code></pre><h2 id="对象逸出"><a href="#对象逸出" class="headerlink" title="对象逸出"></a>对象逸出</h2><p>双重检测机制不能保证线程安全–原因：指令重排–解决：volatile</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="线程安全策略–不可变对象"><a href="#线程安全策略–不可变对象" class="headerlink" title="线程安全策略–不可变对象"></a>线程安全策略–不可变对象</h2><p>1.final关键字实现不可变对象:</p><p>final修饰类：不能被继承</p><p>final修饰方法：锁定方法不被继承类修改</p><p>final修饰变量：基本数据类型变量(不可修改)，引用类型变量(不能再指向新对象)</p><pre><code class="java">public class ImmutableExample1 {    private final static Integer a = 1;    private final static String b = &quot;2&quot;;    private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();    static {        map.put(1, 2);        map.put(3, 4);        map.put(5, 6);    }    public static void main(String[] args) {//        a = 2; //值不可变//        b = &quot;3&quot;;//        map = Maps.newHashMap();//引用类型不能指向别的对象        map.put(1, 3); //但是可以对引用的对象进行修改        log.info(&quot;{}&quot;, map.get(1));    }    private void test(final int a) {//        a = 1;//类型是final，也是不能修改    }}  </code></pre><p>2.工具包实现不可变对象：</p><p>这两个工具：连引用的对象都不能被修改了，比final更牛逼</p><pre><code>1.Collections.unmodifiableXXX2.guava.immutable</code></pre><p>Collections.unmodifiableXXX</p><pre><code class="java">public class ImmutableExample2 {    private static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();    static {        map.put(1, 2);        map.put(3, 4);        map.put(5, 6);        map = Collections.unmodifiableMap(map);//这样map引用的对象都不能被修改    }    public static void main(String[] args) {        map.put(1, 3);//不能修改了，抛出异常        log.info(&quot;{}&quot;, map.get(1));//2    }}</code></pre><p>guava.immutableXXX</p><pre><code class="java">public class ImmutableExample3 {    private final static ImmutableList&lt;Integer&gt; list = ImmutableList.of(1, 2, 3);    private final static ImmutableSet set = ImmutableSet.copyOf(list);    private final static ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(1, 2, 3, 4);    private final static ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()            .put(1, 2).put(3, 4).put(5, 6).build();    public static void main(String[] args) {//        list.add(1);//抛出异常，不能被修改//        map.put(1,3);//抛出异常，不能被修改//        map2.put(1,3);//抛出异常，不能被修改        System.out.println(map2.get(3));//out: 4 取值没问题，可以取    }}</code></pre><h2 id="线程安全策略–线程封闭"><a href="#线程安全策略–线程封闭" class="headerlink" title="线程安全策略–线程封闭"></a>线程安全策略–线程封闭</h2><p>实现好的并发是一件困难的事情，所以很多时候我们都想躲避并发。避免并发最简单的方法就是线程封闭。什么是线程封闭呢？</p><p><strong>线程封闭就是把对象封装到一个线程里，只有这一个线程能看到此对象</strong>。那么这个对象就算不是线程安全的也不会出现任何安全问题。实现线程封闭有哪些方法呢？</p><p>1：ad-hoc线程封闭: 程序控制实现，最糟糕，忽略</p><p>2：<strong>栈封闭: 局部变量，无并发问题</strong></p><p><strong>栈封闭是我们编程当中遇到的最多的线程封闭。</strong>什么是栈封闭呢？简单的说就是局部变量。多个线程访问一个方法，此方法中的局部变量都会被拷贝一分儿到线程栈中。所以局部变量是不被多个线程所共享的，也就不会出现并发问题。所以能用局部变量就别用全局的变量，全局变量容易引起并发问题。</p><p>3.ThreadLocal封闭</p><p>使用ThreadLocal是实现线程封闭的最好方法。<strong>ThreadLocal内部维护了一个Map，Map的key是每个线程的名称，而Map的值就是我们要封闭的对象。</strong>每个线程中的对象都对应着Map中一个值，也就是ThreadLocal利用Map实现了对象的线程封闭。</p><h2 id="线程安全策略–非线程安全的类与方法"><a href="#线程安全策略–非线程安全的类与方法" class="headerlink" title="线程安全策略–非线程安全的类与方法"></a>线程安全策略–非线程安全的类与方法</h2><p>1.StringBuilder不安全 –&gt; 解决：StringBuffer安全(底层用了synchronized)</p><p>2.simpleDateFormat不安全 –&gt; 解决1：将simpleDateFormat变量弄成局部变量，在线程中创建，栈封闭，安全;  解决2：第三方包JodaTime.DateTimeFormat</p><p>3.Collection(ArrayList/HashSet/HashMap等)都不安全—&gt; 解决：同步容器，下面着重介绍</p><p>4.先检查再执行：if(condition(a)){handle(a);}可能不安全 –&gt; 解决：加锁/atomic CAS算法等方法</p><h2 id="线程安全–同步容器"><a href="#线程安全–同步容器" class="headerlink" title="线程安全–同步容器"></a>线程安全–同步容器</h2><p>同步容器：用来解决Collections(ArrayList/HashSet/HashMap等)线程不安全的问题</p><pre><code>1.ArrayList不安全 --&gt; Vector, Stack2.HashMap不安全 --&gt; HashTable(key, value不能为null)3.Collections.synchronizedXXX(List,Set,Map)</code></pre><p>Vector在某些情况下还是线程不安全。</p><p>Vector线程安全例子：</p><pre><code class="java">public class VectorExample1 {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    private static List&lt;Integer&gt; list = new Vector&lt;&gt;();//在本例中线程安全    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal; i++) {            final int count = i;            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    update(count);                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;size:{}&quot;, list.size());    }    private static void update(int i) {        list.add(i);    }}</code></pre><p>Vector线程不安全的例子：运行就报错，out of index</p><pre><code class="java">public class VectorExample2 {    private static Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();    public static void main(String[] args) {        while (true) {            for (int i = 0; i &lt; 10; i++) {                vector.add(i);            }            Thread thread1 = new Thread() {                public void run() {                    for (int i = 0; i &lt; vector.size(); i++) {                        vector.remove(i);//多个线程可能remove多了                    }                }            };            Thread thread2 = new Thread() {                public void run() {                    for (int i = 0; i &lt; vector.size(); i++) {                        vector.get(i);                    }                }            };            thread1.start();            thread2.start();        }    }}</code></pre><p>Collections.synchronizedXXX(List,Set,Map)线程安全的，举个例子：</p><pre><code>private static Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</code></pre><p>demo：</p><pre><code class="java">public class CollectionsExample1 {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal; i++) {            final int count = i;            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    update(count);                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;size:{}&quot;, list.size());    }    private static void update(int i){        list.add(i);    }}</code></pre><h2 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h2><p><strong>在遍历集合时尽量不要在遍历同时进行remove等修改操作(原因：fail-fast机制)</strong>，</p><p>fail-fast机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变</p><p>解决方法：若在多线程环境下使用fail-fast机制的集合，<strong>建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”</strong>； 或者先记下来，遍历完再remove等操作。</p><p>例子如下：</p><pre><code class="java">public class VectorExample3 {    // java.util.ConcurrentModificationException    private static void test1(Vector&lt;Integer&gt; v1) { // foreach        for(Integer i : v1) {            if (i.equals(3)) {                v1.remove(i);            }        }    }    // java.util.ConcurrentModificationException    private static void test2(Vector&lt;Integer&gt; v1) { // iterator        Iterator&lt;Integer&gt; iterator = v1.iterator();        while (iterator.hasNext()) {            Integer i = iterator.next();            if (i.equals(3)) {                v1.remove(i);            }        }    }    // success    private static void test3(Vector&lt;Integer&gt; v1) { // for        for (int i = 0; i &lt; v1.size(); i++) {            if (v1.get(i).equals(3)) {                v1.remove(i);            }        }    }    public static void main(String[] args) {        Vector&lt;Integer&gt; vector = new Vector&lt;&gt;();        vector.add(1);        vector.add(2);        vector.add(3);//        test1(vector);//异常//        test2(vector);//异常        test3(vector);    }}</code></pre><h2 id="线程安全–并发容器J-U-C"><a href="#线程安全–并发容器J-U-C" class="headerlink" title="线程安全–并发容器J.U.C"></a>线程安全–并发容器J.U.C</h2><p>J.U.C–java.util.concurrent</p><p><img src="https://img.braincao.cn/blogimg/1583506850.png" alt="1583506850"></p><p><strong>图中没有AQS，AbstractQueuedSynchronizer(AQS)是锁机制实现的核心所在。是这五大部分很多东西实现的前提。</strong></p><p>1.</p><p>ArrayList –&gt; CopyOnWriteArrayList线程安全(读操作不加锁，写操作底层是锁；且先copy另外开辟空间，这样就线程安全了)</p><pre><code>private static List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();`</code></pre><p>2.</p><p>HashSet –&gt; CopyOnWriteArraySet </p><p>TreeSet –&gt; ConcurrentSkipListSet</p><h5 id="3-重点，面试经常考"><a href="#3-重点，面试经常考" class="headerlink" title="3.(重点，面试经常考):"></a>3.(重点，面试经常考):</h5><pre><code>HashMap --&gt; ConcurrentHashMapTreeMap--&gt; ConcurrentSkipListMap</code></pre><p><strong>由于ConcurrentHashMap、ConcurrentSkipListMap经过优化后具有很高的并发性，因此面试中常考</strong></p><p>一、Hashmap</p><p>1.Hashmap的数据结构：</p><p>HashMap的底层就是一个数组结构，而数组中的每一项又是一个链表结构；</p><p>当我们新建一个HashMap的时候，就会初始化一个数组出来。</p><p>HashMap有两个参数影响它的性能，一个是初始容量（默认是16），一个是加载因子（默认是0.75）。</p><p>容量是哈希表中桶的数量。初始容量只是哈希表在创建时的容量；</p><p>加载因子是哈希表在容量自动增加之前，可以达到多满的一个尺度。如果达到了加载因子的值 ，那么会调用resize方法进行扩容。将容量进行翻倍。</p><p>这两个值在初始化时构造函数是可以自定义的。</p><p>2.Hashmap的寻址方式：</p><p>对于一个新插入的数据，或者我们需要读取的数据。Hashmap会对它的key按照一定的计算规则计算出的哈希值并对数组长度进行取模。结果作为它数组中的index。但是在计算机中取模的代价比较大，所以Hashmap要求数组的长度必须为2的N次方，此时呢它将key的哈希值对2的N-1次方进行与运算，结果与取模相同的。</p><p>Hashmap并不要求用户在初始化的时候指定容量必须传入的N次方的整数，而是在初始化时根据传入的参数计算出一个满足的容量值。源码中的tableSizeFor方法即可看到。</p><p>总所周知，<strong>Hashmap的线程不安全，其实主要体现在刚才的resize方法可能会出现死循环(出现循环链表)，以及使用迭代器会出现FastFail。</strong></p><p>当Hashmap得size超过容量乘加载因子的时候，就会进行扩容。就是创建了一个新的长度为原容量2倍的数组。并将原数组全部重新插入到现数组中，这个方法我们成为rehash。这个方法不保证线程安全，并且在多线程环境下可能会出现死循环。</p><p>二.HashMap–&gt;ConcurrentHashMap(key\value不允许空值)</p><p>1.ConcurrentHashMap的数据结构：</p><p><img src="https://img.braincao.cn/blogimg/1583506916.png" alt="1583506916"></p><p>也是数组+链表结构，但是最外层不像HashMap直接是个大的数组，而是Segment数组，每个Segment里面是跟HashMap结构差不多的链表数组</p><p><strong>Java7之前是分段锁。Java8之后在链表长度超过一定长度之后（默认是8），链表转化为了红黑树，提高并发性</strong></p><p>三.ConcurrentSkipListMap</p><p>ConcurrentSkipListMap的效率一般没有ConcurrentHashMap高，但是也有优点。</p><pre><code>1.可以保证有序性2.并发数越大，越能体现优势</code></pre><p>一个demo，线程安全：</p><pre><code class="java">public class ConcurrentSkipListMapExample {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    private static Map&lt;Integer, Integer&gt; map = new ConcurrentSkipListMap&lt;&gt;();    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal; i++) {            final int count = i;            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    update(count);                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;size:{}&quot;, map.size());    }    private static void update(int i) {        map.put(i, i);    }}</code></pre><h2 id="线程安全–并发容器J-U-C之AQS"><a href="#线程安全–并发容器J-U-C之AQS" class="headerlink" title="线程安全–并发容器J.U.C之AQS"></a>线程安全–并发容器J.U.C之AQS</h2><p>详看：<a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></p><p><a href="https://blog.csdn.net/jesonjoke/article/details/80054133" target="_blank" rel="noopener">慕课网实战·高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier</a></p><p>AQS: AbstractQueuedSynchronizer,它是一个Java提高的底层同步工具类。<strong>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列(“CLH”队列)来完成获取资源线程的排队工作</strong>。用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。AQS的主要作用是为Java中的并发同步组件提供统一的底层支持，例如ReentrantLock，CountdowLatch就是基于AQS实现的，用法是通过继承AQS实现其模版方法，然后将子类作为同步组件的内部类。</p><p>AQS设计思想：</p><p>1.使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。<br>利用int类型标识状态。在AQS类中有一个叫做state的成员变量</p><pre><code>/** * The synchronization state. */private volatile int state;</code></pre><p>2.基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</p><p>3.继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p><p>4.可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p><p>AQS主要组件：</p><pre><code>CountdowLatch 通过计数来保证线程是否需要阻塞Semaphore 表现剩余的许可数ReentrantLock 表现拥有它的线程已经请求了多少次锁</code></pre><p>AQS支持两种同步方式：</p><ul><li>独占式</li><li>共享式</li></ul><h2 id="AQS组件之CountdowLatch"><a href="#AQS组件之CountdowLatch" class="headerlink" title="AQS组件之CountdowLatch"></a>AQS组件之CountdowLatch</h2><p>通过一个计数来保证线程是否需要被阻塞。实现一个或多个线程等待其他线程执行的场景。</p><p>我们定义一个CountDownLatch，通过给定的计数器为其初始化，该计数器是原子性操作，保证同时只有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态。只有其他线程调用countDown方法（每次使计数器-1），使计数器归零才能继续执行。</p><pre><code class="java">final CountDownLatch countDownLatch = new CountDownLatch(threadCount);for (int i = 0; i &lt; threadCount; i++) {    final int threadNum = i;    exec.execute(() -&gt; {        try {            test(threadNum);  //需要被等待的线程执行的方法        } catch (Exception e) {            log.error(&quot;exception&quot;, e);        } finally {            countDownLatch.countDown();        }    });}countDownLatch.await();log.info(&quot;finish&quot;);//必须在countDownLatch减为0后才会执行await()后面的代码exec.shutdown();</code></pre><p>可以看到，线程池必须在countDownLatch减为0后才会执行await()后面的代码</p><h2 id="AQS组件之Semaphore"><a href="#AQS组件之Semaphore" class="headerlink" title="AQS组件之Semaphore"></a>AQS组件之Semaphore</h2><pre><code>用于保证同一时间并发访问线程的数目。信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。使用场景：仅能提供有限访问的资源。比如数据库连接。Semaphore使用acquire方法和release方法来实现控制：</code></pre><p>代码：</p><pre><code class="java">public class SemaphoreExample1 {    private final static int threadCount = 20;    public static void main(String[] args) throws Exception {        ExecutorService exec = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(3);//一个线程可访问的许可总数        for (int i = 0; i &lt; threadCount; i++) {            final int threadNum = i;            exec.execute(() -&gt; {                try {                    semaphore.acquire(); // 获取一个许可                    test(threadNum);                    semaphore.release(); // 释放一个许可                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }            });        }        exec.shutdown();    }    private static void test(int threadNum) throws Exception {        log.info(&quot;{}&quot;, threadNum);        Thread.sleep(1000);    }}</code></pre><h2 id="AQS组件之CyclicBarrier"><a href="#AQS组件之CyclicBarrier" class="headerlink" title="AQS组件之CyclicBarrier"></a>AQS组件之CyclicBarrier</h2><p>也是一个同步辅助类，<strong>它允许一组线程相互等待，直到到达某个公共的屏障点（循环屏障）才一起执行</strong></p><p>通过它可以完成多个线程之间相互等待，只有每个线程都准备就绪后才能继续往下执行后面的操作。</p><p>每当有一个线程执行了await方法，计数器就会执行+1操作，待计数器达到预定的值，所有的线程再同时继续执行。由于计数器释放之后可以重用（reset方法），所以称之为循环屏障。</p><p><strong>CyclicBarrier与CountDownLatch区别：</strong></p><ul><li>1、CyclicBarrier计数器可重复用 </li><li>2、CyclicBarrier描述一个或多个线程等待其他线程的关系/多个线程相互等待</li></ul><p>代码：</p><pre><code class="java">public class CyclicBarrierExample1 {    private static CyclicBarrier barrier = new CyclicBarrier(5);    public static void main(String[] args) throws Exception {        ExecutorService executor = Executors.newCachedThreadPool();        for (int i = 0; i &lt; 10; i++) {            final int threadNum = i;            Thread.sleep(1000);            executor.execute(() -&gt; {                try {                    race(threadNum);                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }            });        }        executor.shutdown();    }    private static void race(int threadNum) throws Exception {        Thread.sleep(1000);        log.info(&quot;{} is ready&quot;, threadNum);        barrier.await();//等待多个线程准备好一起执行        log.info(&quot;{} continue&quot;, threadNum);    }}out:0 is ready1 is ready2 is ready3 is ready4 is ready0 continue1 continue2 continue3 continue4 continue5 is ready...</code></pre><h2 id="AQS组件之ReentrantLock"><a href="#AQS组件之ReentrantLock" class="headerlink" title="AQS组件之ReentrantLock"></a>AQS组件之ReentrantLock</h2><p>ReentrantLock<br>java中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。</p><p><strong>ReentrantLock与synchronized的区别</strong></p><p>可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁</p><p>锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。</p><p>性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐</p><p>synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）</p><p>功能区别： </p><ul><li><p>1.便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p></li><li><p>2.锁的细粒度和灵活度，ReentrantLock优于synchronized</p></li></ul><pre><code class="java">public class LockExample2 {    // 请求总数    public static int clientTotal = 5000;    // 同时并发执行的线程数    public static int threadTotal = 200;    public static int count = 0;    private final static Lock lock = new ReentrantLock();    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        final Semaphore semaphore = new Semaphore(threadTotal);        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);        for (int i = 0; i &lt; clientTotal ; i++) {            executorService.execute(() -&gt; {                try {                    semaphore.acquire();                    add();                    semaphore.release();                } catch (Exception e) {                    log.error(&quot;exception&quot;, e);                }                countDownLatch.countDown();            });        }        countDownLatch.await();        executorService.shutdown();        log.info(&quot;count:{}&quot;, count);    }    private static void add() {        lock.lock();//上锁        try {            count++;        } finally {            lock.unlock();//解锁        }    }}</code></pre><p>还有个ReadWriteLock读写锁</p><h2 id="Java不可重入锁和可重入锁理解"><a href="#Java不可重入锁和可重入锁理解" class="headerlink" title="Java不可重入锁和可重入锁理解"></a>Java不可重入锁和可重入锁理解</h2><p><a href="https://blog.csdn.net/u012545728/article/details/80843595" target="_blank" rel="noopener">Java不可重入锁和可重入锁理解</a></p><p>所谓不可重入锁（自旋锁），即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。</p><p>所谓可重入，意味着线程可以进入它已经拥有的锁的同步代码块儿。</p><p>java中的synchronized、ReentrantLock都是可重入锁</p><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><p>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><p>乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制(如stampedLock)。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中<strong>java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</strong></p><h1 id="Day-3"><a href="#Day-3" class="headerlink" title="Day.3"></a>Day.3</h1><h2 id="J-U-C之FutureTask"><a href="#J-U-C之FutureTask" class="headerlink" title="J.U.C之FutureTask"></a>J.U.C之FutureTask</h2><p><strong>当想获取线程返回结果时，应该实现callable接口，而FutureTask就是超级方便的东西，使用它就行。</strong>。FutureTask 表现任务的状态(尚未开始、运行、完成和取消)</p><p>FutureTask是J.U.C中的类，是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)。</p><p>Runnable与Callable对比</p><p>通常实现一个线程我们会使用继承Thread的方式或者实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从Java1.5之后就提供了<strong>Callable与Future，这两个接口就可以实现获取任务执行结果</strong>。</p><p>Future接口提供了一系列方法用于控制线程执行计算</p><p>FutureTask</p><p>Future实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p><p><strong>FutureTask支持两种参数类型，Callable和Runnable，在使用Runnable 时，还可以多指定一个返回结果类型。</strong></p><p>当使用future接口：</p><pre><code class="java">public class FutureExample {    static class MyCallable implements Callable&lt;String&gt; {        @Override        public String call() throws Exception {            log.info(&quot;do something in callable&quot;);            Thread.sleep(5000);            return &quot;Done&quot;;        }    }    public static void main(String[] args) throws Exception {        ExecutorService executorService = Executors.newCachedThreadPool();        Future&lt;String&gt; future = executorService.submit(new MyCallable());        log.info(&quot;do something in main&quot;);        Thread.sleep(1000);        String result = future.get();        log.info(&quot;result：{}&quot;, result);    }}out:do something in callabledo something in mainresult：Done</code></pre><p>使用FutureTask更方便(out是一样的)：</p><pre><code class="java">public class FutureTaskExample {    public static void main(String[] args) throws Exception {        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {            @Override            public String call() throws Exception {                log.info(&quot;do something in callable&quot;);                Thread.sleep(5000);                return &quot;Done&quot;;            }        });        new Thread(futureTask).start();        log.info(&quot;do something in main&quot;);        Thread.sleep(1000);        String result = futureTask.get();        log.info(&quot;result：{}&quot;, result);    }}</code></pre><h2 id="J-U-C之ForkJoin"><a href="#J-U-C之ForkJoin" class="headerlink" title="J.U.C之ForkJoin"></a>J.U.C之ForkJoin</h2><p>ForkJoin是Java7提供的一个并行执行任务的框架，<strong>是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架</strong>。主要采用的是工作窃取算法，工作窃取算法是指某个线程从其他队列里窃取任务来执行。 这个思想和MapReduce算法类似</p><p><img src="https://img.braincao.cn/blogimg/1583506947.png" alt="1583506947"></p><p>在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。</p><p>一个1~100和的任务示例:</p><pre><code class="java">public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; {    public static final int threshold = 2;    private int start;    private int end;    public ForkJoinTaskExample(int start, int end) {        this.start = start;        this.end = end;    }    @Override    protected Integer compute() {        int sum = 0;        //如果任务足够小就计算任务        boolean canCompute = (end - start) &lt;= threshold;        if (canCompute) {            for (int i = start; i &lt;= end; i++) {                sum += i;            }        } else {            // 如果任务大于阈值，就分裂成两个子任务计算            int middle = (start + end) / 2;            ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);            ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);            // 执行子任务            leftTask.fork();            rightTask.fork();            // 等待任务执行结束合并其结果            int leftResult = leftTask.join();            int rightResult = rightTask.join();            // 合并子任务            sum = leftResult + rightResult;        }        return sum;    }    public static void main(String[] args) {        ForkJoinPool forkjoinPool = new ForkJoinPool();        //生成一个计算任务，计算1+2+3+4        ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);        //执行一个任务        Future&lt;Integer&gt; result = forkjoinPool.submit(task);        try {            log.info(&quot;result:{}&quot;, result.get());        } catch (Exception e) {            log.error(&quot;exception&quot;, e);        }    }}</code></pre><h2 id="J-U-C之BlockingQueue阻塞队列"><a href="#J-U-C之BlockingQueue阻塞队列" class="headerlink" title="J.U.C之BlockingQueue阻塞队列"></a>J.U.C之BlockingQueue阻塞队列</h2><p>阻塞情况：1、当队列满了进行入队操作; 2、当队列空了的时候进行出队列操作</p><p>BlockingQueue阻塞队列主要应用场景：生产者消费者模型，是线程安全的</p><p><img src="https://img.braincao.cn/blogimg/1583506978.png" alt="1583506978"></p><p>想使用阻塞队列就使用它的实现类即可，如ArrayBlockingQueue、DelayQueue、DalayQueue、LinkedBlockingQueue、PriorityBlockingQueue、SynchronusQueue（这里不一一介绍了）</p><h2 id="J-U-C之线程池-重点"><a href="#J-U-C之线程池-重点" class="headerlink" title="J.U.C之线程池(重点)"></a>J.U.C之线程池(重点)</h2><p><strong>new Thread的弊端</strong></p><p>1.每次new Thread 新建对象，性能差</p><p>2.线程缺乏统一管理，可能无限制的新建线程，相互竞争，可能占用过多的系统资源导致死机或者OOM（out of memory 内存溢出），这种问题的原因不是因为单纯的new一个Thread，而是可能因为程序的bug或者设计上的缺陷导致不断new Thread造成的。</p><p>3.缺少更多功能，如更多执行、定期执行、线程中断。</p><p><strong>线程池的好处</strong></p><p>1.重用存在的线程，不需要每次都创建，减少对象创建、消亡的开销，性能好</p><p>2.可有效控制最大并发线程数，提高系统资源利用率，同时可以避免过多资源竞争，避免阻塞。</p><p>3.提供定时执行、定期执行、单线程、并发数控制等功能。</p><p><strong>线程池核心类-ThreadPoolExecutor</strong></p><p>参数说明：ThreadPoolExecutor一共有七个参数，这七个参数配合起来，构成了线程池强大的功能。</p><pre><code>corePoolSize：核心线程数量maximumPoolSize：线程最大线程数workQueue：阻塞队列，存储等待执行的任务，很重要，会对线程池运行过程产生重大影响keepAliveTime：线程没有任务执行时最多保持多久时间终止（当线程中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交核心线程外的线程不会立即销毁，而是等待，直到超过keepAliveTime）unit：keepAliveTime的时间单位threadFactory：线程工厂，用来创建线程，有一个默认的工场来创建线程，这样新创建出来的线程有相同的优先级，是非守护线程、设置好了名称）rejectHandler：当拒绝处理任务时(阻塞队列满)的策略（AbortPolicy默认策略直接抛出异常、CallerRunsPolicy用调用者所在的线程执行任务、DiscardOldestPolicy丢弃队列中最靠前的任务并执行当前任务、DiscardPolicy直接丢弃当前任务） </code></pre><p><strong>线程池生命周期</strong></p><p><img src="https://img.braincao.cn/blogimg/1583507011.png" alt="1583507011"></p><pre><code>running：能接受新提交的任务，也能处理阻塞队列中的任务shutdown：不能处理新的任务，但是能继续处理阻塞队列中任务stop：不能接收新的任务，也不处理队列中的任务tidying：如果所有的任务都已经终止了，这时有效线程数为0terminated：最终状态</code></pre><p><strong>使用Executor创建线程池</strong></p><p>使用Executor可以创建四种线程池：分别对应四种线程池初始化方法。</p><p>1、Executors.newCachedThreadPool </p><p>创建一个可缓存的线程池，如果线程池的长度超过了处理的需要，可以灵活回收空闲线程。如果没有可回收的就新建线程。</p><p>2、newFixedThreadPool</p><p>定长线程池，可以线程现成的最大并发数，超出在队列等待</p><p>3、newSingleThreadExecutor</p><p>单线程化的线程池，用唯一的一个共用线程执行任务，保证所有任务按指定顺序执行（FIFO、优先级…）</p><p>4、newScheduledThreadPool </p><p>定长线程池，支持定时和周期任务执行</p><pre><code class="java">public class ThreadPoolExample1 {    public static void main(String[] args) {        ExecutorService executorService = Executors.newCachedThreadPool();        for (int i = 0; i &lt; 10; i++) {            final int index = i;            executorService.execute(new Runnable() {                @Override                public void run() {                    log.info(&quot;task:{}&quot;, index);                }            });        }        executorService.shutdown();    }}</code></pre><h2 id="多线程并发扩展–死锁"><a href="#多线程并发扩展–死锁" class="headerlink" title="多线程并发扩展–死锁"></a>多线程并发扩展–死锁</h2><p>死锁产生的必要条件</p><pre><code>互斥条件：进程对锁分配的资源进行排他性使用请求和保持条件：线程已经保持了一个资源，但是又提出了其他请求，而该资源已被其他线程占用不剥夺条件：在使用时不能被剥夺，只能自己用完释放环路等待条件：资源调用是一个环形的链</code></pre><p>死锁示例：</p><pre><code class="java">public class DeadLock implements Runnable {    public int flag = 1;    //静态对象是类的所有对象共享的    private static Object o1 =  new Object(), o2 = new Object();    @Override    public void run() {        if (flag == 1) {            synchronized (o1) {                try {                    log.info(&quot;flag:{}&quot;, flag);                    Thread.sleep(500);                } catch (Exception e) {                    e.printStackTrace();                }                synchronized (o2) {                    log.info(&quot;1&quot;);                }            }        }        if (flag == 0) {            synchronized (o2) {                try {                    log.info(&quot;flag:{}&quot;, flag);                    Thread.sleep(500);                } catch (Exception e) {                    e.printStackTrace();                }                synchronized (o1) {                    log.info(&quot;0&quot;);                }            }        }    }    public static void main(String[] args) {        DeadLock td1 = new DeadLock();        DeadLock td2 = new DeadLock();        td1.flag = 1;        td2.flag = 0;        //td1,td2都处于可执行状态，但JVM线程调度先执行哪个线程是不确定的。        //td2的run()可能在td1的run()之前运行        new Thread(td1).start();        new Thread(td2).start();    }}out：flag:0flag:1....</code></pre><h2 id="多线程并发的最佳实践"><a href="#多线程并发的最佳实践" class="headerlink" title="多线程并发的最佳实践"></a>多线程并发的最佳实践</h2><p>1.使用本地变量</p><p>2.使用不可变类</p><p>3.使用线程池的Executor,而不是直接new Thread执行</p><p>4.宁可使用同步(countdownLatch/semaphore)也不要使用线程的wait/notify</p><p>5.使用blockingqueue实现生产-消费模式</p><p>6.使用并发集合(CopyonWriteArrayList/concurrentHashMap)而不是加了锁的同步集合(synchronizedXXX)</p><p>7.使用semaphore创建有界的访问</p><p>8.宁可使用同步代码块，也不使用同步的方法</p><p>9.避免使用静态变量(静态变量在并发情况下会出现很多问题，避免使用)</p><h2 id="高并发之扩容思路"><a href="#高并发之扩容思路" class="headerlink" title="高并发之扩容思路"></a>高并发之扩容思路</h2><p>读操作扩展(如博客系统)：memcached、redis、CDN缓存</p><p>写操作扩展(如订单系统)：Cassandra、Hbase等</p><h2 id="高并发之缓存思路"><a href="#高并发之缓存思路" class="headerlink" title="高并发之缓存思路"></a>高并发之缓存思路</h2><p><strong>缓存分类</strong></p><pre><code>本地缓存：编程实现(成员变量、局部变量、静态变量)、Guava Cache分布式缓存：Memcached、Redis(更常用)</code></pre><p><strong>缓存清空策略</strong>：FIFO、LFU、LRU、过期时间、随机</p><p>FIFO：先进先出，优先保证最新数据的有效性</p><p>LFU：最少使用策略，优先保证高频数据的有效性</p><p>LRU：最近使用策略，优先保证热点数据的有效性</p><p><strong>关于Memcached\Redis请左转详看</strong>：<a href="https://www.cnblogs.com/lina520/p/7919551.html" target="_blank" rel="noopener">吐血强推_Nosql简介 Redis,Memchche,MongoDb的区别</a></p><h2 id="jRedis的demo"><a href="#jRedis的demo" class="headerlink" title="jRedis的demo"></a>jRedis的demo</h2><p>0.application.properties</p><pre><code># redisjedis.host = 127.0.0.1jedis.port = 6379</code></pre><p>1.RedisConfig</p><pre><code class="java">public class RedisConfig {    @Bean(name = &quot;redisPool&quot;)    public JedisPool jedisPool(@Value(&quot;${jedis.host}&quot;) String host,                               @Value(&quot;${jedis.port}&quot;) int port) {        return new JedisPool(host, port);    }}</code></pre><p>2.RedisClient:指定jedisPool，自定义set和get方法，当然还可以写更多的方法功能</p><pre><code class="java">public class RedisClient {    @Resource(name = &quot;redisPool&quot;)    private JedisPool jedisPool;    public void set(String key, String value) throws Exception {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            jedis.set(key, value);        } finally {            if (jedis != null) {                jedis.close();            }        }    }    public String get(String key) throws Exception {        Jedis jedis = null;        try {            jedis = jedisPool.getResource();            return jedis.get(key);        } finally {            if (jedis != null) {                jedis.close();            }        }    }}</code></pre><p>3.CacheController:调用redis</p><pre><code class="java">@Controller@RequestMapping(&quot;/cache&quot;)public class CacheController {    @Autowired    private RedisClient redisClient;    @RequestMapping(&quot;/set&quot;)    @ResponseBody    public String set(@RequestParam(&quot;k&quot;) String k, @RequestParam(&quot;v&quot;) String v)            throws Exception {        redisClient.set(k, v);        return &quot;SUCCESS&quot;;    }    @RequestMapping(&quot;/get&quot;)    @ResponseBody    public String get(@RequestParam(&quot;k&quot;) String k) throws Exception {        return redisClient.get(k);    }}</code></pre><p>4.启动项目 + 启动redis-server，在postman中输入请求:</p><p><code>http://localhost:8080/cache/set?k=test1&amp;v=1</code> – success</p><p><code>http://localhost:8080/cache/get?k=test1</code> – 1</p><h2 id="面试常考的一致性Hash算法"><a href="#面试常考的一致性Hash算法" class="headerlink" title="面试常考的一致性Hash算法"></a>面试常考的一致性Hash算法</h2><p><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368" target="_blank" rel="noopener">面试必备：什么是一致性Hash算法？</a></p><p><img src="https://img.braincao.cn/blogimg/1583507035.jpg" alt="1583507035"></p><p>一个hash环，顺时针找</p><h2 id="高并发之消息队列"><a href="#高并发之消息队列" class="headerlink" title="高并发之消息队列"></a>高并发之消息队列</h2><p><strong>为什么要使用消息队列？</strong></p><p>主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过<strong>使用消息队列，我们可以异步处理请求</strong>，从而缓解系统的压力。</p><p><strong>消息队列特性</strong></p><p>业务无关：只做消息分发(业务解耦)</p><p>FIFO：先投递先到达</p><p>容灾：节点的动态增删和消息的持久化</p><p>性能：吞吐量提升，系统内部通信效率提高</p><p>广播</p><p>错峰与流控</p><p><strong>Apache Kafka消息队列</strong></p><p>消息持久化</p><p>高吞吐</p><p><strong>RabbitMQ消息队列</strong></p><p>可视化界面</p><h2 id="高并发之应用拆分"><a href="#高并发之应用拆分" class="headerlink" title="高并发之应用拆分"></a>高并发之应用拆分</h2><p><strong>拆分原则：</strong>业务优先、循序渐进、重构+分层、可靠测试</p><p><strong>应用之间的通信：RPC(dubbo等)、消息队列</strong></p><h2 id="高并发其他知识点"><a href="#高并发其他知识点" class="headerlink" title="高并发其他知识点"></a>高并发其他知识点</h2><p><strong>常见限流算法</strong>：计数器算法、漏斗桶算法、令牌桶算法</p><p><strong>数据库切库</strong>： 主从库，主库实时，从库异步</p><p><strong>数据库分表</strong>：mybatis分表插件shardbatis2.0</p><p><strong>高可用的一些手段</strong>：</p><p>1.任务调度系统分布式：elastic-job + zookeeper</p><p>2.主备切换：apache curator + zookeeper分布式锁实现。两台服务器交替进行服务</p><p>3.监控报警机制</p><p><a href="https://www.cnblogs.com/heyonggang/p/9112731.html" target="_blank" rel="noopener">面试必备：HashMap、Hashtable、ConcurrentHashMap的原理与区别</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/2018/12/16/java-collection/"/>
      <url>/2018/12/16/java-collection/</url>
      
        <content type="html"><![CDATA[<p>此文档为java集合的学习总结</p><a id="more"></a><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><pre><code>Collection接口：    List接口：有序，可以重复        ArrayList(主要实现类)        LinkedList(频繁的插入、删除操作)        Vector(古老的实现类，线程安全)    Set接口：无序、不可重复        HashSet(主要实现类)        LinkedHashSet(使用链表维护了添加元素顺序，可以有序遍历，但底层存储元素还是hash无序的)        TreeSet(可以按照添加进集合中的元素的指定顺序遍历)Map接口：存储key-value对        HashMap、LinkedHashMap、TreeMap、HashTable(-Properties)两个排序接口：    自然排序：实现Comparable接口重写compareTo()方法    定制排序：创建TreeSet时传入Comparator对象</code></pre><p>LinkedList类</p><p>LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。<strong>这些操作使LinkedList可被用作队列（queue）或双向队列（deque）</strong>，因为LinkedList类也实现了Queue、Deque接口。</p><pre><code class="java">import java.util.LinkedList; //这是实现了List、Queue、Deque等接口的实现类import java.util.Queue; //这是队列的接口public class Main {    public static void main(String[] args) {        //add()和remove()方法在失败的时候会抛出异常(不推荐)        Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();        //队尾添加元素        queue.offer(&quot;a&quot;);        queue.offer(&quot;b&quot;);        queue.offer(&quot;c&quot;);        queue.offer(&quot;d&quot;);        queue.offer(&quot;e&quot;);        for(String q : queue){            System.out.println(q);        }        System.out.println(&quot;===&quot;);        System.out.println(&quot;poll=&quot;+queue.poll()); //返回并删除队头元素        for(String q : queue){            System.out.println(q);        }        System.out.println(&quot;===&quot;);        System.out.println(&quot;element=&quot;+queue.element()); //返回第一个元素         for(String q : queue){            System.out.println(q);        }        System.out.println(&quot;===&quot;);        System.out.println(&quot;peek=&quot;+queue.peek()); //返回第一个元素         for(String q : queue){            System.out.println(q);        }    }}out:abcde===poll=abcde===element=bbcde===peek=bbcde</code></pre><p>注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List:</p><p><code>List list = Collections.synchronizedList(new LinkedList(...));</code></p><p>Set</p><p>Set中的元素是用hash算法来存储的。</p><p>hash算法：当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算此对象的hash值，此hash值决定了此对象在Set中的存储位置。若此位置没有对象存储，则存储该对象，若已有对象，再通过equals()方法比较两个对象是否相等，如果相等则不再存储，如果不相等，则hash冲突往后进行存储。</p><p>hash算法使Set有不可重复性，因此若要往Set中添加元素时，该元素所在的类需要同时重写equals()和hashCode()方法。</p><p>#####TreeSet</p><p>与其他Set不同，TreeSet中的元素必须是同一类的，且涉及排序(自然排序、定制排序)，TreeSet底层按照红黑树进行排序。</p><p>自然排序：需要TreeSet中元素所在的类实现Comparable接口，重写相应的compareTo()方法。<br>compareTo()、equals()、hashCode()三者须一致。如果不一致，判断set重复元素时先按照compareTO()中定义的来，如compareTO()定义的name比较，那么相同名字的就算重复元素。</p><p>定制排序：创建TreeSet时传入Comparator对象</p><pre><code class="java">import org.junit.Test;import java.util.*;/** * TreeSet自然排序、定制排序的演示例子 * 自然排序：需要TreeSet中元素所在的类实现Comparable接口，重写相应的compareTo()方法 * 定制排序：创建TreeSet时传入Comparator对象 */public class TestTreeSet{    //自然排序：需要Employee实现Comparable接口。这里按照name进行排序    @Test    public void test1(){        Employee e1 = new Employee(&quot;名1&quot;, 25, new MyDate(1990,10,13));        Employee e6 = new Employee(&quot;名1&quot;, 24, new MyDate(1990,10,13));        Employee e2 = new Employee(&quot;名2&quot;, 21, new MyDate(1993,10,13));        Employee e3 = new Employee(&quot;学1&quot;, 21, new MyDate(1993,6,13));        Employee e4 = new Employee(&quot;张2&quot;, 21, new MyDate(1993,6,20));        Employee e5 = new Employee(&quot;名5&quot;, 26, new MyDate(1997,3,13));        TreeSet set = new TreeSet();        set.add(e1);        set.add(e2);        set.add(e3);        set.add(e4);        set.add(e5);        set.add(e6);        Iterator it = set.iterator();        while(it.hasNext()){            System.out.println(it.next());        }    }    //定制排序：创建TreeSet时传入Comparator对象。这里按照生日进行排序    @Test    public void test2(){        Comparator com = new Comparator() {            @Override            public int compare(Object o1, Object o2) {                if(o1 instanceof Employee &amp;&amp; o2 instanceof Employee){                    Employee e1 = (Employee)o1;                    Employee e2 = (Employee)o2;                    MyDate bir1 = e1.getBirthday();                    MyDate bir2 = e2.getBirthday();                    if(bir1.getYear() == bir2.getYear()){                        if(bir1.getMonth() == bir2.getMonth()){                            return bir1.getDay() - bir2.getDay();                        }                        return bir1.getMonth() - bir2.getMonth();                    }                    return bir1.getYear() - bir2.getYear();                }                return 0;            }        };        Employee e1 = new Employee(&quot;名1&quot;, 25, new MyDate(1990,10,13));        Employee e6 = new Employee(&quot;名1&quot;, 24, new MyDate(1990,10,13));        Employee e2 = new Employee(&quot;名2&quot;, 21, new MyDate(1993,10,13));        Employee e3 = new Employee(&quot;学1&quot;, 21, new MyDate(1993,6,13));        Employee e4 = new Employee(&quot;张2&quot;, 21, new MyDate(1993,6,20));        Employee e5 = new Employee(&quot;名5&quot;, 26, new MyDate(1997,3,13));        TreeSet set = new TreeSet(com);        set.add(e1);        set.add(e2);        set.add(e3);        set.add(e4);        set.add(e5);        set.add(e6);        Iterator it = set.iterator();        while(it.hasNext()){            System.out.println(it.next());        }    }}class Employee implements Comparable{    private String name;    private int age;    private MyDate birthday;    //自然排序：需要Employee实现Comparable接口。这里按照name进行排序    public int compareTo(Object o){        if(o instanceof Employee){            Employee e = (Employee)o;            return this.name.compareTo(e.getName());        }        return 0;    }    public Employee(String name, int age, MyDate birthday) {        this.name = name;        this.age = age;        this.birthday = birthday;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public MyDate getBirthday() {        return birthday;    }    public void setBirthday(MyDate birthday) {        this.birthday = birthday;    }    @Override    public String toString() {        return &quot;Employee{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, birthday=&quot; + birthday +                &#39;}&#39;;    }    //同时需要重写equals方法，因为TreeSet中如contains等方法都需要equals判断    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Employee employee = (Employee) o;        return age == employee.age &amp;&amp;                Objects.equals(name, employee.name) &amp;&amp;                Objects.equals(birthday, employee.birthday);    }    @Override    public int hashCode() {        return Objects.hash(name, age, birthday);    }}class MyDate{    private int month;    private int day;    private int year;    public MyDate(int year, int month, int day) {        this.month = month;        this.day = day;        this.year = year;    }    public int getMonth() {        return month;    }    public void setMonth(int month) {        this.month = month;    }    public int getDay() {        return day;    }    public void setDay(int day) {        this.day = day;    }    public int getYear() {        return year;    }    public void setYear(int year) {        this.year = year;    }    @Override    public String toString() {        return &quot;MyDate{&quot; +                &quot;month=&quot; + month +                &quot;, day=&quot; + day +                &quot;, year=&quot; + year +                &#39;}&#39;;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        MyDate myDate = (MyDate) o;        return month == myDate.month &amp;&amp;                day == myDate.day &amp;&amp;                year == myDate.year;    }    @Override    public int hashCode() {        return Objects.hash(month, day, year);    }}</code></pre><p>#####Map接口</p><blockquote><p>HashMap：主要实现类</p><p>LinkedHashMap：使用链表维护添加进Map中的顺序，故遍历Map时，是按添加顺序遍历的</p><p>TreeMap：按照添加进Map中元素的key的指定属性进行排序。故key必须是同一类的对象</p><p>Hashtable(子类Properties):Hashtable古老实现类，线程安全</p></blockquote><p>Map与Collection并列存在，用于保存具有映射关系的数据:key-value</p><p>Map中的key和value都可以是任何引用类型的数据</p><p>Map中的key用Set来存放，不可重复，即同一个Map对象所对应的类，须重写hashCode()、equals()方法</p><p>各类Set其实就是Map的特例，Map中的key-value的value=null即为Set</p><p>常用String类作为Map的key</p><p>key和value之间存在单项一对一关系，即通过指定的key总能找到唯一的、确定的value</p><h5 id="Java遍历Map对象的四种方式"><a href="#Java遍历Map对象的四种方式" class="headerlink" title="Java遍历Map对象的四种方式"></a>Java遍历Map对象的四种方式</h5><p><a href="https://www.cnblogs.com/fqfanqi/p/6187085.html" target="_blank" rel="noopener">Java遍历Map对象的四种方式</a></p><p>文中讲了四种遍历方法，最快捷常用的是：</p><pre><code class="java">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) {   System.out.println(&quot;Key = &quot; + entry.getKey() + &quot;, Value = &quot; + entry.getValue()); }</code></pre><p>#####HashMap</p><p>向HashMap中添加元素时，会调用key所在类的equals方法，判断两个key是否相同，若相同则只能添加后面添加的那个元素（覆盖前面元素）</p><p>HashMap遍历key集、value集。key是Set，value是Collection、key-value对是一个Set entrySet()</p><pre><code class="java">public void test1(){    HashMap hm = new HashMap();    hm.put(123, &quot;asdad&quot;);    hm.put(&quot;AA&quot;, 12532);    hm.put(1234, new SimpleDateFormat(&quot;mm:ss&quot;).format(new Date()));    System.out.println(hm);    //遍历key集    Set set = hm.keySet();    Iterator it = set.iterator();    while(it.hasNext()){//迭代器遍历        System.out.println(it.next());    }    for(Object o: set){//增强for循环遍历        System.out.println(o);    }    //遍历value集    for(Object o: set){//通过key遍历来遍历value        System.out.println(hm.get(o));    }    Collection coll = hm.values();    for(Object o: coll){//通过value集的增强for循环遍历        System.out.println(o);    }    //遍历key-value对    //通过上述key遍历来遍历value可以得到，另一种方法是key-value对是一个Set entrySet()    Set entry = hm.entrySet();    for(Object obj: entry){        Map.Entry ety = (Map.Entry)obj;        System.out.println(ety.getKey() + &quot;--&gt;&quot; + ety.getValue());    }}</code></pre><p>#####TreeMap</p><p>TreeSet是特殊的TreeMap，按照添加进Map中元素的key的指定属性进行排序。因此TreeMap的key必须是同一类的对象，且有自然排序、定制排序。</p><p>自然排序：key元素所在类要实现Comparable接口重写compareTo()、equals()、hashCode()方法</p><p>定制排序：创建TreeMap时传入Comparator对象</p><p>#####Hashtable</p><p>Hashtable古老实现类，线程安全</p><p>与HashMap不同，Hashtable不允许使用null作为key和value</p><p>与HashMap一样，Hashtable也不能保证其中key-value对的顺序</p><p>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致</p><p>Hashtable的子类Properties：常用来处理属性文件，key、value都为String类型</p><pre><code class="java">import org.junit.Test;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.*;public class TestHashMap{    @Test    public void test1() throws IOException{        Properties pro = new Properties();        pro.load(new FileInputStream(new File(&quot;abc.properties&quot;)));        String user = pro.getProperty(&quot;user&quot;);        String pass = pro.getProperty(&quot;password&quot;);        System.out.println(user + &quot;:&quot; + pass);    }}//abc.properties//user=root//pass=123456//out:  root:123456</code></pre><p>#####Collections：操作集合的工具类</p><p>Arrays是一个操作数组的工具类；Collections是一个操作Set、List、Map等集合的工具类</p><p>Collections提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制方法</p><p>1.排序操作：</p><pre><code class="java">Collections.reverse(list);//反转list中元素的顺序Collections.shuffle(list);//对list集合元素进行随机排序Collections.sort(list); //根据元素的自然顺序对list集合元素进行升序排序Collections.sort(list, Comparator); //根据指定的Comparator产生的顺序对list集合元素进行排序Collections.swap(list, int, int)//将list中i处、j处元素进行交换</code></pre><p>2.查找、替换：</p><pre><code>Collections.max(Collection) //根据自然顺序，返回集合中最大元素Collections.max(Collection, Comparator) //根据指定顺序，返回集合中最大元素Collections.frequency(Collection) //返回指定元素的出现次数Collections.copy(List dest, List src) //将src的内容复制到dest中Collections.replaceAll(List, Object oldVal, Object newVal) //替换</code></pre><p>这里注意Collections.copy(dest list, src list)需要提前设置dest list大小：</p><pre><code class="java">public void test1(){        List list = new ArrayList();        list.add(123);        list.add(13);        list.add(12);        list.add(12);        list.add(4456);        System.out.println(list);        List list2 = Arrays.asList(new Object[list.size()]);//没有这句设置list2空间的话error        Collections.copy(list2, list);        System.out.println(list2);}</code></pre><p>3.同步控制：</p><p>Collections类中提供了多个synchronizedXxX()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题(因为ArrayList、HashSet、HashMap等等全部都线程不安全，所以多线程时可使用Collections的同步控制来达到线程安全)</p><pre><code class="java">    public void test1(){            List list = new ArrayList(); //线程不安全            list.add(123);            list.add(13);            list.add(12);            list.add(12);            list.add(4456);            List list2 = Collections.synchronizedList(list);            System.out.println(list2); //list2是线程安全的    }</code></pre><h2 id="HashMap与co1ncurrentHashMap"><a href="#HashMap与co1ncurrentHashMap" class="headerlink" title="HashMap与co1ncurrentHashMap"></a>HashMap与co1ncurrentHashMap</h2><p>1.HashMap:</p><p><img src="https://img.braincao.cn/blogimg/1583508137.jpg" alt="1583508137"></p><p>2.concurrentHashMap:</p><p><img src="https://img.braincao.cn/blogimg/1583508181.jpg" alt="1583508181"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区与常量池</title>
      <link href="/2018/12/16/java-constant-pool/"/>
      <url>/2018/12/16/java-constant-pool/</url>
      
        <content type="html"><![CDATA[<p>此文档为java枚举的学习总结</p><a id="more"></a><h2 id="方法区与常量池"><a href="#方法区与常量池" class="headerlink" title="方法区与常量池"></a>方法区与常量池</h2><p>方法区里存储着class文件的信息和动态常量池,class文件的信息包括类信息和静态常量池。可以将类的信息是对class文件内容的一个框架，里面具体的内容通过常量池来存储。</p><p>动态常量池里的内容除了是静态常量池里的内容外，还将静态常量池里的符号引用转变为直接引用，而且动态常量池里的内容是能动态添加的。例如调用String的intern方法就能将string的值添加到String常量池中，这里String常量池是包含在动态常量池里的，但在jdk1.8后，将String常量池放到了堆中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java枚举</title>
      <link href="/2018/12/16/java-enum/"/>
      <url>/2018/12/16/java-enum/</url>
      
        <content type="html"><![CDATA[<p>此文档为java枚举的学习总结</p><a id="more"></a><h2 id="使用枚举表示常量数据"><a href="#使用枚举表示常量数据" class="headerlink" title="使用枚举表示常量数据"></a>使用枚举表示常量数据</h2><p>使用枚举表示常量数据，将多个参数一起打包作为常量</p><pre><code class="java">package com.braincao.enums;/** * @FileName: SeckillStateEnum * @Author: braincao * @Date: 2018/11/27 16:41 * @Description: 使用枚举表示seckill秒杀状态的常量数据。 */public enum SeckillStateEnum {    SUCCESS(1,&quot;秒杀成功&quot;),    END(0, &quot;秒杀结束&quot;),    REPEAT_KILL(-1, &quot;重复秒杀&quot;),    INNER_ERROR(-2, &quot;系统异常&quot;),    DATA_REWRITE(-3,&quot;数据篡改&quot;);    //状态    private int state;    //状态说明    private String stateInfo;    //构造方法赋值    SeckillStateEnum(int state, String stateInfo) {        this.state = state;        this.stateInfo = stateInfo;    }    public int getState() {        return state;    }    public String getStateInfo() {        return stateInfo;    }    public static SeckillStateEnum stateOf(int index){        for(SeckillStateEnum state: values()){            if(state.getState() == index){                return state;            }        }        return null;    }}</code></pre><p>定义枚举后使用：SeckillStateEnum.SUCCESS</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java深浅拷贝</title>
      <link href="/2018/12/16/java-copy/"/>
      <url>/2018/12/16/java-copy/</url>
      
        <content type="html"><![CDATA[<p>此文档为java深浅拷贝的学习总结</p><a id="more"></a><h2 id="Java-浅拷贝和深拷贝"><a href="#Java-浅拷贝和深拷贝" class="headerlink" title="Java 浅拷贝和深拷贝"></a>Java 浅拷贝和深拷贝</h2><p>来源：<a href="https://www.cnblogs.com/qlky/p/7348353.html" target="_blank" rel="noopener">Java 浅拷贝和深拷贝</a></p><p>1.直接赋值</p><p>A1 a1 = a2;</p><p>那么对象a1/a2指向同一个对象，即a2对对象的操作，a1也跟着变了</p><p>2.浅拷贝</p><p>类的方法中加个clone方法。这种浅拷贝实现的是：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是<strong>引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</strong></p><pre><code class="java">private String name;  //姓名  private String sex;   //性别  private int age;      //年龄  private String experience; //工作经历public Object clone() {      try {          return (Resume)super.clone();      } catch (Exception e) {          e.printStackTrace();          return null;      }  }public static void main(String[] args) {          Resume zhangsan = new Resume(&quot;zhangsan&quot;,&quot;男&quot;,24);          zhangsan.setExperience(&quot;2009-2013就读于家里蹲大学，精通JAVA,C,C++,C#等代码拷贝和粘贴&quot;);          zhangsan.displayResume();          Resume zhangsan1 = (Resume)zhangsan.clone();          zhangsan1.setAge(23);          zhangsan1.displayResume();          Resume zhangsan2 = (Resume)zhangsan.clone();          zhangsan2.setExperience(&quot;2009-2013就读于家里蹲大学，精通JAVA,C,C++,C#等代码&quot;);          zhangsan2.displayResume();          zhangsan.displayResume();      }  </code></pre><p>上面代码没问题，因为数据没有引用类型，a1/a2指向对象不同，彼此对立，但是下面的就不行了:</p><pre><code class="java">class Experience {      private String educationBackground;      private String skills;      public void setExperience(String educationBackground, String skills) {          // TODO Auto-generated constructor stub          this.educationBackground = educationBackground;          this.skills = skills;      }      public String toString() {          return educationBackground + skills;      }  }  /* 建立类，实现Clone方法  */  class Resume  implements Cloneable{      private String name;  //姓名      private String sex;   //性别      private int age;      //年龄      private Experience experience; //工作经历,引用类型    public Resume(String name, String sex, int age) {          this.name = name;          this.sex = sex;          this.age = age;          this.experience = new Experience();      }      public void setAge(int age) {          this.age = age;      }      public int getAge() {          return age;      }      public Experience getExperience() {          return experience;      }      public void setExperience(String educationBackground, String skills) {          experience.setExperience(educationBackground, skills);      }      public void displayResume() {          System.out.println(&quot;姓名：&quot;+name+&quot; 性别：&quot;+sex+&quot; 年龄:&quot;+age);          System.out.println(&quot;工作经历：&quot;+experience.toString());      }      public Object clone() {          try {              return (Resume)super.clone();          } catch (Exception e) {              e.printStackTrace();              return null;          }      }  }  public class MainClass {      public static void main(String[] args) {          Resume zhangsan = new Resume(&quot;zhangsan&quot;,&quot;男&quot;,24);          zhangsan.setExperience(&quot;2009-2013就读于家里蹲大学&quot;,&quot;精通JAVA,C,C++,C#等代码拷贝和粘贴&quot;);          zhangsan.displayResume();          Resume zhangsan2 = (Resume)zhangsan.clone();          zhangsan2.setExperience(&quot;2009-2013就读于家里蹲大学&quot;,&quot;精通JAVA,C,C++,C#等&quot;);          zhangsan2.displayResume();          zhangsan.displayResume();          zhangsan2.displayResume();      }  }out:姓名：zhangsan 性别：男 年龄:24  工作经历：2009-2013就读于家里蹲大学精通JAVA,C,C++,C#等代码拷贝和粘贴  姓名：zhangsan 性别：男 年龄:24  工作经历：2009-2013就读于家里蹲大学精通JAVA,C,C++,C#等  姓名：zhangsan 性别：男 年龄:24  工作经历：2009-2013就读于家里蹲大学精通JAVA,C,C++,C#等  姓名：zhangsan 性别：男 年龄:24  工作经历：2009-2013就读于家里蹲大学精通JAVA,C,C++,C#等</code></pre><p>如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。”其实也就是说，zhangsan和zhangsan2里面的Experience类指向的是同一个对象,不管是zhangsan里面的Experience变化，还是zhangsan2里面的Experience变化都会影响另外一个。</p><p>3.深拷贝</p><p>java深拷贝两种方法:</p><ul><li>1.继承Cloneable重写clone方法</li><li>2.对象实现Serializable通过序列化实现深拷贝</li></ul><p>其实出现问题的关键就在于clone()方法上，我们知道该clone()方法是使用Object类的clone()方法，但是该方法存在一个缺陷，它并不会将对象的所有属性全部拷贝过来，而是有选择性的拷贝，基本规则如下：</p><p>1、 基本类型</p><p> 如果变量是基本很类型，则拷贝其值，比如int、float等。</p><p>2、 String字符串</p><p>若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有对象保持不变。</p><p>3、 对象/引用类型</p><p>如果变量是一个实例对象，则拷贝其地址引用，也就是说此时新对象与原来对象是公用该实例变量。（即浅拷贝）</p><p>因此深拷贝就是在clone方法中把引用类型深拷贝即可。</p><pre><code class="java">public class YuelyLog implements Cloneable {    private Attachment attachment;//引用类型    private String name;    private String date;    @Override    protected YuelyLog clone() throws CloneNotSupportedException {        return (YuelyLog)super.clone();    }}</code></pre><p>深拷贝问题解决了，但对于上面的解决方案还是存在一个问题，若我们系统中存在大量的对象是通过拷贝生成的，如果我们每一个类都写一个clone()方法，并将还需要进行深拷贝，新建大量的对象，这个工程是非常大的，这里我们可以利用<strong>对象的序列化来实现对象的拷贝</strong>。</p><p>如何利用序列化来完成对象的拷贝呢？在内存中通过<strong>字节流的拷贝</strong>是比较容易实现的。把母对象写入到一个字节流中，再从字节流中将其读出来，这样就可以创建一个新的对象了，并且该新对象与母对象之间并不存在引用共享的问题，真正实现对象的深拷贝。</p><pre><code class="java">public class CloneUtils {    @SuppressWarnings(&quot;unchecked&quot;)    public static &lt;T extends Serializable&gt; T clone(T obj){        T cloneObj = null;        try {            //写入字节流            ByteArrayOutputStream out = new ByteArrayOutputStream();            ObjectOutputStream obs = new ObjectOutputStream(out);            obs.writeObject(obj);            obs.close();            //分配内存，写入原始对象，生成新对象            ByteArrayInputStream ios = new ByteArrayInputStream(out.toByteArray());            ObjectInputStream ois = new ObjectInputStream(ios);            //返回生成的新对象            cloneObj = (T) ois.readObject();            ois.close();        } catch (Exception e) {            e.printStackTrace();        }        return cloneObj;    }}</code></pre><p>使用该工具类的对象必须要实现Serializable接口，否则是没有办法实现克隆的。</p><pre><code class="java">public class Person implements Serializable{    private static final long serialVersionUID = 2631590509760908280L;    ..................    //去除clone()方法}public class Email implements Serializable{    private static final long serialVersionUID = 1267293988171991494L;    ....................}</code></pre><p>所以使用该工具类的对象只要实现Serializable接口就可实现对象的克隆，无须继承Cloneable接口实现clone()方法。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //写封邮件        Email email = new Email(&quot;请参加会议&quot;,&quot;请与今天12:30到二会议室参加会议...&quot;);        Person person1 =  new Person(&quot;张三&quot;,email);        Person person2 =  CloneUtils.clone(person1);        person2.setName(&quot;李四&quot;);        Person person3 =  CloneUtils.clone(person1);        person3.setName(&quot;王五&quot;);        person1.getEmail().setContent(&quot;请与今天12:00到二会议室参加会议...&quot;);        System.out.println(person1.getName() + &quot;的邮件内容是：&quot; + person1.getEmail().getContent());        System.out.println(person2.getName() + &quot;的邮件内容是：&quot; + person2.getEmail().getContent());        System.out.println(person3.getName() + &quot;的邮件内容是：&quot; + person3.getEmail().getContent());    }}-------------------Output:张三的邮件内容是：请与今天12:00到二会议室参加会议...李四的邮件内容是：请与今天12:30到二会议室参加会议...王五的邮件内容是：请与今天12:30到二会议室参加会议...</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2018/12/16/java-final/"/>
      <url>/2018/12/16/java-final/</url>
      
        <content type="html"><![CDATA[<p>此文档为java反射的学习总结</p><a id="more"></a><h1 id="匿名内部类使用的形参要设置为final"><a href="#匿名内部类使用的形参要设置为final" class="headerlink" title="匿名内部类使用的形参要设置为final"></a>匿名内部类使用的形参要设置为final</h1><p>详情参考<a href="https://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="noopener">使用的形参为何要为final</a></p><p><strong>我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final</strong>。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。</p><p>为什么必须要为final呢？</p><p>简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是<strong>用final来让该引用不可改变</strong>。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。</p><p>首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用。</p><p>内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。</p><p>直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。</p><pre><code class="java">@Override    public void transfer(final String out, final String in, final double money) {//        accountDao.outMoney(out, money);//        accountDao.inMoney(in, money);//        System.out.println(&quot;转账成功&quot;);        //将上述方法进行事务管理:        transactionTemplate.execute(new TransactionCallbackWithoutResult() {            @Override            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {                accountDao.outMoney(out, money);                accountDao.inMoney(in, money);                System.out.println(&quot;转账成功&quot;);            }        });    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java内存模型JMM</title>
      <link href="/2018/12/16/java-jmm/"/>
      <url>/2018/12/16/java-jmm/</url>
      
        <content type="html"><![CDATA[<p>此文档为java内存模型JMM的学习总结</p><a id="more"></a><h2 id="java内存模型JMM"><a href="#java内存模型JMM" class="headerlink" title="java内存模型JMM"></a>java内存模型JMM</h2><p><img src="https://img.braincao.cn/blogimg/1583508070.jpg" alt="1583508070"></p><p>程序运行的时候，内存主要由以下部分组成：</p><p>堆：所有线程共享一个堆；存放的都是new 出来的对象；由垃圾回收器回收；</p><p>方法区：所有线程共享一个方法区；里面存放的内容有点杂，可以认为是除堆和栈中的其它东西（如类信息，静态变量，常量，代码等）；Java虚拟机规范规定可以不对方法区进行垃圾回收，当并不是不回收，主要看具体虚拟机的实现，比如可以回收一些废弃常量和无用的类；</p><p>程序计数器：也叫PC,存放下一条指令所在单元的地址的地方;</p><p>JAVA栈：每个线程都有一个自己的JAVA栈;存放的一般是方法的局部变量，方法出口信息等；方法调用过程中，自动压栈出栈；ps：栈空间大小是有限制的；</p><p>本地方法栈：与JAVA栈类似，区别是使用的对象不一样，本地方法栈是给Native方法使用的，JAVA栈是给JAVA方式使用的；</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lamada表达式</title>
      <link href="/2018/12/16/java-lamada/"/>
      <url>/2018/12/16/java-lamada/</url>
      
        <content type="html"><![CDATA[<p>此文档为java中lamada表达式的学习总结</p><a id="more"></a><h2 id="java中的lamada表达式"><a href="#java中的lamada表达式" class="headerlink" title="java中的lamada表达式"></a>java中的lamada表达式</h2><p>x -&gt; 2 * x 接收一个参数(数字类型),返回其2倍的值 </p><p>() -&gt; {} 没有参数，右边的函数里面什么也不做</p><p>lamada实现Runnable接口:</p><pre><code class="java">Thread thread = new Thread( () -&gt; {System.out.print(&quot;hello&quot;)} );等同于Thread thread = new Thread( new Runnable(){    public void run(){        System.out.print(&quot;hello&quot;);    }} );</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java IO</title>
      <link href="/2018/12/16/java-io/"/>
      <url>/2018/12/16/java-io/</url>
      
        <content type="html"><![CDATA[<p>此文档为java IO的学习总结</p><a id="more"></a><h2 id="Java-IO-管道"><a href="#Java-IO-管道" class="headerlink" title="Java IO: 管道"></a>Java IO: 管道</h2><p>由于java语言的stream严格区分为inputstream和outputstream，流数据读写之间转换一般使用临时文件方式来转换，但是这种方式使用的效率比较低，因此可以使用管道来实现，java管道支持比较弱，需要多线程来支持，</p><pre><code class="java">import org.junit.Test;import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * FileName: TestPipe * Author:   braincao * Date:     2018/10/4 15:23 * Description: 两个线程间用管道实现通信的例子 * Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力 */public class TestPipe {    @Test    public void test1() throws IOException{        PipedOutputStream output = new PipedOutputStream();        PipedInputStream input = new PipedInputStream(output);        Thread thread1 = new Thread(new Runnable() {            @Override            public void run() {                try{                    output.write(&quot;hello world&quot;.getBytes());                    output.close(); //通信完切记关闭管道资源                }catch(IOException e){                    e.printStackTrace();                }            }        });        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                try{                    int data = input.read();                    while(data!=-1){                        System.out.print((char)data + &quot; &quot;);                        data = input.read();                    }                    input.close();//通信完切记关闭管道资源                }catch(IOException e){                    e.printStackTrace();                }            }        });        thread1.start();        thread2.start();    }}//out：h e l l o   w o r l d </code></pre><h2 id="java-IO"><a href="#java-IO" class="headerlink" title="java IO"></a>java IO</h2><p>1.File类: 文件或目录路径(文件夹)的抽象表示形式。通过File对象可以访问文件的属性、创建空文件和目录</p><pre><code class="java">@Testpublic void test1() throws IOException, InterruptedException{    //创建目录路径(文件夹)--mkdir():如果父目录不存在，失败    String path2 = &quot;/Users/braincao/git/test&quot;;    File file2 = new File(path2);    boolean flag = file2.mkdir();    System.out.println(flag);    //创建目录路径(文件夹)--mkdirs():如果父目录不存在，一同创建    String path = &quot;/Users/braincao/git/test/test&quot;;    File file3 = new File(path);    boolean flag3 = file3.mkdirs();    System.out.println(flag3);    //创建文件--createNewFile()    File file = new File(&quot;/Users/braincao/git/2.txt&quot;);    if(!file.exists()){ //如果不存在则创建新文件，存在就不创建        file.createNewFile();    }//        if(file.exists()){//            file.delete();//如果存在则删除文件，不存在就不创建//        }    //创建临时文件，程序退出即删除    File tmp = File.createTempFile(&quot;test&quot;, &quot;.temp&quot;, new File(&quot;/Users/braincao/git&quot;));    Thread.sleep(2000);//放大延时便于观看效果    tmp.deleteOnExit();//文件退出即删除    //输出当前系统的根目录--listRoots()    File[] roots = File.listRoots(); //当前系统的根目录}@Testpublic void test2(){    //遍历文件夹中的文件--String[] list()    File file4 = new File(&quot;/Users/braincao/git&quot;);    if(file4.isDirectory()){ //如果是目录路径        String[] lists = file4.list(); //返回的是文件夹中所有东西的路径字符串，不是File对象        for(String s: lists){            System.out.println(s);        }        System.out.println(&quot;=========&quot;);        File[] files = file4.listFiles();//返回的是文件夹中所有东西的File对象        for(File f: files){            System.out.println(f.getName());        }        System.out.println(&quot;=========&quot;);        //命令设计模式        //FilenameFilter()--设置过滤模板，显示想要的文件或路径        File[] ff = file4.listFiles(new FilenameFilter() {            @Override            public boolean accept(File dir, String name) {                return new File(dir, name).isFile() &amp;&amp; name.endsWith(&quot;.txt&quot;); //返回后缀.txt的文件(非路径)            }        });        for(File f: ff){            System.out.println(f.getName());        }    }}</code></pre><p>输出子孙级目录的绝对路径名称—递归</p><pre><code class="java">static void test3(String path) throws Exception{        /**         * @Description: 输出子孙级目录的绝对路径名称---递归         */        File file = new File(path);        if(file.isFile()){            System.out.println(file.getAbsolutePath());            return;        }        File[] ff = file.listFiles();        for(File f: ff){            if(f.isFile()){                System.out.println(f.getAbsolutePath());            }            else{                test3(f.getAbsolutePath());            }        }    }    public static void main(String[] args) throws Exception{        test3(&quot;/Users/braincao/git/test&quot;);    }</code></pre><p>2.IO：</p><p><img src="https://img.braincao.cn/blogimg/1583507875.jpg" alt="1583507875"></p><ul><li>节点流：节点流处于IO操作的第一线，所有操作必须通过它们进行</li></ul><ul><li><p>字节流</p></li><li><p>字符流</p></li></ul><ul><li>处理流：处理流可以对其他流进行处理（增强功能，提高效率）</li></ul><p>字节流：二进制流，可以处理一切文件，包括纯文本、doc、音频、视频等等</p><pre><code>输入流：InputStream--read(byte[] b)、read(byte[] b, int off, int len)、close()       FileInputStream()输出流：OutputStream--write(byte[] b)、write(byte[] b, int off, int len)、flush()、close()       FileOutputStream()</code></pre><p>字符流：文本流，只能处理纯文本</p><pre><code>输入流：Reader--read(char[] cbuf)、read(char[] cbuf, int off, int len)、close()       FileReader()输出流：Writer--write(char[] cbuf)、write(String[] str, int off, int len)、write(char[] cbuf, int off, int len)、flush()、close()       FileWriter()</code></pre><p>2.1字节流</p><p>读取文件input、写入文件output的demo</p><pre><code class="java">@Testpublic void input(){    /**     * @Description: 读取文件     *     1.建立联系:File对象        2.选择流:字节输入流:InputStream FileInputStream        3.操作：数组大小byte[] b = new byte[1024]、read、write        4.释放资源     */    //1.建立联系    File file = new File(&quot;/Users/braincao/git/1.txt&quot;);    //2.选择流，这里有异常需要try catch    InputStream input = null; //提升作用域便于后面释放资源    try {        input = new FileInputStream(file);        //3.操作：不断读取        byte[] b = new byte[10]; //每次最多读取10字节的缓冲数组        int len = 0;//每次读取的真实字节长度        //循环读取        while(-1 != (len=input.read(b))){            //输出，需要将字节数组转成String            String str = new String(b, 0, len);            System.out.println(str);        }    } catch (IOException e) {        e.printStackTrace();    }finally{        if(input!=null){            try {                input.close(); //释放资源            } catch (IOException e) {                e.printStackTrace();            }        }    }}@Testpublic void output(){    /**     * @Description: 写出文件     *  1.建立联系:File对象        2.选择流:字节输出流:OutputStream FileOutputStream        3.操作：write、flush、close        4.释放资源     */    //1.建立联系    File file = new File(&quot;/Users/braincao/git/2.txt&quot;);    //2.选择流    OutputStream output = null;//提升作用域便于后面释放资源    try {        output = new FileOutputStream(file, true);//true是追加写入，false是覆盖写入        String str = &quot;hello world!\n&quot;;        //将String转成byte数组        byte[] b = str.getBytes();        try {            output.write(b, 0, b.length); //3.操作：写入文件            output.flush(); //强制刷新出去。如果没有强制刷新，IO管道满了或者需要等到释放资源时，才会flush推出写入。因此要养成手动flush的习惯        } catch (IOException e) {            e.printStackTrace();        }    } catch (IOException e) {        e.printStackTrace();    }finally{        if(output!=null){            try {                output.close(); //释放资源            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>#####拷贝文件、拷贝文件夹</p><p>拷贝文件：实现文件拷贝。结合了输入流input和输出流output，边读取边写入</p><p>拷贝文件夹</p><p>1.递归查找子孙级文件/文件夹</p><p>2.文件:IO流复制；文件夹:创建并递归下一级</p><pre><code class="java">@Testpublic static void copy(String pathSrc, String pathDest) throws IOException {    /**     * @Description: 实现文件拷贝。结合了输入流input和输出流output，边读取边写入     *  1.建立联系:File对象        2.选择流:字节输入流:InputStream FileInputStream                字节输出流:OutputStream FileOutputStream        3.操作：数组大小byte[]+read                write                flush+close        4.释放资源     */    //1.建立联系    File fileSrc = new File(pathSrc);    File fileDest = new File(pathDest);    //2.选择流    InputStream input = null;    OutputStream output = null; //提升作用域便于后面释放资源    try {        input = new FileInputStream(fileSrc);        output = new FileOutputStream(fileDest);        byte[] b = new byte[1024]; //读取与写入缓冲数组        int len = 0;        while(-1 != (len=input.read(b))){ //读取            try {                output.write(b, 0, len); //写入            } catch (IOException e) {                e.printStackTrace();            }        }        output.flush();//强制刷新出去    } catch (FileNotFoundException e) {        e.printStackTrace();    }finally{        try {            if(input!=null){                input.close();            }            if(output!=null){                output.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}@Testpublic static void copyFileDir(String pathSrc, String pathDest){    /**     * @Description: 文件夹拷贝，递归实现     *  1.递归查找子孙级文件/文件夹     *  2.文件:IO流复制；文件夹:创建并递归下一级     */    //1.建立联系    File fileSrc = new File(pathSrc);    File fileDest = new File(pathDest + File.separator + fileSrc.getName());    if(fileSrc.isFile()){//如果是文件，IOcopy        System.out.println(&quot;====file&quot;);        try {            if(!fileDest.exists()){                copy(fileSrc.getAbsolutePath(), fileDest.getAbsolutePath());            }        } catch (IOException e) {            e.printStackTrace();        }    }    else if(fileSrc.isDirectory()){ //如果是文件夹路径，创建路径并递归遍历        System.out.println(&quot;====fileDir&quot;);        if(!fileDest.exists()){            fileDest.mkdir(); //创建文件夹路径            System.out.println(&quot;chuangjianchenggong &quot;);        }        File[] ff = fileSrc.listFiles();        for(File f: ff){            copyFileDir(f.getAbsolutePath(), fileDest.getAbsolutePath());        }    }}public static void main(String[] args) throws Exception{    //文件拷贝: IO流    //copy(&quot;/Users/braincao/git/1.txt&quot;, &quot;/Users/braincao/git/2.txt&quot;);    /*文件夹拷贝: 文件-&gt;IO流复制；文件夹-&gt;创建路径并递归     *最终是把/Users/braincao/git/test文件夹拷贝到了/Users/braincao/git/test2/test中     */    copyFileDir(&quot;/Users/braincao/git/test&quot;, &quot;/Users/braincao/git/test2&quot;);}</code></pre><p>2.2 字符流</p><p>只能处理纯文本，全部为可见字符。</p><p>读取：Reader FileReader</p><p>写入：Writer FileWriter</p><pre><code class="java">@Testpublic void charInputStream() throws IOException {    /**     * @Description: 字符流。从文本读取     *     1.建立联系:File对象        2.选择流:字符输入流:Reader FileReader        3.操作：数组大小char[] b = new byte[1024]、read、close        4.释放资源     */    //1.建立联系    File src = new File(&quot;/Users/braincao/git/1.txt&quot;);    Reader r = null;    //2.选择流    try {        r = new FileReader(src);        //3.操作        char[] cbuf = new char[10];        int len = 0;        while(-1 != (len=r.read(cbuf))){            String ss = new String(cbuf, 0, cbuf.length);            System.out.println(ss);        }    } catch (FileNotFoundException e) {        e.printStackTrace();    }    finally {        if(r!=null){            r.close();        }    }}@Testpublic void charOutputStream() throws IOException {    /**     * @Description: 字符流。写入文本到文件     *     1.建立联系:File对象        2.选择流:字符输入流:Writer FileWriter        3.操作：write、flush、close        4.释放资源     */    //1.建立联系    File dest = new File(&quot;/Users/braincao/git/2.txt&quot;);    //2.选择流    Writer w = null;    try {        w = new FileWriter(dest, true);//true追加；false覆盖        //3.操作        String data = &quot;asdadasdasdqweasd&quot;;        w.write(data);        w.append(&quot;\nsada&quot;);        w.flush();    } catch (FileNotFoundException e) {        e.printStackTrace();    }    finally {        if(w!=null){            w.close();        }    }}</code></pre><p>3.处理流：在节点流之上，处理流可以对其他流进行处理（增强功能，提高效率）</p><p><img src="https://img.braincao.cn/blogimg/1583507907.png" alt="1583507907"></p><p>为什么要有缓冲流？</p><p>比如说，家里盖房子，有一堆砖头要搬在工地100米外，单字节的读取就好比你一个人每次搬一块砖头，从堆砖头的地方搬到工地，这样可定很费时间，然后好的方法就是多叫几个小伙伴帮你一起搬砖头，这样因为人多了，每次可以搬十块砖头，但效率还是很低，这就好比我们的字节/字符数组读写操作；然而聪明的人类会用小推车，每次先搬砖头搬到小车上，再利用小推车运到工地上去，这样你或者你的小伙伴们再从小推车上取砖头是不是方便多了呀！这样效率就会大大提高，缓冲流就好比我们的小推车；给砖头暂时提供一个可存放的空间；</p><p>针对字节的处理流：字节缓冲流</p><ul><li>BufferedInputStream–直接把缓冲流加在字节流上就行，其他与字节流完全一样</li><li>BufferedOutputStream–建议今后都加上缓冲流，提高性能</li></ul><p>针对字符流的处理流：字符缓冲流</p><ul><li>BufferedReader  新增readLine()</li><li>BufferedWriter  新增newLine()</li></ul><p>字节缓冲流demo：</p><pre><code class="java">@Testpublic static void copy(String pathSrc, String pathDest) throws IOException {    /**     * @Description: 字节缓冲流--拷贝文件demo     * 缓冲流直接加在字节流上     */    //1.建立联系    File fileSrc = new File(pathSrc);    File fileDest = new File(pathDest);    //2.选择流    InputStream input = null;    OutputStream output = null; //提升作用域便于后面释放资源    try {        input = new BufferedInputStream(new FileInputStream(fileSrc));//缓冲流直接加在字节流上        output = new BufferedOutputStream(new FileOutputStream(fileDest));        byte[] b = new byte[1024]; //读取与写入缓冲数组        int len = 0;        while(-1 != (len=input.read(b))){ //读取            try {                output.write(b, 0, len); //写入            } catch (IOException e) {                e.printStackTrace();            }        }        output.flush();//强制刷新出去    } catch (FileNotFoundException e) {        e.printStackTrace();    }finally{        try {            if(input!=null){                input.close();            }            if(output!=null){                output.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>字符缓冲流demo：</p><p>在字符流上加缓冲流。有新增方法readline()、newLine()</p><pre><code class="java">@Testpublic static void bufferedCharCopy(String pathSrc, String pathDest) throws IOException {    /**     * @Description: 字符流，拷贝文本文件。在字符流上加缓冲流。有新增方法readline()、newLine()     */    //1.建立联系    File src = new File(pathSrc);    File dest = new File(pathDest);    //2.选择流    Reader r = null;    Writer w = null;    try {        r = new BufferedReader(new FileReader(src)); //在字符流上加了缓冲流。有新增方法readLine()        w = new BufferedWriter(new FileWriter(dest)); //在字符流上加了缓冲流。有新增方法newLine()//            //3.1 读取写入操作//            char[] cbuf = new char[10];//            int len = 0;//            while(-1 != (len=r.read(cbuf))){//                w.write(cbuf, 0, cbuf.length);//            }        //3.2. 读取写入操作--用缓冲流的新增方法readLine()、newLine()        String line = null;        while(null != (line=((BufferedReader) r).readLine()) ){ //这里用缓冲流的新增方法，不能使用多态            w.write(line);            ((BufferedWriter) w).newLine();        }        w.flush();    } catch (FileNotFoundException e) {        e.printStackTrace();    }    finally {        if(r!=null){            r.close();        }        if(w!=null){            w.close();        }    }}public static void main(String[] args) throws IOException {    bufferedCharCopy(&quot;/Users/braincao/git/1.txt&quot;, &quot;/Users/braincao/git/2.txt&quot;);}</code></pre><p>转换流：将字符流转为字节流，将字节流转为字符流—&gt;处理乱码(编码集、解码集)</p><p>字符  –编码集–&gt;  二进制<br>字符  &lt;–解码集–  二进制</p><p>出现乱码原因：</p><ul><li>1.编解码字符集不统一</li><li>2.字节缺少，长度缺失(一个中文字符需要两个字节，少一个字节就乱码)</li></ul><p>编解码例子：</p><pre><code class="java">@Testpublic void test1() throws UnsupportedEncodingException {    /**     * @Description: 编解码例子，idea平台默认utf-8编解码     */    String str = &quot;中国&quot;; //utf-8解码(将二进制解码成了&quot;中国&quot;)    byte[] b1 = str.getBytes(); //utf-8编码(将字符串&quot;中国&quot;编码成了utf-8)    byte[] b2 = str.getBytes(&quot;gbk&quot;); //gbk编码(将字符串&quot;中国&quot;编码成了gbk)    System.out.println(new String(b1,&quot;utf-8&quot;)); //解码    System.out.println(new String(b1,&quot;gbk&quot;)); //解码    System.out.println(new String(b2,&quot;utf-8&quot;)); //解码    System.out.println(new String(b2,&quot;gbk&quot;)); //解码    /*out:        中国        涓浗        �й�        中国     */}转换流：//输入流(字节流--&gt;字符流)：InputStreamReader 解码 //输出流：OutputStreamWriter(字节流--&gt;字符流) 编码    @Testpublic static void bufferedCharCharsetCopy(String pathSrc, String pathDest) throws IOException {    /**     * @Description: 当出现乱码问题时，使用转换流(字节流&lt;---&gt;字符流)     *  输入流：InputStreamReader 解码        输出流：OutputStreamWriter 编码     * 本例中：目的是：使用字符流进行文件拷贝     *  源文件(已知是gbk编码的二进制文件)，我们想用字符流(直接用会出现乱码)        因此先用字节流，再用转换流将字节流转成字符流(解决编码问题的字符流)        同时最后还是加上一层缓冲字符流     */    //    File src = new File(pathSrc);    File dest = new File(pathDest);    //BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(src), &quot;utf-8&quot;)); //指定解码集,error乱码，源文件是gbk因此解码必须是gbk    //BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(src), &quot;gbk&quot;)); //指定解码集,ok    //BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dest), &quot;gbk&quot;)); //指定编码集,ok    //BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(src), &quot;gbk&quot;)); //指定解码集,ok    //BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dest), &quot;utf-8&quot;)); //指定编码集,ok    BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(src), &quot;gbk&quot;)); //指定解码集,ok    BufferedWriter w = new BufferedWriter(new FileWriter(dest)); //不指定编码集，直接用字符流就行,也ok    String line = null;    while (null != (line = r.readLine())) {        System.out.println(line); //输出解码后的文本        w.write(line);        w.newLine();    }    w.flush();    w.close();    r.close();}public static void main(String[] args) throws IOException {    bufferedCharCharsetCopy(&quot;/Users/braincao/git/1.txt&quot;, &quot;/Users/braincao/git/2.txt&quot;);}</code></pre><p>其他流：</p><ul><li><p>字节数组流：将传入的File对象换成了byte[]数组，其他一样</p><p>  输入流：ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a);    </p><p>  输出流：ByteArrayOutputStream bOut = new ByteArrayOutputStream();</p><pre><code>      byte[] dest = bOut.toByteArray() //这点不太一样，要用这种方式传给接受数组dest</code></pre></li><li><p>基础数据类型处理流：基本类型+String，保留数据+类型 </p><p>  输入流：DataInputStream  readXxx()</p><p>  输出流：DataOutputStream  writeXxx()</p></li><li><p>引用类型(对象)处理流：保留数据+类型，就是<strong>序列化、反序列化</strong>。通俗讲就是把对象序列化保存到文件中，再从文件中反序列化拿出对象</p><p>  反序列化(输入流): ObjectInputStream  readObject()</p><p>  序列化(输出流): ObjectOutputStream  writeObject()</p><p>  注意：</p><p>  先序列化后反序列化，反序列化顺序必须与序列化顺序一致</p><p>  不是所有对象都可以序列化，对象所在类要实现java.io.Serializable接口(空接口让JVM识别)</p><p>  每个对象有很多属性，不是所有属性都需要序列化，只序列化目标属性即可。transient</p></li></ul><p>序列化反序列化Demo：</p><pre><code class="java">import java.io.*;/** * @FileName: EmployeeDemo * @Author: braincao * @Date: 2018-10-07 11:35:10 * @Description: 序列化反序列化demo */class Employee implements java.io.Serializable{    private String name;    private transient int id; //transient标识，不让属性序列化    public Employee(String name, int id) {        this.name = name;        this.id = id;    }    public Employee() {    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    @Override    public String toString() {        return &quot;Employee{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, id=&quot; + id +                &#39;}&#39;;    }}public class EmployeeDemo{    public static void main(String[] args) throws IOException, ClassNotFoundException {        Employee e = new Employee(&quot;张三&quot;, 2017111110);        //序列化        File outfile = new File(&quot;/Users/braincao/git/2.txt&quot;);        ObjectOutputStream os = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(outfile)));        os.writeObject(e);        os.close();        //反序列化        File infile = new File(&quot;/Users/braincao/git/2.txt&quot;);        ObjectInputStream is = new ObjectInputStream(new BufferedInputStream(new FileInputStream(infile)));        Object obj = is.readObject();        if(obj instanceof Employee){            Employee tmp = (Employee)obj;            System.out.println(tmp.getName());            System.out.println(tmp.getId()); //transient修饰的属性不可见        }        is.close();        //out:张三 0    }}</code></pre><p>打印流：</p><p>System.out.println(“hello world”);中的out定义<code>public final static PrintStream out = null;</code>，可见out就是PrintStream打印流</p><p>demo1:</p><pre><code class="java">import java.io.*;public class PrintDemo {    public static void main(String[] args) throws IOException {        /**         * @Description: 打印流PrintStream(OutputStream out)demo         */        //1.创建源        String ss = &quot;锄禾日当午，汗滴禾下土&quot;;        //2.选择流        PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(&quot;/Users/braincao/git/2.txt&quot;))));        //3.操作        ps.write(ss.getBytes());        //4.释放资源        ps.close();    }}    </code></pre><p>demo2:</p><pre><code class="java">import java.io.*;import java.util.Scanner;public class PrintDemo {    public static void test1() throws IOException {        /**         * @Description: 打印流PrintStream(OutputStream out)demo         * 输出到文件         */        //1.创建源        String ss = &quot;锄禾日当午，汗滴禾下土&quot;;        //2.选择流        PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(&quot;/Users/braincao/git/2.txt&quot;))));        //3.操作        ps.write(ss.getBytes());        //4.释放资源        ps.close();    }    public static void test2() throws FileNotFoundException {        /**         * @Description:三个常量         * System.in  --输入流InputStream，默认是从键盘输入         * System.out  --输出流OutputStream，默认是控制台输出         * System.err(与System.out一样，就是输出颜色不同)         */        //输出流        System.out.println(&quot;asd&quot;);        System.err.println(&quot;asd&quot;);        //输入流1        InputStream is = System.in; //输入流，键盘输入        Scanner sc = new Scanner(is); //获取键盘输入的输入流        System.out.println(sc.nextLine());        //输入流2        BufferedInputStream fs = new BufferedInputStream(new FileInputStream(new File(&quot;/Users/braincao/git/2.txt&quot;)));        Scanner sc2 = new Scanner(fs); //获取文件输入的输入流        System.out.println(sc2.nextLine());    }    public static void test3() throws FileNotFoundException {        /**         * @Description:将System.in、System.out重定向，不再使用默认的键盘输入、控制台输出         * 重新分配“标准”输入/出流：System类方法：setIn(InputStream in)、setOut(PrintStream out)、setErr(PrintStream err)         */        PrintStream ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(new File(&quot;/Users/braincao/git/2.txt&quot;))), true);//autoFlush设为true，如果不加一定要手动flush        System.setOut(ps); //重定向输出流        System.out.println(&quot;哈哈1234&quot;); //直接写入到文件        ps.flush();        ps.close();        /**         * @Description:重定向后又想重新设为控制台         * FileDescriptor.in 键盘输入         * FileDescriptor.out 控制台输出         */        ps = new PrintStream(new BufferedOutputStream(new FileOutputStream(FileDescriptor.out)),true);        System.setOut(ps); //重定向输出流        System.out.println(&quot;哈哈1234&quot;);    }    public static void main(String[] args) throws IOException {        //test1();        //test2();        test3();    }}</code></pre><h2 id="装饰设计模式"><a href="#装饰设计模式" class="headerlink" title="装饰设计模式"></a>装饰设计模式</h2><p>IO流用到的就是装饰设计模式，包装后增强功能</p><pre><code class="java">/** * @FileName: Decrator * @Author: braincao * @Date: 2018/10/7 16:29 * @Description: 装饰设计模式Demo---扩音器例子。IO流用到的就是装饰设计模式，包装后增强功能 */class Voice{    private int voice = 10; //初始音量为10    public Voice() {    }    public void say(){        System.out.println(voice); //播放声音，音量为10    }    public int getVoice() {        return voice;    }    public void setVoice(int voice) {        this.voice = voice;    }}class Amplify{    private Voice voice;    public Amplify(Voice voice) {        this.voice = voice;    }    public void say(){        System.out.println(voice.getVoice()*100); //放大音量，现在为1000    }    public Voice getVoice() {        return voice;    }    public void setVoice(Voice voice) {        this.voice = voice;    }}public class Decrator {    public static void main(String[] args){        Voice v = new Voice();        v.say(); //音量为10        Amplify am = new Amplify(v);        am.say(); //音量为1000    }}</code></pre><p>文件分割与合并Demo1</p><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.Enumeration;import java.util.Properties;import java.io.*;/** * @Description: 文件分割与合并的demo */public class TestDemo {    public static void main(String[] args) throws IOException {        File fileSplit = new File(&quot;/Users/braincao/git/test/xiezhu_pub.rar&quot;); //要分割的文件，分割后存放的目录也在同级目录中        File fileMerge = new File(&quot;/Users/braincao/git/test&quot;); //存放分割文件的目录，合并后的文件也存在此目录中//        split(fileSplit);        merge(fileMerge);    }    //文件分割    public static void split(File file) throws IOException {        FileInputStream fis = new FileInputStream(file);        FileOutputStream fos = null;        byte[] buf = new byte[1024*1024]; //每个分割文件的大小        int len = 0;        int count = 1;        while(-1 != (len=fis.read(buf))){            fos = new FileOutputStream(new File(file.getParent(), count+&quot;.part&quot;));            count++;            fos.write(buf, 0, len);            fos.flush();        }        fis.close();        //输出写入配置文件        Properties prop = new Properties();        fos = new FileOutputStream(new File(file.getAbsoluteFile() + &quot;.properties&quot; ));        prop.setProperty(&quot;fileName&quot;, file.getName());        prop.setProperty(&quot;partCount&quot;, (count-1)+&quot;&quot;);        prop.store(fos,&quot;save file info&quot;);        fos.close();    }    //文件合并    public static void merge(File file) throws IOException{        //1.拿到properties中的相关信息        File[] propFiles = file.listFiles(new SuffixFilter(&quot;.properties&quot;));        if(propFiles.length!=1){            throw new RuntimeException(file+&quot;该目录下没有properties扩展名的文件或者不唯一&quot;);        }        Properties pp = new Properties();        FileInputStream propInput = new FileInputStream(propFiles[0]);        pp.load(propInput);        String fileName = pp.getProperty(&quot;fileName&quot;);        int partNum = Integer.parseInt(pp.getProperty(&quot;partCount&quot;));        //2.遍历目录中.part文件，用SequenceInputStream输入流组合        ArrayList&lt;FileInputStream&gt; fis = new ArrayList&lt;&gt;();        File[] files = file.listFiles(new SuffixFilter(&quot;.part&quot;));        for(int i=0; i&lt;files.length; ++i){            fis.add(new FileInputStream(files[i]));        }        Enumeration&lt;FileInputStream&gt; efis = Collections.enumeration(fis);        SequenceInputStream sis = new SequenceInputStream(efis);        //3.输入流：SequenceInputStream；输出流：FileOutputStream---&gt;拷贝写入        FileOutputStream fos = new FileOutputStream(new File(file.getAbsolutePath(), &quot;Merge_&quot; + fileName));        byte[] b = new byte[1024*1024];        int len = 0;        while(-1 != (len=sis.read(b))){            fos.write(b, 0, len);            fos.flush();        }        fos.close();        sis.close();    }}class SuffixFilter implements FilenameFilter{    private String suffix;    public SuffixFilter(String suffix){        super();        this.suffix = suffix;    }    @Override    public boolean accept(File dir, String name) {        return name.endsWith(suffix);    }}</code></pre><p>文件分割与合并Demo2(这个包含很多知识点，建议详看)</p><pre><code class="java">import java.io.*;import java.util.ArrayList;import java.util.List;import java.util.Vector;/** * @FileName: RandomAccessFileDemo * @Author: braincao * @Date: 2018/10/7 16:52 * @Description: 文件分割与合并Demo * 文件分割思路： * 1.确定每一块的大小  blockSize * 2.已知文件总大小length和blockSize，计算确定分割的块数  n=Math.ceil(length/blockSize) //Math.ceil(double a)返回大于等于a的最小整数(返回double类型) * 3.确定最后一块的大小 length - (n-1)*blockSize */public class SplitFileDemo {    private String filePath; //源文件路径    private String fileName; //源文件名    private long length; //源文件名    private String destPath; //分割后文件存放目录    private long blockSize; //每块的大小    private List&lt;String&gt; blockPath; //每块的名称    private int n; //分割的块数    public SplitFileDemo(String filePath, String destPath){        this(filePath, destPath, 10);    }    public SplitFileDemo(String filePath, String destPath, long blockSize){        blockPath = new ArrayList&lt;&gt;();        this.filePath = filePath;        this.destPath = destPath;        this.blockSize = blockSize;        init(); //初始化各项参数    }    private void init(){        /**         * @Description: 初始化操作：修正每块大小、计算块数、确定文件名         */        File src = null;        //健壮性        if(null==filePath || !(src=new File(filePath)).exists() || !(src.isFile()) ){            return;        }        //文件名        this.fileName = src.getName();        //修正每块大小、计算块数        this.length = src.length(); //文件实际大小        if(this.blockSize &gt; length){//修正每块大小            this.blockSize = length;        }        //确定块数        n = (int)Math.ceil(length*1.0/this.blockSize); //Math.ceil(double a)返回大于等于a的最小整数，返回double类型        initPathName(destPath);    }    private void initPathName(String destPath){//确定文件名        for(int i=0; i&lt;n; ++i){            blockPath.add(destPath + &quot;/&quot; + fileName + &quot;.part&quot; + i);        }    }    //文件分割    public void split(){        /**         * @Description: 上面都是为文件分割做准备，现在开始分割         * @Param: [destPath] 分割文件存放的目录         * 文件分割：         * 第几块、起始位置、实际大小         */        long beginPos = 0; //起始点        long actualBlockSize = blockSize; //实际大小        for(int i=0; i&lt;n; ++i){            if(i==n-1){                actualBlockSize = this.length-beginPos;            }            splitDetail(i, beginPos, actualBlockSize);            beginPos += actualBlockSize;        }    }    private void splitDetail(int blockNum, long beginPos, long actualBlockSize){        /**         * @Description:文件分割的具体操作，其实就是文件拷贝过程         * 输入流：RandomAccessFile         * 输出流: FileOutputStream         * @Param: [blockNum, beginPos, actualBlockSize] 第几块、起始点、实际每块大小(主要针对最后一块)         */        //1.创建源        File src = new File(this.filePath);        File dest = new File(this.blockPath.get(blockNum));        //2.选择流        RandomAccessFile rnd = null;//参数&quot;r&quot;只读        BufferedOutputStream fo = null;        try {            rnd = new RandomAccessFile(src, &quot;r&quot;);            fo = new BufferedOutputStream(new FileOutputStream(dest));            //3.操作            rnd.seek(beginPos); //从beginPos位置开始读取文件            byte[] b = new byte[1024]; //定义缓冲区            int len = 0;//实际读取长度            //目标：从文件beginPos位置读取actualBlockSize大小的东西，每次实际读取len大小            while(-1 != (len=rnd.read(b))){                if(len&lt;actualBlockSize){                    fo.write(b, 0, len); //写入文件                    fo.flush();                    actualBlockSize -= len;                }                else{//最后一块了                    fo.write(b, 0, (int)actualBlockSize); //写入文件                    fo.flush();                    break;                }            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally{            try {                if(rnd!=null){                    rnd.close();                }                if(fo!=null){                    fo.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    //文件合并--法1    public void mergeFile(String destPath) {        /**         * @Description:文件合并的具体操作，其实就是文件拷贝过程         * 输入流：FileInputStream         * 输出流: FileOutputStream         * @Param: [destPath] 合并后文件的存放目录         */        File dest = new File(destPath);        BufferedOutputStream fo = null;        try {            fo = new BufferedOutputStream(new FileOutputStream(dest,true));            for (int i = 0; i &lt; blockPath.size(); ++i) {                //1.创建源                File src = new File(this.blockPath.get(i));                //2.选择流                BufferedInputStream fs = null;//参数&quot;r&quot;只读                fs = new BufferedInputStream(new FileInputStream(src));                //3.操作                byte[] b = new byte[1024]; //定义缓冲区                int len = 0;//实际读取长度                while (-1 != (len = fs.read(b))) {                    fo.write(b, 0, len); //写入文件                    fo.flush();                }                fs.close();            }        }catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            try{                if (fo != null) {                    fo.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    //文件合并--法2--SequenceInputStream:将很多流组合成一个流的InputStream    public void merge2(String destPath){        /**         * @Description: SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)         * Enumeration：vector         * @Param:         * @return: void         */        //1.创建源        File dest = new File(destPath);        //2.选择流        SequenceInputStream sis = null;  //输入流        BufferedOutputStream fo = null; //输出流        //创建一个容器用于后面组合流        Vector&lt;InputStream&gt; vi = new Vector&lt;&gt;();        try {            for (int i = 0; i &lt; blockPath.size(); ++i){                vi.add(new BufferedInputStream(new FileInputStream(new File(this.blockPath.get(i)))));            }            sis = new SequenceInputStream(vi.elements()); //SequenceInputStream组合流;vi.elements()返回此向量的枚举            fo = new BufferedOutputStream(new FileOutputStream(dest,true));            //3.操作            byte[] b = new byte[1024]; //定义缓冲区            int len = 0;//实际读取长度            while (-1 != (len = sis.read(b))) {                fo.write(b, 0, len); //写入文件                fo.flush();            }        }catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            try{                if (fo != null) {                    fo.close();                }                if (sis != null) {                    sis.close();                }            } catch (IOException e) {                e.printStackTrace();            }        }    }    public static void main(String[] args){        String fileSrc = &quot;/Users/braincao/git/1.txt&quot;; //要分割的文件        String destPath = &quot;/Users/braincao/git&quot;; //分割后文件存放目录        String destMergePath = &quot;/Users/braincao/git/test.txt&quot;; //合并后文件的路径        SplitFileDemo file = new SplitFileDemo(fileSrc, destPath, 20);        file.split(); //文件分割//        file.mergeFile(destMergePath); //文件合并--法1        file.merge2(destMergePath); //文件合并--法2    }}</code></pre><h5 id="File类的一个例子"><a href="#File类的一个例子" class="headerlink" title="File类的一个例子"></a>File类的一个例子</h5><p>获取git目录下后缀名为.txt的文件</p><pre><code class="java">    public static void test1(){            File file = new File(&quot;/Users/braincao/git&quot;);            FilenameFilter filter = new FilenameFilter() {                @Override                public boolean accept(File dir, String name) {                    return name.endsWith(&quot;.txt&quot;); //文件名的后缀要以.txt                }            };            String[] ff = file.list(filter);            for(String f: ff){                System.out.println(f);            }        }</code></pre><p>日期Date、Calendar相关Demo</p><p>打印指定日期的月历:</p><pre><code class="java">import java.text.ParseException;import java.util.Calendar;import java.util.Date;import java.util.Scanner;/** * @Description: 键盘输入一个日期，打印该日期所在月份的月历 */public class TestDemo{    public static void main(String[] args) throws ParseException {        //1.获取输入字符串的日期        System.out.println(&quot;请输入想要查看的日期:(2018-11-09)&quot;);        Scanner sc = new Scanner(System.in);        String s = sc.nextLine();        Date d = java.sql.Date.valueOf(s);        Calendar cal = Calendar.getInstance();        cal.setTime(d);        int thisDay = cal.get(Calendar.DAY_OF_MONTH); //指定的日期        int days_of_month = cal.getActualMaximum(Calendar.DAY_OF_MONTH); //这个月有多少天。getActualMaximum--&gt;返回指定Calendar日历字段可能拥有的最大值。        cal.set(Calendar.DAY_OF_MONTH, 1);        int week_of_firstDay_of_month = cal.get(Calendar.DAY_OF_WEEK); //这个月1号是周几        //2.打印指定日期的月份        System.out.println(&quot;日\t一\t二\t三\t四\t五\t六&quot;);//1周日 2周一 3周二 4周三 5周四 6周六 7周日        //2.1 打印1号之前的空格        String suffixHead = &quot;&quot;;        for(int i=1; i&lt;=week_of_firstDay_of_month-1; ++i){            suffixHead = suffixHead+&quot;\t&quot;;        }        System.out.print(suffixHead);        int cnt = week_of_firstDay_of_month; //打印月历时换行的计数器        //2.2 打印本月月份，并将指定的当天日期后加&quot;*&quot;        for(int cntDay=1; cntDay&lt;=days_of_month; ++cntDay){            if(cntDay==thisDay){                System.out.print(cntDay + &quot;*\t&quot;);            }            else{                System.out.print(cntDay + &quot;\t&quot;);            }            //判断是否换行            if(cnt%7 == 0){                System.out.println();                cnt = 1;            }            else{                cnt++;            }        }    }}</code></pre><p>out:</p><pre><code>请输入想要查看的日期:(2018-11-09)2018-10-09日    一    二    三    四    五    六    1    2    3    4    5    6    7    8    9*    10    11    12    13    14    15    16    17    18    19    20    21    22    23    24    25    26    27    28    29    30    31</code></pre><p>枚举Demo</p><p>什么情况用枚举：值比较少且固定时</p><pre><code class="java">import java.text.ParseException;/** * @Description: 枚举使用Demo */enum Gendar{ //枚举    男, 女}class Person{    private String name;    private int age;    private Gendar sex; //使用枚举    @Override    public String toString() {        return &quot;Person{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &quot;, sex=&quot; + sex +                &#39;}&#39;;    }    public Person(String name, int age, Gendar sex) {        this.name = name;        this.age = age;        this.sex = sex;    }    public Person() {    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Gendar getSex() {        return sex;    }    public void setSex(Gendar sex) {        this.sex = sex;    }}public class TestDemo{    public static void main(String[] args) throws ParseException {        Person p = new Person();        p.setName(&quot;张三&quot;);        p.setAge(25);        p.setSex(Gendar.男); //用枚举进行设置。好处:如果是String类型的sex，会遇到乱七八糟的String，这样给判断String带来很多麻烦，用枚举更好        System.out.println(p.toString());        //枚举与switch结合使用        Gendar sex = Gendar.女;        switch (sex){            case 男:                System.out.println(&quot;这是男孩&quot;);                break;            case 女:                System.out.println(&quot;这是女孩&quot;);                break;        }    }}</code></pre><p>Math.random()与Random r = new Random(long seed)</p><pre><code class="java">public static void main(String[] args){    System.out.println(Math.random()*10);    System.out.println(&quot;-------------&quot;);    Random r = new Random(10); //new Random(long seed)seed是生成随机数的种子，seed不变生成的随机数也不变，seed变了随机数也就变了    for(int i=0; i&lt;5; ++i){//重复运行发现生成的随机数都相同，伪随机数        System.out.println(r.nextInt());    }    System.out.println(&quot;-------------&quot;);    Random r1 = new Random(System.currentTimeMillis()); //new Random(long seed)seed是生成随机数的种子，seed不变生成的随机数也不变，seed变了随机数也就变了    for(int i=0; i&lt;5; ++i){//重复运行发现生成的随机数都不同，因为种子变了        System.out.println(r1.nextInt());    }}out:1.7647342360229157--------------1157793070191398476011072545861773446580254270492-------------958951514-17481659869676144019816424-782039092</code></pre><p>管道流</p><p>PipedInputStream和PipedOutputStream：输入输出可以直接进行连接，通过结合线程使用。</p><pre><code class="java">import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream;/** * @Description: 管道流结合多线程使用 */public class TestDemo{    public static void main(String[] args) throws IOException {        PipedInputStream input = new PipedInputStream();        PipedOutputStream output = new PipedOutputStream();        input.connect(output);        new Thread(new Input(input)).start(); //Input是一个线程        new Thread(new Output(output)).start(); //Output是一个线程    }}class Input implements Runnable{    private PipedInputStream in;    public Input(PipedInputStream in){        this.in = in;    }    public void run(){        try{            byte[] buf = new byte[1024];            int len = in.read(buf);            String s = new String(buf, 0, len);            System.out.println(&quot;s=&quot; + s);            in.close();        }catch (IOException e){            e.printStackTrace();        }    }}class Output implements Runnable{    private PipedOutputStream out;    public Output(PipedOutputStream out){        this.out = out;    }    public void run(){        try{            out.write( &quot;hi,管道来了！&quot;.getBytes());            out.flush();            out.close();        }catch (IOException e){            e.printStackTrace();        }    }}//out: s=hi,管道来了！</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2018/12/16/java-multi-thread/"/>
      <url>/2018/12/16/java-multi-thread/</url>
      
        <content type="html"><![CDATA[<p>此文档为java多线程的学习总结</p><a id="more"></a><h2 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h2><p><a href="https://www.cnblogs.com/wxd0108/p/5479442.html" target="_blank" rel="noopener">Java中的多线程你只要看这一篇就够了</a></p><p><img src="https://img.braincao.cn/blogimg/1583507126.png" alt="1583507126"></p><p>这张图的几点解释：</p><p>1.thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。</p><p>2.sleep()与wait()。</p><p>对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。</p><p>sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。</p><p>在调用sleep()方法的过程中，线程不会释放对象锁。而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备</p><p>获取对象锁进入运行状态。</p><h3 id="别人总结的："><a href="#别人总结的：" class="headerlink" title="别人总结的："></a>别人总结的：</h3><p>是否释放锁：调用sleep和yield的时候不释放当前线程所获得的锁，但是调用await/wait的时候却释放了其获取的锁并阻塞等待。</p><p>调用后何时恢复：</p><p>sleep让线程阻塞，且在指定的时间之内都不会执行，时间到了之后恢复到就绪状态，也不一定被立即调度执行；</p><p>yield只是让当前对象回到就绪状态，还是有可能马上被再次被调用执行。</p><p>await/wait，它会一直阻塞在条件队列之上，之后某个线程调用对应的notify/signal方法，才会使得await/wait的线程回到就绪状态，也是不一定立即执行。</p><p>谁的方法：yield和sleep方法都是Thread类的，而wait方法是Object类的，await方法是Condition显示条件队列的。</p><p>执行环境：yield和sleep方法可以放在线程中的任意位置，而await/wait方法必须放在同步块里面，否则会产生运行时异常。</p><p>1.多线程中线程安全：线程同步与锁定synchronized</p><pre><code class="java">/** * FileName: WebDemo * Author:   braincao * Date:     2018/10/2 10:59 * Description: 模拟抢票过程，主要演示线程不安全与加锁后安全 */public class WebDemo implements Runnable{    private int num = 20; //总共20张票    private boolean flag = true;    public static void main(String[] args){        //真实角色        WebDemo w = new WebDemo();        //代理角色        Thread t1 = new Thread(w, &quot;路人&quot;);        Thread t2 = new Thread(w, &quot;黄牛&quot;);        Thread t3 = new Thread(w, &quot;程序员&quot;);        //启动线程        t1.start();        t2.start();        t3.start();    }    public void run(){        while(flag) {//            test01(); //线程不安全//            test02(); //线程安全            test03(); //线程安全        }    }    //线程不安全    public void test01(){        if(num&lt;=0){            flag = false;            return;        }        try{            Thread.sleep(500); //模拟抢票延时        }        catch (InterruptedException e){            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;抢到了&quot; + num--);    }    //线程安全，synchronized同步方法    public synchronized void test02(){        if(num&lt;=0){            flag = false;            return;        }        try{            Thread.sleep(100); //模拟抢票延时        }        catch (InterruptedException e){            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;抢到了&quot; + num--);    }    //线程安全，synchronized同步块    public void test03(){        synchronized (this){            if(num&lt;=0){                flag = false;                return;            }            try{                Thread.sleep(100); //模拟抢票延时            }            catch (InterruptedException e){                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;抢到了&quot; + num--);        }    }}    out：//线程不安全test01黄牛抢到了20路人抢到了19程序员抢到了18路人抢到了17程序员抢到了15黄牛抢到了16路人抢到了14程序员抢到了13黄牛抢到了12黄牛抢到了11路人抢到了9程序员抢到了10路人抢到了8--&gt;重复程序员抢到了7黄牛抢到了8--&gt;重复路人抢到了5黄牛抢到了4程序员抢到了6黄牛抢到了3路人抢到了1程序员抢到了2//线程安全test02、test03路人抢到了20路人抢到了19路人抢到了18路人抢到了17程序员抢到了16程序员抢到了15程序员抢到了14程序员抢到了13程序员抢到了12程序员抢到了11程序员抢到了10程序员抢到了9程序员抢到了8程序员抢到了7程序员抢到了6程序员抢到了5程序员抢到了4程序员抢到了3程序员抢到了2程序员抢到了1</code></pre><p>###2、多线程中的单例模式(加同步锁)</p><ul><li>单例模式创建的方式</li></ul><blockquote><p>1.懒汉式：</p><p>1)、构造器私有化，避免外部直接创建对象</p><p>2)、声明一个私有的静态变量</p><p>3)、创建一个对外的公共的静态方法访问该变量，如果变量没有对象，创建该对象。且考虑多线程因素，这里要使用<strong>double checking的同步锁</strong></p></blockquote><p>懒汉式单例模式模板：</p><pre><code class="java">/** * FileName: Lanhan * Author:   braincao * Date:     2018/10/2 15:44 * Description: 单例模式之懒汉式 * 1、构造器私有化，避免外部直接创建对象 * 2、声明一个私有的静态变量 * 3、创建一个对外的公共的静态方法访问该变量，如果变量没有对象，创建该对象。且考虑多线程因素，这里要使用double checking的同步锁 */public class Lanhan {    private static Lanhan instance = null;    private Lanhan(){    }    public static Lanhan getInstance(){        if(Lanhan==null){ //double checking 这里是提高效率作用            synchronized(Lanhan.class){ //同步块synchronized()中的参数是引用类型，但这里没有this对象，注意要用Lanhan.class                if(Lanhan==null){//double checking 这里是安全同步作用                    instance = new Lanhan();                }            }        }        return instance;    }}饿汉式单例模式模板：public class Lanhan {    private static class JvmHolder{ //内部类，调用时再创建对象，而不是加载类时就创建对象，更有效率        private static Lanhan instance = new Lanhan();    }    private Lanhan(){    }    public static Lanhan getInstance(){        return JvmHolder.instance;    }}一个测试例子：/** * 单例设计模式：确保一个类只有一个对象 * 多线程中单例模式需要添加同步锁 */class WebDemo{    public static void main(String[] args){//        Jvm jvm1 = Jvm.getInstance();//        Jvm jvm2 = Jvm.getInstance();//        System.out.println(jvm1);//        System.out.println(jvm2); //单线程中，两者相等        JvmThread t1 = new JvmThread(100);        JvmThread t2 = new JvmThread(500);        t1.start();        t2.start();        //out1:Thread-0--&gt;创建:Jvm@46543a6c  Thread-1--&gt;创建:Jvm@59dafc71 //多线程中，t1,t2不相等。这时需要添加同步锁        //out2：Thread-0--&gt;创建:Jvm@6ab31cd3  Thread-1--&gt;创建:Jvm@6ab31cd3 //加同步锁后，多线程中t1、t2相等    }}//多线程class JvmThread extends Thread{    private long time;    public JvmThread(){    }    public JvmThread(long time){        this.time = time;    }    @Override    public void run(){        System.out.println(Thread.currentThread().getName() + &quot;--&gt;创建:&quot; + Jvm.getInstance(time));    }}/** * 懒汉式 * 1、构造器私有化，避免外部直接创建对象 * 2、声明一个私有的静态变量 * 3、创建一个对外的公共的静态方法访问该变量，如果变量没有对象，创建该对象 */class Jvm{    private static Jvm instance = null; //懒汉式就是这里懒的创建对象    private Jvm(){    }    //在这里添加同步锁后，多线程模式下也一样是单例模式了public static Lanhan getInstance(){    if(Lanhan==null){ //double checking 这里是提高效率作用        synchronized(Lanhan.class){ //同步块synchronized()中的参数是引用类型，但这里没有this对象，注意要用Lanhan.class            if(Lanhan==null){//double checking 这里是安全同步作用                instance = new Lanhan();            }        }    }    return instance;    }}</code></pre><p>3、死锁</p><p>过多的同步容易造成死锁，解决方法：生产者消费者模式</p><p>死锁例子演示：</p><pre><code class="java">public class Demo implements Runnable{    private boolean flag = false;    private static Object o1 = new Object();    private static Object o2 = new Object();    public Demo(boolean flag){        this.flag = flag;    }    public void run(){        if(flag==true){            synchronized (o1){                System.out.println(&quot;t1 : o1&quot;);                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (o2){                    System.out.println(&quot;t2 : o1&quot;);                }            }        }        else{            synchronized (o2){                System.out.println(&quot;t2 : o2&quot;);                synchronized (o1){                    System.out.println(&quot;t2 : o2&quot;);                }            }        }    }    public static void main(String[] args) {        Thread t1 = new Thread(new Demo(true));        Thread t2 = new Thread(new Demo(false));        t1.start();        t2.start();        //out:        //t1:o1        //t2:o2...    }}</code></pre><p>4、生产者消费者模式：信号灯法</p><blockquote><p>wait()：等待、释放锁；sleep()：等待、不释放锁</p></blockquote><blockquote><p>notify()/notifyAll()：唤醒</p></blockquote><blockquote><p>wait()与notify()/notifyAll()是要与锁synchronized一起使用的</p></blockquote><pre><code class="java">/** * FileName: App * Author:   braincao * Date:     2018/10/2 16:13 * Description:生产者消费者模式：信号灯法 */public class App{    public static void main(String[] args){        //共同资源        Movie m = new Movie();        //两个线程        Player p = new Player(m);        Watcher w = new Watcher(m);        new Thread(p).start();        new Thread(w).start();    }}/** * 一个场景，共同资源 * 且使用生产者消费者模式：信号灯法 * wait()：等待、释放锁；sleep()：等待、不释放锁 * notify()/notifyAll()：唤醒 * wait()与notify()/notifyAll()是要与锁synchronized一起使用的 * */class Movie {    private String pic;    private boolean flag;    /**     * 信号灯     * flag--&gt;T 生产者生产，消费者等待，生产完成后通知消费者     * flag--&gt;F 消费者消费，生产者等待，消费完成后通知生产者     */    //生产    public synchronized void player(String pic){        if(!flag){//生产者等待            try{                this.wait(); //等待，释放锁            }catch (InterruptedException e){                e.printStackTrace();            }        }        //开始生产        try{            Thread.sleep(500);        }catch (InterruptedException e){            e.printStackTrace();        }        //生产完毕        System.out.println(&quot;生产了：&quot; + pic);        this.pic = pic;        //通知消费者，唤醒正在等待的线程，这里只有一个线程在等待notifyAll()也可以        this.notify();        //生产者停下        this.flag = false;    }    //观看    public synchronized void watch(){        if(flag){//消费者等待            try{                this.wait(); //等待，释放锁            }catch (InterruptedException e){                e.printStackTrace();            }        }        //开始消费        try{            Thread.sleep(200);        }catch (InterruptedException e){            e.printStackTrace();        }        //消费完毕        System.out.println(&quot;消费了：&quot; + pic);        //通知生产者，唤醒正在等待的线程，这里只有一个线程在等待notifyAll()也可以        this.notify();        //消费者停下        this.flag = true;    }}/** * 生产者 */class Player implements Runnable{    private Movie m;    public Player(Movie m){        this.m = m;    }    public void run(){        for(int i=0; i&lt;20; ++i){            if(i%2==0){                m.player(&quot;左青龙&quot;);            }            else{                m.player(&quot;右白虎&quot;);            }        }    }}/** * 消费者 */class Watcher implements Runnable{    private Movie m;    public Watcher(Movie m){        this.m = m;    }    public void run(){        for(int i=0; i&lt;20; ++i){            m.watch();        }    }}out:消费了：null生产了：左青龙消费了：左青龙生产了：右白虎消费了：右白虎生产了：左青龙消费了：左青龙生产了：右白虎消费了：右白虎生产了：左青龙消费了：左青龙生产了：右白虎消费了：右白虎生产了：左青龙</code></pre><p>5、线程之任务调度</p><p>想让该程序晚上11点跑，使用线程之任务调度，Timer定时器类，相当于一个闹钟。</p><pre><code class="java">import java.util.Date;import java.util.Timer;import java.util.TimerTask;class TimerDemo {    public static void main(String[] args) {        Timer timer = new Timer();        timer.schedule(new TimerTask() {            @Override            public void run() {                System.out.println(&quot;so easy...&quot;);            }        }, new Date(System.currentTimeMillis()+3000), 1000); //3秒后运行，每隔1秒运行一次; 如果没有period参数，就只运行一次    }}out:so easy...so easy...so easy...so easy...</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java参数...</title>
      <link href="/2018/12/16/java-parameter/"/>
      <url>/2018/12/16/java-parameter/</url>
      
        <content type="html"><![CDATA[<p>此文档为java参数…的学习总结</p><a id="more"></a><h2 id="java中参数的…"><a href="#java中参数的…" class="headerlink" title="java中参数的…"></a>java中参数的…</h2><p>…表示的是可变长参数，相当于一个数组</p><pre><code>如果是是形参 里面出现，表示的是可变参数比如：//表示的传入的参数可以随意，你传多少个参数都被放到一个数组里面。public static void dealArray(int...intArray) {for(int i: intArray){System.out.print(i +&quot; &quot;);}System.out.println();}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java优先队列</title>
      <link href="/2018/12/16/java-priority-queue/"/>
      <url>/2018/12/16/java-priority-queue/</url>
      
        <content type="html"><![CDATA[<p>此文档为java优先队列的学习总结</p><a id="more"></a><h2 id="java中优先队列和堆的详细使用"><a href="#java中优先队列和堆的详细使用" class="headerlink" title="java中优先队列和堆的详细使用"></a>java中优先队列和堆的详细使用</h2><p>来源:<a href="https://blog.csdn.net/cquzhengdayday/article/details/72514900" target="_blank" rel="noopener">java中优先队列和堆的详细使用</a></p><p><a href="https://www.cnblogs.com/lifegoesonitself/p/3391741.html" target="_blank" rel="noopener">优先队列实现 大小根堆 解决top k 问题</a></p><p><strong>我们知道优先队列其实内部实现就是一个堆的数据结构，java默认的是一个小跟堆，每次取出最小的元素，因为堆的性质他可以做到O(logn)级别的插入和删除操作。</strong></p><p>demo_小根堆：</p><pre><code class="java">Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();//优先队列，内部实现就是一个小根堆queue.add(5);queue.add(3);queue.add(3);queue.add(56);while(!queue.isEmpty()){    System.out.println(queue.poll());///维护一个堆保证每次取出的都是最小的并出堆}out:3、3、5、56demo_大根堆:int initialCapacity = 5;//定义一个长度为5的优先队列(且是大根堆)PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;(initialCapacity, new Comparator&lt;Integer&gt;() {    @Override    public int compare(Integer o1, Integer o2) {        return o2 - o1;    }});</code></pre><p>我们知道堆的性质是有： </p><p>1.堆中某个结点的值总是不大于（或不小于）其父结点的值； </p><p>2.堆总是一棵完全二叉树。</p><p>将根结点最大的堆叫做大根堆，根结点最小的堆叫做小根堆。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/2018/12/16/java-reflection/"/>
      <url>/2018/12/16/java-reflection/</url>
      
        <content type="html"><![CDATA[<p>此文档为java反射的学习总结</p><a id="more"></a><h2 id="动态代理详解"><a href="#动态代理详解" class="headerlink" title="动态代理详解"></a>动态代理详解</h2><p>详看这篇博客<a href="https://www.cnblogs.com/cenyu/p/6289209.html" target="_blank" rel="noopener">Java的三种代理模式</a></p><p>动态代理有以下特点:</p><ul><li>1.代理对象,不需要实现接口</li><li>2.代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)</li><li>3.动态代理也叫做:JDK代理,接口代理</li></ul><p>在Spring的AOP编程中:</p><p>如果加入容器的目标对象有实现接口,用JDK代理<br>如果目标对象没有实现接口,用Cglib代理</p><p>1.动态代理之jdk动态代理:</p><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//动态代理demo//接口interface UserManager{    public void call(String name);}//具体对象class UserManagerImpl implements UserManager {    @Override    public void call(String name) {        System.out.println(&quot;call..&quot; + name);    }}//代理类class ProxyT implements InvocationHandler{    private Object objectTarget;    public Object newProxyInstance(Object objectTarget){        this.objectTarget = objectTarget;        return Proxy.newProxyInstance(objectTarget.getClass().getClassLoader(), objectTarget.getClass().getInterfaces(), this);    }    @Override    /*InvocationHandler接口的方法，proxy表示代理，method表示原对象被调用的方法，args表示方法的参数*/    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;startProxy...&quot;);        Object ret = null;        try{            System.out.println(&quot;日志记录start....&quot;);            ret = method.invoke(objectTarget, args);            System.out.println(&quot;日志记录end....&quot;);        }catch (Exception e){            e.printStackTrace();        }        return ret;    }}public class Test{    public static void main(String[] args) {        UserManager userManager = (UserManager)new ProxyT().newProxyInstance(new UserManagerImpl());        userManager.call(&quot;张三&quot;);    }}</code></pre><p>2.Cglib代理</p><p>上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理</p><p><strong>Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展.</strong></p><p>JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现.<br>Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截)<br>Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉.</p><p>Cglib子类代理实现方法:</p><ul><li>1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入spring-core-3.2.5.jar即可.</li><li>2.引入功能包后,就可以在内存中动态构建子类</li><li>3.代理的类不能为final,否则报错</li><li>4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法.</li></ul><pre><code class="java">import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;/** * 动态代理之cglib动态代理 */class UserDao{    public void save(){        System.out.println(&quot;is saved.&quot;);    }}class ProxyFactory implements MethodInterceptor {    //维护一个目标对象    private Object target;    public ProxyFactory(Object target){        this.target = target;    }    //给目标对象生成代理对象    public Object getProxyInstance(){        //1.工具类        Enhancer en = new Enhancer();        //2.设置父类        en.setSuperclass(target.getClass());        //3.设置回调函数        en.setCallback(this);        //4.创建子类（代理对象）        return en.create();    }    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;开始事务...&quot;);        //执行目标对象的方法        Object returnValue = method.invoke(target, objects);        System.out.println(&quot;提交事务...&quot;);        return returnValue;    }}public class Test{    public static void main(String args[]){        // 目标对象        UserDao target = new UserDao();        //原始类型        System.out.println(target.getClass());        // 给目标对象，创建代理对象        UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance();        System.out.println(proxy.getClass());        // 执行方法   代理对象        proxy.save();    }    /**     * out:     *   class UserDao  //原始的类型 class cn.itcast.b_dynamic.UserDao         class $Proxy0  // class UserDao$$EnhancerByCGLIB$$90f08d08   内存中动态生成的代理对象         开始事务2         is saved.         提交事务2     */}</code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM只是简单地检查这个对象，看它属于哪个特定的类。因此，那个类的.class对于JVM来说必须是可获取的，要么在本地机器上，要么从网络获取。所以对于RTTI和反射之间的<strong>真正区别只在于</strong>：</p><p>RTTI，编译器在编译时打开和检查.class文件</p><p>反射，运行时打开和检查.class文件</p><p>反射调用对象的过程：获取反射的 Class 对象、通过反射创建类对象、通过反射获取类属性方法及构造器。</p><pre><code class="java">import java.lang.reflect.Constructor;import java.lang.reflect.Method;/** * 反射 */public class Test{    private int price;    public int getPrice(){        return price;    }    public void setPrice(int price){        this.price = price;    }    public static void main(String args[]) throws Exception{        //正射调用，代码在未运行时就已经确定了要运行的类（Test）        Test test = new Test();        test.setPrice(5);        System.out.println(test.getPrice());        //反射调用，在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。        Class clazz = Class.forName(&quot;Test&quot;);        Method setMethod = clazz.getMethod(&quot;setPrice&quot;, int.class);        Constructor testConstructor = clazz.getConstructor();        Object testObj = testConstructor.newInstance();        setMethod.invoke(testObj, 5);        Method getMethod = clazz.getMethod(&quot;getPrice&quot;);        System.out.println(getMethod.invoke(testObj));        //out: 5 5    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则</title>
      <link href="/2018/12/16/java-regular/"/>
      <url>/2018/12/16/java-regular/</url>
      
        <content type="html"><![CDATA[<p>思科笔试时遇到的题，将其中的java正则思路保存下便于今后常看。</p><a id="more"></a><h2 id="java正则"><a href="#java正则" class="headerlink" title="java正则"></a>java正则</h2><pre><code class="java">import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 提取sip地址的头部 * 方法：用正则 * 用例： *  1.%22hello%22world%22&lt;sip:10000@172.16.130.42&gt; --&gt;hello%22world *  2.%22%22hello%22world%22%22%22haha%22%22%22&lt;sip:10000@172.16.130.42&gt; --&gt;hello%22world%22%22%22haha *  3.hello22%world&lt;sip:10000@172.16.130.42&gt; --&gt;hello22%world */public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        String url = sc.next();        System.out.println(decode(url));    }    static String decode(String url){        if(url.isEmpty() || url.trim().equals(&quot;&quot;)){            return &quot;&quot;;        }        url = url.trim();        String regex = &quot;^(%22)*(.+(%22)*[^(%22)]+)(%22)*&lt;sip:\\d+@\\d+\\.\\d+\\.\\d+\\.\\d+&gt;$&quot;;        Pattern pattern = Pattern.compile(regex);        Matcher matcher = pattern.matcher(url);        if(matcher.find()) {            return matcher.group(2);        }        return &quot;&quot;;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常和处理详解</title>
      <link href="/2018/12/16/java-throwable/"/>
      <url>/2018/12/16/java-throwable/</url>
      
        <content type="html"><![CDATA[<p>此文档为Java异常的学习总结</p><a id="more"></a><h2 id="Java异常和处理详解"><a href="#Java异常和处理详解" class="headerlink" title="Java异常和处理详解"></a>Java异常和处理详解</h2><p><img src="https://img.braincao.cn/blogimg/1583507974.jpg" alt="1583507974"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法总结</title>
      <link href="/2018/12/16/sort-algorithm/"/>
      <url>/2018/12/16/sort-algorithm/</url>
      
        <content type="html"><![CDATA[<p>此文档记录自己总结的十大经典排序算法，未完结更新中。</p><p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a></p><a id="more"></a><h2 id="排序算法目录"><a href="#排序算法目录" class="headerlink" title="排序算法目录"></a>排序算法目录</h2><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">快速排序</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">冒泡排序</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">直接选择排序</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">堆排序</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">插入排序</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">希尔排序</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">归并排序</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">基数排序（todo）</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">计数排序（todo）</a></td></tr><tr><td align="center">10</td><td align="center"><a href="#10">桶排序（todo）</a></td></tr></tbody></table><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><img src="https://img-blog.csdnimg.cn/20200222170548553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="时间复杂度"></p><p><a name="1"></a></p><h2 id="1-快速排序"><a href="#1-快速排序" class="headerlink" title="1.快速排序"></a>1.快速排序</h2><p>时间o(nlogn)，空间o(logn)</p><p>partition思想代码：</p><pre><code class="java">//数组的快排。思路：partition思想public static void quickSort(int[] num){    quickSortDetail(num, 0, num.length-1);}public static void quickSortDetail(int[] num, int left, int right){    if(left&gt;=right){        return;    }    int index = partition(num, left, right);    quickSortDetail(num, left, index-1);    quickSortDetail(num, index+1, right);}public static int partition(int[] nums, int left, int right){    int pivot = nums[left];    swap(nums, left, right);    int store = left;    for(int i=left; i&lt;right; ++i){// &lt;right        if(nums[i]&lt;=pivot){// &lt;=pivot            swap(nums, i, store++);        }    }    swap(nums, right, store);    return store;}public static void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}</code></pre><p>模板型代码：</p><pre><code class="java">void quickSort(int[] num, int left, int right){    if(left&gt;right){        return;    }    int i = left;    int j = right;    int x = num[left];    while(i&lt;j){        while(i&lt;j &amp;&amp; num[j]&gt;=x){            j--;        }        if(i&lt;j){            num[i++] = num[j];        }        while(i&lt;j &amp;&amp; num[i]&lt;=x){            i++;        }        if(i&lt;j){            num[j--] = num[i];        }    }    num[i] = x;    quickSort(num, left, i-1);    quickSort(num, i+1, right);}</code></pre><p><a name="2"></a></p><h2 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2.冒泡排序"></a>2.冒泡排序</h2><h3 id="冒泡排序思想"><a href="#冒泡排序思想" class="headerlink" title="冒泡排序思想"></a>冒泡排序思想</h3><p>交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。</p><p>冒泡排序是一种交换排序。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端，故名。</p><p>假设有一个大小为 N 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。</p><p><img src="https://img-blog.csdnimg.cn/20200222172442706.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="冒泡排序思想"></p><p>以上图为例，演示一下冒泡排序的实际流程：</p><p>假设有一个无序序列  { 4. 3. 1. 2, 5 }</p><p>第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。</p><p>第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。</p><p>第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。</p><p>至此，所有元素已经有序，排序结束。</p><p>要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。</p><p>假设要对一个大小为 N 的无序序列进行升序排序（即从小到大）。</p><p>(1) 每趟排序过程中需要通过比较找到第 i 个小的元素。</p><blockquote><p>所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 N - 2) ，剩下最后一个元素，必然为最大。</p></blockquote><p>(2) 假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。</p><blockquote><p>所以，需要一个内部循环，从数组末端开始（下标 N - 1），扫描到 (下标 i + 1)。</p></blockquote><h3 id="原始版本代码"><a href="#原始版本代码" class="headerlink" title="原始版本代码"></a>原始版本代码</h3><pre><code class="java">public static void bubbleSort(int[] arr){    for(int i=0; i&lt;arr.length-1; ++i){//循环n-1趟，每趟最大的沉到最后        boolean swapCnt = false;         for(int j=0; j&lt;arr.length-i-1; ++j){//每一趟的相邻元素比较交换            if(arr[j]&gt;arr[j+1]){                swap(arr, j, j+1);                swapCnt = true;            }        }        if(swapCnt==false){//如果没发生交换，则说明已经有序，直接退出，这样有可能达到o(n)            return;        }    }}</code></pre><p>同样的版本另外一种写法：</p><pre><code class="java">public void bubbleSort(int[] list) {    int temp = 0; // 用来交换的临时数    // 要遍历的次数    for (int i = 0; i &lt; list.length - 1; i++) {        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上        for (int j = list.length - 1; j &gt; i; j--) {            // 比较相邻的元素，如果前面的数大于后面的数，则交换            if (list[j - 1] &gt; list[j]) {                temp = list[j - 1];                list[j - 1] = list[j];                list[j] = temp;            }        }        System.out.format(&quot;第 %d 趟：    &quot;, i);        printAll(list);    }}</code></pre><h3 id="算法性能分析"><a href="#算法性能分析" class="headerlink" title="算法性能分析"></a>算法性能分析</h3><p>冒泡排序算法的性能如下图</p><p><img src="https://img-blog.csdnimg.cn/20200222172509463.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="冒泡排序算法的性能"></p><p><strong>时间复杂度</strong></p><pre><code>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，冒泡排序最好时间复杂度为O(N)。若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：Cmax = N(N-1)/2 = O(N2)Mmax = 3N(N-1)/2 = O(N2)冒泡排序的最坏时间复杂度为O(N2)。因此，冒泡排序的平均时间复杂度为O(N2)。</code></pre><p>总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。</p><p><strong>算法稳定性</strong></p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。</p><p>所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><h3 id="优化版本代码"><a href="#优化版本代码" class="headerlink" title="优化版本代码"></a>优化版本代码</h3><p>对冒泡排序常见的改进方法是加入标志性变量exchange，用于标志某一趟排序过程中是否有数据交换。</p><p>如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。</p><pre><code class="java">/ 对 bubbleSort 的优化算法public void bubbleSort_2(int[] list) {    int temp = 0; // 用来交换的临时数    boolean bChange = false; // 交换标志    // 要遍历的次数    for (int i = 0; i &lt; list.length - 1; i++) {        bChange = false;        // 从后向前依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上        for (int j = list.length - 1; j &gt; i; j--) {            // 比较相邻的元素，如果前面的数大于后面的数，则交换            if (list[j - 1] &gt; list[j]) {                temp = list[j - 1];                list[j - 1] = list[j];                list[j] = temp;                bChange = true;            }        }        // 如果标志为false，说明本轮遍历没有交换，已经是有序数列，可以结束排序        if (false == bChange)            break;        System.out.format(&quot;第 %d 趟：    &quot;, i);        printAll(list);    }}</code></pre><p><a name="3"></a></p><h2 id="3-直接选择排序"><a href="#3-直接选择排序" class="headerlink" title="3.直接选择排序"></a>3.直接选择排序</h2><p>时间o(n^2)，空间o(1)</p><p>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到已排序序列的末尾，以此类推，直到所有元素均排序完毕。</p><pre><code class="java">//1.选择排序public static void pickSort(int[] arr){    for(int i=0; i&lt;arr.length-1; ++i){        int minIndex = i;        for(int j=i+1; j&lt;arr.length; ++j){            if(arr[j] &lt; arr[minIndex]){                minIndex = j;            }        }        swap(arr, i, minIndex);    }}</code></pre><p><a name="4"></a></p><h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4.堆排序"></a>4.堆排序</h2><p>来源: <a href="https://www.cnblogs.com/Java3y/p/8639937.html" target="_blank" rel="noopener">堆排序就这么简单</a></p><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。空间o(1)</p><p>堆排序的基本思路：</p><pre><code>a.将无需序列构建成一个堆，根据需求选择大顶堆(升序)或小顶堆(降序);b.将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;c.重新调整剩下元素结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</code></pre><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</p><p>对于完全二叉树对应的数组来说，堆的定义就是：</p><p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p><p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p><pre><code class="java">//堆排序。思路：基于完全二叉树性质进行堆排序，时间o(nlogn)，空间o(1)public static void heapSort(int[] nums){    if(nums==null || nums.length&lt;2){        return;    }    //1.先建好大根堆：从第一个非叶子结点从下至上，从右至左调整结构    for(int i=nums.length/2-1; i&gt;=0; --i){        adjustHeap(nums, i, nums.length);    }    //2.堆排序。每次将堆顶与末尾元素交换并调整堆    for(int i=nums.length-1; i&gt;0; --i){        swap(nums, 0, i);//将堆顶元素与末尾元素进行交换        adjustHeap(nums, 0, i);//重新对堆进行调整，注意这里第三个参数不是length而是i，因为i之后的已经有序    }}//调整堆（仅是调整i节点的过程，建立在大顶堆已构建的基础上）public static void adjustHeap(int[] nums, int i, int length){    int temp = nums[i];    for(int k=2*i+1; k&lt;length; k=2*i+1){        if(k+1&lt;length &amp;&amp; nums[k+1]&gt;nums[k]){//找左右子节点中最大的            k++;        }        if(nums[k]&gt;temp){//子节点比父节点大，需要交换，这里直接赋值，最后再赋值一次即可，减少交换次数            nums[i] = nums[k];            i = k;        }        else{//如果顺序正常，则break            break;        }    }    nums[i] = temp;}public static void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}public static void main(String[] args){    int[] arr = new int[]{6,4,3,1,11,54,2};    System.out.println(Arrays.toString(arr));    heapSort(arr);    System.out.println(Arrays.toString(arr));    //out：    //[6, 4, 3, 1, 11, 54, 2]    //[1, 2, 3, 4, 6, 11, 54]}</code></pre><p><a name="5"></a></p><h2 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5.插入排序"></a>5.插入排序</h2><p>时间o(n^2)，空间o(1)<br>​<br>通过构建有序序列(从第一个元素开始，该元素可以认为已经被排序)，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><pre><code class="java">//3.插入排序public static void insertSort(int[] arr){    if(arr==null || arr.length&lt;2){        return;    }    for(int i=1; i&lt;arr.length; ++i){        int temp = arr[i];        int j = i;        while(j-1&gt;=0 &amp;&amp; arr[j-1]&gt;temp){//如果当前元素大于temp，该元素后移            arr[j] = arr[j-1];            j--;        }        arr[j] = temp; //找到temp应该在的位置    }}</code></pre><p><a name="6"></a></p><h2 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6.希尔排序"></a>6.希尔排序</h2><p>时间o(n^(1.3—2))，空间o(1)</p><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，该算法是冲破O(n2）的第一批算法之一<br>​<br>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，</p><p>比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。</p><p>而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，</p><p>随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。</p><p>希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。</p><p>然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p><p>常用增量：选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，最后增量为1</p><pre><code class="java">//4.希尔排序(缩小增量排序)--两种希尔排序//希尔排序：针对有序序列在插入时采用交换法public static void shellSort(int []arr){    //增量gap，并逐步缩小增量    for(int gap=arr.length/2;gap&gt;0;gap/=2){    //从第gap个元素，逐个对其所在组进行直接插入排序操作        for(int i=gap;i&lt;arr.length;i++){            int j = i;            while(j-gap&gt;=0 &amp;&amp; arr[j]&lt;arr[j-gap]){            //插入排序采用交换法                swap(arr,j,j-gap);                j-=gap;            }        }    }}//希尔排序：针对有序序列在插入时采用移动法。 public static void shellSort2(int []arr){     //增量gap，并逐步缩小增量     for(int gap=arr.length/2;gap&gt;0;gap/=2){         //从第gap个元素，逐个对其所在组进行直接插入排序操作         for(int i=gap;i&lt;arr.length;i++){             int j = i;             int temp = arr[j];             if(arr[j]&lt;arr[j-gap]){                 while(j-gap&gt;=0 &amp;&amp; temp&lt;arr[j-gap]){                     //移动法                     arr[j] = arr[j-gap];                     j-=gap;                 }                 arr[j] = temp;             }         }     }}</code></pre><p><a name="7"></a></p><h2 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h2><p>时间o(nlogn)，空间o(n)，稳定</p><pre><code class="java">public class Solution {    //归并排序    public static void mergeSort(int[] arr){        int[] temp = new int[arr.length]; //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        sort(arr, 0, arr.length-1, temp);    }    private static void sort(int[] arr, int left, int right, int[] temp){        if(left&lt;right){            int mid = (left+right)/2;            sort(arr, left, mid, temp); //左边归并排序，使得左子序列有序            sort(arr, mid+1, right, temp);//右边归并排序，使得右子序列有序            merge(arr, left, mid, right, temp);//将两个有序子数组合并操作        }    }    private static void merge(int[] arr, int left, int mid, int right, int[] temp){        int i = left; //左序列指针        int j = mid+1; //右序列指针        int t = 0; //临时数组指针        while(i&lt;=mid &amp;&amp; j&lt;=right){            if(arr[i]&lt;=arr[j]){                temp[t++] = arr[i++];            }            else{                temp[t++] = arr[j++];            }        }        while(i&lt;=mid){//将左边剩余元素填充进temp中            temp[t++] = arr[i++];        }        while(j&lt;=right){//将右边剩余元素填充进temp中            temp[t++] = arr[j++];        }        t = 0;        //将temp中的元素全部拷贝到原数组中        while(left &lt;= right){            arr[left++] = temp[t++];        }    }    public static void show(int[] arr){        for(int i=0; i&lt;arr.length; ++i){            System.out.print(arr[i] + &quot; &quot;);        }        System.out.println();    }    public static void main(String[] args){        int[] arr = {9,8,7,6,5,4,3,2,1,123,23};        show(arr);//out:9 8 7 6 5 4 3 2 1 123 23        mergeSort(arr);        show(arr); //out:1 2 3 4 5 6 7 8 9 23 123    }}</code></pre><p>另一个版本：</p><pre><code class="java">import java.util.Arrays;public class Solution {    //归并排序。思路：分而治之，先分后治,辅助数组temp[]    public static void mergeSort(int[] nums){        if(nums==null || nums.length&lt;2){            return;        }        int[] temp = new int[nums.length]; //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        mergeSortDetail(nums, 0, nums.length-1, temp);    }    //分    private static void mergeSortDetail(int[] nums, int left, int right, int[] temp){        if(left&lt;right){//一个数字不用merge，只有两个以上才merge            int mid = (left+right)/2;            mergeSortDetail(nums, left, mid, temp);//左边归并排序，使得左子序列有序            mergeSortDetail(nums, mid+1, right, temp);//右边归并排序，使得右子序列有序            merge(nums, left, mid, right, temp);//将两个有序子数组合并操作        }    }    //治    private static void merge(int[] nums, int left, int mid, int right, int[] temp){        int tempIndex = 0;//temp数组的当前位置        int i = left; //左序列的索引        int j = mid+1; //右序列的索引        while(i&lt;=mid &amp;&amp; j&lt;=right){//将左、右序列的元素有序的放进temp数组中            temp[tempIndex++] = nums[i]&lt;=nums[j] ? nums[i++] : nums[j++];        }        while(i&lt;=mid){//将左边剩余元素填充进temp中            temp[tempIndex++] = nums[i++];        }        while(j&lt;=right){//将右边剩余元素填充进temp中            temp[tempIndex++] = nums[j++];        }        //将temp中的元素全部拷贝到nums原数组中        tempIndex = 0;        while(left&lt;=right){            nums[left++] = temp[tempIndex++];        }    }    public static void main(String []args){        int[] nums = {9,8,7,6,5,4,3,2,1};        mergeSort(nums);        System.out.println(Arrays.toString(nums));    }}</code></pre><p><a name="8"></a></p><h2 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8.基数排序"></a>8.基数排序</h2><p><a name="9"></a></p><h2 id="9-计数排序"><a href="#9-计数排序" class="headerlink" title="9.计数排序"></a>9.计数排序</h2><p><a name="10"></a></p><h2 id="10-桶排序"><a href="#10-桶排序" class="headerlink" title="10.桶排序"></a>10.桶排序</h2>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring拦截器与过滤器的区别</title>
      <link href="/2018/12/16/spring-filter/"/>
      <url>/2018/12/16/spring-filter/</url>
      
        <content type="html"><![CDATA[<p>此文档为spring拦截器与过滤器的学习总结</p><a id="more"></a><h2 id="spring拦截器与过滤器的区别"><a href="#spring拦截器与过滤器的区别" class="headerlink" title="spring拦截器与过滤器的区别"></a>spring拦截器与过滤器的区别</h2><pre><code>1.拦截器是基于java的反射机制的，而过滤器是基于函数回调。2.拦截器不依赖与servlet容器，过滤器依赖与servlet容器。3.拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。4.拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。5.在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树系列详解</title>
      <link href="/2018/12/16/sql-btree/"/>
      <url>/2018/12/16/sql-btree/</url>
      
        <content type="html"><![CDATA[<p>此文档为B树系列的学习总结</p><a id="more"></a><h1 id="BST树、AVL树、RBT树；B树、B-树、B-树、B-树"><a href="#BST树、AVL树、RBT树；B树、B-树、B-树、B-树" class="headerlink" title="BST树、AVL树、RBT树；B树、B-树、B+树、B*树"></a>BST树、AVL树、RBT树；B树、B-树、B+树、B*树</h1><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p><h2 id="红黑树详解"><a href="#红黑树详解" class="headerlink" title="红黑树详解"></a>红黑树详解</h2><p><a href="https://blog.csdn.net/yangyutong0506/article/details/78204953" target="_blank" rel="noopener">吐血推荐_面试旧敌之红黑树(直白介绍深入理解)</a></p><p><a href="https://blog.csdn.net/qq_34173549/article/details/79636764" target="_blank" rel="noopener">java面试-彻底搞懂红黑树</a></p><p><a href="https://segmentfault.com/a/1190000014037447" target="_blank" rel="noopener">那些年，面试被虐过的红黑树</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&mid=2247485383&idx=1&sn=0e0ceaf484054850be559cefa86c5298&chksm=e9c5fe76deb27760f41928f683bdf63cbddeda3e4e6bfb7a55bb9a2f15598f9b41895027471a&scene=21#wechat_redirect" target="_blank" rel="noopener">为什么MySQL数据库索引选择使用B+树？</a></p><p><img src="https://img.braincao.cn/blogimg/1583508090.png" alt="1583508090"></p><p>红黑树的左旋操作</p><p>假设待左旋的结构中，P为父节点，S为孩子节点。左旋操作后，S节点代替P节点的位置，P节点成为S节点的左孩子，S节点的左孩子成为P节点的右孩子。</p><p>红黑树的右旋操作。</p><p>假设待右旋的结构中，P为父节点，S为孩子节点。右旋操作后，S节点代替P节点的位置，P节点成为S节点的右孩子，S节点的右孩子成为P节点的左孩子。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md5加密字符串</title>
      <link href="/2018/12/16/java-md5-string/"/>
      <url>/2018/12/16/java-md5-string/</url>
      
        <content type="html"><![CDATA[<p>此文档为md5加密字符串的学习总结</p><a id="more"></a><h2 id="md5加密字符串"><a href="#md5加密字符串" class="headerlink" title="md5加密字符串"></a>md5加密字符串</h2><p>md5:对任意长度字符串返回一个特定长度的加密编码，不可逆</p><pre><code class="java">//盐值字符串，用于混淆md5。越复杂越好，用户猜不到private final String slat = &quot;asdc#$!EFSD$#%$GWVDSQ#!$#%$#T~~@#$^GV&quot;;//对seckillId生成md5的过程private String getMD5(long seckillId){    String base = seckillId + &quot;/&quot; + slat;    String md5 = DigestUtils.md5DigestAsHex(base.getBytes());//用base二进制生成md5    return md5;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题-part1</title>
      <link href="/2018/09/21/leetcode-algorithm-part1/"/>
      <url>/2018/09/21/leetcode-algorithm-part1/</url>
      
        <content type="html"><![CDATA[<p>此leetcode刷题系列记录单独做的leetcode题目与答案，并非每道题都做，只记录做过的。每篇文档25道题，以官网题目序号为顺序。</p><a id="more"></a><h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table><thead><tr><th align="center">leetcode</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">69</td><td align="center"><a href="#69">x的平方根</a></td></tr><tr><td align="center">104</td><td align="center"><a href="#104">二叉树的最大深度</a></td></tr><tr><td align="center">637</td><td align="center"><a href="#637">二叉树的层平均值</a></td></tr><tr><td align="center">695</td><td align="center"><a href="#695">岛屿的最大面积</a></td></tr><tr><td align="center">771</td><td align="center"><a href="#771">宝石与石头</a></td></tr></tbody></table><h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="69"></a></p><h2 id="No-69——x的平方根"><a href="#No-69——x的平方根" class="headerlink" title="No.69——x的平方根"></a>No.69——x的平方根</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p>Example 1:</p><pre><code>Input: 4Output: 2</code></pre><p>Example 2:</p><pre><code>Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>就是开根号，用二分法且用除法避免溢出</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">class Solution {public:    int mySqrt(int x) {        if(x==0)            return 0;        if(x&lt;4){            return 1;        }        int left = 1;        int right = x/2+1; //这里注意        int mid;        while(left &lt;= right){//while中的等号注意            mid = left + (right-left)/2;            if(x/mid == mid){                return mid;            }            else if(x/mid &gt; mid){                left = mid + 1;            }            else if(x/mid &lt; mid){                right = mid - 1;            }        }        return right;    }};</code></pre><p><a name="104"></a></p><h2 id="No-104——二叉树的最大深度"><a href="#No-104——二叉树的最大深度" class="headerlink" title="No.104——二叉树的最大深度"></a>No.104——二叉树的最大深度</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7</code></pre><p>return its depth = 3.</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int maxDepth(TreeNode* root) {//同样用了二叉树左子树右子树的递归思想        if(!root)            return 0;        int ldeep = maxDepth(root-&gt;left);        int rdeep = maxDepth(root-&gt;right);        return ldeep&gt;rdeep ? ldeep+1 : rdeep+1;    }};</code></pre><p><a name="637"></a></p><h2 id="No-637——二叉树的层平均值"><a href="#No-637——二叉树的层平均值" class="headerlink" title="No.637——二叉树的层平均值"></a>No.637——二叉树的层平均值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.</p><p>示例 1:</p><pre><code>输入:    3   / \  9  20    /  \   15   7输出：[3, 14.5, 11]解释：第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].</code></pre><p>注意：节点值的范围在32位有符号整数范围内。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>队列实现层次遍历的核心思路：</p><p><strong>根节点为空返回NULL，根节点入队，while队列不为空则pop()一个元素，访问该元素后，将其左子树、右子树分别入队</strong></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;double&gt; averageOfLevels(TreeNode* root) {         //层次遍历并且要知道每一层的节点都是哪几个；        //用队列实现层次遍历：根节点为空返回NULL，根节点入队，while队列不为空则pop（）一个元素，访问该元素后，将其左子树、右子树分别入队        vector&lt;double&gt; res;        if(!root)            return res;        queue&lt;TreeNode*&gt; que;        que.push(root);        while(!que.empty())        {            int len = que.size();            int cnt = len;            double sum = 0;            while(cnt != 0)            {                TreeNode* tmp = que.front();                sum += tmp-&gt;val;                que.pop();                if(tmp-&gt;left)                    que.push(tmp-&gt;left);                if(tmp-&gt;right)                    que.push(tmp-&gt;right);                cnt--;            }            res.push_back(sum/len);        }        return res;    }};</code></pre><p><a name="695"></a></p><h2 id="No-695——岛屿的最大面积"><a href="#No-695——岛屿的最大面积" class="headerlink" title="No.695——岛屿的最大面积"></a>No.695——岛屿的最大面积</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><pre><code>[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]</code></pre><p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p>示例 2:</p><pre><code>[[0,0,0,0,0,0,0,0]]</code></pre><p>对于上面这个给定的矩阵, 返回 0。</p><p>注意: 给定的矩阵grid 的长度和宽度都不超过 50。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>DFS思想：一直往深处走，直到找到解或者走不下去为止。</p><p>实现：采用递归，使用栈保存未被检测的结点，结点按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。</p><p>详见 <code>DFS模板</code></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int maxDepth(TreeNode* root) {//同样用了二叉树左子树右子树的递归思想        if(!root)            return 0;        int ldeep = maxDepth(root-&gt;left);        int rdeep = maxDepth(root-&gt;right);        return ldeep&gt;rdeep ? ldeep+1 : rdeep+1;    }};</code></pre><p><a name="771"></a></p><h2 id="No-771——宝石与石头"><a href="#No-771——宝石与石头" class="headerlink" title="No.771——宝石与石头"></a>No.771——宝石与石头</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p>示例 1:</p><pre><code>输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3</code></pre><p>示例 2:</p><pre><code>输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0</code></pre><p>注意：S 和 J 最多含有50个字母。 J 中的字符不重复。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">class Solution {    public:        int numJewelsInStones(string J, string S) {            //将J存成hash_map，便于S查询计数            map&lt;char, int&gt; hash_map;            for(int i=0; i&lt;J.length(); i++)            {                hash_map.insert(pair&lt;char, int&gt;(J[i], 1));            }            int res = 0;            for(char c: S)            {                if(hash_map.count(c) != 0) //map.count()返回0或1； map.find()返回迭代器                    res += 1;            }            return res;        }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左神刷题</title>
      <link href="/2018/09/21/leftgod-algorithm/"/>
      <url>/2018/09/21/leftgod-algorithm/</url>
      
        <content type="html"><![CDATA[<p>此文档包含左神书上题目（未完结，只做了部分）以及所涉及的leetcode题目，尽量都留存了最优解，部分简单的题目没有进行总结。左神的书——《程序员代码面试指南》</p><a id="more"></a><h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">按照左右半区的方式重新组合单链表</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">用递归函数和栈操作逆序栈</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">猫狗队列</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">用一个栈来实现另一个栈的排序</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">汉诺塔问题</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">构造数组的MaxTree</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">最大子矩阵(直方图-栈)</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">找两个排序数组的中位数</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">删除链表中的节点(两道)</a></td></tr><tr><td align="center">10</td><td align="center"><a href="#10">找到/删除链表的中间节点(两道)</a></td></tr><tr><td align="center">11</td><td align="center"><a href="#11">删除链表a/b处的节点</a></td></tr><tr><td align="center">12</td><td align="center"><a href="#12">判断一个链表是否为回文结构</a></td></tr><tr><td align="center">13</td><td align="center"><a href="#13">将单链表按某值划分成左边小，中间相等，右边大</a></td></tr><tr><td align="center">14</td><td align="center"><a href="#14">单链表的归并排序</a></td></tr><tr><td align="center">15</td><td align="center"><a href="#15">单链表的快速排序</a></td></tr><tr><td align="center">16</td><td align="center"><a href="#16">单链表的选择排序</a></td></tr><tr><td align="center">17</td><td align="center"><a href="#17">两个链表生成相加链表</a></td></tr><tr><td align="center">18</td><td align="center"><a href="#18">删除单链表的重复节点(三道)</a></td></tr><tr><td align="center">19</td><td align="center"><a href="#19">向有序的环形单链表中插入新节点</a></td></tr><tr><td align="center">20</td><td align="center"><a href="#20">打印二叉树的边界节点</a></td></tr><tr><td align="center">21</td><td align="center"><a href="#21">编辑距离</a></td></tr><tr><td align="center">22</td><td align="center"><a href="#22">找出数组中左边比他小右边比他大的所有元素</a></td></tr><tr><td align="center">23</td><td align="center"><a href="#23">判断二叉树为BST(二叉搜索树)</a></td></tr><tr><td align="center">24</td><td align="center"><a href="#24">Replace Words(字典树应用)</a></td></tr><tr><td align="center">25</td><td align="center"><a href="#25">BFS/DFS思想</a></td></tr><tr><td align="center">26</td><td align="center"><a href="#26">BFS相关题目(1道)</a></td></tr><tr><td align="center">27</td><td align="center"><a href="#27">DFS相关题目(4道)</a></td></tr><tr><td align="center">28</td><td align="center"><a href="#28">图的几种最短路算法(4道)</a></td></tr><tr><td align="center">29</td><td align="center"><a href="#29">Word Ladder(2道)(SPFA最短路算法应用)</a></td></tr><tr><td align="center">30</td><td align="center"><a href="#30">字符串匹配(kmp算法)</a></td></tr><tr><td align="center">31</td><td align="center"><a href="#31">两数相除(转为减法)</a></td></tr><tr><td align="center">32</td><td align="center"><a href="#32">sqrt(x)</a></td></tr><tr><td align="center">33</td><td align="center"><a href="#33">乱序的数组中找到最长的递增子序列</a></td></tr><tr><td align="center">34</td><td align="center"><a href="#34">蓄水池问题</a></td></tr><tr><td align="center">35</td><td align="center"><a href="#35">满足指定sum条件的长度最小的子数组</a></td></tr><tr><td align="center">36</td><td align="center"><a href="#36">最大值减去最小值小于或等于num的子数组数量</a></td></tr><tr><td align="center">37</td><td align="center"><a href="#37">几道未整理的</a></td></tr></tbody></table><h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p><h2 id="1-按照左右半区的方式重新组合单链表"><a href="#1-按照左右半区的方式重新组合单链表" class="headerlink" title="1.按照左右半区的方式重新组合单链表"></a>1.按照左右半区的方式重新组合单链表</h2><p>《左神》86、牛客网有编程挑战题</p><p>给定一个单链表的头部节点head，链表长度为N。 如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区； 如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区； 左半区从左到右依次记为L1-&gt;L2-&gt;…，右半区从左到右依次记为R1-&gt;R2-&gt;…。请将单链表调整成L1-&gt;R1-&gt;L2-&gt;R2-&gt;…的样子。</p><pre><code>1-&gt;2-&gt;3-&gt;4 调整后：1-&gt;3-&gt;2-&gt;4 1-&gt;2-&gt;3-&gt;4-&gt;5 调整后：1-&gt;3-&gt;2-&gt;4-&gt;5 </code></pre><p>要求：如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)</p><p>思路：遍历两遍链表，先找到左半区的最后一个节点，再左右半区重新拼接链表。时间O(N)，空间O(1)</p><pre><code class="java">public static void relocateList(ListNode head) {    if(head==null || head.next==null || head.next.next==null || head.next.next.next==null){        return;    }    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode left = guard.next;//左半区    ListNode right;//左半区的最后一个节点    //1.遍历一遍链表，找到左半区的最后一个节点    ListNode fast = guard;    ListNode low = guard;    while(fast.next!=null &amp;&amp; fast.next.next!=null){//fast走两步，low走一步        fast = fast.next.next;        low = low.next;    }    right = low;//找到了左半区的最后一个节点    //2.再左右半区重新拼接链表    ListNode rightCopy = right;//缓存左半区的最后一个节点    while(left!=rightCopy){        //1.剥离当前节点        ListNode temp = right.next;        right.next = temp.next;        temp.next = null;        //2.拼接左右半区节点        temp.next = left.next;        left.next = temp;        left = left.next.next;    }}</code></pre><p><a name="2"></a></p><h2 id="2-用递归函数和栈操作逆序栈"><a href="#2-用递归函数和栈操作逆序栈" class="headerlink" title="2.用递归函数和栈操作逆序栈"></a>2.用递归函数和栈操作逆序栈</h2><p>《左神》8</p><p>题目：一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现了栈中元素的逆序，请设计一个算法实现逆序栈的操作，但是只能用递归函数来实现，而不能用另外的数据结构。</p><p>思路：两个递归函数搞定</p><pre><code class="java">import java.util.Stack;//用递归函数和栈操作逆序栈public class ReverseStack {    //逆序栈元素    public void reverseStackRecursively(Stack&lt;Integer&gt; stack) {        if(stack.isEmpty()){            return;        }        int bottom = getAndDelBottom(stack);        reverseStackRecursively(stack);        stack.push(bottom);    }    //删除并返回栈底元素    public int getAndDelBottom(Stack&lt;Integer&gt; stack){        int curData = stack.pop();        if(stack.isEmpty()){            return curData;        }        else{            int last = getAndDelBottom(stack);            stack.push(curData);            return last;        }    }}</code></pre><p><a name="3"></a></p><h2 id="3-猫狗队列"><a href="#3-猫狗队列" class="headerlink" title="3.猫狗队列"></a>3.猫狗队列</h2><p>《左神》10</p><p>题目：实现一种狗猫队列的结构，要求如下：</p><p>（1）用户可以调用add方法将cat类或dog类的实例放入队列中；</p><p>（2）用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出；</p><p>（3）用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出；</p><p>（4）用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出；</p><p>（5）用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例；</p><p>（6）用户可以调用isDogEmpty方法，检查队列中是否还有dog类的实例；</p><p>（7）用户可以调用isCatEmpty方法，检查队列中是否还有cat类的实例。</p><p>思路：新定义带时间戳的Pet类(PetEnterQue)，然后用两个队列(dogQue\catQue)结合时间戳来定义新类(dogCatQue)，猫狗队列就是这个类的一个实例</p><pre><code class="java">import java.util.LinkedList;import java.util.Queue;/** * 猫狗队列。 */public class Pet {    private String type;    public Pet(String type) {        this.type = type;    }    public String getPetType() {        return type;    }}public class Dog extends Pet{    public Dog() {        super(&quot;dog&quot;);    }}public class Cat extends Pet{    public Cat() {        super(&quot;cat&quot;);    }}//新定义一个带时间戳的Pet类public class PetEnterQue{    private Pet pet;    private long count; //时间戳    public PetEnterQue(Pet pet, long count) {        this.pet = pet;        this.count = count;    }    public Pet getPet() {        return pet;    }    public long getCount() {        return count;    }}//这个类的实例就是一个猫狗队列public class dogCatQue{    private Queue&lt;PetEnterQue&gt; dogQue;    private Queue&lt;PetEnterQue&gt; catQue;    private long count;    public dogCatQue(){        dogQue = new LinkedList&lt;&gt;();        catQue = new LinkedList&lt;&gt;();        count = 0;    }    public void offer(Pet pet){        if(pet.getPetType().equals(&quot;dog&quot;)){            dogQue.offer(new PetEnterQue(pet, count++));        }        else{            catQue.offer(new PetEnterQue(pet, count++));        }    }    public Pet pollDog(){        if(dogQue.isEmpty()){            return null;        }        return dogQue.poll().getPet();    }    public Pet pollCat(){        if(catQue.isEmpty()){            return null;        }        return catQue.poll().getPet();    }    public Pet pollAll(){        if(dogQue.isEmpty()){            if(!catQue.isEmpty()){                return catQue.poll().getPet();            }        }        else if(catQue.isEmpty()){            if(!dogQue.isEmpty()){                return dogQue.poll().getPet();            }        }        else{//比较时间戳，将早进队列的Pet出队            return dogQue.peek().getCount()&gt;catQue.peek().getCount()? catQue.poll().getPet() :dogQue.poll().getPet();        }        return null;    }    public boolean isEmpty(){        return dogQue.isEmpty() &amp;&amp; catQue.isEmpty();    }    public boolean isDogEmpty(){        return dogQue.isEmpty();    }    public boolean isCatEmpty(){        return catQue.isEmpty();    }}</code></pre><p><a name="4"></a></p><h2 id="4-用一个栈来实现另一个栈的排序"><a href="#4-用一个栈来实现另一个栈的排序" class="headerlink" title="4.用一个栈来实现另一个栈的排序"></a>4.用一个栈来实现另一个栈的排序</h2><p>《左神》13</p><p>题目：在一个栈中元素的类型为整型，现在想将该栈从栈顶到栈底按从大到小的顺序排序，只许申请一个栈，除此之外，可以申请其他变量，但是不能申请额外的数据结构。</p><pre><code class="java">//用一个栈来实现另一个栈的排序public static void sortStackByStack(Stack&lt;Integer&gt; stack){    Stack&lt;Integer&gt; help = new Stack&lt;&gt;();    while(!stack.isEmpty()){        int temp = stack.pop();        while(!help.isEmpty() &amp;&amp; temp&gt;help.peek()){            stack.push(help.pop());        }        help.push(temp);    }    while(!help.isEmpty()){        stack.push(help.pop());    }}public static void main(String[] args){    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    stack.push(4);    stack.push(3);    stack.push(76);    stack.push(5);    stack.push(8);    stack.push(9);    System.out.println(stack);    sortStackByStack(stack);    System.out.println(stack);}</code></pre><p><a name="5"></a></p><h2 id="5-汉诺塔问题-两道"><a href="#5-汉诺塔问题-两道" class="headerlink" title="5.汉诺塔问题(两道)"></a>5.汉诺塔问题(两道)</h2><h3 id="1-正常汉诺塔：可以直接从左移到右，不需经过中间"><a href="#1-正常汉诺塔：可以直接从左移到右，不需经过中间" class="headerlink" title="1.正常汉诺塔：可以直接从左移到右，不需经过中间"></a>1.正常汉诺塔：可以直接从左移到右，不需经过中间</h3><p><strong>法一递归(常用这个)：</strong></p><pre><code class="java">//汉诺塔tower of hanoi问题。法一:递归public static void towerOfHanoi(int n) {    move(&quot;left&quot;, &quot;right&quot;, &quot;mid&quot;, n);}public static void move(String start, String end, String buffer, int n){    if(n==1){        System.out.println(&quot;from &quot; + start + &quot; to &quot; + end);        return;    }    move(start, buffer, end, n-1); //将1-n-1移动到buffer，即缓冲区    System.out.println(&quot;from &quot; + start + &quot; to &quot; + end); //将n移动到目标柱子上    move(buffer, end, start, n-1); // 将1-n-1移动到目标柱子上}public static void main(String[] args){    towerOfHanoi(3);    //out:    //from left to right    //from left to mid    //from right to mid    //from left to right    //from mid to left    //from mid to right    //from left to right}</code></pre><p>法二用栈：</p><pre><code class="java">public class HanoiStack {    public static void main(String[] args) {        Stack hanoi = new Stack();        hanoi.push(new Problem(4, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;));        Problem myProblem = null;        while (!hanoi.isEmpty() &amp;&amp; (myProblem = (Problem) hanoi.pop()) != null) {            if (myProblem.n == 1) {                System.out.println(myProblem.A+&quot;-&gt;&quot;+myProblem.C);            } else {                hanoi.push(new Problem(myProblem.n-1, myProblem.B, myProblem.A, myProblem.C));                hanoi.push(new Problem(1, myProblem.A, myProblem.B, myProblem.C));                hanoi.push(new Problem(myProblem.n-1, myProblem.A, myProblem.C, myProblem.B));            }        }    }}class Problem {    int n;    char A, B, C;    public Problem(int n, char A, char B, char C) {        this.n = n;        this.A = A;        this.B = B;        this.C = C;    }}</code></pre><h3 id="2-特殊汉诺塔：不可以直接从左移到右，必须经过中间"><a href="#2-特殊汉诺塔：不可以直接从左移到右，必须经过中间" class="headerlink" title="2.特殊汉诺塔：不可以直接从左移到右，必须经过中间"></a>2.特殊汉诺塔：不可以直接从左移到右，必须经过中间</h3><p>《左神》14</p><p>法一递归：</p><pre><code class="java">//法一：递归。public static int hanoiProblem1(int num, String left, String mid, String right){    if(num&lt;1){        return 0;    }    return process(num, left, mid, right, left, right);}public static int process(int num, String left, String mid, String right, String from, String to){    if(num==1){        if(from.equals(mid) || to.equals(mid)){            System.out.println(&quot;move 1 from &quot; + from + &quot; to &quot; + to);            return 1;        }        else{            System.out.println(&quot;move 1 from &quot; + from + &quot; to mid&quot;);            System.out.println(&quot;move 1 from mid to &quot; + to);            return 2;        }    }    else{        if(from.equals(mid) || to.equals(mid)){            String another = (from.equals(left)||to.equals(left))? right : left;            int step1 = process(num-1, left, mid, right, from, another);            System.out.println(&quot;move &quot; + num + &quot; from &quot; + from + &quot; to &quot; + to);            int step2 = 1;            int step3 = process(num-1, left, mid, right, another, to);            return step1 + step2 + step3;        }        else{            int step1 = process(num-1, left, mid, right, from, to);            int step2 = 1;            System.out.println(&quot;move &quot; + num + &quot; from &quot; + from + &quot; to mid&quot;);            int step3 = process(num-1, left, mid, right, to, from);            int step4 = 1;            System.out.println(&quot;move &quot; + num + &quot; from mid to &quot; + to);            int step5 = process(num-1, left, mid, right, from, to);            return step1 + step2 + step3 + step4 + step5;        }    }}</code></pre><p>法二：栈。</p><p>非递归的方法核心思想：</p><p>1.由于必须经过中间，把三个柱子想成三个栈，每次操作栈顶的一个元素，只有四个动作L-&gt;M、M-&gt;L、M-&gt;R、R-&gt;M</p><p>2.最优步骤时，每次四个动作只有一个动作能同时满足3、4两个原则，因为满足3、4时直接进行该步骤即可，直到最终第三个栈元素都移过去结束</p><p>3.每次移动元素时，栈顶元素小压大</p><p>4.每次移动元素时，与上一次移动操作不可互逆(那就是重复无意义的操作)</p><pre><code class="java">import java.util.Stack;enum Action{    No, LToM, MToL, RToM, MToR}public class Solution2{    //法二：栈    public static int hanoiProblem2(int num, String left, String mid, String right){        if(num&lt;1){            return 0;        }        Stack&lt;Integer&gt; ls = new Stack&lt;&gt;();        Stack&lt;Integer&gt; ms = new Stack&lt;&gt;();        Stack&lt;Integer&gt; rs = new Stack&lt;&gt;();        ls.push(Integer.MAX_VALUE);        ms.push(Integer.MAX_VALUE);        rs.push(Integer.MAX_VALUE);        for(int i=num; i&gt;=1; i--){            ls.push(i);        }        Action[] record = {Action.No};//record[0]存储上一次操作        int res = 0;        while(rs.size()!=num+1){            res += fstack_To_tStack(record, Action.LToM, Action.MToL, ls, ms, left, mid);            res += fstack_To_tStack(record, Action.MToL, Action.LToM, ms, ls, mid, left);            res += fstack_To_tStack(record, Action.RToM, Action.MToR, rs, ms, right, mid);            res += fstack_To_tStack(record, Action.MToR, Action.RToM, ms, rs, mid, right);        }        return res;    }    private static int fstack_To_tStack(Action[] record, Action nowAct, Action nowActReverse, Stack&lt;Integer&gt;fstack, Stack&lt;Integer&gt;tstack, String from, String to){        if(record[0]!=nowActReverse &amp;&amp; fstack.peek()&lt;tstack.peek()){//和上次操作不互逆 且 栈顶满足小压大，即为当前应该走的一步            tstack.push(fstack.pop());            System.out.println(&quot;move &quot; + tstack.peek() + &quot; from &quot; + from + &quot; to &quot; + to);            record[0] = nowAct;            return 1;        }        return 0;    }    public static void main(String[] args){//        System.out.println(hanoiProblem1(2,&quot;left&quot;, &quot;mid&quot;, &quot;right&quot;));//法一:递归        System.out.println(hanoiProblem2(2,&quot;left&quot;, &quot;mid&quot;, &quot;right&quot;));//法二:栈    }}</code></pre><p><a name="6"></a></p><h2 id="6-构造数组的MaxTree"><a href="#6-构造数组的MaxTree" class="headerlink" title="6.构造数组的MaxTree"></a>6.构造数组的MaxTree</h2><p>leetcode 654、《左神》22</p><p>题目：对于一个没有重复元素的整数数组，请用其中元素构造一棵MaxTree。MaxTree定义为一棵二叉树，其中的节点与数组元素一一对应，同时对于MaxTree的每棵子树，它的根的元素值为子树的最大值。</p><p>思路：现有一建树方法，对于数组中的每个元素，其在树中的父亲为数组中它左边比它大的第一个数和右边比它大的第一个数中更小的一个。若两边都不存在比它大的数，那么它就是树根。请设计O(n)的算法实现这个方法。</p><p>核心转化为了怎么找到左边/右边第一个比它大的数呢？用栈，递减序列即可。</p><p>以找每个数左边第一个比他大的数为例，从左到右遍历每个数，栈中保持递减序列，新来的数不停的Pop出栈顶直到栈顶比新数大或没有数。以[3,1,2]为例，首先3入栈，接下来1比3小，无需pop出3，1入栈，并且确定了1往左第一个比他大的数为3。接下来2比1大，1出栈，2比3小，2入栈。并且确定了2往左第一个比他大的数为3。用同样的方法可以求得每个数往右第一个比他大的数。时间复杂度O(n)，空间复杂度也是O(n)为最优解法。</p><p><strong>本题最巧妙的一点是如何找某数的左边最近的比它大的值和右边最近的比它大的值。取左右两边的较小的数作为该数的父节点。</strong></p><pre><code class="java">import java.util.Stack;class Node{    public int value;    public Node left;    public Node right;    public Node(int data){        this.value = data;    }}public class Solution {    //构造数组的MaxTree。核心:如何找某数的左边最近的比它大的值和右边最近的比它大的值(辅助栈和数组)。取左右两边的较小的数作为该数的父节点。    public static Node makeMaxTree(int[] arr) {        if(arr==null || arr.length==0){            return null;        }        if(arr.length==1){            return new Node(arr[0]);        }        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        int[] lmax = new int[arr.length];//存储找出某数的左边最近的比它大的值的索引        int[] rmax = new int[arr.length];//存储找出某数的右边最近的比它大的值的索引        for(int i=0; i&lt;arr.length; ++i){//从左往右遍历，找出某数的左边最近的比它大的值。栈递减序列            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i]){                stack.pop();            }            lmax[i] = !stack.isEmpty() ? stack.peek() : -1;//左边最近的比它大的值，如果左边没有比它大的，则为-1            stack.push(i);        }        stack.clear();//清空栈        for(int i=arr.length-1; i&gt;=0; --i){//从右往左遍历，找出某数的右边最近的比它大的值。栈递减序列            while(!stack.isEmpty() &amp;&amp; arr[stack.peek()]&lt;arr[i]){                stack.pop();            }            rmax[i] = !stack.isEmpty() ? stack.peek() : -1;//左边最近的比它大的值，如果左边没有比它大的，则为-1            stack.push(i);        }        //两个数组(左边首个最大、右边首个最大)存储好了，取较小的节点作为父节点，开始构建maxTree        Node[] nodes = new Node[arr.length];        for(int i=0; i&lt;nodes.length; ++i){            nodes[i] = new Node(arr[i]);        }        Node head = null;        for(int i=0; i&lt;arr.length; ++i){            if(lmax[i]==-1 &amp;&amp; rmax[i]==-1){                head = nodes[i];            }            else if(lmax[i]==-1 &amp;&amp; rmax[i]!=-1){                if(nodes[rmax[i]].left == null){                    nodes[rmax[i]].left = nodes[i];                }                else{                    nodes[rmax[i]].right = nodes[i];                }            }            else if(rmax[i]==-1 &amp;&amp; lmax[i]!=-1){                if(nodes[lmax[i]].right == null){                    nodes[lmax[i]].right = nodes[i];                }                else{                    nodes[lmax[i]].left = nodes[i];                }            }            else if(arr[lmax[i]]&lt;arr[rmax[i]]){                if(nodes[lmax[i]].right == null){                    nodes[lmax[i]].right = nodes[i];                }                else{                    nodes[lmax[i]].left = nodes[i];                }            }            else if(arr[lmax[i]]&gt;arr[rmax[i]]){                if(nodes[rmax[i]].left == null){                    nodes[rmax[i]].left = nodes[i];                }                else{                    nodes[rmax[i]].right = nodes[i];                }            }        }        return head;    }    public static void main(String[] args){        int[] arr = new int[]{3,1,2};        System.out.println(makeMaxTree(arr));    }}</code></pre><p><a name="7"></a></p><h2 id="7-最大子矩阵-2道-直方图-单调栈"><a href="#7-最大子矩阵-2道-直方图-单调栈" class="headerlink" title="7.最大子矩阵(2道)(直方图-单调栈)"></a>7.最大子矩阵(2道)(直方图-单调栈)</h2><pre><code>1.Largest Rectangle in Histogram(直方图面积)--leetcode 842.Maximal Rectangle(最大子矩阵大小)--leetcode85、《左神》26</code></pre><h3 id="1-Largest-Rectangle-in-Histogram-直方图面积"><a href="#1-Largest-Rectangle-in-Histogram-直方图面积" class="headerlink" title="1.Largest Rectangle in Histogram(直方图面积)"></a>1.Largest Rectangle in Histogram(直方图面积)</h3><p>leetcode 84</p><p>题目：Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. out: 10</p><p>思路：<strong>辅助单调栈，递增存储</strong>。遍历原直方图数组，递增往栈里存储，如果遇到比栈顶小的元素时，循环栈顶弹出并计算resMax，直到继续递增存储。时间o(n)，空间o(n)</p><pre><code class="java">public int largestRectangleArea(int[] heights) {    if(heights==null || heights.length==0){        return 0;    }    if(heights.length==1){        return heights[0];    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断    int resMax = 0;    for(int i=0; i&lt;heights.length; ++i){        while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()]){//每次遇到比栈顶小的元素时，对栈进行判断            int j = stack.pop();            int k = stack.isEmpty() ? -1 : stack.peek();            resMax = Math.max(resMax, (i-k-1)*heights[j]);        }        stack.push(i);//递增存储    }    while(!stack.isEmpty()){//考虑[1,2,3]的情况，栈一直递增存储，最后必须要清空栈        int j = stack.pop();        int k = stack.isEmpty() ? -1 : stack.peek();        resMax = Math.max(resMax, (heights.length-k-1)*heights[j]);    }    return resMax;}</code></pre><h3 id="2-Maximal-Rectangle-最大子矩阵大小"><a href="#2-Maximal-Rectangle-最大子矩阵大小" class="headerlink" title="2.Maximal Rectangle(最大子矩阵大小)"></a>2.Maximal Rectangle(最大子矩阵大小)</h3><p>leetcode85、《左神》26</p><p>题目：Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p><pre><code>1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0Return 6.</code></pre><p>思路：一行一行进行，对矩阵每一行为底的直方图数组求解直方图最大面积，直方图最大面积：用单调递增栈。</p><pre><code class="java">public int maximalRectangle(char[][] matrix) {    if(matrix==null || matrix.length==0){        return 0;    }    int m = matrix.length;    int n = matrix[0].length;    if(n==0){        return 0;    }    int res = 0;    int[] temp = new int[n+1];//以矩阵每一行为底的直方图数组，最后一个元素temp[n]要为0，便于求解直方图面积    for(int i=0; i&lt;m; ++i){//一行一行处理直方图的最大面积        for(int j=0; j&lt;n; ++j){//每一行先更新直方图            if(matrix[i][j] == &#39;0&#39;){                temp[j] = 0;            }else{                temp[j]++;            }        }        res = Math.max(res, largeArea(temp)); //直方图最大面积    }    return res;}//求一行的直方图最大面积--单调递增栈public int largeArea(int[] heights){    if(heights.length==1){        return heights[0];    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();//单调栈，递增存储，每次遇到比栈顶小的元素时，对栈进行判断    int resMax = 0;    for(int i=0; i&lt;heights.length; ++i){        while(!stack.isEmpty() &amp;&amp; heights[i]&lt;heights[stack.peek()]){//每次遇到比栈顶小的元素时，对栈进行判断            int j = stack.pop();            int k = stack.isEmpty() ? -1 : stack.peek();            resMax = Math.max(resMax, (i-k-1)*heights[j]);        }        stack.push(i);//递增存储    }    return resMax;}</code></pre><p><a name="8"></a></p><h2 id="8-找两个排序数组的中位数"><a href="#8-找两个排序数组的中位数" class="headerlink" title="8.找两个排序数组的中位数"></a>8.找两个排序数组的中位数</h2><p>leetcode 4</p><p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p><pre><code class="java">//Median of Two Sorted Arrays找两个排序数组的中位数。思路：二分法，核心是注意怎么二分和边界条件public double findMedianSortedArrays(int[] nums1, int[] nums2) {    int n = nums1.length;    int m = nums2.length;    int left = (n + m + 1) / 2;    int right = (n + m + 2) / 2;    return 0.5 * (getKth(nums1,0,n-1,nums2,0,m-1,left) + getKth(nums1,0,n-1,nums2,0,m-1,right));}private double getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k){    int len1 = end1 - start1 + 1;    int len2 = end2 - start2 + 1;    if(len1 &gt; len2){        return getKth(nums2,start2,end2,nums1,start1,end1,k);    }    if(len1 == 0) return nums2[start2 + k - 1];    if(k == 1) return Math.min(nums1[start1],nums2[start2]);    int s1 = Math.min(start1 + k/2 - 1, start1 + len1 - 1);    int s2 = Math.min(start2 + k/2 - 1, start2 + len2 - 1);//两个数组的k/2位置上的数，如果数组长度小于k/2，直接比len-1上的数    if(nums1[s1] &lt; nums2[s2]){//nums1数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2        return getKth(nums1,s1+1,end1,nums2,start2,end2,k-Math.min(k/2,len1));    }else{//nums2数组的前k/2个数不要了，下次k=k-k/2或者k=k-len1/2        return getKth(nums1,start1,end1,nums2,s2+1,end2,k-Math.min(k/2,len2));    }}</code></pre><p><a name="9"></a></p><h2 id="9-删除链表中的节点-两道"><a href="#9-删除链表中的节点-两道" class="headerlink" title="9. 删除链表中的节点(两道)"></a>9. 删除链表中的节点(两道)</h2><pre><code>1.删除某个链表中指定的（非末尾）节点--leetcode237、《左神》832.删除链表中等于给定值 val 的所有节点--leetcode203</code></pre><h3 id="1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"><a href="#1-删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。" class="headerlink" title="1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。"></a>1.删除某个链表中指定的（非末尾）节点，你将只被给定要求被删除的节点。</h3><p>leetcode237、《左神》83</p><p>思路：后一个节点的val覆盖当前节点，删除后一个节点即可</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public void deleteNode(ListNode node) {        node.val = node.next.val;        node.next = node.next.next;    }}</code></pre><h3 id="2-删除链表中等于给定值-val-的所有节点"><a href="#2-删除链表中等于给定值-val-的所有节点" class="headerlink" title="2.删除链表中等于给定值 val 的所有节点"></a>2.删除链表中等于给定值 val 的所有节点</h3><p>leetcode203、《左神》73</p><pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre><p>思路：遍历链表删除即可。</p><pre><code class="java">public ListNode removeElements(ListNode head, int val){    if(head==null){        return null;    }    ListNode resHead = new ListNode(0); //哨兵    resHead.next = head;    ListNode p = resHead;    ListNode cur = p.next;    while(cur!=null){        if(cur.val==val){            p.next = cur.next;//这种删除思想特别好        }        else{            p = cur;        }        cur = cur.next;    }    return resHead.next;}</code></pre><p><a name="10"></a></p><h2 id="10-找到-删除链表的中间节点-两道"><a href="#10-找到-删除链表的中间节点-两道" class="headerlink" title="10.找到/删除链表的中间节点(两道)"></a>10.找到/删除链表的中间节点(两道)</h2><pre><code>1.找到链表的中间节点--leetcode 8762.删除链表的中间节点--《左神》38</code></pre><h3 id="1-找到链表的中间节点"><a href="#1-找到链表的中间节点" class="headerlink" title="1.找到链表的中间节点"></a>1.找到链表的中间节点</h3><p>leetcode 876</p><p>题目：Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p><p>If there are two middle nodes, return the second middle node.</p><pre><code>Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3. [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])</code></pre><p>思路：两个指快慢指针走即可。</p><pre><code class="java">public ListNode middleNode(ListNode head) {    if(head.next==null){        return head;    }    ListNode right = head;    ListNode left = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    return right.next==null ? left : left.next;}</code></pre><h3 id="2-删除链表的中间节点"><a href="#2-删除链表的中间节点" class="headerlink" title="2.删除链表的中间节点"></a>2.删除链表的中间节点</h3><p>《左神》38.</p><p>题目：删除一个链表的中间节点，当链表只有一个节点的时候或者head节点为空的时候返回head，当链表有两个节点的时候删除第一个节点，当链表有三个节点的时候删除第二个节点，当链表有四个节点的时候删除第二个节点，当链表有五个节点的时候删除第三个节点…</p><p>思路：一个链表长度每增加二，要删除的节点就后移一个节点，要删除一个节点需要知道它的前一个节点。</p><pre><code class="java">//删除链表中间节点。思路：两个快慢指针走即可public static ListNode removeMidNode(ListNode head){    if(head==null || head.next==null){//空节点或只有一个节点        return head;    }    if(head.next.next==null){//两个节点，删除第一个节点        head = head.next;        return head;    }    ListNode right = head.next.next;    ListNode left = head;//要删除节点的上一个节点    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    left.next = left.next.next;//删除中间节点    return head;}</code></pre><p><a name="11"></a></p><h2 id="11-删除链表a-b处的节点"><a href="#11-删除链表a-b处的节点" class="headerlink" title="11.删除链表a/b处的节点"></a>11.删除链表a/b处的节点</h2><p>《左神》38.</p><p>题目：给两个整数a，b(a&lt;=b)，实现删除链表a/b处节点的函数。若r=0，不删除；其他r的值向上取整，比如r在范围(2/5,3/5]中，取3，删除第三个节点。</p><p>思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点</p><pre><code class="java">//删除链表a/b处的节点。思路：1.一次遍历求链表长度；2.求删第几个(向上取整);3.删除r节点public static ListNode removeByRatio(ListNode head, int a, int b){    if(a==0 || b==0 || a==b || head==null){//不删除任何节点        return head;    }    //1.遍历链表，得其长度len    ListNode p = head;    int len = 0;    while(p!=null){        len++;        p = p.next;    }    //2.计算a/b处是第k个节点    int k = (int)Math.ceil( ((double)a/b)*len );    if(k&lt;0){//a/b为负数，不删除节点        return head;    }    //3.删除第k个节点    if(k==1){        head = head.next;        return head;    }    p = head;//从头遍历    while(k!=2){//走到第k-1处        p = p.next;        k--;    }    p.next = p.next.next;//删除第k个节点    return head;}</code></pre><p><a name="12"></a></p><h2 id="12-判断一个链表是否为回文结构"><a href="#12-判断一个链表是否为回文结构" class="headerlink" title="12.判断一个链表是否为回文结构"></a>12.判断一个链表是否为回文结构</h2><p>《左神》48、leetcode234</p><p>题目：判断一个链表是否为回文链表(1\121\1221)，要求时间o(n)，空间o(1)</p><p>思路：由于要求时间o(n)，空间o(1)，感觉必须要动链表了。1.先找到中间节点，2.然后右半边逆序，3.然后分别从头部和中间开始比较元素是否相等即可。时间o(n)，空间o(1)。</p><pre><code class="java">//判断一个链表是否为回文结构。思路：1.两个快慢指针先找到中间节点，2.然后右半边链表逆序，3.再从头遍历比较元素是否相等public boolean isPalindrome(ListNode head) {    if(head==null || head.next==null){        return true;    }    //2.两个快慢指针先找到中间节点    ListNode left = head;    ListNode right = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        right = right.next.next;        left = left.next;    }    //2.现将left后边的链表逆序    ListNode cur = left.next;    ListNode temp = cur;    cur = cur.next;    temp.next = null;    while(cur!=null){        temp = cur;        cur = cur.next;        temp.next = left.next;        left.next = temp;    }    //3.从头遍历比较元素是否相等    right = left.next;    left = head;    while(right!=null){        if(left.val!=right.val){//遇到元素不等，不是回文结构，false            return false;        }        left = left.next;        right = right.next;    }    return true;}public static void main(String[] args){    ListNode head = new ListNode(1);    head.next = new ListNode(2);    head.next.next = new ListNode(3);    head.next.next.next = new ListNode(3);    head.next.next.next.next = new ListNode(2);    head.next.next.next.next.next = new ListNode(1);    System.out.println(isPalindrome(head));//true}</code></pre><p><a name="13"></a></p><h2 id="13-将单向链表按某值划分成左边小，中间相等，右边大"><a href="#13-将单向链表按某值划分成左边小，中间相等，右边大" class="headerlink" title="13.将单向链表按某值划分成左边小，中间相等，右边大"></a>13.将单向链表按某值划分成左边小，中间相等，右边大</h2><p>《左神》52.</p><p>题目：给定一个单向链表的头结点head,节点的值类型是整型，再给定一个整数privot。实现一个调整链表的函数，将链表调整为左部分都是值小于privot的节点，中间部分都是值等于privot的节点，右部分都是大于privot的节点。<br>例如:链表9-0-4-5-1，pivot=3。<br>调整后是1-0-4-9-5，也可以是0-1-9-5-4。 </p><p>思路：解法一：我们可以利用数组额外空间，利用数组partition排序来实现。时间o(n) 空间o(n)</p><pre><code>​1. 先遍历一遍链表，得到链表长度。​2. 建立一个链表数组。​3. 利用三向快排的划分​4. 调整数组中的next值。​</code></pre><p>解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可。时间o(n) 空间o(1)</p><pre><code class="java">class Node {    public int val;    public Node next;    public Node(int x) {        val = x;        this.next = null;    }}public class Solution2 {    //解法一：我们可以利用数组额外空间来实现    //时间o(n) 空间o(n)    //1. 先遍历一遍链表，得到链表长度。    //2. 建立一个链表数组。    //3. 利用三向快排的划分    //4. 调整数组中的next值。    public static Node listPartition1(Node head, int privot){        if(head==null || head.next==null){            return head;        }        //1.遍历链表得到长度。        int len = 0;        Node p = head;        while(p!=null){            len++;            p = p.next;        }        //2.建立一个链表数组。        Node[] arr = new Node[len];        p = head;        for(int i=0; i&lt;len; ++i){            arr[i] = p;            p = p.next;        }        //3.数组partition排序        paitition(arr, 0, len-1, privot);        //4.重新连接数组的node        for(int i=0; i&lt;len-1; ++i){            arr[i].next = arr[i+1];        }        arr[len-1].next = null;        return arr[0];    }    public static void paitition(Node[] arr, int left, int right, int privot){        //注意的这里的partition保持了数组原来的顺序        int small = left;        int big = right;        for(int i=left; i&lt;=right&amp;&amp;i&lt;=big; ++i){            if(arr[i].val&lt;privot){                swap(arr, i, small++);            }            else if(arr[i].val&gt;privot){                swap(arr, i, big--);            }        }        while(big&lt;right){            swap(arr, big++, right--);        }    }    //解法二：遍历链表，拆分三个链表small, equal, big表头，最后再连接即可    //时间o(n) 空间o(1)    public static Node listPartition2(Node head, int privot){        if(head==null || head.next==null){            return head;        }        Node small = new Node(0);        Node smallCopy = small;        Node equal = new Node(0);        Node equalCopy = equal;        Node big = new Node(0);        Node bigCopy = big;        Node p = head;        while(p!=null){//遍历链表            if(p.val&lt;privot){                Node temp = p;                p = p.next;                temp.next = null;                small.next = temp;                small = temp;            }            else if(p.val == privot){                Node temp = p;                p = p.next;                temp.next = null;                equal.next = temp;                equal = temp;            }            else{                Node temp = p;                p = p.next;                temp.next = null;                big.next = temp;                big = temp;            }        }        small.next = equalCopy.next;        equal.next = bigCopy.next;        return smallCopy.next;    }    public static void main(String[] args){        Node head = new Node(9);        Node p = head;        p.next = new Node(0);        p = p.next;        p.next = new Node(3);        p = p.next;        p.next = new Node(4);        p = p.next;        p.next = new Node(5);        p = p.next;        p.next = new Node(1);        show(head);//        head = listPartition1(head, 3);        head = listPartition2(head, 3);        System.out.println();        show(head);    }    public static void show(Node head){        while(head!=null){            System.out.print(head.val + &quot; &quot;);            head = head.next;        }    }    public static void swap(Node[] arr, int i, int j){        Node temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}//out: 9 0 3 4 5 1        0 1 3 9 4 5 </code></pre><p><a name="14"></a></p><h2 id="14-单链表的归并排序"><a href="#14-单链表的归并排序" class="headerlink" title="14.单链表的归并排序"></a>14.单链表的归并排序</h2><p>leetcode148</p><p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p><p>思路：归并排序应该是单链表排序最好的方法了，时间o(nlogn)，空间o(1)。分而治之，先找到中间节点，拆分成两个链表，merge</p><pre><code class="java">public static ListNode sortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode left = head;    ListNode right = head;    while(right.next!=null &amp;&amp; right.next.next!=null){        left = left.next;        right = right.next.next;    }    right = left.next;    left.next = null;//将链表从中间节点拆分，分离成两个链表    left = sortList(head);    right = sortList(right);    return merge(left, right);}public static ListNode merge(ListNode l1, ListNode l2){    ListNode guard = new ListNode(0);    ListNode p = guard;    ListNode temp;    while(l1!=null &amp;&amp; l2!=null){        if(l1.val&lt;=l2.val){            temp = l1;            l1 = l1.next;        }        else{            temp = l2;            l2 = l2.next;        }        temp.next = null;        p.next = temp;        p = p.next;    }    if(l1!=null){        p.next = l1;    }    if(l2!=null){        p.next = l2;    }    return guard.next;}public static void show(ListNode head){    while(head!=null){        System.out.print(head.val + &quot; &quot;);        head = head.next;    }    System.out.println();}public static void main(String[] args){    ListNode head = new ListNode(1);    head.next = new ListNode(2);    head.next.next = new ListNode(5);    head.next.next.next = new ListNode(4);    head.next.next.next.next = new ListNode(7);    show(head);    show(sortList(head));    //out:1 2 5 4 7    //    1 2 4 5 7}</code></pre><p><a name="15"></a></p><h2 id="15-单链表的快速排序"><a href="#15-单链表的快速排序" class="headerlink" title="15.单链表的快速排序"></a>15.单链表的快速排序</h2><p>leetcode148</p><p>题目：Sort a linked list in O(n log n) time using constant space complexity.</p><pre><code>Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4</code></pre><p>思路：partition思想，用三个指针来控制，pBase指针指向枢纽值结点，pleft指针指向当前最后一个比枢纽值小的结点，pright结点用于遍历，将遇到的比pBase小的结点的值交换到前面去。<br>​<br><img src="https://img-blog.csdnimg.cn/20200215151042325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="ListquickSort"></p><pre><code class="java">//单链表的快排public ListNode sortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode tail = head;    while(tail.next!=null){        tail = tail.next;    }    quickSortList(head, tail);    return head;}public void quickSortList(ListNode head, ListNode tail){    if(head==tail || head==null || tail==null){        return;    }    ListNode pBase = head; //基准key节点    ListNode pSmall = head; //此节点之前的节点都是比pBase小的    ListNode cur = head.next; //遍历节点    while(cur!=tail.next){        if(cur.val&lt;pBase.val){            pSmall = pSmall.next;            swap(pSmall, cur);        }        cur = cur.next;    }    swap(pBase, pSmall);    quickSortList(head, pSmall);    quickSortList(pSmall.next, tail);}public void swap(ListNode a, ListNode b){    int temp = a.val;    a.val = b.val;    b.val = temp;}</code></pre><p><a name="16"></a></p><h2 id="16-单链表的选择排序"><a href="#16-单链表的选择排序" class="headerlink" title="16.单链表的选择排序"></a>16.单链表的选择排序</h2><p>《左神》79、和88题(单链表快排)一起看</p><p>题目：单链表的选择排序</p><p>思想：时间o(n^2)，空间o(1)，正常的选择排序思想，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，接入到排序好的链表部分，这里注意节点的断开与接入的指针变量操作</p><pre><code class="java">//单链表的选择排序。时间o(n^2)public static ListNode selectSortList(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode resHeadCopy = new ListNode(0); //哨兵，最终返回resHeadCopy.next    ListNode resHead = resHeadCopy; //存储排序链表的最后一个节点    while(head.next!=null){//选择排序，每次都从剩下链表头结点遍历，选出剩下链表中最小的节点，连接到resHead后        ListNode minTemp = head;        ListNode minPre=null;        ListNode cur = head.next;//遍历剩下链表        ListNode curPre = head;        while(cur!=null){//每次都从剩下链表头结点遍历，找剩下链表中最小节点            if(cur.val&lt;minTemp.val){                minTemp = cur;                minPre = curPre;            }            curPre = cur;            cur = cur.next;        }        ListNode temp = minTemp;//这是找到的min节点        if(temp==head){//如果min节点是头结点            head = head.next;//断开min节点        }        else{            minPre.next = minPre.next.next; //断开min节点        }        temp.next = null;//断开min节点        resHead.next = temp;//min节点连入排序链表尾        resHead = temp;    }    resHead.next = head; //链表剩下最后一个节点接入    return resHeadCopy.next;}</code></pre><p><a name="17"></a></p><h2 id="17-两个链表生成相加链表"><a href="#17-两个链表生成相加链表" class="headerlink" title="17.两个链表生成相加链表"></a>17.两个链表生成相加链表</h2><p>《左神》59、leetcode 2</p><p>题目：You are given two non-empty linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><pre><code>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807.</code></pre><p>思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位，注意如果最后还有进位，别忘了再生成一个节点</p><pre><code class="java">//两个链表生成相加链表。思路：遍历两个链表，每个节点相加放进新建链表即可，有个cnt变量记录进位public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    ListNode guard = new ListNode(0);    ListNode p = guard;    int cnt = 0;//进位    int sum;//每两个节点的和    while(l1!=null &amp;&amp; l2!=null){        sum = l1.val + l2.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l1 = l1.next;        l2 = l2.next;    }    while(l1!=null){        sum = l1.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l1 = l1.next;    }    while(l2!=null){        sum = l2.val + cnt;        cnt = sum/10;        p.next = new ListNode(sum%10);        p = p.next;        l2 = l2.next;    }    if(cnt!=0){//如果还有进位，则再创建一个节点        p.next = new ListNode(1);    }    return guard.next;}</code></pre><p><a name="18"></a></p><h2 id="18-删除单链表的重复节点-三道"><a href="#18-删除单链表的重复节点-三道" class="headerlink" title="18.删除单链表的重复节点(三道)"></a>18.删除单链表的重复节点(三道)</h2><h3 id="1-链表有序，保留一个"><a href="#1-链表有序，保留一个" class="headerlink" title="1.链表有序，保留一个"></a>1.链表有序，保留一个</h3><p>leetcode 83</p><p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p><pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>思路：时间o(n)，空间o(1)，遍历删除即可</p><pre><code class="java">public static ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode p = head;    ListNode cur = head.next;    while(cur!=null){        if(p.val==cur.val){            p.next = cur.next;        }        else{            p = cur;        }        cur = cur.next;    }    return head;}</code></pre><h2 id="2-链表有序，不保留"><a href="#2-链表有序，不保留" class="headerlink" title="2.链表有序，不保留"></a>2.链表有序，不保留</h2><p>leetcode 82</p><p>题目：Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p><p>Example 1:</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5</code></pre><p>思路：定义一个哨兵，定义一个前驱指针和一个现指针，每当前驱指针指向新建的节点，现指针从下一个位置开始往下遍历，遇到相同的则继续往下，直到遇到不同项时，把前驱指针的next指向下面那个不同的元素。如果现指针遍历的第一个元素就不相同，则把前驱指针向下移一位。</p><p>代码：</p><pre><code class="java">public ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode pre = guard;//前驱指针    ListNode cur = guard.next;    while(cur!=null){        if(cur.next!=null &amp;&amp; cur.next.val==cur.val){//有重复，要准备删除了            int temp = cur.val;//缓存要删除的val            while(cur!=null &amp;&amp; cur.val==temp){                cur = cur.next;            }            pre.next = cur;        }        else{            pre = cur;            cur = cur.next;        }    }    return guard.next;}</code></pre><h3 id="3-链表无序"><a href="#3-链表无序" class="headerlink" title="3.链表无序"></a>3.链表无序</h3><p>《左神》71</p><p>题目：Given a sorted linked list, delete all duplicates such that each element appear only once. </p><pre><code>Input: 1-&gt;2-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>思路：哈希set。时间o(n)，空间o(n)</p><pre><code class="java">public static void deleteDuplicate(ListNode head){    if(head==null || head.next==null){        return;    }    HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();//哈希表    ListNode p = head;    ListNode cur = head.next;    set.add(p.val);    while(cur!=null){        if(set.contains(cur.val)){            p.next = cur.next;        }        else{            set.add(cur.val);            p = cur;        }        cur = cur.next;    }}</code></pre><p><a name="19"></a></p><h2 id="19-向有序的环形单链表中插入新节点"><a href="#19-向有序的环形单链表中插入新节点" class="headerlink" title="19.向有序的环形单链表中插入新节点"></a>19.向有序的环形单链表中插入新节点</h2><p>《左神》82</p><p>题目：一个环形单链表从头节点 head 开始不降序，同时由最后的节点指回头节点。给定这样的一个环形单链表的头节点 head 和 一个整数 num ，请生成节点值为 num 的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。</p><p>思路：直接从头结点遍历插入即可，时间复杂度为 O(N)、额外空间复杂度为 O(1)。</p><pre><code class="java">//环形有序链表中插入新节点public static ListNode insertNum(ListNode head, int num){    ListNode newNode = new ListNode(num);    if(head==null){        newNode.next = newNode;        return newNode;    }    ListNode cur = head;    if(num &lt;= head.val){//如果要插入到头结点之前        while(cur.next!=head){            cur = cur.next;        }        newNode.next = head;        cur.next = newNode;        head = newNode;    }    else{        while(true){            if(cur.next.val&gt;=num){                newNode.next = cur.next;                cur.next = newNode;                break;            }            cur = cur.next;        }    }    return head;}</code></pre><p><a name="20"></a></p><h2 id="20-打印二叉树的边界节点"><a href="#20-打印二叉树的边界节点" class="headerlink" title="20.打印二叉树的边界节点"></a>20.打印二叉树的边界节点</h2><p>《左神》95、 leetcode545(会员)</p><p>题目：给定一颗二叉树的头结点head,按照如下两种标准分别实现二叉树边界节点的逆时针打印。</p><pre><code>1.头节点为边界节点2.叶结点为边界节点3.如果节点在其所在的层中是最左边或最右边，那么也是边界节点</code></pre><p><a name="21"></a></p><h2 id="21-编辑距离"><a href="#21-编辑距离" class="headerlink" title="21.编辑距离"></a>21.编辑距离</h2><p>leetcode 72</p><p>题目：Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.You have the following 3 operations permitted on a word:</p><pre><code>Insert a characterDelete a characterReplace a characte</code></pre><p>Example 1:</p><pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;Output: 3Explanation: horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)rorse -&gt; rose (remove &#39;r&#39;)rose -&gt; ros (remove &#39;e&#39;)Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;Output: 5Explanation: intention -&gt; inention (remove &#39;t&#39;)inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)exection -&gt; execution (insert &#39;u&#39;)</code></pre><p>思路：DP问题。维护一个二维的数组dp，其中dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤。那我们可以先给这个二维数组dp的第一行第一列赋值，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤完全是另一个字符串的长度。</p><p>转移方程：当word1[i]==word2[j]时，dp[i][j] = dp[i-1][j-1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1。</p><pre><code>if word1[i-1]==word2[j-1]：    dp[i][j] = dp[i - 1][j - 1]else:     dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 //替换、删除、插入   </code></pre><p>代码：   </p><pre><code class="java">public int minDistance(String word1, String word2) {    if(word1==null || word2==null){        return 0;    }    int len1 = word1.length();    int len2 = word2.length();    int[][] dp = new int[len1+1][len2+1];    for (int i=0; i&lt;=len2; ++i){//第一行        dp[0][i] = i;    }    for (int i=0; i&lt;=len1; ++i){//第一列        dp[i][0] = i;    }    for(int i=1; i&lt;=len1; ++i){        for (int j=1; j&lt;=len2; ++j){            if(word1.charAt(i-1) == word2.charAt(j-1)){                dp[i][j] = dp[i-1][j-1];            }            else{                dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1;            }        }    }    return dp[len1][len2];}public int min(int a, int b, int c){    int temp = Math.min(a,b);    return Math.min(temp,c);}</code></pre><p><a name="22"></a></p><h2 id="22-找出数组中左边比他小右边比他大的所有元素"><a href="#22-找出数组中左边比他小右边比他大的所有元素" class="headerlink" title="22.找出数组中左边比他小右边比他大的所有元素"></a>22.找出数组中左边比他小右边比他大的所有元素</h2><p>题目：给定一个不重复的数组，找出所有符合条件的元素：该元素左边都比它小，右边都比它大。e.g. [1,2,3,4,5]–&gt;out:[1,2,3,4,5]所有元素都满足。时间要求o(n)</p><p>思路：<strong>辅助一个o(n)数组temp[]，遍历两次数组即可</strong>。第一次从后往前记录temp[]，temp[i]表示从结尾到i时最小的数，第二次遍历从前往后，tempMax存从头到i时最大的数，如果nums[i]比tempMax大且比temp[i]小则nums[i]符合条件。</p><pre><code class="java">//找出数组中左边比他小右边比他大的所有元素。思路：辅助o(n)的temp[]，遍历两遍数组即可public static ArrayList&lt;Integer&gt; findEleBigLeftSmallRight(int[] numbers){    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(numbers==null || numbers.length==0){        return res;    }    int len = numbers.length;    if(len==1){//只有一个节点时直接返回该节点，无需比较        res.add(numbers[0]);        return res;    }    //1.从后往前遍历，存最小的数    int[] temp = new int[len];//辅助数组    temp[len-1] = numbers[len-1];    for(int i=len-2; i&gt;=0; --i){        temp[i] = numbers[i]&lt;temp[i+1] ? numbers[i] : temp[i+1];    }    //2.从前往后遍历，找符合条件的数    int tempMax = Integer.MIN_VALUE;//存最大的数    for(int i=0; i&lt;len-1; ++i){        if(numbers[i]&gt;tempMax &amp;&amp; numbers[i]&lt;temp[i+1]){            res.add(numbers[i]);//符合条件        }        if(numbers[i]&gt;tempMax){            tempMax = numbers[i];        }    }    if(numbers[len-1]&gt;tempMax){//最后一个数        res.add(numbers[len-1]);    }    return res;}</code></pre><p><a name="23"></a></p><h2 id="23-判断二叉树为BST-二叉搜索树"><a href="#23-判断二叉树为BST-二叉搜索树" class="headerlink" title="23.判断二叉树为BST(二叉搜索树)"></a>23.判断二叉树为BST(二叉搜索树)</h2><p>leetcode 98</p><p>题目：判断二叉树为BST(二叉搜索树)</p><p>思路：中序遍历判断且使用全局变量记录前继节点的值</p><p>代码：</p><pre><code class="java">private Long last = Long.MIN_VALUE;//全局变量记录前继节点的值//中序遍历判断public boolean isValidBST(TreeNode root) {    if(root==null){        return true;    }        if(!isValidBST(root.left)){        return false;    }    if(root.val&lt;=last){        return false;    }    last = Long.valueOf(root.val);    return isValidBST(root.right);}</code></pre><p><a name="24"></a></p><h2 id="24-Replace-Words-字典树应用"><a href="#24-Replace-Words-字典树应用" class="headerlink" title="24.Replace Words(字典树应用)"></a>24.Replace Words(字典树应用)</h2><p>leetcode 648</p><p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p>Example 1:</p><pre><code>Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot;Note:The input will only have lower-case letters.1 &lt;= dict words number &lt;= 10001 &lt;= sentence words number &lt;= 10001 &lt;= root length &lt;= 1001 &lt;= sentence words length &lt;= 1000</code></pre><p>题目大意：给定一个字典，里面是词根root，给定一句话，如果这句话的单词前缀是字典中词根，则将单词用词根替换，如果有多个词根，找最短的词根替换，最后返回替换好的话</p><p>思路1(不可取)：暴力替换。将这句话split成words[]单词组，将每个单词从前往后字符组的依次与hash字典中的词根比较，如果出现就替换。时间o(nk),n这句话，k字典，空间辅助hash o(k)。时间效率很低</p><pre><code class="java">public String replaceWords(List&lt;String&gt; dict, String sentence) {    HashSet&lt;String&gt; set = new HashSet&lt;&gt;(dict);    String[] words = sentence.split(&quot; &quot;);    StringBuilder sb = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        for(int j=1; j&lt;words[i].length(); ++j){            String root = words[i].substring(0,j);            if(set.contains(root)){                words[i] = root;                break;            }        }        sb.append(words[i] + &quot; &quot;);    }    return sb.toString().trim();}</code></pre><p>思路2(可取，但还是不够好)：不暴力替换，采用了字典树的思想。1.字典的roots词根用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组;2.将这句话split成words[]单词组，遍历words单词数组，一个单词一个单词的在字典树中替换，最后返回替换好的话。时间o(n)，空间o(k),n是原句子，k是字典</p><pre><code class="java">//思路：字典树思想。将字典中的词根按照首字母构建字典public String replaceWords(List&lt;String&gt; dict, String sentence) {    HashSet[] set = new HashSet[26];//字典树，用首字母索引，首字母相同的前缀都放到同一个HashSet中，总共需要26个索引数组    String[] words = sentence.split(&quot; &quot;);    StringBuilder sb = new StringBuilder();    //1.构建字典树,26个字母开头索引    for(int i=0; i&lt;dict.size(); ++i){        String word = dict.get(i);        int wordIndex =  word.charAt(0)-&#39;a&#39;;        if(set[wordIndex]==null){            set[wordIndex] = new HashSet&lt;String&gt;();        }        set[wordIndex].add(word);    }    //2.遍历words单词数组，一个单词一个单词的在字典树中替换    for(int i=0; i&lt;words.length; ++i){        int wordIndex = words[i].charAt(0)-&#39;a&#39;;        if(set[wordIndex]==null){//这个单词在字典树中没有首字母索引，即也没有词根对应，continue            sb.append(words[i] + &quot; &quot;);            continue;        }        Iterator&lt;String&gt; iterator = set[wordIndex].iterator();        while(iterator.hasNext()) {            String root = iterator.next();            if (words[i].startsWith(root) &amp;&amp; root.length() &lt; words[i].length()) {//找最短的词根替换                words[i] = root;            }        }        sb.append(words[i] + &quot; &quot;);//替换好的单词加入到新话中    }    return sb.toString().trim();}</code></pre><p>思路3(高效字典树，棒):思路2只是很简单用首字母进行索引实现字典树，但还是不够，应该使用字典树(也叫前缀树)实现高效查询。</p><pre><code class="java">//字典树节点class TrieNode{    char c;    TrieNode[] children = new TrieNode[26];    boolean isComplete = false;    public TrieNode(char c){        this.c = c;    }}class Solution {    //思路：构建字典树。    public String replaceWords(List&lt;String&gt; dict, String sentence) {        if(sentence==null || sentence.length()&lt;2 || dict==null || dict.size()==0){            return sentence;        }        //1.遍历字典中的词根，构建字典树        TrieNode root = new TrieNode(&#39;c&#39;);//字典树的根节点        for(String dictWord: dict){//遍历字典中的词根            char[] chs = dictWord.toCharArray();            TrieNode temp = root;            for(char c: chs){//对每个词根进行字典树构建                if(temp.children[c-&#39;a&#39;]==null){                    temp.children[c-&#39;a&#39;] = new TrieNode(c);                }                temp = temp.children[c-&#39;a&#39;];            }            temp.isComplete = true;//一个词根构建完，标记位置为true        }        //2.遍历原话的words[]单词数组，对每个单词进行字典树替换        StringBuilder sb = new StringBuilder();        String[] words = sentence.split(&quot; &quot;);        for(int i=0; i&lt;words.length; ++i){//遍历原单词数组words[]            TrieNode temp = root;            StringBuilder tempSb = new StringBuilder();            boolean can_change = false;//是否找到一个可以替换的词根            for(char ch: words[i].toCharArray()){                if(temp.children[ch-&#39;a&#39;]==null){//当前字符在字典树中没有索引                    break;                }                tempSb.append(ch);                temp = temp.children[ch-&#39;a&#39;];                if(temp.isComplete==true){//找到了当前单词对应的一个词根                    can_change = true;                    break;                }            }            if(can_change){//将单词替换成词根                sb.append(tempSb.toString() + &quot; &quot;);            }            else{//没有对应的词根，单词不变                sb.append(words[i] + &quot; &quot;);            }        }        return sb.toString().trim();    }}</code></pre><p><a name="25"></a></p><h2 id="25-BFS-DFS思想"><a href="#25-BFS-DFS思想" class="headerlink" title="25.BFS/DFS思想"></a>25.BFS/DFS思想</h2><p>参考：<a href="https://www.cnblogs.com/developerY/p/3323264.html" target="_blank" rel="noopener">LeoYang<br>Coding and learning<br>BFS和DFS详解以及java实现</a></p><p>总的来说，BFS多用于寻找最短路径的问题，DFS多用于快速发现底部节点。</p><h3 id="BFS广度优先搜索-遍历"><a href="#BFS广度优先搜索-遍历" class="headerlink" title="BFS广度优先搜索/遍历"></a>BFS广度优先搜索/遍历</h3><p>BFS主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对A再加1，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问），而对于连通图来说，每个顶点都会被访问。加上每个顶点的邻接链表都会被遍历，因此<strong>BFS的时间复杂度是O（V+E</strong>），其中V是顶点个数，E是边数，也就是所有邻接表中的元素个数。</p><h3 id="DFS深度优先搜索-遍历"><a href="#DFS深度优先搜索-遍历" class="headerlink" title="DFS深度优先搜索/遍历"></a>DFS深度优先搜索/遍历</h3><p>DFS深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。</p><p><a name="26"></a></p><h2 id="26-BFS相关题目-1道"><a href="#26-BFS相关题目-1道" class="headerlink" title="26.BFS相关题目(1道)"></a>26.BFS相关题目(1道)</h2><h3 id="BFS相关题目-1-01-Matrix"><a href="#BFS相关题目-1-01-Matrix" class="headerlink" title="BFS相关题目_1.01 Matrix"></a>BFS相关题目_1.01 Matrix</h3><p>leetcode 542</p><p>题目：Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.</p><pre><code>Example 1: Input:0 0 00 1 00 0 0Output:0 0 00 1 00 0 0Example 2: Input:0 0 00 1 01 1 1Output:0 0 00 1 01 2 1Note:The number of elements of the given matrix will not exceed 10,000.There are at least one 0 in the given matrix.The cells are adjacent in only four directions: up, down, left and right.</code></pre><p>思路：BFS。这道题给了我们一个只有0和1的矩阵，让我们求每一个1到离其最近的0的距离，其实也就是求一个距离场，而求距离场那么BFS将是不二之选。</p><pre><code>1.首先遍历一次矩阵，将值为0的点都存入queue，将值为1的点换成MAX_VALUE;2.对队列中的每一个0进行BFS上下左右搜索:从queue中取出一个数字，遍历其周围四个点，如果越界或者周围点的值小于等于当前值加1，则直接跳过;否则将周围点的值更新为当前值加1，然后把周围点的坐标加入queue</code></pre><p>代码：</p><pre><code class="java">public int[][] updateMatrix(int[][] matrix) {    if(matrix==null || matrix.length==0 || matrix[0].length==0){        return matrix;    }    int m = matrix.length;    int n = matrix[0].length;    //1.把原矩阵中1换成MAX_VALUE; 2.把0全部放进队列    Queue&lt;Pair&lt;Integer,Integer&gt; &gt; queue = new LinkedList&lt;&gt;();    for(int i=0; i&lt;m; ++i){        for (int j=0; j&lt;n; ++j){            if(matrix[i][j]==0){                queue.offer(new Pair&lt;&gt;(i, j));            }            else{                matrix[i][j] = Integer.MAX_VALUE;            }        }    }    //3.对队列中的每一个0进行BFS上下左右搜索    int[][] dirs = new int[][]{{1,0}, {-1,0}, {0,-1}, {0,1}}; //上下左右    while(!queue.isEmpty()){        Pair&lt;Integer, Integer&gt; origin = queue.poll();        for(int i=0; i&lt;4; ++i){            int x = origin.getKey() + dirs[i][0];            int y = origin.getValue() + dirs[i][1];            if(x&lt;0 || x&gt;=m || y&lt;0 || y&gt;=n || matrix[x][y]&lt;=( matrix[origin.getKey()][origin.getValue()]+1 ) ){                continue;            }            matrix[x][y] = matrix[origin.getKey()][origin.getValue()]+1;            queue.offer(new Pair&lt;&gt;(x, y));//BFS入队别忘了        }    }    return matrix;}</code></pre><p><a name="27"></a></p><h2 id="27-DFS相关题目-4道"><a href="#27-DFS相关题目-4道" class="headerlink" title="27.DFS相关题目(4道)"></a>27.DFS相关题目(4道)</h2><h3 id="DFS相关题目-1-Number-of-Islands"><a href="#DFS相关题目-1-Number-of-Islands" class="headerlink" title="DFS相关题目_1.Number of Islands"></a>DFS相关题目_1.Number of Islands</h3><p>leetcode 200</p><p>题目：Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><pre><code>Example 1:Input:11110110101100000000Output: 1</code></pre><p>思路：找岛屿的个数。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索，计数器加1</p><p>代码：</p><pre><code class="java">public int numIslands(char[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int res = 0;    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==&#39;1&#39;){//找到一个岛屿                dfs(grid, m, n, i, j);//对该岛屿进行dfs搜索土地，并将岛屿的全部土地变为&#39;0&#39;已访问                res++;            }        }    }    return res;}public void dfs(char[][] grid, int m, int n, int i, int j){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==&#39;0&#39;){        return;    }    grid[i][j] = &#39;0&#39;;//标记为已访问    dfs(grid, m , n, i-1, j);    dfs(grid, m , n, i+1, j);    dfs(grid, m , n, i, j-1);    dfs(grid, m , n, i, j+1);//上下左右}</code></pre><h3 id="DFS相关题目-2-Max-Area-of-Island"><a href="#DFS相关题目-2-Max-Area-of-Island" class="headerlink" title="DFS相关题目_2.Max Area of Island"></a>DFS相关题目_2.Max Area of Island</h3><p>leetcode 695</p><p>题目：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p><pre><code>Example 1:[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.(斜着的不算)</code></pre><p>思路：在很多岛屿中，返回最大岛屿面积。思路：dfs,找到图中值为1的点，分别从上、下、左、右四个方向搜索。搜索过的‘1’就置为‘0’，每完成一整片陆地的搜索并计算面积。</p><p>代码：</p><pre><code class="java">public int maxAreaOfIsland(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int resMax = 0;    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==1){//找到一个岛屿                int[] tempMax = new int[]{0};//计算当前岛屿的面积                dfs(grid, m, n, i, j, tempMax);//对该岛屿进行dfs搜索土地并计算面积，并将岛屿的全部土地变为&#39;0&#39;已访问                resMax = Math.max(resMax, tempMax[0]);            }        }    }    return resMax;}public void dfs(int[][] grid, int m, int n, int i, int j, int[] tempMax){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==0){        return;    }    grid[i][j] = 0;//标记为已访问    tempMax[0]++;    dfs(grid, m , n, i-1, j, tempMax);    dfs(grid, m , n, i+1, j, tempMax);    dfs(grid, m , n, i, j-1, tempMax);    dfs(grid, m , n, i, j+1, tempMax);//上下左右}</code></pre><h3 id="DFS相关题目-3-Island-Perimeter"><a href="#DFS相关题目-3-Island-Perimeter" class="headerlink" title="DFS相关题目_3.Island Perimeter"></a>DFS相关题目_3.Island Perimeter</h3><p>leetcode 463</p><p>题目大意：二维地图，每个单元格的长度为1的方形。1代表陆地，0代表水，上、下、左、右四个方向的单元格相连，求出相连陆地单元格的周长。 </p><p>思路：图中只有唯一一个岛屿,不用dfs，直接遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可。</p><p>代码：</p><pre><code class="java">//求图中唯一岛屿的周长。思路：//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可//对岛屿的一个节点计算周长的规律:周围相邻有0/1/2/3/4的节点的话，对应的周长分别为4/3/3/2/1/0public int islandPerimeter(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int resPrm = 0;//该岛屿的周长    int m = grid.length;    int n = grid[0].length;    for(int i=0; i&lt;m; ++i){//遍历图中所有的节点，对是岛屿的每一个节点计算其贡献的周长，加起来即可        for(int j=0; j&lt;n; ++j){            if(grid[i][j]==1){                int temp = 4;                if(i-1&gt;=0 &amp;&amp; grid[i-1][j]==1){//上：有相邻的一个节点                    temp--;                }                if(i+1&lt;m &amp;&amp; grid[i+1][j]==1){//下：有相邻的一个节点                    temp--;                }                if(j-1&gt;=0 &amp;&amp; grid[i][j-1]==1){//左：有相邻的一个节点                    temp--;                }                if(j+1&lt;n &amp;&amp; grid[i][j+1]==1){//右：有相邻的一个节点                    temp--;                }                resPrm += temp;            }        }    }    return resPrm;}</code></pre><h3 id="DFS相关题目-4-Surrounded-Regions"><a href="#DFS相关题目-4-Surrounded-Regions" class="headerlink" title="DFS相关题目_4.Surrounded Regions"></a>DFS相关题目_4.Surrounded Regions</h3><p>leetcode 130</p><p>题目：这道题的意思是将所有被X包围的O都变为X(边缘的不算)</p><p>思路：1.从图的4个边界出发DFS找O的土地，全部换成*;2.遍历图中剩下的节点，将O换成X，将*换成O</p><p>代码：</p><pre><code class="java">public void solve(char[][] board) {    if(board==null || board.length==0 || board[0].length==0){        return;    }    int m = board.length;    int n = board[0].length;    //1.从图的4个边界出发DFS找O的土地，全部换成*    for (int i = 0; i &lt; n; ++i){        dfsSolve(board, m, n, 0, i);//上边界        dfsSolve(board, m, n, m-1, i);//下边界    }    for (int i = 0; i &lt; m; ++i){        dfsSolve(board, m, n, i, 0);//左边界        dfsSolve(board, m, n, i, n-1);//右边界    }    //2.遍历图中剩下的节点，将O换成X，将*换成O    for (int i = 0; i &lt; m; ++i) {        for (int j = 0; j &lt; n; ++j) {            if(board[i][j]==&#39;*&#39;){                board[i][j]=&#39;O&#39;;            }            else if(board[i][j]==&#39;O&#39;){                board[i][j]=&#39;X&#39;;            }        }    }}//从图的4个边界出发DFS找O的土地，访问过的换成*public void dfsSolve(char[][] grid, int m, int n, int i, int j){    if(i&lt;0 || i&gt;=m || j&lt;0 || j&gt;=n || grid[i][j]==&#39;X&#39; || grid[i][j]==&#39;*&#39;){        return;    }    grid[i][j] = &#39;*&#39;;//把边界O换成*    dfsSolve(grid, m, n, i+1, j);//上    dfsSolve(grid, m, n, i-1, j);//下    dfsSolve(grid, m, n, i, j-1);//左    dfsSolve(grid, m, n, i, j+1);//右}</code></pre><p><a name="28"></a></p><h2 id="28-图的几种最短路算法-4道"><a href="#28-图的几种最短路算法-4道" class="headerlink" title="28.图的几种最短路算法(4道)"></a>28.图的几种最短路算法(4道)</h2><pre><code>1.单源最短路径_1.Dijkstra算法2.单源最短路径_2.Bellman-Ford算法3.单源最短路径_3.SPFA算法4.多源最短路径_Floyd-Warshall算法</code></pre><h3 id="1-单源最短路径-1-Dijkstra算法"><a href="#1-单源最短路径-1-Dijkstra算法" class="headerlink" title="1.单源最短路径_1.Dijkstra算法"></a>1.单源最短路径_1.Dijkstra算法</h3><p>普通实现的时间复杂度为O(V2)，若基于 Fibonacci heap 的最小优先队列实现版本则时间复杂度为 O(E+VlogV)</p><p>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s</p><p>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，此时完成一个顶点， 然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。 然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p><p>图片截图：</p><p><img src="https://img-blog.csdnimg.cn/20200215151327162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="dijkstra.png)"></p><p>自己跑过的代码：</p><pre><code class="java">/** * @FileName: Dijkstra * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: Dijkstra最短路径算法实现 */public class Dijkstra {    private static int N = Integer.MAX_VALUE - 2;    private static int[][] Graph = {            {0, 1, 5, N, N, N, N, N, N},            {1, 0, 3, 7, 5, N, N, N, N},            {5, 3, 0, N, 1, 7, N, N, N},            {N, 7, N, 0, 2, N, 3, N, N},            {N, 5, 1, 2, 0, 3, 6, 9, N},            {N, N, 7, N, 3, 0, N, 5, N},            {N, N, N, 3, 6, N, 0, 2, 7},            {N, N, N, N, 9, 5, 2, 0, 4},            {N, N, N, N, N, N, 7, 4, 0}};    public static void main(String[] args) {        dijkstra(0, Graph);    }    /**     * Dijkstra最短路径。     * 即图中&quot;节点vs&quot;到其它各个节点的最短路径。     *     * @param vs    起始节点     * @param Graph 图     */    public static void dijkstra(int vs, int[][] Graph) {        int NUM = Graph.length;//图中节点的个数        int[] prenode = new int[NUM];//前驱节点数组        int[] mindist = new int[NUM];// 最短距离数组        boolean[] find = new boolean[NUM];// 该节点是否已经找到最短路径，即已经确定节点的集合，初始里面只有vs节点        int vnear = 0;        for (int i = 0; i &lt; NUM; i++) {//初始化            prenode[i] = i;            mindist[i] = Graph[vs][i];            find[i] = false;        }        find[vs] = true;//节点自己到自己的最短路径能找到        for (int v = 1; v &lt; NUM; v++) {//循环NUM-1次            // 每次循环找一个距离vs最近的节点vnear和最短距离min            int min = Integer.MAX_VALUE;            for (int j = 0; j &lt; NUM; j++) {                if (!find[j] &amp;&amp; mindist[j] &lt; min) {                    min = mindist[j];                    vnear = j;                }            }            find[vnear] = true;//vnear节点已经确定，访问标记            // 根据vnear修正vs到其他所有节点的前驱节点及距离，即松弛操作            for (int k = 0; k &lt; NUM; k++) {                if (!find[k] &amp;&amp; (min + Graph[vnear][k]) &lt; mindist[k]) {                    prenode[k] = vnear;                    mindist[k] = min + Graph[vnear][k];                }            }        }        for (int i = 0; i &lt; NUM; i++) {            System.out.println(&quot;v&quot; + vs + &quot;...v&quot; + prenode[i] + &quot;-&gt;v&quot; + i + &quot;, s=&quot; + mindist[i]);        }    }}out:v0...v0-&gt;v0, s=0v0...v1-&gt;v1, s=1v0...v1-&gt;v2, s=4v0...v2-&gt;v3, s=-2147483647v0...v3-&gt;v4, s=-2147483645v0...v7-&gt;v5, s=-2147483642v0...v2-&gt;v6, s=-2147483647v0...v2-&gt;v7, s=-2147483647v0...v2-&gt;v8, s=-2147483647</code></pre><h3 id="2-单源最短路径-2-Bellman-Ford算法"><a href="#2-单源最短路径-2-Bellman-Ford算法" class="headerlink" title="2.单源最短路径_2.Bellman-Ford算法"></a>2.单源最短路径_2.Bellman-Ford算法</h3><p>时间o(VE),比dijkstra慢</p><p>Bellman-Ford 算法描述：</p><p>1.创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；<br>计算最短路径，执行 V - 1 次遍历，每次遍历中，依赖所有边进行松弛操作；</p><p>2.松弛操作：对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；</p><p>3.检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</p><p>自己跑过的代码：</p><pre><code class="java">import java.util.HashSet;import java.util.Set;/** * @FileName: Dijkstra * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: Bellman-Ford最短路径算法实现 */class Edge{    int start; //有向边的起点    int end;   //有向边的终点    int weight;//边的权重}public class Bellman {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构、源节点的下标(0~节点个数-1)     * @return     */    public void Bellman_Ford(int[][] graph, int source){        //图结构中的节点数目、边集合        int nodenum = graph.length;        Set&lt;Edge&gt; edge = new HashSet&lt;&gt;();//边集合        //1.根据graph的图结构给edge[]边数组赋值        for(int i=0; i&lt;nodenum; ++i){            for(int j=i+1; j&lt;nodenum; ++j){                if(graph[i][j]!=N &amp;&amp; graph[i][j]!=0){//有边的话就赋值，最终有edgeIndex条边                    Edge tempEdge = new Edge();                    tempEdge.start = i;                    tempEdge.end = j;                    tempEdge.weight = graph[i][j];                    edge.add(tempEdge);                }            }        }        //2.为dist最短路径数组初始化赋值        int[] dist = new int[nodenum];        for(int i=0; i&lt;nodenum; i++){            dist[i]=graph[source][i];        }        dist[source]=0;        //3.循环nodenum-1次,每次都遍历所有边，进行松弛操作        for(int i=0; i&lt;nodenum-1; i++)//循环nodenum-1次        {            for (Edge edgeTemp: edge){//每次都遍历所有边，进行松弛操作                int start = edgeTemp.start;                int end = edgeTemp.end;                int weight = edgeTemp.weight;                if(dist[end]&gt;dist[start]+weight){//松弛操作                    dist[end]=dist[start]+weight;                }            }        }        //4.判断是否存在负回路        boolean flag=false;//是否存在回路        for (Edge edgeTemp: edge){            if( dist[edgeTemp.end] &gt; dist[edgeTemp.start]+edgeTemp.weight )            {                flag=true;                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++)                System.out.println(dist[i]);//打印源节点到每个节点的距离        }    }    public static void main(String[] args){        Bellman bellman = new Bellman();        int[][] graph = new int[][]{                                    {0, 1, 5, N},                                    {1, 0, 3, 7},                                    {5, 3, 0, N},                                    {N, 7, N, 0}};        bellman.Bellman_Ford(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径    }}</code></pre><h3 id="3-单源最短路径-3-SPFA算法"><a href="#3-单源最短路径-3-SPFA算法" class="headerlink" title="3.单源最短路径_3.SPFA算法"></a>3.单源最短路径_3.SPFA算法</h3><p>SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。</p><p>很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)。</p><p>但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。</p><p>实现方法：建立一个队列，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。然后执行松弛操作，用队列里有的点去刷新起始点到所有点的最短路，如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。重复执行直到队列为空。</p><p>此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。</p><p>图结构为邻接矩阵的spfa代码：</p><pre><code class="java">import java.util.*;/** * @FileName: SPFA * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: SPFA最短路径算法实现 */public class SPFA {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)     * @return     */    public static int[] spfa(int[][] graph, int source){        int nodenum = graph.length;        int[] dist = new int[nodenum];//最短路径数组        boolean[] used = new boolean[nodenum];//访问标记位        for(int i = 0; i&lt;nodenum; i++){            dist[i] = Integer.MAX_VALUE;            used[i] = false;        }        int[] num = new int[nodenum]; //记录每个节点遍历过的次数，用于检测负向环        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//辅助队列        int path[] = new int[nodenum];         //记录最短路的路径        dist[source] = 0;     //source顶点到自身距离为0        used[source] = true;    //表示source顶点进入数组队        num[source] = 1;       //表示source顶点已被遍历一次        queue.add(source);      //source顶点入队        boolean flag = false;//是否存在回路        while(!queue.isEmpty()) {            int u = queue.poll();   //获取队头            used[u] = false;            for (int v = 0; v &lt; nodenum; ++v) {//对每一个u的相邻节点进行松弛操作                if (graph[u][v] != N) {////u与v直接邻接                    if (dist[v] &gt; dist[u] + graph[u][v]) {                        dist[v] = dist[u] + graph[u][v];                        path[v] = u;                        if (!used[v]) {//如果v没有访问过，入队                            queue.offer(v);                            used[v] = true;                            num[v]++;                            if (num[v] &gt;= nodenum) {//遍历次数大于等于节点数，存在负向环,break                                flag = true;                                break;                            }                        }                    }                }            }            if(flag){//存在负向环,break                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++)                System.out.println(dist[i]);//打印源节点到每个节点的距离        }        return dist;    }    public static void main(String[] args){        int[][] graph = new int[][]{                                    {0, 1, 5, N},                                    {1, 0, 3, 7},                                    {5, 3, 0, N},                                    {N, 7, N, 0}};        int[] dist = spfa(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径        System.out.println(Arrays.toString(dist));//out:[4, 3, 0, 10]    }}</code></pre><p>图结构为邻接链表的spfa代码:</p><pre><code class="java">import java.util.*;/** * @FileName: SPFA * @Author: braincao * @Date: 2019/1/9 16:55 * @Description: SPFA最短路径算法实现 */public class SPFA {    private final static int N = 9999;//不可达边的权值    /**     * @param: 图结构(邻接矩阵)、源节点的下标(0~节点个数-1)     * @return 单源最短路径     */    public static int[] spfa(int[][] graph, int source){        //1.邻接矩阵转成邻接表        int nodenum = graph.length;        List[] vex = new List[nodenum];        for(int i=0; i&lt;nodenum; ++i){            vex[i] = new ArrayList();        }        for(int i=0; i&lt;nodenum; ++i){            for(int j=i+1; j&lt;nodenum; ++j){//假设给定的图是无向图                if(graph[i][j]!=N){                    vex[i].add(j);                    vex[j].add(i);                }            }        }        //2.spfa        int[] dist = new int[nodenum];//最短路径数组,初始化为MAX_VALUE        for(int i=0; i&lt;nodenum; ++i){            dist[i] = Integer.MAX_VALUE;        }        boolean[] used = new boolean[nodenum];//访问标记位        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//辅助队列        int[] num = new int[nodenum];//记录每个节点遍历过的次数，用于检测负向环        queue.offer(source);//source顶点入队        dist[source] = 0;//source顶点到自身距离为0        num[source] = 1;//表示source顶点已被遍历一次        used[source] = true;        boolean flag = false;//是否存在负向环        int[] path = new int[nodenum];//记录最短路径，初始化上一个节点都为source        for(int i=0; i&lt;nodenum; ++i){            path[i] = source;        }        while (!queue.isEmpty()){            int u = queue.poll();//获取队头            used[u] = false;            for(int i=0; i&lt;vex[u].size(); ++i){//对u的每个相邻节点v进行松弛操作                int v = (int)vex[u].get(i);                if( dist[v]&gt;dist[u]+graph[u][v] ){                    dist[v] = dist[u]+graph[u][v];                    path[v] = u;                    if(!used[v]){//如果v没有访问过，入队                        queue.offer(v);                        num[v]++;                        used[v] = true;                        if(num[v]&gt;=nodenum){//遍历次数大于等于节点数，存在负向环,break                            flag = true;                            break;                        }                    }                }            }            if(flag){//存在负向环,break                break;            }        }        if(!flag){//不存在负回路的话打印dist最短路径            for(int i=0;i&lt;nodenum;i++){                System.out.println(&quot;source:&quot;+source+&quot;...pass:&quot;+path[i]+&quot;--&gt;dest:&quot;+i+&quot;,distance:&quot;+dist[i]);            }        }        return dist;    }    public static void main(String[] args){        int[][] graph = new int[][]{                {0, 1, 5, N},                {1, 0, 3, 7},                {5, 3, 0, N},                {N, 7, N, 0}};        int[] dist = spfa(graph, 2);//节点0、1、2、3，现求节点2的单源最短路径        System.out.println(Arrays.toString(dist));        //out:        //source:2...pass:1--&gt;dest:0,distance:4        //source:2...pass:2--&gt;dest:1,distance:3        //source:2...pass:2--&gt;dest:2,distance:0        //source:2...pass:1--&gt;dest:3,distance:10        //[4, 3, 0, 10]    }}</code></pre><h3 id="4-多源最短路径-Floyd-Warshall算法"><a href="#4-多源最短路径-Floyd-Warshall算法" class="headerlink" title="4.多源最短路径_Floyd-Warshall算法"></a>4.多源最短路径_Floyd-Warshall算法</h3><p>时间o(V^3)</p><p>最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。</p><p>核心代码:</p><pre><code class="java">for(k=1;k&lt;=n;k++)      for(i=1;i&lt;=n;i++)          for(j=1;j&lt;=n;j++)              if(e[i][j]&gt;e[i][k]+e[k][j])                  e[i][j]=e[i][k]+e[k][j]; </code></pre><p><a name="29"></a></p><h2 id="29-Word-Ladder-2道-SPFA最短路算法应用"><a href="#29-Word-Ladder-2道-SPFA最短路算法应用" class="headerlink" title="29.Word Ladder(2道)(SPFA最短路算法应用)"></a>29.Word Ladder(2道)(SPFA最短路算法应用)</h2><pre><code>Word Ladder--leetcode 127Word Ladder2--leetcode 126</code></pre><h3 id="1-Word-Ladder"><a href="#1-Word-Ladder" class="headerlink" title="1.Word Ladder"></a>1.Word Ladder</h3><p>leetcode 127</p><p>题目：Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</p><pre><code>1.Only one letter can be changed at a time.2.Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</code></pre><p>Note:</p><pre><code>Return 0 if there is no such transformation sequence.All words have the same length.All words contain only lowercase alphabetic characters.You may assume no duplicates in the word list.You may assume beginWord and endWord are non-empty and are not the same.</code></pre><p>Example 1:</p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output: 5Explanation: As one shortest transformation is &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,return its length 5.</code></pre><p>题目大意: </p><p>思路：最短路径问题。1.构造图结构(邻接表); 2.用SPFA最短路算法求beginWord到endWord的最短改变次数</p><p>代码：</p><pre><code class="java">//Word Ladder找出beginWord到endWord的最小改变次数。//思路：最短路问题。1.构图; 2.用SPFA最短路算法求beginWord到endWord的最短改变次数public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {    if(diff(beginWord, endWord)==1){        return 2;    }    //1.构造图的邻接表    int size = wordList.size();    List[] edge = new List[size+2];//size装beginWord，size+1装endWord    for(int i=0; i&lt;edge.length; ++i){        edge[i] = new ArrayList&lt;Integer&gt;();    }    boolean can_arrive = false;//从beginWord到endWord是否能顺利改变    for(int i=0; i&lt;size; ++i){        for(int j=i+1; j&lt;size; ++j){            if(diff(wordList.get(i), wordList.get(j)) == 1){//这两个单词可以转变，图中有边                edge[i].add(j);                edge[j].add(i);            }        }        if(diff(beginWord, wordList.get(i))==1){//字典中的当前单词与beginWord可以改变，图中有边            edge[size].add(i);        }        int temp = diff(endWord, wordList.get(i));        if(temp == 1){//字典中的当前单词与endWord可以改变，图中有边            edge[i].add(size+1);        }        if(temp == 0){//字典中包含endWord，can_arrive            can_arrive = true;        }    }    if(can_arrive==false){        return 0;    }    //2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径    int[] dist = new int[size+2];//求edge[size]节点的单源最短路径数组    for(int i = 0; i&lt;size+2; i++){        dist[i] = Integer.MAX_VALUE;    }    dist[size] = 1;    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    queue.offer(size);//起始节点入队    while(!queue.isEmpty()) {        int queFirstNode = queue.poll();   //获取队头        int dest = dist[queFirstNode];        for(int i=0; i&lt;edge[queFirstNode].size(); ++i){//遍历queFirstNode为起点的每条边            //当队头的节点等于边edgeTemp的起点时,进行松弛操作            int temp = (int)edge[queFirstNode].get(i);            if( dist[temp] &gt; dest+1 ) {                dist[temp] = dest+1;                queue.add(temp);                if(temp == size+1) {//该节点是终点，即改变成功                    return dist[temp];//从起点(size)到终点(size+1)的最短距离                }            }        }    }    return 0;}//判断两个字符串不同的字符个数public int diff(String word1, String word2){    int res = 0;    for(int i=0; i&lt;word1.length(); ++i){        if(word1.charAt(i)!=word2.charAt(i)){            res++;        }    }    return res;}</code></pre><h3 id="2-Word-Ladder2"><a href="#2-Word-Ladder2" class="headerlink" title="2.Word Ladder2"></a>2.Word Ladder2</h3><p>leetcode 126</p><p>题目：题目与上面同，只是结果应该返回所有转换的路径而不是最短的路径长度</p><p>思路：还是构造邻接链表+SPFA最短路径算法，当找到终点时用<strong>dfs</strong>从终点节点反推找出所有不同的最短路径即可。</p><p>Example 1:</p><pre><code>Input:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]Output:[  [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],  [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</code></pre><p>代码：</p><pre><code class="java">import java.util.*;public class Solution {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    int size;    int[] dist;    List[] edge;    String a;    String b;//这些变量弄成全局是为了dfs函数中使用    List&lt;String&gt; wl;    ArrayList&lt;String&gt; tempPath = new ArrayList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) {        a = beginWord;        b = endWord;        wl = wordList;        size = wordList.size();        //1.构造图的邻接表        edge = new List[size+2];//size装beginWord，size+1装endWord        for(int i=0; i&lt;edge.length; ++i){            edge[i] = new ArrayList&lt;Integer&gt;();        }        boolean can_arrive = false;//从beginWord到endWord是否能顺利改变        if(diff(beginWord, endWord)==1){            edge[size].add(size+1);            edge[size+1].add(size);        }        for(int i=0; i&lt;size; ++i){            for(int j=i+1; j&lt;size; ++j){                if(diff(wordList.get(i), wordList.get(j)) == 1){//这两个单词可以转变，图中有边                    edge[i].add(j);                    edge[j].add(i);                }            }            if(diff(beginWord, wordList.get(i))==1){//字典中的当前单词与beginWord可以改变，图中有边                edge[size].add(i);                edge[i].add(size);            }            int temp = diff(endWord, wordList.get(i));            if(temp == 1){//字典中的当前单词与endWord可以改变，图中有边                edge[i].add(size+1);                edge[size+1].add(i);            }            if(temp == 0){//字典中包含endWord，can_arrive                can_arrive = true;            }        }        if(!can_arrive){            return res;        }        //2.上述构好图后，用SPFA最短路算法求beginWord到endWord的最短路径        dist = new int[size+2];//求edge[size]节点的单源最短路径数组        for(int i = 0; i&lt;size+2; i++){            dist[i] = Integer.MAX_VALUE;        }        dist[size] = 1;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        queue.offer(size);//起始节点入队        while(!queue.isEmpty()) {            int queFirstNode = queue.poll();   //获取队头            int dest = dist[queFirstNode];            for(int i=0; i&lt;edge[queFirstNode].size(); ++i){//遍历queFirstNode为起点的每条边                //当队头的节点等于边edgeTemp的起点时,进行松弛操作                int temp = (int)edge[queFirstNode].get(i);                if( dist[temp] &gt; dest+1 ) {                    dist[temp] = dest+1;                    queue.add(temp);                    if(temp == size+1) {//该节点是终点，即改变成功,用dfs从终点返回回去找路径                        dfs(temp);                        return res;                    }                }            }        }        return res;    }    public void dfs(int p){        if(p==size){//起点            tempPath.add(a);        }        else if(p==size+1){//终点            tempPath.add(b);        }        else{            tempPath.add(wl.get(p));        }        if(dist[p]==1){//递归出口，如果递归到了起点，说明一条路径已经找到了            ArrayList&lt;String&gt; temp = new ArrayList&lt;&gt;(tempPath);            Collections.reverse(temp);            res.add(temp);            if (!tempPath.isEmpty()){                tempPath.remove(tempPath.size()-1);            }            return;        }        //往回走        for(int i=0; i&lt;edge[p].size(); ++i){            int dest = (int)edge[p].get(i);            if(dist[dest]+1 == dist[p]){                dfs(dest);            }        }        if (!tempPath.isEmpty()){            tempPath.remove(tempPath.size()-1);        }    }    //判断两个字符串不同的字符个数    public int diff(String word1, String word2){        int res = 0;        for(int i=0; i&lt;word1.length(); ++i){            if(word1.charAt(i)!=word2.charAt(i)){                res++;            }        }        return res;    }    public static void main(String[] args){        Solution s = new Solution();        String beginWord = &quot;hit&quot;;        String endWord = &quot;cog&quot;;        String[] wordList = new String[]{&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;};        System.out.println(s.findLadders(beginWord, endWord, Arrays.asList(wordList)));        //out:[[hit, hot, dot, dog, cog], [hit, hot, lot, log, cog]]    }}</code></pre><p><a name="30"></a></p><h2 id="30-字符串匹配-kmp算法"><a href="#30-字符串匹配-kmp算法" class="headerlink" title="30.字符串匹配(kmp算法)"></a>30.字符串匹配(kmp算法)</h2><p>leetcode 28</p><p>题目：Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Example 1:</p><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Example 2:Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1</code></pre><p>思路：kmp算法。求模式串的next数组，然后进行字符串匹配即可。不用kmp算法之前的时间o(mn),m字符串，n模式串，用kmp算法之后的时候是o(m+n)。下面重点讲解kmp中的next数组怎么求。</p><p>如果不写代码的话，kmp的next非常好求，就是考研时候的那个套路，如”ABAD”–&gt;next:[-1,0,0,1]，有了next数组，拿模式串j和字符串i依次进行匹配即可，如果不等，则i不动，对应模式串跳转到next[j]继续匹配，如果next[j]==-1，则i也+1即可</p><p>代码实现next数组的过程强推油管<a href="https://www.youtube.com/watch?v=GTJr8OvyEVQ" target="_blank" rel="noopener">(KMP) Pattern Matching</a>，下面是自己的总结。</p><p>核心就是代码求kmp的next数组如”ABAD”–&gt;next:[-1,0,0,1],见下面的代码:</p><pre><code class="java">public int strStr(String haystack, String needle) {    if(needle==null || needle.length()==0){        return 0;    }    if(haystack==null || haystack.length()==0){        return -1;    }    int i = 0;    int j = 0;    int[] next = getNext(needle);    while (i &lt; haystack.length() &amp;&amp; j &lt; needle.length())    {        if ( j==-1 || haystack.charAt(i)==needle.charAt(j) )        {            i++;            j++;        }        else            j = next[j];    }    if ( j==needle.length() ){//匹配成功，返回needle出现的位置        return i-j;    }    return -1;}public int[] getNext(String needle){    int[] next = new int[needle.length()];    int j = -1;    int i = 0;    next[0] = -1;    while(i&lt;needle.length()){        if(j==-1 || needle.charAt(i)==needle.charAt(j)){            j++;            i++;            if(i&lt;needle.length()){                next[i] = j;            }        }        else{            j = next[j];        }    }    return next;}</code></pre><p><a name="31"></a></p><h2 id="31-两数相除-转为减法"><a href="#31-两数相除-转为减法" class="headerlink" title="31.两数相除(转为减法)"></a>31.两数相除(转为减法)</h2><p>leetcode 29</p><p>题目：除法运算，但是不能使用/、%、*（除数不会为0）。</p><p>思路：将除法转化为减法，但是单纯的做减法计算次数太粗暴，故采用除数扩大（左移），商随之扩大（左移）的思想，同时要考虑正负两边的最大绝对值是不一样的。最简单的方法是用long去处理。另外一个边界条件需要单独处理：<code>-2147483648/-1= 2147483647</code></p><p>把除数表示为：dividend = 2^i * divisor + 2^(i-1) * divisor + … + 2^0 * divisor。这样一来，我们所求的商就是各系数之和了，而每个系数都可以通过移位操作获得。</p><p>分两步走：</p><pre><code>1）获得i的值；2）将各系数求和。显然每步都是logN的复杂度。</code></pre><p>代码：</p><pre><code class="java">//除法转换为减法。具体思路:除数左移几次，商左移几次。dividend=2^i*divisor+2^(i-1)*divisor+...+2^0*divisor.public int divide(int dividend, int divisor) {    if(dividend == 0){        return 0;    }    boolean isPositive = (dividend&gt;0 &amp;&amp; divisor&gt;0) || (dividend&lt;0 &amp;&amp; divisor&lt;0);    long res = divideDetail( Math.abs((long)dividend), Math.abs((long)divisor) );    if(isPositive &amp;&amp; res&gt;Integer.MAX_VALUE){//溢出特例必须处理-2147483648/-1= 2147483647        res = Integer.MAX_VALUE;    }    return isPositive ? (int)res : -(int)res;}public long divideDetail(long dividend, long divisor){    //1.除数左移, 获取i值    long i = 0;    while(dividend &gt;= (divisor&lt;&lt;1)){        divisor &lt;&lt;= 1;        i++;    }    //2.商左移cnt次，获取多项式系数和，即商系数相加    long res = 0;    while(i&gt;=0){        if(dividend&gt;=divisor){            res += (1L&lt;&lt;i);            dividend -= divisor;        }        divisor &gt;&gt;= 1;        i--;    }    return res;}</code></pre><p><a name="32"></a></p><h2 id="32-sqrt-x"><a href="#32-sqrt-x" class="headerlink" title="32.sqrt(x)"></a>32.sqrt(x)</h2><p>leetcode 69</p><p>题目：Implement int sqrt(int x).求x的平方根。</p><p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p><p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p><p>思路1：二分法。定义一个最小精度，用二分法逼近即可。</p><pre><code class="java">//二分法public int mySqrt(int x) {    if(x == 0){        return 0;    }    if(x&lt;4){        return 1;    }    double left = 1;    double right = x;    double mid;    while(left&lt;=right){        mid = left + (right-left)/2;        if(mid*mid==x || right-mid&lt;1e-9){            return (int)mid;        }        else if(mid*mid&gt;x){//因为是double类型所以乘法比除法好，也不会溢出            right = mid;        }        else if(mid*mid&lt;x){            left = mid;        }    }    return 0;}</code></pre><p>思路1的改进：因为题目中所求是int类型，所以不需要double类型去逼近，用int</p><pre><code class="java">//二分法的改进public int mySqrt(int x) {    if(x == 0){        return 0;    }    if(x&lt;4){        return 1;    }    int left = 1;    int right = x;    int mid;    while(left&lt;=right){        mid = left + (right-left)/2;        if(x/mid==mid){            return mid;        }        else if(x/mid&lt;mid){//因为是int类型所以除法比乘法好，这样也可以避免溢出            right = mid-1;        }        else if(x/mid&gt;mid){            left = mid+1;        }    }    return right;//while跳出循环时，right &lt; left，应该返回right}</code></pre><p>思路2：牛顿法。对x的平方根的值一个猜想y。通过执行一个简单的操作去得到一个更好的猜测：只需要求出y和x/y的平均值（它更接近实际的平方根值）。</p><pre><code class="java">//牛顿法public int mySqrt(int x) {    double k=1.0； //当然猜想的数拿来主义会更快k=0x5f3759df;    while(Math.abs(k*k-x)&gt;0.0001) {//精度不能太高，否则太慢        k=(k+x/k)/2;    }    return (int)k;}</code></pre><p><a name="33"></a></p><h2 id="33-乱序的数组中找到最长的递增子序列"><a href="#33-乱序的数组中找到最长的递增子序列" class="headerlink" title="33.乱序的数组中找到最长的递增子序列"></a>33.乱序的数组中找到最长的递增子序列</h2><p>leetcode 300</p><p>题目：Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><p>思路1(可取，但不够好)：DP问题。时间o(n^2)</p><p>设长度为N的数组为{a0，a1, a2, …an-1)，则假定以aj结尾的数组序列的最长递增子序列长度为L(j)，<strong>则L(j)={ max(L(i))+1, i&lt;j且a[i]&lt;a[j] }</strong>。也就是说，我们需要遍历在j之前的所有位置i(从0到j-1)，找出满足条件a[i]&lt;a[j]的L(i)，求出max(L(i))+1即为L(j)的值。最后，我们遍历所有的L(j)（从0到N-1），找出最大值即为最大递增子序列。时间复杂度为O(N^2)。</p><p>例如给定的数组为{5，6，7，1，2，8}，则L(0)=1, L(1)=2, L(2)=3, L(3)=1, L(4)=2, L(5)=4。所以该数组最长递增子序列长度为4，序列为{5，6，7，8}。算法代码如下：</p><pre><code class="java">//最长递增子序列。思路1：一维DP，时间o(n^2)public int lengthOfLIS(int[] nums) {    int len = nums.length;    int[] longest = new int[len];    for (int i=0; i&lt;len; i++){        longest[i] = 1; //初始化都为1    }    //dp[j] = {max(L(i))+1}, 如果i&lt;j且a[i]&lt;a[j]    for (int j=1; j&lt;len; j++) {        for (int i=0; i&lt;j; i++) {            if (nums[j]&gt;nums[i] &amp;&amp; longest[j]&lt;longest[i]+1){ //注意longest[j]&lt;longest[i]+1这个条件，不能省略。                longest[j] = longest[i] + 1; //计算以arr[j]结尾的序列的最长递增子序列长度            }        }    }    //再遍历一遍dp[]数组，取最大的    int max = 0;    for (int j=0; j&lt;len; j++) {        if (longest[j] &gt; max) max = longest[j];  //从longest[j]中找出最大值    }    return max;}</code></pre><p>思路2(更好)：二分。假设存在一个序列d[1..9] ={ 2，1 ，5 ，3 ，6，4， 8 ，9， 7}，可以看出来它的LIS长度为5。</p><p>下面一步一步试着找出它。</p><p>我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。<br>此外，我们用一个变量Len来记录现在最长算到多少了</p><p>首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p><p>然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1</p><p>接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2</p><p>再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p><p>继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p><p>第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p><p>第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p><p>第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p><p>最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p><p>于是我们知道了LIS的长度为5。</p><p>注意，这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] = 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p><p>然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)<del>~</del>于是算法的时间复杂度就降低到了O(NlogN)～！</p><p>代码如下（代码中的数组B从位置0开始存数据）：</p><pre><code class="java">//最长递增子序列。思路2：辅助数组存储有序数列，时间o(nlogn)public int lengthOfLIS(int[] nums) {    int[] dp = new int[nums.length];    int len = 0;    for(int num : nums){        //二分查找，查找不到的话就返回负数,负数从1开始。[1,2,3](索引是0，1，2/找不到的索引是1,2,3) 找num=1.5 返回-2        int i = Arrays.binarySearch(dp, 0, len, num);        if(i &lt; 0) i = -i-1;        dp[i] = num;        if(len == i) len ++;//不是更新的值，而是实实在在的扩张递增序列了，所以len++    }    return len;}</code></pre><p><a name="34"></a></p><h2 id="34-蓄水池问题"><a href="#34-蓄水池问题" class="headerlink" title="34.蓄水池问题"></a>34.蓄水池问题</h2><p>leetcode 42</p><p><img src="https://img-blog.csdnimg.cn/2020021515145692.png" alt="蓄水池.jpg"></p><p>题目：Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p><p>Example:</p><pre><code>Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6</code></pre><p>思路：两头双指针往中间。</p><pre><code class="java">//蓄水池问题。思路：两头双指针往中间public int trap(int[] height) {    int leftmax = 0;//左边最大的板子    int rightmax = 0;//右边最大的板子    int a = 0;    int b = height.length - 1;    int sum = 0;    while(a &lt;= b){        leftmax = Math.max(height[a], leftmax);//每次都更新下左右两边最大的板子        rightmax = Math.max(height[b], rightmax);        if(leftmax &lt; rightmax){//左边比右边的板子小，右边能挡住，因此看左边的短板            sum += leftmax - height[a];            a++;        }else{            sum += rightmax - height[b];            b--;        }    }    return sum;}</code></pre><p><a name="35"></a></p><h2 id="35-满足指定sum条件的长度最小的子数组"><a href="#35-满足指定sum条件的长度最小的子数组" class="headerlink" title="35.满足指定sum条件的长度最小的子数组"></a>35.满足指定sum条件的长度最小的子数组</h2><p>leetcode 209 Minimum Size Subarray Sum</p><p>题目：Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>Example: </p><pre><code>Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint.</code></pre><p>思路：遍历一遍数组，两个指针变量i,j控制窗口动态变化，时间o(n)</p><pre><code class="java">public int minSubArrayLen(int s, int[] nums) {    if(nums==null || nums.length==0){        return 0;    }    int i = 0;    int j = 0;    int resMin = Integer.MAX_VALUE;    int sum = nums[i];    while(j&lt;nums.length){        while(sum &lt; s){//和不够，j++，扩大窗口            j++;            if(j&gt;=nums.length){//循环出口                return resMin==Integer.MAX_VALUE ? 0 : resMin;            }            sum += nums[j];        }        resMin = Math.min(resMin, j-i+1);//更新最小窗口长度        while(sum &gt;= s){//和够了，i++，缩小窗口            resMin = Math.min(resMin, j-i+1);////更新最小窗口长度            sum -= nums[i];            i++;        }    }    return 0;}</code></pre><p><a name="36"></a></p><h2 id="36-最大值减去最小值小于或等于num的子数组数量"><a href="#36-最大值减去最小值小于或等于num的子数组数量" class="headerlink" title="36.最大值减去最小值小于或等于num的子数组数量"></a>36.最大值减去最小值小于或等于num的子数组数量</h2><p>《左神》31</p><p>题目：给定数组arr和整数num，共返回有多少个子数组满足子数组的最大值-最小值&lt;=num</p><p>思路：数组长度n，时间o(n),空间o(n)</p><p>1、生成两个队列qmax和qmin. 两个指针i,j，标定数组边界</p><p>2、令j不断向右移动（j++）,表示arr[i..j]一直向右扩大，并不断更新qmax和qmin结构，保证qmax和qmin始终维持动态窗口最大值和最小值的更新结构。直到j不满足向右扩张条件时，以arr[i]为左边界且满足条件的子数组(子数组长度&gt;=2)个数为j-i</p><p>3、当进行完步骤2，令i向右移动一个位置并对qmax和qmin做出相应的更新做出相应的更新。 </p><p>4、根据步骤2，步骤3，依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量分别有多少，累加起来起来的数量就是最终的结果。</p><pre><code class="java">//最大值减去最小值小于或等于num的子数组数量(子数组长度大于1)。思路：两个队列qmax和qmin. 两个指针i,j//依次求出以arr[0],arr[1],arr[2]…..、arr[N-1]作为第一个元素的子数组中满足条件的数量public static int getNum(int[] arr,int num){    if(arr==null || arr.length&lt;2){        return 0;    }    int i = 0;    int j = 0;//辅助i/j两个指针    Deque&lt;Integer&gt; qmax = new LinkedList&lt;&gt;();    Deque&lt;Integer&gt; qmin = new LinkedList&lt;&gt;();//辅助两个双端队列记录当前子数组的最大/小值    int res = 0;    while(i&lt;arr.length){        while(j&lt;arr.length){//j不断往右扩            while(!qmax.isEmpty() &amp;&amp; arr[j]&gt;=arr[qmax.peekLast()]){//注意这里必须有=                qmax.pollLast();            }            qmax.offerLast(j);            while(!qmin.isEmpty() &amp;&amp; arr[j]&lt;=arr[qmin.peekLast()]){                qmin.pollLast();            }            qmin.offerLast(j);            if(!qmax.isEmpty()&amp;&amp;!qmin.isEmpty() &amp;&amp; arr[qmax.peekFirst()]-arr[qmin.peekFirst()] &lt;= num){                j++;            }            else{//当j不满足继续向右扩的条件时，break并计算当前以arr[i]为底的子数组的个数                break;            }        }        i++;        res += j-i;//计算当前以arr[i]为底的子数组的个数        if(!qmax.isEmpty() &amp;&amp; qmax.peekFirst()&lt;i){//将队列窗口之外的元素索引弹出(i之前的都不要了)            qmax.pollFirst();        }        if(!qmin.isEmpty() &amp;&amp; qmin.peekFirst()&lt;i){            qmin.pollFirst();        }    }    return res;}public static void main(String[] args){    int[] nums = new int[]{1,2,3,4,5};    System.out.println(getNum(nums,1));//out:4  [1,2][2,3][3,4][4,5]}</code></pre><p><a name="37"></a></p><h2 id="37-几道未整理的"><a href="#37-几道未整理的" class="headerlink" title="37.几道未整理的"></a>37.几道未整理的</h2><p>###1.有序数组合并###</p><p>####问题：</p><p>有两个从小到大排序以后的数组A和B，其中A的末端有足够的缓冲空容纳B。请编写一个方法，将B合并入A并排序。<br>给定两个有序int数组A和B，A中的缓冲空用0填充，同时给定A和B的真实大小int n和int m，请返回合并后的数组。</p><p>####思路：</p><p>这道题很简单，就是一个归并的过程。和归并排序里面的归并函数做法基本一样，但需要注意的是，这道题是把数组B加入到数组A里。我们需要从后往前比较、加入，这样防止覆盖掉数组A前面的有用部分。过程大致为我们每次从两个列表后面元素选取较大的一个，放入A最后，直到某一个列表到达头部，再将另一个剩下部分逆序取出。时间复杂度O（n+m），空间O（1）。</p><p>####代码：</p><pre><code class="java">class A{    public int[] mergeAB(int[] a, int[] b, int n, int m)    {        int pa = n - 1;        int pb = m - 1;        int p = m + n - 1;        do        {            if(pa==-1)                for(int i=p; i&gt;=0; i--)                    a[i] = b[pb--];            else if(pb==-1)                return a;            else                a[p--] = (a[pa]&gt;b[pb])?a[pa--]:b[pb--];        }while(p!=0);    return a;    }}public class Example{    public static void main(String[] args)    {        A cc = new A();        int[] a = {1,3,5,7,11, 0, 0, 0, 0, 0};        int[] b = {2,4,6,8,12};        int[] c = new int[5];        c = cc.mergeAB(a, b, 5, 5);        for(int i: c)            System.out.print(i + &quot; &quot;);    }}//output:1 2 3 4 5 6 7 8 11 12</code></pre><p>###2.三色排序</p><p>####问题：</p><p>有一个只由0，1，2三种元素构成的整数数组，请使用交换、原地排序而不是使用计数进行排序。<br>给定一个只含0，1，2的整数数组A及它的大小，请返回排序后的数组。保证数组大小小于等于500。</p><p>测试样例：[0,1,1,0,2,2],6</p><p>返回：[0,0,1,1,2,2]</p><p>####思路：</p><p>这是一个经典的荷兰国旗问题，处理过程和快排的划分过程相似，可以参考快排的划分技巧。时间复杂度O（n），空间O（1）。过程为：</p><p>遍历数组之前，在数组左端设立“0区”，初始大小0，在数组右端设立“2区”，初始大小0。遍历数组，如果是1，直接跳到下一个；如果是0，把当前元素与“0区”后一位交换，“0区”大小+1，遍历下一个元素；遇到2，把当前元素与“2区”前一位交换，“2区”大小+1，由于“2区”元素并没有遍历过，所以不跳到后一个位置，继续遍历该位置元素。</p><p>####代码:</p><pre><code class="java">public class ThreeColor {    public int[] sortThreeColor(int[] A, int n) {        // write code here        int i=-1;        int j=n;        int temp;        for(int k=0;k&lt;j;){            if(A[k]==0){                swap(A,++i,k++);             }            else if(A[k]==2){                swap(A,--j,k);            }            else                k++;        }        return A;    }    void swap(int A[],int a,int b){        int temp=A[a];        A[a]=A[b];        A[b]=temp;    }}</code></pre><p>其实拿到这个问题我最先想到的是用计数排序处理，只要三个桶，几乎可以认为是原地的，简单多了。但这里明确说要用交换，而不是计数。在在线课程下面的评论区里，有小伙伴提出和我一样的疑问，老师的回答是:</p><blockquote><p>如果数组里面放的不是int，long这种类型，而是具体一个一个实例呢？你还能压缩在一起吗？比如数组里面放的是“人”这个类的实例，每个实例有一个“身高”的数据项，请把小于160放左边，160~170放中间，170以上放右边。荷兰国旗问题重点介绍的是一种处理数组的技巧。这种技巧从快排中来，掌握了可以解决很多类似的问题。我并不是在强调这么做才对，只是一种技巧而已。</p></blockquote><p>###3.最短子数组问题</p><p>####问题：</p><p>对于一个数组，请设计一个高效算法计算需要排序的最短子数组的长度。<br>给定一个int数组A和数组的大小n，请返回一个二元组，代表所求序列的长度。(原序列位置从0开始标号,若原序列有序，返回0)。保证A中元素均为正整数。<br>测试样例：<br>[1,4,6,5,9,10],6<br>返回：2</p><p>####思路：<br>拿到这道题，我最直接的想法就是先排序，再比较排序后的数组有变化的位置，位置有变化的元素里的最左的一个到最右的一个，这之间的数组就是题目要求的需要排序的最短子数组。这种方法需要额外空间复杂度O（n），用来保存排序后的数组（或者保存原数组各元素下标情况，这取决于具体实现）。时间复杂度O（nlogn）。</p><p>由上面的这个思路，我们可以想到，其实只要知道，需要调整的元素里最右的元素和最左的元素的位置，就可以得到需要排序的最短子数组的长度。我们知道，如果是有序数组，一定是越往右，数值越大，越往左，数值越小，不满足这个条件的元素，那么就是需要调整的元素。于是可以想到下面的这种处理方法。它可以做到时间复杂度O（n），额外空间复杂度O（1）。处理过程大致为：</p><p>先向右遍历，记住遍历过的元素中的最大值max。如果遍历的当前元素i的值A[i]小于max，说明i是需要向左调整的，记住它。向右遍历，只记录需要向左调整的元素的最右的一个，记为R。<br>再从右至左遍历一次，这次记住遍历过的元素中的最小值min。同理，如果遍历的当前元素i的值A[i]大于min，说明i是需要向右调整的，记住它。遍历过程只记录要调整的最左的一个元素，记为L。A[l]~A[R]就是需要排序的最短子数组，它的长度是R-L+1.</p><p>####代码：</p><pre><code class="java">public int shortestSubsequence(int[] A, int n) {    int max = A[0];    int min = A[n-1];    int l = -1;    int r = 0;    //从左至右遍历，记录最右的当前值小于最大值情况    for(int i=1; i&lt;n; ++i)    {        if(A[i]&gt;=max)            max = A[i];        else            l = i;    }    //从右至左遍历，记录最左的当前值大于最小值情况    for(int j=n-2; j&gt;=0; j--)    {        if(A[j]&lt;min)            min = A[j];        else            r = j;    }    return l-r+1;}</code></pre><p>###4.有序矩阵查找</p><p>####问题：</p><p>现在有一个行和列都排好序的矩阵，请设计一个高效算法，快速查找矩阵中是否含有值x。<br>给定一个int矩阵mat，同时给定矩阵大小nxm及待查找的数x，请返回一个bool值，代表矩阵中是否存在x。所有矩阵中数字及x均为int范围内整数。保证n和m均小于等于1000。</p><p>测试样例：</p><p>[[1,2,3],[4,5,6],[7,8,9]],3,3,10</p><p>返回：false</p><p>####思路：</p><p>这道题可以做到时间复杂度O（m+n），额外空间复杂度O（1）。用下面这个矩阵举例说明。</p><p><img src="https://img-blog.csdnimg.cn/20200215151658115.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BvcF9SYWlu,size_16,color_FFFFFF,t_70" alt="matrix0.jpg"></p><p>我们从右上角或左下角作为起始位置开始遍历。这么做是因为矩阵行列都是有序的，右上角是行最小，列最大，左下角相反。我们这里选择从右上角开始，假设待查值是3。当前值是5，如果待查值比当前值大，那么往下走一步，因为我们知道这一行当前位置是最大的，左面所有元素都小于该值，就不用考虑；如果待查值更小，那么往左走一步，理由同上；如果相等，返回true。待查值3&lt;当前值5，往左走一步，当前值变成2。重复上面过程，当前值=4。3&lt;4,所以再往左走，现在待查值3=当前值3，返回true。如果直到越界都没找到，则返回false。</p><p>####代码：</p><pre><code class="java">boolean findX(int[][] mat, int n, int m, int x){    for(int i=0, j=m-1; (i!=n)&amp;&amp;(j!=-1); ) //起始位置(i,j)从矩阵右上角开始    {        if(x&gt;mat[i][j]) //目标值大于矩阵元素，向下走            i++;        else if(x &lt; mat[i][j])  //目标值小于矩阵元素，向左走            j--;        else if(x == mat[i][j])            return true;    }    return false;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题</title>
      <link href="/2018/09/21/sword-offer-algorithm/"/>
      <url>/2018/09/21/sword-offer-algorithm/</url>
      
        <content type="html"><![CDATA[<p>此文档包含剑指offer书上所有题目，部分简单的题目没有总结。其中涉及leetcode相关题目也进行对比记录，尽量都留存了最优解。同时牛客网上有剑指offer专题oj，可在上面进行练习验证。</p><a id="more"></a><h1 id="一、题目总览"><a href="#一、题目总览" class="headerlink" title="一、题目总览"></a>一、题目总览</h1><table><thead><tr><th align="center">编号</th><th align="center">题目</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">找出数组中重复的数字</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">不修改数组找出重复的数字</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">0~n-1中缺失的数字(2道)</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">数组中数字出现的次数(3道)</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">数组中出现次数超过一半的数字</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">数组中出现次数超过1/3的数字</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">统计指定数字在排序数组中出现的次数</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">二维数组中的查找</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">替换空格</a></td></tr><tr><td align="center">10</td><td align="center"><a href="#10">Replace Words–字典树</a></td></tr><tr><td align="center">11</td><td align="center"><a href="#11">Find And Replace in String</a></td></tr><tr><td align="center">12</td><td align="center"><a href="#12">从尾到头打印链表</a></td></tr><tr><td align="center">13</td><td align="center"><a href="#13">反转链表(三道)</a></td></tr><tr><td align="center">14</td><td align="center"><a href="#14">重建二叉树</a></td></tr><tr><td align="center">15</td><td align="center"><a href="#15">二叉树的下一个节点</a></td></tr><tr><td align="center">16</td><td align="center"><a href="#16">Populating Next Right Pointers in Each Node</a></td></tr><tr><td align="center">17</td><td align="center"><a href="#717">Populating Next Right Pointers in Each Node II</a></td></tr><tr><td align="center">18</td><td align="center"><a href="#18">两个栈实现队列</a></td></tr><tr><td align="center">19</td><td align="center"><a href="#19">两个队列实现栈</a></td></tr><tr><td align="center">20</td><td align="center"><a href="#20">斐波那契数列(三道)</a></td></tr><tr><td align="center">21</td><td align="center"><a href="#21">斐波那契数列变种_medium难度(两道)</a></td></tr><tr><td align="center">22</td><td align="center"><a href="#22">Additive Number</a></td></tr><tr><td align="center">23</td><td align="center"><a href="#23">旋转数组的最小数字(三道)</a></td></tr><tr><td align="center">24</td><td align="center"><a href="#24">矩阵中的路径</a></td></tr><tr><td align="center">25</td><td align="center"><a href="#25">机器人的运动范围</a></td></tr><tr><td align="center">26</td><td align="center"><a href="#26">Unique Paths(两道)</a></td></tr><tr><td align="center">27</td><td align="center"><a href="#27">剪绳子</a></td></tr><tr><td align="center">28</td><td align="center"><a href="#28">不用加减乘除做加法(位运算)</a></td></tr><tr><td align="center">29</td><td align="center"><a href="#29">Two Sum</a></td></tr><tr><td align="center">30</td><td align="center"><a href="#30">二进制中1的个数</a></td></tr><tr><td align="center">31</td><td align="center"><a href="#31">数值的整数次方</a></td></tr><tr><td align="center">32</td><td align="center"><a href="#32">打印从1到最大的n位数</a></td></tr><tr><td align="center">33</td><td align="center"><a href="#33">删除链表中重复的节点(两道)</a></td></tr><tr><td align="center">34</td><td align="center"><a href="#34">正则表达式匹配</a></td></tr><tr><td align="center">35</td><td align="center"><a href="#35">表示数值的字符串</a></td></tr><tr><td align="center">36</td><td align="center"><a href="#36">调整数组顺序使奇数位于偶数前面(3道)</a></td></tr><tr><td align="center">37</td><td align="center"><a href="#37">链表中倒数第k个结点(两道)</a></td></tr><tr><td align="center">38</td><td align="center"><a href="#38">判断链表是否有环(两道)</a></td></tr><tr><td align="center">39</td><td align="center"><a href="#39">两个单链表相交的第一个公共节点(2道)</a></td></tr><tr><td align="center">40</td><td align="center"><a href="#40">合并两个排序的链表</a></td></tr><tr><td align="center">41</td><td align="center"><a href="#41">树的子结构</a></td></tr><tr><td align="center">42</td><td align="center"><a href="#42">二叉树的翻转(镜像)与对称(2道)</a></td></tr><tr><td align="center">43</td><td align="center"><a href="#43">顺时针打印矩阵</a></td></tr><tr><td align="center">44</td><td align="center"><a href="#44">包含min函数的栈</a></td></tr><tr><td align="center">45</td><td align="center"><a href="#45">栈的压入、弹出序列</a></td></tr><tr><td align="center">46</td><td align="center"><a href="#46">二叉树的层序遍历(3道)</a></td></tr><tr><td align="center">47</td><td align="center"><a href="#47">递归与非递归实现二叉树前序、中序、后序遍历</a></td></tr><tr><td align="center">48</td><td align="center"><a href="#48">判断数组是否为二叉搜索树的后续遍历序列</a></td></tr><tr><td align="center">49</td><td align="center"><a href="#49">二叉树中和为某一值的路径</a></td></tr><tr><td align="center">50</td><td align="center"><a href="#50">复杂链表的复制</a></td></tr><tr><td align="center">51</td><td align="center"><a href="#51">二叉搜索树与双向链表(两道)</a></td></tr><tr><td align="center">52</td><td align="center"><a href="#52">序列化二叉树</a></td></tr><tr><td align="center">53</td><td align="center"><a href="#53">全排列问题(五道)</a></td></tr><tr><td align="center">54</td><td align="center"><a href="#54">打印出给定字符串中字符的所有组合</a></td></tr><tr><td align="center">55</td><td align="center"><a href="#55">大/小根堆–优先队列实现(两道)</a></td></tr><tr><td align="center">56</td><td align="center"><a href="#56">数据流中的中位数</a></td></tr><tr><td align="center">57</td><td align="center"><a href="#57">数组中最大连续子序列的和</a></td></tr><tr><td align="center">58</td><td align="center"><a href="#58">1到n整数中1出现的次数</a></td></tr><tr><td align="center">59</td><td align="center"><a href="#59">正整数序列中的第n个数字</a></td></tr><tr><td align="center">60</td><td align="center"><a href="#60">把数组排成最小的数</a></td></tr><tr><td align="center">61</td><td align="center"><a href="#61">求把一个数字翻译成不同字符串的个数(DP)</a></td></tr><tr><td align="center">62</td><td align="center"><a href="#62">礼物的最大价值</a></td></tr><tr><td align="center">63</td><td align="center"><a href="#63">最长不含重复的子字符串长度</a></td></tr><tr><td align="center">64</td><td align="center"><a href="#64">丑数(两道)</a></td></tr><tr><td align="center">65</td><td align="center"><a href="#65">第一个只出现一次的字符</a></td></tr><tr><td align="center">66</td><td align="center"><a href="#66">归并排序相关(3道)</a></td></tr><tr><td align="center">67</td><td align="center"><a href="#67">二叉搜索树的第k小节点(中序遍历)</a></td></tr><tr><td align="center">68</td><td align="center"><a href="#68">二叉树的深度(两道)</a></td></tr><tr><td align="center">69</td><td align="center"><a href="#69">数组中和为s的数字(四道)</a></td></tr><tr><td align="center">70</td><td align="center"><a href="#70">翻转字符串(两道)</a></td></tr><tr><td align="center">71</td><td align="center"><a href="#71">滑动窗口的最大值(双端队列)</a></td></tr><tr><td align="center">72</td><td align="center"><a href="#72">打印n个骰子所有可能的点数和及概率</a></td></tr><tr><td align="center">73</td><td align="center"><a href="#73">扑克牌中的顺子(2道)</a></td></tr><tr><td align="center">74</td><td align="center"><a href="#74">圆圈中剩下的数(约瑟夫环问题)</a></td></tr><tr><td align="center">75</td><td align="center"><a href="#75">股票的最大利润问题(四道)</a></td></tr><tr><td align="center">76</td><td align="center"><a href="#76">求1+2+3+…+n(不用if而用或短路的方式结束递归)</a></td></tr><tr><td align="center">77</td><td align="center"><a href="#77">构建乘积数组</a></td></tr><tr><td align="center">78</td><td align="center"><a href="#78">普通二叉树中两个节点的最低公共祖先</a></td></tr><tr><td align="center">79</td><td align="center"><a href="#79">把字符串转换成整数</a></td></tr></tbody></table><h1 id="二、题目及解答"><a href="#二、题目及解答" class="headerlink" title="二、题目及解答"></a>二、题目及解答</h1><p><a name="1"></a></p><h2 id="1-找出数组中重复的数字"><a href="#1-找出数组中重复的数字" class="headerlink" title="1.找出数组中重复的数字"></a>1.找出数组中重复的数字</h2><pre><code>LeetCode 217：Contains Duplicate LeetCode 219：Contains Duplicate II LeetCode 220：Contains Duplicate III LeetCode 287：Find the Duplicate Number</code></pre><h3 id="1-《剑指offer》p39、leetcode-287"><a href="#1-《剑指offer》p39、leetcode-287" class="headerlink" title="1.《剑指offer》p39、leetcode 287"></a>1.《剑指offer》p39、leetcode 287</h3><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>思路：交换法、映射。数组不重复的情形是array[i]=i。遍历数组元素，元素值为m时，与array[m]的值作对比，如果相同则重复了，返回即可，否则二者交换，继续比较，直到遍历完数组。时间o(n)，空间o(1)</p><pre><code class="java">public class Solution {    public boolean duplicate(int numbers[],int length,int [] duplication) {        for(int i=0; i&lt;length; ++i){            while(numbers[i]!=i){//注意这里是while                if(numbers[numbers[i]]==numbers[i]){                    duplication[0] = numbers[i];                    return true;                }else{                    swap(numbers, i, numbers[i]);                }            }        }        return false;    }    public void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><h3 id="2-LeetCode-217：Contains-Duplicate"><a href="#2-LeetCode-217：Contains-Duplicate" class="headerlink" title="2.LeetCode 217：Contains Duplicate"></a>2.LeetCode 217：Contains Duplicate</h3><p>题目：Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><pre><code>Input: [1,2,3,1]Output: true</code></pre><p>思路：</p><p>1）将数组排序，判断前后两个元素是否一样，如果一样则返回true，否则返回false； </p><p>2）方法（1）对数组进行排序，改变了数组元素的位置；若要求不能修改数组元素，可以创建一个辅助HashSet，判断HashSet中是否已经存在该元素，存在则返回true，否则返回false，并将其加入在HashSet中。</p><pre><code class="java">//法一：排序(改变了位置,时间o(nlogn)，空间o(1))public boolean containsDuplicate(int[] nums) {    Arrays.sort(nums);    for(int i=0; i&lt;nums.length-1; ++i){        if(nums[i+1]==nums[i]){            return true;        }    }    return false;}//法二：hashSet(不改变位置，时间o(n),空间o(n))public boolean containsDuplicate2(int[] nums) {    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();    for(int num: nums){        if(!set.add(num)){            return true;        }    }    return false;}</code></pre><h3 id="3-LeetCode-219：Contains-Duplicate-II"><a href="#3-LeetCode-219：Contains-Duplicate-II" class="headerlink" title="3.LeetCode 219：Contains Duplicate II"></a>3.LeetCode 219：Contains Duplicate II</h3><p>题目：给定一个数组nums和一个整数k，是否存在两个不相等的整数 i 和 j，使得nums[i] == nums[j]，并且i和j之间的距离最多为k。</p><pre><code>Input: nums = [1,2,3,1], k = 3Output: trueInput: nums = [1,0,1,1], k = 1Output: trueInput: nums = [1,2,3,1,2,3], k = 2Output: false</code></pre><p>思路：辅助map存储数组元素值-元素索引，遍历数组即可，时间o(n)，空间o(n)</p><pre><code class="java">public boolean containsNearbyDuplicate(int[] nums, int k) {    //值-索引    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        if(map.containsKey(nums[i]) &amp;&amp; (i-map.get(nums[i]))&lt;=k){//找到重复            return true;        }else{            map.put(nums[i], i);//更新键值对        }    }    return false;}</code></pre><h3 id="4-LeetCode-220：Contains-Duplicate-III"><a href="#4-LeetCode-220：Contains-Duplicate-III" class="headerlink" title="4.LeetCode 220：Contains Duplicate III"></a>4.LeetCode 220：Contains Duplicate III</h3><p>题目：给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。</p><p>思路：维持一个大小为k的窗口，由左向右在nums中移动。对于nums[i]，只要查找其之前的元素中是否存在大小范围在[nums[i] - t,nums[i] + t]的元素，如果存在就返回true。还要注意整数的溢出问题，Long</p><pre><code class="java">//使得nums [i]和nums [j]之间的绝对差值不超过为t，i和j之间的绝对差值不超过ķ。//思路：treeset滑窗保存有序元素//treeset.ceiling--返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null//treeset.floor--返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 nullpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {    if (nums == null || nums.length == 0 || k &lt;= 0){        return false;    }    TreeSet&lt;Long&gt; treeSet = new TreeSet&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        if(i&gt;k){//超过滑窗k，删除treeset中的一个元素            treeSet.remove((long)nums[i-k-1]);        }        Long left = treeSet.ceiling((long)nums[i]-t);        Long right = treeSet.floor((long)nums[i]+t);        if(left!=null &amp;&amp; right!=null &amp;&amp; right&gt;=left){            return true;        }        treeSet.add((long)nums[i]);    }    return false;}</code></pre><p><a name="2"></a></p><h2 id="2-不修改数组找出重复的数字"><a href="#2-不修改数组找出重复的数字" class="headerlink" title="2.不修改数组找出重复的数字"></a>2.不修改数组找出重复的数字</h2><p>《剑指offer》p41. </p><p>题目：在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。</p><p>第一种思路：与题目1思路相似，利用哈希表，创建一个相同长度的辅助数组，将数组元素存在对应辅助数组下标处，很容易发现重复的数字。辅助空间O(n)</p><p>思路：二分查找。若有重复出现，则数字的个数会大于区间的长度，O(nlogn)、O(1)。</p><p>详细思路：如果数组中有重复的数，那么n+1个0~n范围内的数中，一定有几个数的个数大于1。那么，我们可以利用这个思路解决该问题。</p><p>我们把从1<del>n的数字从中间的数字m分为两部分，前面一半为1</del>m，后面一半为m+1<del>n。如果1</del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，反之，如果大于m，那么这一半的区间一定包含重复的数字；如果小于m，另一半m+1~n的区间里一定包含重复的数字。接下来，我们可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。</p><p>由于如果1<del>m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，我们可以逐步减少m，然后判断1</del>m之间是否有重复的数，即，我们可以令m=m-1，然后再计算1<del>m的数字的数目是否等于m，如果等于m，再令m=m-1，如果大于m，则说明1</del>m的区间有重复的数，如果小于m，则说明m+1~n有重复的数，不断重复此过程。</p><pre><code class="java">/** * FileName: Hello * Author:   braincao * Date:     2018/8/29 15:21 * Description: 《剑指offer》P41.不修改数组找出重复的数字 */public class Hello{    public static void main(String[] args){        int[] c = new int[]{2,3,3,5,5,2,6,7};        System.out.println(getDuplication(c,8));    }    static int getDuplication(int[] array, int length){        int left = 1;        int right = array.length - 1;        while(left&lt;=right) {            int mid = (left + right) / 2;            int cnt = count(array, length, left, mid);            if (left == right) {                if (cnt &gt; 1)                    return left;                else                    break;            }            if (cnt &gt; (mid - left + 1)) {                right = mid;            } else {                left = mid + 1;            }        }        return -1;    }    static int count(int[] array, int length, int start, int end){        int cnt = 0;        for(int i=0; i&lt;length; ++i){            if(array[i]&gt;=start &amp;&amp; array[i]&lt;=end){                cnt++;            }        }        return cnt;    }}</code></pre><p><a name="3"></a></p><h2 id="3-0-n-1中缺失的数字-2道"><a href="#3-0-n-1中缺失的数字-2道" class="headerlink" title="3.0~n-1中缺失的数字(2道)"></a>3.0~n-1中缺失的数字(2道)</h2><pre><code>0~n-1中缺失的数字(数组有序)--《剑指offer》p2660~n-1中缺失的数字(数组无序)--leetcode 268</code></pre><h3 id="1-0-n-1中缺失的数字-数组有序"><a href="#1-0-n-1中缺失的数字-数组有序" class="headerlink" title="1.0~n-1中缺失的数字(数组有序)"></a>1.0~n-1中缺失的数字(数组有序)</h3><p>《剑指offer》p266</p><p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0<del>n-1之内。在范围0</del>n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>思路：排序数组，问题转换成找出第一个下标与值不等的那个下标对应的数，显然是二分查找，时间o(logn)</p><pre><code class="java">//0~n-1中缺失的数字(数组有序)。思路：利用二分查找查找第一个nums[i]!=i的数字public static int findLostNumber(int[] arr){    int left = 0;    int right = arr.length-1;    while(left&lt;=right){        int mid = left+(right-left)/2;        if(arr[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找            left = mid+1;        }        else if(arr[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素            if(mid==left || (mid&gt;left&amp;&amp;arr[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的                return mid;            }            else{//往左边找                right = mid-1;            }        }    }    return arr.length;//之前的都相符，说明缺失的数字在最右边}public static void main(String[] args){    int[] nums = new int[]{0,1,2,3,4,5,7,8,9};//0~9一共10个数，数组长度为9，缺失的数字为6    System.out.println(findLostNumber(nums));}</code></pre><h3 id="2-0-n-1中缺失的数字-数组无序"><a href="#2-0-n-1中缺失的数字-数组无序" class="headerlink" title="2.0~n-1中缺失的数字(数组无序)"></a>2.0~n-1中缺失的数字(数组无序)</h3><p>leetcode 268</p><p>题目：Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p><pre><code>Input: [3,0,1]Output: 2Input: [9,6,4,2,3,5,7,0,1]Output: 8</code></pre><p>这道题的几种思路如下：</p><pre><code>1. 二分查找(not good)把数组排序，用二分查找来找到缺失值。时间o(nlogn)1. 累加(good)计算1+2+...+n. 用和值减去数组中数的和值，最后的差就是我们要的结果。这个过程中要防止溢出。3. 异或(best)异或运算有一个性质，x^y^y=x. 结果与x和y的顺序无关。我们把0～n与数组中的数都异或到一起，那么最后的结果就是缺失的那个数。</code></pre><p>法一(不好)：先排序，再利用二分查找找第一个下标不符的元素，时间o(nlogn)，代码如下：</p><pre><code class="java">public int missingNumber(int[] nums) {    Arrays.sort(nums);//先排序    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left+(right-left)/2;        if(nums[mid]==mid){//nums[i]==i说明该元素与下标相符，往右边找            left = mid+1;        }        else if(nums[mid]!=mid) {//nums[i]!=i说明该元素与下标不符，应该往左边找或者就是当前元素            if(mid==left || (mid&gt;left&amp;&amp;nums[mid-1]==mid-1) ){//该元素左边元素与下标相符，说明该元素是第一个不符的                return mid;            }            else{//往左边找                right = mid-1;            }        }    }    return nums.length;//之前的都相符，说明缺失的数字在最右边}</code></pre><p>法二忽略</p><p>法三(更好)：<strong>异或性质。0～n与数组中的数都异或到一起，最后的结果即为所求的缺失数字</strong>，代码如下：</p><pre><code class="java">public int missingNumber(int[] nums) {    int res = 0;    for(int i=0; i&lt;nums.length; ++i){        res ^= i;        res ^= nums[i];    }    return res^nums.length;}</code></pre><p><a name="4"></a></p><h2 id="4-数组中数字出现的次数-3道"><a href="#4-数组中数字出现的次数-3道" class="headerlink" title="4.数组中数字出现的次数(3道)"></a>4.数组中数字出现的次数(3道)</h2><p>《剑指offer》p275、leetcode 260、leetcode 136、leetcode 137、leetcode 540</p><p>题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。</p><p>思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求</p><p>题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。</p><p>思路2：</p><pre><code>​1.所有数字异或;​2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);​3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)​</code></pre><p>题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字</p><p>思路3：</p><pre><code>1.这里不能用异或了，但是还是考虑位运算思路;2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除,则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为13.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好</code></pre><p>代码：</p><pre><code class="java">/** * 题目1：一个整型数组里只有一个数字出现了一次，其余数字都出现了两次，找出唯一一个一个出现了一次的数字。 * 思路1：利用异或运算的性质：异或运算相同为0，相异为1。将数组所有数字异或，最后的数字即为所求 * * 题目2：一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。找出这两个只出现一次的数字。 * 思路2：1.所有数字异或; *       2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中); *       3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次) * * 题目3：数组中唯一只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字 * 思路3：1.这里不能用异或了，但是还是考虑位运算思路; *       2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除， *         则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1 *       3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好 */public class Solution {    //题目1：找出唯一一个一个出现了一次的数字--&gt;所有数字异或    public static int findSingleNumber(int[] arr){        int res = 0;        for(int i: arr){            res ^= i;        }        return res;    }    /**     * 题目2：找出这两个只出现一次的数字--&gt;     * 1.所有数字异或;     * 2.将最后的数字从右往左首位出现的1分为1、0两组(所求两个数字分别在两个组中);     * 3.两组数字再分别进行异或，剩下的两个数即为所求(在每组中两个所求数字都只出现了一次)     */    public static int[] findSingleNumber2(int[] arr){        int tempRes = 0;        for(int i: arr){//1.将数组所有数字异或            tempRes ^= i;        }        int k=1;//2.找出tempRes从右往左首个1出现在第k位        while(tempRes!=0){            if((tempRes&amp;1) == 1){ //出现了首个1                break;            }            else{//还没出现首个1                k++;                tempRes = tempRes&gt;&gt;1;            }        }        int groupOne = 0;//3.将原数组数字分组，并在每个组中找出只出现一个的数字        int groupTwo = 0;        for(int i: arr){            int bit = (i&gt;&gt;(k-1)) &amp; 1; //该数的第k位是bit            if(bit==1){                groupOne ^= i;            }            else{                groupTwo ^= i;            }        }        return new int[]{groupOne, groupTwo};    }    /**     * 题目3：找出这两个只出现一次的数字。在一个数组中除一个数字只出现一次之外，其他数字都出现了三次，找出那个只出现一次的数字--&gt;     * 1.这里不能用异或了，但是还是考虑位运算思路;     * 2.将数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，     *   则所求只出现一次的数字二进制表示中对应的哪一位是0，否则即为1     * 3.位运算的好处时间o(n)，空间长度32的数组o(1)，比排序o(nlogn)o(1)、哈希o(n)o(n)都好     */    public static int findSingleNumber3(int[] arr) {        int[] bits = new int[32]; //int类型4字节，32位        for(int number: arr){//将数组中所有数字的二进制表示的每一位都加起来，每一位的和存在bits数组中            for(int i=0; i&lt;32; ++i){ //从个位到第32位依次相加存储                bits[i] += (number&gt;&gt;i)&amp;1; //数字number的第i位上的数            }        }        int res = 0;        for(int i=0; i&lt;32; ++i) { //把bits每一位上的数%3，如果为0，则所求的数该位也为0，否则为1            res += ((bits[i]%3)&lt;&lt;i);        }        return res;    }    public static void main(String[] args){        int[] arr = {1,2,1,2,3};//找出一个出现一次的数字        int[] arr2 = {1,2,1,2,3,4}; //找出两次出现一次的数字        int[] arr3 = {1,2,1,1,2,5,2}; //找出两次出现一次的数字        System.out.println(findSingleNumber(arr));//找出一个出现一次的数字。out:3        System.out.println(findSingleNumber2(arr2)[0] + &quot; &quot; + findSingleNumber2(arr2)[1]);//找出两次出现一次的数字。out:3,4        System.out.println(findSingleNumber3(arr3));//找出这两个只出现一次的数字，其他都出现三次。out:5    }}</code></pre><p><a name="5"></a></p><h2 id="5-数组中出现次数超过一半的数字"><a href="#5-数组中出现次数超过一半的数字" class="headerlink" title="5.数组中出现次数超过一半的数字"></a>5.数组中出现次数超过一半的数字</h2><p>《剑指offer》p205、leetcode 169</p><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p>思路：</p><p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p><p>法二_更简单高效的方法：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p><p>法一：排序后位于数组中间的数即为所求。这里不排序的话，就利用partition找中位数即可—&gt;o(n)</p><pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {    int len = array.length;    int middle = len/2;    int left = 0;    int right = len-1;    int index = partition(array, left, right, left);    while(index != middle){//如果不是中位数        if(index &lt; middle){//说明中位数在index的右边            left = index + 1;            index = partition(array, left, right, left);        }        else if(index &gt; middle){//说明中位数在index的左边            right = index - 1;            index = partition(array, left, right, left);        }    }    //现在array[index]是中位数了    int res = 0;    if(check(array, array[index])){//检查array[index]是否真的出现次数超过一半，不超过返回0        res = array[index];    }    return res;}public static int partition(int[] arr, int left, int right, int pivotIndex){    int pivot = arr[pivotIndex];    swap(arr, pivotIndex, right);    int storeIndex = left;    for(int i=left; i&lt;=right; i++){        if(arr[i] &lt; pivot){            swap(arr, i, storeIndex);            storeIndex++;        }    }    swap(arr, storeIndex, right);    return storeIndex;}public static boolean check(int[] arr, int key){//经过算法后求出的数，再次进行检查看看是否真的超过一半，不符合条件res=0    int times = 0;    for(int i=0; i&lt;arr.length; ++i){        if(arr[i] == key){            times++;        }    }    if(times &gt; (arr.length/2)){        return true;    }    return false;}public static void swap(int[] arr, int i, int j){    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p>法二：利用两个辅助变量num、times来计数，遍历一遍，最后的num即为所求—&gt;o(n)</p><pre><code class="java">public static int MoreThanHalfNum_Solution(int [] array) {    if(array==null || array.length==0){        return 0;    }    if(array.length==1){        return array[0];    }    int times = 1;    int num = array[0];    for(int i=1; i&lt;array.length; ++i){        if(array[i]==num){            times++;        }        else{            times--;            if(times==0){                times = 1;                num = array[i];            }        }    }    if(times&gt;1){//一定是        return num;    }    if(times==1){//有可能不是，再重新检查该数出现次数是否超过数组长度一半，不超过返回0        int temp = 0;        for(int i=0; i&lt;array.length; ++i){            if(array[i]==num){                temp++;            }        }        if(temp &gt; (array.length)/2){            return num;        }    }    return 0;}public static void main(String[] args){    int[] array = new int[]{2,2,2,2,2,1,3,4,5};    System.out.println(MoreThanHalfNum_Solution(array));}</code></pre><p><a name="6"></a></p><h2 id="6-数组中出现次数超过1-3的数字"><a href="#6-数组中出现次数超过1-3的数字" class="headerlink" title="6.数组中出现次数超过1/3的数字"></a>6.数组中出现次数超过1/3的数字</h2><p>leetcode 229</p><p>题目：Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space.</p><p>给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)</p><pre><code>Input: [3,2,3]Output: [3]Input: [1,1,1,3,3,2,2,2]Output: [1,2]</code></pre><p>思路：每次从nums中拿出3个不一样的数作为一组，肯定会出现两种情况。一，nums被取空了，那么nums中每个数出现次数最多占总次数的1/3，不存在超过1/3的数字；二，还有剩余，这个情况就复杂了，有可能剩余多个，但是……但是，<strong>最多只可能剩余两种数</strong>。 为什么？ 3个不同的数凑一组才能删掉，所以不可能删掉超过1/3的数。所以超过1/3的数肯定被剩下来，但是，<strong>剩下来的俩数并不一定都是超过1/3的</strong>，这点额外注意。 很容易举个例子， 比如</p><p><code>1 1 1 1 1 2 2 3 3 4 4 5--最后剩1,4--&gt;只有1是结果</code></p><p>我们把原问题转换为如何快速高效的从数组中每次去掉3个不同的数，最后把剩下的两个不同的数保存起来，重新遍历数组判断即可。</p><p>代码实现：用a,b表示两种不同的数，用计数器cnta,cntb表示a,b不同的数出现的次数来计数，在遍历数组的过程中计数抵消，看他们俩最终还剩下多少个。</p><pre><code class="java">//给你一个数组nums，如何找nums中出现次数超过总数的1/3的数，要求时间复杂度O(N)和空间复杂度O(1)//思路：遍历数组，每次抵消三个不同的数，最后剩下的2个数重新遍历数组判断。public List&lt;Integer&gt; majorityElement(int[] nums) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    int a = nums[0];    int b = nums[0];//a,b存两种不同的数    int cnta = 0;    int cntb = 0;//cnta,cntb对a,b两种不同的数出现次数的计数，当计数为0时，重置a/b    for(int num: nums){//遍历字符串        if(a==num){            cnta++;            continue;        }        if(b==num){            cntb++;            continue;        }        if(cnta==0){//a的计数为0，重置a            a = num;            cnta = 1;            continue;        }        if(cntb==0){//b的计数为0，重置b            b = num;            cntb = 1;            continue;        }        cnta--;        cntb--;//当前的num和a,b都不同，则一起抵消    }    cnta = 0;    cntb = 0;    //最后剩下的有a,b,重新遍历数组查看是否次数超过1/3    for(int num: nums){        if(num==a){            cnta++;        }        else if(num==b){            cntb++;        }    }    if(cnta&gt;(nums.length)/3){            res.add(a);    }    if(cntb&gt;(nums.length)/3){        res.add(b);    }    return res;}</code></pre><p><a name="7"></a></p><h2 id="7-统计指定数字在排序数组中出现的次数"><a href="#7-统计指定数字在排序数组中出现的次数" class="headerlink" title="7.统计指定数字在排序数组中出现的次数"></a>7.统计指定数字在排序数组中出现的次数</h2><p>《剑指offer》p263、leetcode 34</p><p>题目：统计一个数字在排序数组中出现的次数。</p><p>思路：</p><p>因为数组排序，很明显要用二分查找。</p><p>法一(不可取)，最差时间o(n)。先二分查找k在数组array中的索引，然后从该索引处向左向右外扩，找出所有相等的数。</p><p>法二(更好的方法)：充分利用二分查找直接找到第一个k和最后一个k，二者索引相减即为出现的个数。时间o(logn)</p><p>什么时候是第一个k：找到的k的前面一个元素如果不等于k，则此时是第一个k</p><p>什么时候是最后一个k：找到的k的后面一个元素如果不等于k，则此时是第一个k</p><pre><code class="java">//统计指定数字在排序数组中出现的次数。思路：充分利用二分查找第一个k和最后一个k的位置，两者的区间长度即为所求次数public static int GetNumberOfK(int [] array , int k) {    if(array==null || array.length==0){        return 0;    }    //二分查找左边第一个k的位置    int left = getFirst(array, k);    int right = getLast(array, k);    if(left==-1 || right==-1){//数组中没有k        return 0;    }    if(left&lt;=right){        return right-left+1;    }    return 0;}//二分查找第一个k的位置public static int getFirst(int[] nums, int k){    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left + (right-left)/2;        if(nums[mid]==k){            if( (mid&gt;left&amp;&amp;nums[mid-1]!=k) || mid==left){//找到第一个k                return mid;            }            else{//不是第一个k，继续往左边找                right = mid-1;            }        }        else if(nums[mid]&lt;k){//k在右边            left = mid+1;        }        else{//k在左边            right = mid-1;        }    }    return -1;//没找到k，返回-1}//二分查找最后一个k的位置public static int getLast(int[] nums, int k){    int left = 0;    int right = nums.length-1;    while(left&lt;=right){        int mid = left + (right-left)/2;        if(nums[mid]==k){            if( (mid&lt;right&amp;&amp;nums[mid+1]!=k) || mid==right){//找到最后一个k                return mid;            }            else{//不是最后一个k，继续往右边找                left = mid+1;            }        }        else if(nums[mid]&lt;k){//k在右边            left = mid+1;        }        else{//k在左边            right = mid-1;        }    }    return -1;//没找到k，返回-1}public static void main(String[] args){    int[] nums = new int[]{1,2,3,4,5,5,5,5,5,5,5,7,8,11};//out:7    System.out.println(GetNumberOfK(nums, 5));}</code></pre><p><a name="8"></a></p><h2 id="8-二维数组中的查找"><a href="#8-二维数组中的查找" class="headerlink" title="8.二维数组中的查找"></a>8.二维数组中的查找</h2><p>《剑指offer》p44、leetcode74</p><p>题目：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：从二维数组右上角开始查找，因为从右上角/左下角开始比较的话若不相等可以删除不符合条件的一行或者一列</p><p>以右上角为例，若相等则返回true；若target比右上角大，说明目标在其下面，则删除所在行；若target比右上角小，说明目标在其左侧，则删除所在列</p><p>以左上角为例，若target比左上角大，则不能缩小范围，因为右侧和下侧的元素都比左上角，右下角同理，pass！</p><pre><code class="java">public boolean Find(int target, int [][] array) {    if(array==null || array.length==0){        return false;    }    int m = array.length-1;    if(array[0].length==0){        return false;    }    int n = array[0].length-1;    int i = 0;    int j = n;    while(i&lt;=m &amp;&amp; j&gt;=0){        if(array[i][j] == target){            return true;        }        else if(target&lt;array[i][j]){            j--;        }        else{            i++;        }    }    return false;}</code></pre><p><a name="9"></a></p><h2 id="9-替换空格"><a href="#9-替换空格" class="headerlink" title="9.替换空格"></a>9.替换空格</h2><p>《剑指offer》p51</p><p>题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br>思路：先遍历字符串计算空格出现次数，然后设置新数组大小，从后往前遍历数组，替换空格。</p><pre><code class="java">public class Solution {    public String replaceSpace(StringBuffer str) {        int cnt = 0;        for(int i=0; i&lt;str.length(); i++)        {            if(str.charAt(i)==&#39; &#39;)            {                cnt++;            }        }        int newLen = str.length() + cnt*2;        char[] newStr = new char[newLen];        int i = str.length()-1;        int j = newLen-1;        while(i&gt;=0){            if(str.charAt(i)==&#39; &#39;){                newStr[j--] = &#39;0&#39;;                newStr[j--] = &#39;2&#39;;                newStr[j--] = &#39;%&#39;;            }            else{                newStr[j--] = str.charAt(i);            }            i--;        }        return new String(newStr);    }}</code></pre><p><a name="10"></a></p><h2 id="10-Replace-Words–字典树"><a href="#10-Replace-Words–字典树" class="headerlink" title="10.Replace Words–字典树"></a>10.Replace Words–字典树</h2><p>LeetCode 648. Replace Words 字典树练习</p><p>题目：In English, we have a concept called root, which can be followed by some other words to form another longer word - let’s call this word successor. For example, the root an, followed by other, which can form another word another.</p><p>Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with theroot forming it. If a successor has many roots can form it, replace it with the root with the shortest length.</p><p>You need to output the sentence after the replacement.</p><p>Example 1:</p><pre><code>Input: dict = [&quot;cat&quot;, &quot;bat&quot;, &quot;rat&quot;]sentence = &quot;the cattle was rattled by the battery&quot;Output: &quot;the cat was rat by the bat&quot;</code></pre><p>题意：用字典中存在的前缀代替句子中的单词，若有多个前缀可以表示单词，则选择最短的一个<br>​<br>暴力思路：1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根(换长度最小的那个); 2.将words数组重新组成sentence返回即可</p><pre><code class="java">class Solution {    public String replaceWords(List&lt;String&gt; dict, String sentence) {        //1.将sentence分成words数组，每个单词进行前缀判断，有词根的换成词根        String[] words = sentence.split(&quot; &quot;);        for(int i=0; i&lt;words.length; ++i){            int min = Integer.MAX_VALUE;            for(String root: dict){                if(words[i].startsWith(root) &amp;&amp; root.length()&lt;min){                    words[i] = root;                }            }        }        //2.将words数组重新组成sentence返回即可        StringBuilder res = new StringBuilder();        for(int i=0; i&lt;words.length; ++i){            res.append(words[i] + &quot; &quot;);        }        return res.toString().trim();    }}</code></pre><p>优化思路(字典树):这道题给了我们一个前缀字典，又给了一个句子，让我们将句子中较长的单词换成其前缀(如果在前缀字典中存在的话)。我们对于句子中的一个长单词如何找前缀呢，是不是可以根据第一个字母来快速定位呢，比如cattle这个单词的首字母是c，那么我们在前缀字典中找所有开头是c的前缀，为了方便查找，我们<strong>将首字母相同的前缀都放到同一个数组中，总共需要26个数组</strong>，所以我们可以定义一个二维数组来装这些前缀。还有，我们希望短前缀在长前缀的前面，因为题目中要求用最短的前缀来替换单词，所以我们可以<strong>先按单词的长度来给所有的前缀排序</strong>，然后再依次加入对应的数组中，这样就可以保证短的前缀在前面。</p><p>提交显示暴力思路50ms，优化思路19ms，优化的还不错。</p><pre><code class="java">public static String replaceWords(List&lt;String&gt; dict, String sentence) {    //1.roots数组按长度排序    Collections.sort(dict);    //2.构建字典树，采用HashMap，用首字母索引，首字母相同的前缀都放到同一个数组中，总共需要26个数组    Map&lt;Integer, ArrayList&lt;String&gt;&gt; wordTree = new HashMap&lt;&gt;();    for(int i=0; i&lt;dict.size(); ++i){        int wordIndex =  dict.get(i).charAt(0)-&#39;a&#39;;        if(!wordTree.containsKey(wordIndex)){            wordTree.put(wordIndex, new ArrayList&lt;String&gt;());        }        wordTree.get(wordIndex).add(dict.get(i));    }    //3.将sentencesplit(&quot; &quot;)分成words单词数组，每个单词通过字典树进行前缀判断，有词根的换成词根    String[] words = sentence.split(&quot; &quot;);    for(int i=0; i&lt;words.length; ++i){        int wordIndex = words[i].charAt(0)-&#39;a&#39;;        if(wordTree.containsKey(wordIndex)){            for(int j=0; j&lt;wordTree.get(wordIndex).size(); ++j){                if(words[i].startsWith(wordTree.get(wordIndex).get(j))){                    words[i] = wordTree.get(wordIndex).get(j);                }            }        }    }    //4.将words数组重新组成sentence返回即可    StringBuilder res = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        res.append(words[i] + &quot; &quot;);    }    return res.toString().trim();}</code></pre><p><a name="11"></a></p><h2 id="11-Find-And-Replace-in-String"><a href="#11-Find-And-Replace-in-String" class="headerlink" title="11.Find And Replace in String"></a>11.Find And Replace in String</h2><p>LeetCode 833. Find And Replace in String</p><p>题目：To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p><p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing.</p><p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p><p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p><p>All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p><p>Example 1:</p><pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeebffff&quot;Explanation: &quot;a&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;.&quot;cd&quot; starts at index 2 in S, so it&#39;s replaced by &quot;ffff&quot;.</code></pre><p>Example 2:</p><pre><code>Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeecd&quot;Explanation: &quot;ab&quot; starts at index 0 in S, so it&#39;s replaced by &quot;eee&quot;. &quot;ec&quot; doesn&#39;t starts at index 2 in the original S, so we do nothing.</code></pre><p>题目大意：给了原始的字符串S，给出了要开始替换的位置indexes，判断S在indexes的位置向后是否能匹配sources中对应位置的元素，如果相等，则把S的该部分替换成targets对应的部分。</p><p>思路：</p><p>不可能直接对S进行替换操作的，因为那样直接改变了S的值和长度，影响以后的匹配操作。</p><p>而应该将原字符串S按照indexs拆分成几段子字符串，然后分别进行替换，最终拼接返回即可。同时应该从右往左处理原字符串，替换用replaceFirst()</p><p>将indexes按逆序排序，然后对S从右往左依次查找可替换的单词，如果出现在指定位置，则替换。由于indexes排序后，会变化，因此需要用map结构保存原来的索引。</p><pre><code class="java">public static String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {    if(S==null || S.length()==0){        return S;    }    //由于indexes排序后，会变化，因此需要用map结构保存原来的索引。    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:index[i] value:i    for(int i=0; i&lt;indexes.length; ++i){        map.put(indexes[i], i);    }    //将indexes按排序    Arrays.sort(indexes);    //将原字符串S按照indexs拆分成几段子字符串，然后分别进行判断    String[] words = new String[indexes.length+1];    //字符串从右往左处理，同时index也从最大到最小    for(int i=indexes.length-1; i&gt;=0; --i){        String last;//当前需要处理的子字符串，判断是否需要替换        if(i==indexes.length-1){            last = S.substring(indexes[i]);        }        else{            last = S.substring(indexes[i], indexes[i+1]);        }        int tempIndex = map.get(indexes[i]); //当前字符串对应的index        if(last.startsWith(sources[tempIndex])){            words[i+1] = last.replaceFirst(sources[tempIndex],targets[tempIndex]);        }        else{            words[i+1] = last;        }    }    words[0] = S.substring(0,indexes[0]).replaceFirst(sources[0],targets[0]);//最前面的字符串    //将替换完的words数组拼接成最终的字符串    StringBuilder res = new StringBuilder();    for(int i=0; i&lt;words.length; ++i){        res.append(words[i]);    }    return res.toString();}</code></pre><p><a name="12"></a></p><h2 id="12-从尾到头打印链表"><a href="#12-从尾到头打印链表" class="headerlink" title="12.从尾到头打印链表"></a>12.从尾到头打印链表</h2><p>《剑指offer》p58.</p><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>思路：</p><p>法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可</p><p>法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可</p><p>法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可</p><p>法四：递归实现，从头遍历链表，但是递归实现</p><pre><code class="java">//法一：从头遍历链表放进ArrayList中，最后Collections.reverse即可public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    ListNode p = listNode;    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    while(p!=null){        res.add(p.val);        p = p.next;    }    Collections.reverse(res);    return res;}//法二：反转链表(头插法)，之后从头遍历放进ArrayList中即可public ArrayList&lt;Integer&gt; printListFromTailToHead2(ListNode listNode) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(listNode==null){        return res;    }    ListNode p = listNode;    ListNode cur = p.next;    p.next = null;    while(cur!=null){        ListNode temp = cur;        cur = cur.next;        temp.next = p;        p = temp;    }    while(p!=null){        res.add(p.val);        p = p.next;    }    return res;}//法三：用栈辅助，从头遍历放进栈中，之后从栈弹出ArrayList中即可public ArrayList&lt;Integer&gt; printListFromTailToHead3(ListNode listNode) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(listNode==null){        return res;    }    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    ListNode p = listNode;    while(p!=null){        stack.push(p.val);        p = p.next;    }    while(!stack.isEmpty()){        res.add(stack.pop());    }    return res;}//法四：递归实现，从头遍历链表，但是递归实现ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; printListFromTailToHead4(ListNode listNode) {    if(listNode!=null){        printListFromTailToHead4(listNode.next);        res.add(listNode.val);    }    return res;}</code></pre><p><a name="13"></a></p><h2 id="13-反转链表-三道"><a href="#13-反转链表-三道" class="headerlink" title="13.反转链表(三道)"></a>13.反转链表(三道)</h2><h3 id="1-反转全部链表"><a href="#1-反转全部链表" class="headerlink" title="1.反转全部链表"></a>1.反转全部链表</h3><p>《剑指offer》p142、《左神》p40、leetcode206</p><p>题目：输入一个链表，反转链表后，输出新链表的表头。</p><p>思路：头插法</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode reverseList(ListNode head) {        if(head==null || head.next==null){            return head;        }        ListNode newHead = head;        head = head.next;        newHead.next = null; //这步别忘了        while(head!=null){            ListNode tempNode = head;            //原链表继续遍历下一个            head = head.next;            //头插法            tempNode.next = newHead;            newHead = tempNode;        }        return newHead;    }}</code></pre><h3 id="2-反转部分链表"><a href="#2-反转部分链表" class="headerlink" title="2.反转部分链表"></a>2.反转部分链表</h3><p>《左神》p42、leetcode92</p><p>题目：这道题目规定了要进行反转的位置区间。</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre><p>思路：我们要先<strong>添加一个哨兵</strong>，指向head节点（最后返回头指针的next即可）；然后一直往后访问，一直到要反转的节点的前一位停下来。</p><p>我们要<strong>记录下两个节点的位置</strong>：开始反转位置的节点的前一位、开始反转位置的节点。因为在反转后，开始反转的节点的前一个节点的next指针要指向反转的最后一个节点，开始反转的节点的next要指向反转的最后一个节点的后一个节点。</p><p>然后<strong>进行与上面一题同样的反转即可</strong>。</p><pre><code class="java">public ListNode reverseBetween(ListNode head, int m, int n) {    if(head==null || head.next==null || m&gt;=n || m&lt;=0){        return head;    }    //1.哨兵，这样不用考虑m==1从头反转的问题，都转化成从中间反转    ListNode guard = new ListNode(0);    guard.next = head;    ListNode p = guard;    //2..将p移到要反转部分的前一个节点，移动次数为m-1次    for(int i=1; i&lt;=m-1; ++i){        p = p.next;        if(p==null){//如果遍历完链表都没有加到m，则不需要反转            return head;        }    }    if(p.next==null || p.next.next==null){//需要反转的部分为空或者只有一个节点，则不需要反转        return head;    }    //3.保存反转部分的前一个节点    ListNode pre = p;    //4.反转部分链表(头插法)    p = p.next;    ListNode cur = p.next;    p.next=null;    ListNode last = p;//保存反转部分的最后一个节点    for(int i=m; i&lt;n; ++i){        ListNode temp = cur;        cur = cur.next;        temp.next = p;        p = temp;        if(cur==null){            break;        }    }    //5.拼接反转部分前，反转部分，反转部分后的链表    last.next = cur;    pre.next = p;    return guard.next;}</code></pre><h3 id="3-分组翻转链表"><a href="#3-分组翻转链表" class="headerlink" title="3.分组翻转链表"></a>3.分组翻转链表</h3><p>leetcode 25 Reverse Nodes in k-Group、《左神》68</p><p>题目：将链表的每k个节点逆序。给定一个单链表的头结点head，实现一个调整单链表的函数，使得每k个节点之间逆序，如果最后不管k个节点一组，则不调整最后几个节点。</p><p>Example:</p><pre><code>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></pre><p>思路：先遍历一次链表记录长度，然后分组进行翻转即可。</p><pre><code class="java">public ListNode reverseKGroup(ListNode head, int k) {    if(head==null || head.next==null || k&lt;2){        return head;    }    //1.遍历一遍链表记录链表长度    int len = 0;    ListNode p = head;    while(p!=null){        len++;        p = p.next;    }    //2.分组翻转链表    ListNode guard = new ListNode(0);//哨兵    guard.next = head;    ListNode pre = guard;//缓存翻转后的尾节点指针    ListNode cur = guard.next;//哨兵    ListNode last = cur;//缓存翻转后的尾节点指针    while(len&gt;=k){//翻转这么多次        len -= k;        int tempK = k;        while(tempK!=0){//每次翻转k个节点            ListNode temp = cur;            cur = cur.next;            temp.next = pre.next;//头插法            pre.next = temp;            tempK--;        }        last.next = cur;//翻转后的链表尾部连接到需要反转部分的下一个节点        pre = last;        last = cur;    }    return guard.next;}</code></pre><p><a name="14"></a></p><h2 id="14-根据前序-中序遍历数组来重建二叉树"><a href="#14-根据前序-中序遍历数组来重建二叉树" class="headerlink" title="14.根据前序+中序遍历数组来重建二叉树"></a>14.根据前序+中序遍历数组来重建二叉树</h2><p>《剑指offer》p62、leetcode105</p><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：在函数recon中，先根据前序遍历数组的第一个数字创建根节点，之后在中序遍历数组中找到根节点的位置，这样就能确定左、右子树节点的数量。在前序遍历和中序遍历数组中划分了左、右子树节点的值之后，就可以递归地调用函数recon去分别构建它的左、右子树。</p><pre><code class="java">class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) { val = x; }}public class Solution {    public TreeNode buildTree(int[] preorder, int[] inorder) {        if(preorder==null || preorder.length==0){            return null;        }        return recon(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);    }    //递归重建二叉树    public TreeNode recon(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd){        if(preStart&gt;preEnd || inStart&gt;inEnd){            return null;        }        TreeNode root = new TreeNode(preorder[preStart]);//前序遍历第一个节点为根节点        int rootIndex = findRootIndex(inorder, inStart, inEnd, root.val);//前序遍历的根节点在中序遍历数组的位置索引        int leftCnt = rootIndex-inStart;//左子树节点的个数        root.left = recon(preorder, preStart+1, preStart+leftCnt, inorder, inStart, rootIndex-1);        root.right = recon(preorder, preStart+leftCnt+1, preEnd, inorder, rootIndex+1, inEnd);        return root;    }    //找到根节点在中序遍历中的位置    public int findRootIndex(int[] order, int start, int end, int root){        int index = -1;        for(int i=start; i&lt;=end; ++i){            if(order[i]==root){                index = i;            }        }        return index;    }}</code></pre><p><a name="15"></a></p><h2 id="15-二叉树的下一个节点"><a href="#15-二叉树的下一个节点" class="headerlink" title="15.二叉树的下一个节点"></a>15.二叉树的下一个节点</h2><p>《剑指offer》p65.</p><p>题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p>思路：这个节点可以分为三种情况<br>​    </p><blockquote><p>1.该节点有右子树：下一个节点就是它的右子树中最左子节点</p><p>2.该节点没有右子树且是父节点的左子节点：下一个节点就是它的父节点</p><p>3.该节点没有右子树且是父节点的右子节点：沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点</p></blockquote><pre><code class="java">class TreeLinkNode {    int val;    TreeLinkNode left = null;    TreeLinkNode right = null;    TreeLinkNode next = null;    TreeLinkNode(int val) {        this.val = val;    }}public class Solution {    public TreeLinkNode GetNext(TreeLinkNode pNode)    {        if(pNode == null){            return null;        }        //如果该节点有右子树，返回其右子树中最左的子节点        if(pNode.right != null){            pNode = pNode.right;            while(pNode.left != null){                pNode = pNode.left;            }            return pNode;        }        //如果该节点没有右子树        while(pNode.next != null){            //该节点是父节点的左子节点，返回父节点            if(pNode.next.left== pNode){                return pNode.next;            }            //该节点是父节点的右子节点，沿着指向父节点的指针一直向上遍历，            // 直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是要找的下一个节点            pNode = pNode.next;        }        //如果第3中情况下一直向上遍历到根节点，则没有要找的下一个节点，返回null        return null;    }}</code></pre><p><a name="16"></a></p><h2 id="16-Populating-Next-Right-Pointers-in-Each-Node"><a href="#16-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="16.Populating Next Right Pointers in Each Node"></a>16.Populating Next Right Pointers in Each Node</h2><p>leetcode 116.</p><p>题目：Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><p>题目大意：将满二叉树每个节点的next指针赋值，每个节点的next指针指向同一层的下一个节点，要求空间复杂度是O(1)。本题的前提是给定的二叉树是满二叉树，即所有的叶子节点都在同一层。举例如下</p><p>原始：</p><pre><code>     1   /  \  2    3 / \  / \4  5  6  7</code></pre><p>变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \  / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre><p>思路：如果有下一层的话，为下一层的子节点的next指针赋值。每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器，并且不用递归，循环层即可完成</p><pre><code class="java">public void connect(TreeLinkNode root){    TreeLinkNode pRoot = root;    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点    while(pRoot!=null){//层的循环        guard.next=null;//哨兵，指向下一层的第一个节点        TreeLinkNode cur = guard;        if(pRoot.left!=null) {//如果有下层的话            while(pRoot!=null){//依次为下一层的每个节点next指针                cur.next = pRoot.left;                cur.next.next = pRoot.right;                cur = cur.next.next;                pRoot = pRoot.next;            }        }        pRoot = guard.next;//进入下一层的第一个节点    }}</code></pre><p><a name="17"></a></p><h2 id="17-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#17-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="17.Populating Next Right Pointers in Each Node II"></a>17.Populating Next Right Pointers in Each Node II</h2><p>leetcode 117.Populating Next Right Pointers in Each Node</p><p>题目：本题要求和上面一样，不同的是这里给定的二叉树不一定是满二叉树。You may only use constant extra space</p><p>原始：</p><pre><code>     1   /  \  2    3 / \    \4   5    7</code></pre><p>变为：</p><pre><code>     1 -&gt; NULL   /  \  2 -&gt; 3 -&gt; NULL / \    \4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre><p>思路：因为可能不是满二叉树而是任意二叉树，所以下一层的第一个节点需要手动寻找，我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个<strong>哨兵</strong>，代表下一层的第一个节点。本题的哨兵思想是解题利器</p><pre><code class="java">public void connect(TreeLinkNode root){    TreeLinkNode pRoot = root;    //我们要寻找下层的第一个节点first，为了避免这个寻找，每层都设置一个哨兵，代表第一个节点    TreeLinkNode guard = new TreeLinkNode(0);//哨兵，指向下一层的第一个节点    while(pRoot!=null){        guard.next=null;//哨兵，指向下一层的第一个节点        TreeLinkNode cur = guard;        while(pRoot!=null){//依次为下一层的节点next指针赋值            if(pRoot.left!=null){                cur.next = pRoot.left;                cur = cur.next;            }            if(pRoot.right!=null){                cur.next = pRoot.right;                cur = cur.next;            }            pRoot = pRoot.next;        }        pRoot = guard.next;//进入下一层(下一层的root从下一层的第一个节点guard.next开始)    }}</code></pre><p><a name="18"></a></p><h2 id="18-两个栈实现队列"><a href="#18-两个栈实现队列" class="headerlink" title="18.两个栈实现队列"></a>18.两个栈实现队列</h2><p>《剑指offer》p68、leetcode232、《左神》5</p><p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><pre><code class="java">import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();    //入队    public void push(int node) {        stack1.push(node);    }    //出队    public int pop() {        if(stack2.empty()){            while(!stack1.empty()){                stack2.push(stack1.pop());            }        }        return stack2.pop();    }}</code></pre><p><a name="19"></a></p><h2 id="19-两个队列实现栈"><a href="#19-两个队列实现栈" class="headerlink" title="19.两个队列实现栈"></a>19.两个队列实现栈</h2><p>《剑指offer》p71、leetcode225</p><p>题目：两个队列实现栈</p><pre><code class="java">class MyStack {    Queue&lt;Integer&gt; que1;    Queue&lt;Integer&gt; que2;    /** Initialize your data structure here. */    public MyStack() {        que1 = new LinkedList&lt;&gt;();        que2 = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        if(!que1.isEmpty()){            que1.offer(x);        }        else{            que2.offer(x);        }    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        while(!que1.isEmpty()){            int temp = que1.poll();            if(que1.isEmpty()){                return temp;            }            else{                que2.offer(temp);            }        }        while(!que2.isEmpty()){            int temp = que2.poll();            if(que2.isEmpty()){                return temp;            }            else{                que1.offer(temp);            }        }        return -1;    }    /** Get the top element. */    public int top() {        while(!que1.isEmpty()){            int temp = que1.poll();            que2.offer(temp);            if(que1.isEmpty()){                return temp;            }        }        while(!que2.isEmpty()){            int temp = que2.poll();            que1.offer(temp);            if(que2.isEmpty()){                return temp;            }        }        return -1;    }    /** Returns whether the stack is empty. */    public boolean empty() {        return que1.isEmpty() &amp;&amp; que2.isEmpty();    }}</code></pre><p><a name="20"></a></p><h2 id="20-斐波那契数列-三道"><a href="#20-斐波那契数列-三道" class="headerlink" title="20.斐波那契数列(三道)"></a>20.斐波那契数列(三道)</h2><pre><code>斐波那契数列--《剑指offer》p75 青蛙跳台阶--《剑指offer》p77、leetcode 70变态跳台阶--牛客网 </code></pre><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h3><p>《剑指offer》p75</p><p>题目：大家都知道斐波那契数列f(n)=f(n-1)+f(n-2)，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39</p><p>思路：动态规划问题。解法：自上而下递归分析，自下而上循环实现。</p><pre><code class="java">public static int Fibonacci(int n) {    if(n==0){        return 0;    }    if(n==1){        return 1;    }    int n1 = 0;    int n2 = 1;    for(int i=2; i&lt;=n; ++i){        int temp = n1+n2;        n1 = n2;        n2 = temp;    }    return n2;}</code></pre><h3 id="2-青蛙跳台阶"><a href="#2-青蛙跳台阶" class="headerlink" title="2.青蛙跳台阶"></a>2.青蛙跳台阶</h3><p>《剑指offer》p77、leetcode 70</p><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p><p>思路：就是斐波那切数列</p><pre><code class="java">public int JumpFloor(int target) {    if(target==1){        return 1;    }    if(target==2){        return 2;    }    int n1 = 1;    int n2 = 2;    for(int i=3; i&lt;=target; ++i){        int temp = n1 + n2;        n1 = n2;        n2 = temp;    }    return n2;}</code></pre><h3 id="3-变态跳台阶"><a href="#3-变态跳台阶" class="headerlink" title="3.变态跳台阶"></a>3.变态跳台阶</h3><p>牛客网上的</p><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p>思路：动态规划分析：f(n)=f(n-1)+f(n-2)+…f(1)+1，因此需要数组来缓存之前的值，但其实不需要数组，直接用变量来缓存即可，即f(n)=之前的和+1。</p><pre><code class="java">public int JumpFloorII(int target) {    if(target==1){        return 1;    }    if(target==2){        return 2;    }    int sumTemp = 3;//缓存之前的和    int resTemp = 0;    for(int i=3; i&lt;=target; ++i){        resTemp = sumTemp+1;//当前的结果值        sumTemp += resTemp; //把当前的结果值加到缓存和中    }    return resTemp;}</code></pre><p><a name="21"></a></p><h2 id="21-斐波那契数列变种-两道"><a href="#21-斐波那契数列变种-两道" class="headerlink" title="21.斐波那契数列变种(两道)"></a>21.斐波那契数列变种(两道)</h2><pre><code>Length of Longest Fibonacci Subsequence--leetcode 873 Split Array into Fibonacci Sequence--leetcode842 </code></pre><h3 id="1-Length-of-Longest-Fibonacci-Subsequence"><a href="#1-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="1.Length of Longest Fibonacci Subsequence"></a>1.Length of Longest Fibonacci Subsequence</h3><p>leetcode 873</p><p>题目：给定一个严格递增的正整数数组形成序列 A ，找到A中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</p><p>子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列</p><p>Example 1:</p><pre><code>Input: [1,2,3,4,5,6,7,8]Output: 5Explanation:The longest subsequence that is fibonacci-like: [1,2,3,5,8].</code></pre><p>思路：动态规划问题。二维dp问题。</p><p>使用一维DP解决不了这个问题，因为一维DP只保存了到某个为止的最长斐波那契数列，但是新的数字到来之后能不能满足之前的费布拉奇数列是未知的。所以使用二维DP。</p><p>dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。</p><p>核心方程：dp[j][k]=dp[i][j]+1</p><p>条件是 A[i] + A[j] = A[k]</p><p>这个算法的时间复杂度是O(n^2)，空间复杂度是O(n^2).</p><pre><code class="java">//二维dp问题。dp[i][j]表示以A[i]、A[j]结尾的最长斐波那契数列长度，初始化为2。//核心方程：dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]public static int lenLongestFibSubseq(int[] A) {    if(A==null || A.length==0){        return 0;    }    int m = A.length;    int[][] dp = new int[m][m];//dp[i][j]表示以A[i]、A[j]结尾的斐波那契数列长度，初始化为2    for(int i=0; i&lt;m; i++){        for(int j=i+1; j&lt;m; ++j){            dp[i][j] = 2;        }    }    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//map存放A[]数组便于下面查找。key:a[i], value:i    for(int i=0; i&lt;A.length; ++i){        map.put(A[i], i);    }    //dp[j][k]=dp[i][j]+1，A[k]-A[j]=A[i]    int res = 0;    for(int j=0; j&lt;m; j++){        for(int k=j+1; k&lt;m; ++k){            int a_i = A[k]-A[j];            if(a_i&lt;A[j] &amp;&amp; map.containsKey(a_i)){                dp[j][k] = Math.max(dp[j][k], dp[map.get(a_i)][j]+1);                res = Math.max(res, dp[j][k]);            }        }    }    return res;}</code></pre><h3 id="2-Split-Array-into-Fibonacci-Sequence"><a href="#2-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="2.Split Array into Fibonacci Sequence"></a>2.Split Array into Fibonacci Sequence</h3><p>leetcode 842、与leetcode 306类似</p><p>题目：给出了一个有0-9数字组成的纯数字字符串。判断能否组成斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。最终要返回的是任何一个组合即可。</p><p>Example 1:</p><pre><code>Input: &quot;123456579&quot;Output: [123,456,579]</code></pre><p>思路:回溯法。本题和下面的刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p><p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p><p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p><p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p><p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p><p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p><p>本题需要把斐波那契数列的各个数字存起来，同时还要注意要防止int溢出</p><pre><code class="java">public List&lt;Integer&gt; splitIntoFibonacci(String S) {    int L = S.length();    List&lt;Integer&gt; res= new ArrayList&lt;&gt;();    for(int i=1; i&lt;=(L-1)/2; ++i){//第一个数的长度为[1,(L-1)/2]        String s1 = S.substring(0,i);//第一个数        if(S.startsWith(&quot;0&quot;) &amp;&amp; s1.length()&gt;1){//第一个数长度超过2起始位不能为0            break;        }        Long num1 = Long.valueOf(s1);        if(num1&gt;Integer.MAX_VALUE){//防止int溢出            break;        }        for(int j=i+1;j&lt;=L-1&amp;&amp;(L-j)&gt;=(j-i)&amp;&amp;(L-j)&gt;=i; ++j){//第三个数大于等于第一、第二个数            String s2 = S.substring(i,j);//第二个数            if(S.charAt(i)==&#39;0&#39; &amp;&amp; s2.length()&gt;1){//第二个数长度超过2起始位不能为0                break;            }            Long num2 = Long.valueOf(s2);            if(num2&gt;Integer.MAX_VALUE){//防止int溢出                break;            }            if(isValid(S.substring(j), num1, num2, res)){//进行斐波那契判断                return res;            }        }    }    res.clear();    return res;}public boolean isValid(String S, long num1, long num2, List&lt;Integer&gt; temp){    if(S.equals(&quot;&quot;)){//递归结束        temp.add((int) num1);        temp.add((int) num2);        return true;    }    long sum = num1 + num2;    if(sum&gt;Integer.MAX_VALUE){//防止int溢出        return false;    }    String sumStr = &quot;&quot; + sum;    if(sumStr.length()&gt;1 &amp;&amp; S.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0        return false;//剪枝，回溯点    }    if(S.startsWith(sumStr)){        temp.add((int) num1);        return isValid(S.substring(sumStr.length()), num2, sum, temp);//递归判断    }else{        temp.clear();        return false;    }}</code></pre><p><a name="22"></a></p><h2 id="22-Additive-Number"><a href="#22-Additive-Number" class="headerlink" title="22.Additive Number"></a>22.Additive Number</h2><p>leetcode 306</p><p>题目：给出了一个有0-9数字组成的纯数字字符串。判断它能不能组成所谓的“加法数字”，即斐波那契数列。注意这个题注重点在不管你几位数字去划分，只要满足后面的数字等于前两个的和即可。</p><p>Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</p><pre><code>Input: &quot;112358&quot;Output: true Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8Input: &quot;199100199&quot;Output: true Explanation: The additive sequence is: 1, 99, 100, 199.1 + 99 = 100, 99 + 100 = 199</code></pre><p>思路:回溯法。刚一看这个题的时候没有思路，知道应该是用dfs或backtracking一类的算法。</p><p>解题的关键在于确定前两个数，只要确定了前两个数，后面的数可以依次计算出来，要么符号条件要么不符合条件。那么如何确定前两个数？ </p><p>首先分析如何确定第一个数，第一个数的最小的长度是1（只包含一个数字），最大的长度是（L-1）/2，其中L为字符串的长度，最大的长度一定小于总长度的一半，比如如果总长度是5，第一个数长度不能超过2，如果总长度是6，第一个数长度也不能超过2，所以最大的长度是（L-1）/2,。 </p><p>再确定第二个数的范围，第二个数从第一个数后面开始，第三个数从第二个数后面开始，我们首先知道，第三个数肯定至少和第一个数与第二个数一样大，因为是和嘛，若第二个数从i开始到j-1结束，那么第三个数长度最大为L-j，这个长度一定大于等于第一个数和第二个数长度的较大者，即：L-j&gt;=i &amp;&amp; L-j&gt;=j-i。 </p><p>确定了第二个数的范围之后问题就简单了，看看能不能构成加法序列，只要判断剩下的字串是不是以sum开头即可，然后递归判定。 </p><p>这题的关键在于找前两个数，前两个数确定了，后面的依次判断即可。第一个数肯定从0开始，但最长是（L-1）/2，第二个数从第一个数后面开始，第三个数至少跟第一个和第二个较大的数一样长,即第三个数长度不小于第一个数 &amp;&amp; 第三个数长度不小于第二个数</p><pre><code class="java">//回溯法问题。关键在于确定前两个数即可。//三个数的长度: 第一个数,[0,i)，长度为i；第二个数,[i,j)长度为j-i; 第三个数(和):[j,L-1],长度L-j//三个数的长度最长的范围：第一个数长度上限:x=(L-1)/2; 第二个数长度下限：y=x，第三个数长度下限: ypublic static boolean isAdditiveNumber(String num) {    int L = num.length();    for(int i=1; i&lt;=(L-1)/2; ++i){//i从1起，第一个数长度至少为1        if(num.startsWith(&quot;0&quot;) &amp;&amp; i&gt;1){            break;//第一个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环        }        for(int j=i+1; j&lt;=L-1 &amp;&amp; (L-j)&gt;=i &amp;&amp; (L-j)&gt;=(j-i); ++j){//第三个数长度不小于第一个数，第三个数长度不小于第二个数            if(num.charAt(i)==&#39;0&#39; &amp;&amp; j-i&gt;1){                break;//第二个数长度大于1，不能以0开头，这里break而不是continue，好，直接省去很多不必要的循环            }            long num1 = Long.valueOf(num.substring(0, i));//第一个数            long num2 = Long.valueOf(num.substring(i, j));//第二个数            if(isAdditive(num.substring(j), num1, num2)){                return true;//找到满足斐波那契条件的一个划分序列            }        }    }    return false;}public static boolean isAdditive(String num, long num1, long num2){    if(num.equals(&quot;&quot;)){        return true; //递归结束，回溯点    }    long sum = num1+num2;    String sumStr = &quot;&quot; + sum;    int sumLen = sumStr.length();    if(sumLen&gt;1 &amp;&amp; num.startsWith(&quot;0&quot;)){//如果和的长度大于1，则起始位不能是0        return false;//剪枝，回溯点    }    if(num.startsWith(sumStr)){//如果和在字符串中，则进行下一次递归        return isAdditive(num.substring(sumLen), num2, sum);    }    return false;}public static void main(String[] args){    String num = &quot;123&quot;;    System.out.println(isAdditiveNumber(num));}</code></pre><p><a name="23"></a></p><h2 id="23-旋转数组的最小数字-三道"><a href="#23-旋转数组的最小数字-三道" class="headerlink" title="23.旋转数组的最小数字(三道)"></a>23.旋转数组的最小数字(三道)</h2><pre><code>《剑指offer》p82Find Minimum in Rotated Sorted Array--leetcode153Find Minimum in Rotated Sorted Array 2--leetcode154</code></pre><h3 id="1-旋转数组的最小数字"><a href="#1-旋转数组的最小数字" class="headerlink" title="1.旋转数组的最小数字"></a>1.旋转数组的最小数字</h3><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>普通二分查找思路：顺序解法o(n)，从头到尾遍历数组一次，我们就能找出最小的数字。但本题部分排序，排序的题优先考虑二分查找，因此采用二分查找的双指针的思路，o(logn)。</p><p><strong>两个指针代表两大阵营</strong>(原数组/旋转的那部分数组)，最终会相邻，第二个指针指向的刚好是最小的元素</p><pre><code class="java">//这里是部分排序的数组，考虑二分查找public static int minNumberInRotateArray(int [] array) {    if(array==null){        return 0;    }    int len = array.length;    if(len==0){        return 0;    }    if(len==1){        return array[0];    }    int left = 0;    int right = len-1;    while(left&lt;right){//二分查找        //结束条件：两个指针最终会相邻，代表两大阵营(原数组/旋转的那部分数组)，第二个指针指向的刚好是最小的元素        if(left+1==right){//结束条件            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况                return nums[right];            }else{                return nums[0];            }        }        int mid = (left+right)/2;        //特殊情况，当left、right、mid对应的三个数相等时，无法判断最小的数位于哪一边，因此要顺序查找        if(array[mid]==array[left]&amp;&amp;array[mid]==array[right]){            return search(array,left, right);        }        if(array[mid]&gt;=array[left]){//最小值在右半边            left = mid;        }        else if(array[mid]&lt;=array[right]){//最小值在左半边            right = mid;        }    }    return array[left];}public static int search(int[] array, int left, int right){    for(int i=left+1; i&lt;=right; ++i){        if(array[i]&lt;array[i-1]){//顺序查找，注意这里也不是完全遍历，而是第一个比之前小的数就是所求            return array[i];        }    }    return array[left];}</code></pre><p>牛客网答案区很干练的二分查找思路：(仅供参考一般想不到，还是用上面自己想的即可)</p><pre><code>采用二分法解答这个问题，mid = low + (high - low)/2需要考虑三种情况：(1)array[mid] &gt; array[high]:出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。low = mid + 1(2)array[mid] == array[high]:出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ，high = high - 1(3)array[mid] &lt; array[high]:出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。high = mid注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字比如 array = [4,6]array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;如果high = mid - 1，就会产生错误， 因此high = mid但情形(1)中low = mid + 1就不会错误</code></pre><p>代码：</p><pre><code class="java">public class Solution {    public int minNumberInRotateArray(int [] array) {        int low = 0 ; int high = array.length - 1;           while(low &lt; high){            int mid = low + (high - low) / 2;                    if(array[mid] &gt; array[high]){                low = mid + 1;            }else if(array[mid] == array[high]){                high = high - 1;            }else{                high = mid;            }           }        return array[low];    }}</code></pre><h3 id="2-Find-Minimum-in-Rotated-Sorted-Array-2"><a href="#2-Find-Minimum-in-Rotated-Sorted-Array-2" class="headerlink" title="2.Find Minimum in Rotated Sorted Array 2"></a>2.Find Minimum in Rotated Sorted Array 2</h3><p>leetcode154</p><p>题目：和153一样，这里新增数组可以有重复数字，如[1,3,3,3]</p><p>思路：思路还是一样，就是需要考虑重复的问题，改动如下：</p><pre><code class="java">public static int findMin(int[] nums) {    int len = nums.length;    if(len==1){        return nums[0];    }    //left、right代表原数组、旋转数组两大阵营，结束条件是相邻    int left = 0;    int right = nums.length-1;    while(left&lt;right){        int mid = (left+right)/2;        if(left+1==right){//结束条件            if(nums[right]&lt;nums[0]){//也可能存在原数组没旋转的情况                return nums[right];            }else{                return nums[0];            }        }        if(nums[mid]==nums[left]&amp;&amp; nums[mid]==nums[right]){            return search(nums);        }        else if(nums[mid]&gt;=nums[left]){//在右半边            left = mid;        }        else if(nums[mid]&lt;=nums[right]){//在左半边            right = mid;        }    }    return nums[left];}public static int search(int[] array){    int min = array[0];    for(int i=1; i&lt;array.length; ++i){        min = Math.min(min, array[i]);//顺序查找，注意这里必须完全全部遍历    }    return min;}</code></pre><p><a name="24"></a></p><h2 id="24-矩阵中的路径"><a href="#24-矩阵中的路径" class="headerlink" title="24.矩阵中的路径"></a>24.矩阵中的路径</h2><p>《剑指offer》p89、leetcode 79</p><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><pre><code>a b c es f c sa d e e</code></pre><p>思路：二维矩阵中路径查找问题通常用回溯法。回溯法非常适合由多个步骤组成的问题，每个步骤都有多个选项。它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法可以看成蛮力法的升级版。</p><pre><code class="java">public static boolean hasPath(char[] matrix, int rows, int cols, char[] str){    if(str==null){        return true;    }    if(matrix==null || matrix.length&lt;str.length){        return false;    }    //路径查找中，不能重复进入相同的格子，因此需要设置标记矩阵，初始为false    boolean[] visited = new boolean[rows*cols];    for(int i=0; i&lt;rows; ++i){        for(int j=0; j&lt;cols; ++j){            int index = i*cols+j;            if(matrix[index]==str[0]){//如果第一个字符匹配，则开始回溯法匹配路径                if(isPath(matrix,rows,cols,i,j,str,0, visited)){//匹配成功                    return true;                }            }        }    }    return false;}public static boolean isPath(char[] matrix, int rows, int cols, int i, int j, char[] str, int strIndex, boolean[] visited){    if(strIndex==str.length){        return true;//查找完成，找到路径的结束条件    }    int index = i*cols+j;    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[index]==true){        return false;//查找到边界外或已经访问过，false    }    if(matrix[index]==str[strIndex]){//如果当前字符匹配，则开始回溯法匹配路径        visited[index] = true;        //上下左右回溯法查找        if(isPath(matrix,rows,cols,i-1,j,str,strIndex+1, visited)                ||isPath(matrix,rows,cols,i+1,j,str,strIndex+1,visited)                ||isPath(matrix,rows,cols,i,j-1,str,strIndex+1,visited)                ||isPath(matrix,rows,cols,i,j+1,str,strIndex+1,visited)){            return true;        }    }    visited[index] = false;//回溯    return false;}</code></pre><p>leetcode79的代码：</p><pre><code class="java">public static boolean exist(char[][] board, String word) {    if(board==null || board.length==0 || word==null || word.length()==0){        return false;    }    int m = board.length;    int n = board[0].length;    if((m*n)&lt;word.length()){        return false;    }    boolean[][] visited = new boolean[m][n];//避免重复访问的标记数组，初始为false    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(board[i][j]==word.charAt(0)){                if(isPath(board, m, n, i, j, word, 0, visited))                    return true;            }        }    }    return false;}public static boolean isPath(char[][] board, int m, int n, int i, int j, String word, int strIndex, boolean[][] visited){    if(strIndex==word.length()){        return true;//查找完成，结束条件    }    if(i&lt;0 || j&lt;0 || i&gt;=m || j&gt;=n || visited[i][j]==true || board[i][j]!=word.charAt(strIndex)){        return false;//剪枝，错误条件:访问越界或已经访问过或当前字符不匹配    }    visited[i][j] = true;    if(isPath(board, m, n, i-1, j, word, strIndex+1, visited)||            isPath(board, m, n, i+1, j, word, strIndex+1, visited)||            isPath(board, m, n, i, j-1, word, strIndex+1, visited)||            isPath(board, m, n, i, j+1, word, strIndex+1, visited)){        return true;    }    visited[i][j] = false;//回溯    return false;}</code></pre><p><a name="25"></a></p><h2 id="25-机器人的运动范围"><a href="#25-机器人的运动范围" class="headerlink" title="25.机器人的运动范围"></a>25.机器人的运动范围</h2><p>《剑指offer》p92.</p><p>题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：通常物体或人在二维矩阵运动这类问题够可以用回溯法解决。</p><pre><code class="java">public int movingCount(int threshold, int rows, int cols){    int[] res = new int[]{0};//最多可到达的格子数，存成数组便于参数传递修改    boolean[][] visited = new boolean[rows][cols];//记录访问过的标记位数组，初始化为false    return isPath(rows, cols, 0, 0, visited, res, threshold);}//回溯法矩阵路径查找，返回能到达格子的个数public static int isPath(int rows, int cols, int i, int j, boolean[][] visited, int[] res, int k){    if(i&lt;0 || j&lt;0 || i&gt;=rows || j&gt;=cols || visited[i][j]==true || (digitSum(i)+digitSum(j))&gt;k){        return res[0];//剪枝的结束条件:访问越界或已经访问过或行列数位和大于k    }    visited[i][j] = true;    res[0]++;    int resTemp;    resTemp = Math.max(isPath(rows,cols,i-1,j,visited,res,k), res[0]);    resTemp = Math.max(isPath(rows,cols,i+1,j,visited,res,k), resTemp);    resTemp = Math.max(isPath(rows,cols,i,j-1,visited,res,k), resTemp);    resTemp = Math.max(isPath(rows,cols,i,j+1,visited,res,k), resTemp);    return resTemp;}//一个数字的数位和public static int digitSum(int num){    int sum = 0;    while(num!=0){        sum += (num%10);        num/=10;    }    return sum;}</code></pre><p><a name="26"></a></p><h2 id="26-Unique-Paths-两道"><a href="#26-Unique-Paths-两道" class="headerlink" title="26.Unique Paths(两道)"></a>26.Unique Paths(两道)</h2><h3 id="1-Unique-Paths"><a href="#1-Unique-Paths" class="headerlink" title="1.Unique Paths"></a>1.Unique Paths</h3><p>leetcode 62 Unique Paths</p><p>题目：给定m*n的矩阵，机器人从左上走到右下，每次只能向右或向下，How many possible unique paths are there?</p><p>思路：dp问题，dp[i][j]表示走至当前格子时的unique paths数。</p><p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p><p>dp问题，自上而下分析上述方程，自下而上循环解决</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePaths(int m, int n) {    int[][] dp = new int[m][n];//dp[i][j]表示走至当前格子时的unique paths数    dp[0][0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i==0){//第一行的dp[0][j]=1                dp[i][j] = 1;            }            else{                if(j==0){//每行的第一个dp[i][0]=dp[i-1][0]                    dp[i][j] = dp[i-1][j];                }                else{//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]                    dp[i][j] = dp[i-1][j] + dp[i][j-1];                }            }        }    }    return dp[m-1][n-1];}</code></pre><p><strong>优化:</strong>上述方法时间o(m<em>n)、空间o(m</em>n)，其实只用o(n)的空间即可，对每行来说只缓存上一行的dp即可</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePaths(int m, int n) {    if(m==1 || n==1){        return 1;    }    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数，初始第一行的dp[j]=1    dp[0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=1; j&lt;n; ++j){//直接从第1列开始就行了，第0列不用考虑            if(i==0){//初始第一行的dp[j]=1                dp[j] = 1;            }            else{                dp[j] = dp[j-1] + dp[j];//其他的dp[i][j] = dp[i-1][j] + dp[i][j-1]            }        }    }    return dp[n-1];}</code></pre><h3 id="2-Unique-Paths-2"><a href="#2-Unique-Paths-2" class="headerlink" title="2.Unique Paths 2"></a>2.Unique Paths 2</h3><p>leetcode 63 Unique Paths 2</p><p>题目：和Unique Paths一样，左上到右下，每次只能向右或者向下，但是新增了障碍物条件，Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>example:</p><pre><code>Input:[  [0,0,0],  [0,1,0],  [0,0,0]]Output: 2</code></pre><p>思路：还是一样的。dp问题，用了优化后思路，dp[j]缓存上一行的unique paths数</p><p>方程：dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1</p><p>dp问题，自上而下分析上述方程，自下而上循环解决</p><pre><code class="java">//dp[i][j]=dp[i-1][j]+dp[i][j-1], dp[0][0]=1public static int uniquePathsWithObstacles(int[][] obstacleGrid) {    int m = obstacleGrid.length;    int n = obstacleGrid[0].length;    if(obstacleGrid[0][0]==1){//如果起始点是障碍物        return 0;    }    int[] dp = new int[n];//dp[j]缓存上一行的unique paths数    dp[0] = 1;    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i==0){//初始第一行的dp[j]=1                if(obstacleGrid[i][j]!=1){                    if(j&gt;0){                        dp[j] = dp[j-1];                    }                }                else{                    dp[j] = 0;//有障碍物，此路不通                }            }            else{//其他行                if(obstacleGrid[i][j]!=1){                    if(j&gt;0){                        dp[j] = dp[j-1] + dp[j];                    }                }                else{                    dp[j] = 0;//有障碍物，此路不通                }            }        }    }    return dp[n-1];}</code></pre><p><a name="27"></a></p><h2 id="27-剪绳子"><a href="#27-剪绳子" class="headerlink" title="27.剪绳子"></a>27.剪绳子</h2><p>《剑指offer》p96.</p><p>题目：给定一根长度为n的绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]* k[1] * … *k[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>思路：</p><blockquote><p>问题是求最优解；</p><p>整体的问题的最优解是依赖各个子问题的最优解；</p><p>子问题之间还有互相重叠的更小的子问题；</p><p>为避免子问题的重复计算，我们存储子问题的最优解。从上往下分析问题，从下往上求解问题。</p></blockquote><p>上面的几个条件可以看出，属于动态规划问题。</p><p>dp方程：<code>f(n) = max(f(i)*f(n-i))</code></p><pre><code class="java">public static int maxProduct(int n){    if(n==2){        return 1;    }    if(n==3){        return 2;    }    int[] res = new int[n+1];    res[1] = 1;    res[2] = 2;    res[3] = 3;    for(int i=4; i&lt;=n; ++i){        for(int j=1; j&lt;=(i/2); ++j){            res[i] = Math.max(res[j]*res[i-j], res[i]);//f(n)=max(f(i)*f(n-i))        }    }    return res[n];}</code></pre><p><a name="28"></a></p><h2 id="28-不用加减乘除做加法"><a href="#28-不用加减乘除做加法" class="headerlink" title="28.不用加减乘除做加法"></a>28.不用加减乘除做加法</h2><p>牛客网、leetcode 371</p><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p>思路：首先看十进制是如何做的： 5+7=12，三步走 </p><blockquote><p>第一步：相加各位的值，不算进位，得到2。 </p></blockquote><blockquote><p>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。</p></blockquote><blockquote><p>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p></blockquote><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p><blockquote><p>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</p></blockquote><blockquote><p>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</p></blockquote><blockquote><p>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 </p></blockquote><p>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p><pre><code class="java">public int Add(int num1,int num2) {    int temp;    while(num2!=0){        temp = num1^num2;//加        num2 = (num1&amp;num2)&lt;&lt;1;//进位        num1 = temp;    }    return num1;}</code></pre><p><a name="29"></a></p><h2 id="29-Two-Sum"><a href="#29-Two-Sum" class="headerlink" title="29.Two Sum"></a>29.Two Sum</h2><p>leetcode 1</p><p>题目：给定数组(非有序)和target，找到nums[i]+nums[j]==target的i、j，假定给定条件一定会有一个解</p><p>Example:</p><pre><code>Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].</code></pre><p>思路1：暴力解法，时间o(n2)，空间o(1)–38ms</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    int[] res = new int[2];    for(int i=0; i&lt;nums.length-1; ++i){        for(int j=i+1; j&lt;nums.length; ++j){            if( (nums[i] + nums[j]) == target ){                res[0] = i;                res[1] = j;            }        }    }    return res;}</code></pre><p>思路2：只遍历一次数组，辅助map，temp=target-nums[i],看map中是否有temp，有则返回两者索引即可，没有将当前nums[i]存入map，继续遍历。时间o(n)，空间o(n)–5ms</p><pre><code class="java">public static int[] twoSum(int[] nums, int target) {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();//key:nums[i]; value:i    for(int i=0; i&lt;nums.length; ++i){        int temp = target-nums[i];        if(!map.containsKey(temp)){            map.put(nums[i], i);        }        else{            return new int[]{map.get(temp), i};        }    }    return new int[]{0,0};}</code></pre><p><a name="30"></a></p><h2 id="30-二进制中1的个数"><a href="#30-二进制中1的个数" class="headerlink" title="30.二进制中1的个数"></a>30.二进制中1的个数</h2><p>《剑指offer》p100、leetcode191 Number of 1 Bits</p><p>题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p>本题超级技巧：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong></p><p>思路：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>，通过这个小技巧，我们只要循环判断n=n&amp;(n-1)是否为0，即可统计1的个数。整数中有多少个1，则循环多少次。</p><p>有了这个思路，可以轻松解以下相关题目。位运算相关题目</p><p>用一条语句判断一个整数是不是2的整数次方。</p><p><code>if(n&amp;(n-1)==0) return true;</code></p><p>输入两个整数m,n,计算需要改变m的二进制表示中的多少位才能得到n？<br>​<br>​<code>int x=m^n; return NumberOf1(x);</code></p><p>解法一：从尾部到最高位(0到32位)，依次找1。不好</p><pre><code class="java">public static int NumberOf2(int n) {//从尾部到最高位(0到32位)，依次找1    int res = 0;    int temp = 1;    int cnt = Integer.toBinaryString(n).length();//返回二进制的位数，这样不用暴力的写32位了    while(cnt!=0){        if((n&amp;temp)==temp){            res++;        }        temp=temp&lt;&lt;1;        cnt--;    }    return res;}</code></pre><p>解法二：<strong>x&amp;(x-1)可以将整数最右边的1变成0</strong>。每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)</p><pre><code class="java">public static int NumberOf1(int n) {    int res = 0;    while(n!=0){        n=(n-1)&amp;n; //每次把二进制的最后一个1置为0(二进制数中不存在1时，立刻变0)        res++;    }    return res;}</code></pre><p><a name="31"></a></p><h2 id="31-数值的整数次方"><a href="#31-数值的整数次方" class="headerlink" title="31.数值的整数次方"></a>31.数值的整数次方</h2><p>《剑指offer》p110、leetcode 50</p><p>题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>思路：记得考虑base==0与exponent&lt;0的情况。解法三更为优化，递归实现将exponent二分下去减少乘法运算次数。判断一个整数为奇数偶数，这里把%运算换成位运算，效率更高（二进制最低位如果为1则为奇数，为0则为偶数）。</p><p><strong>超级知识点</strong>：注意MIN_VALUE取反的情况。在JDK中，整型类型是有范围的 -2147483648～2147483647（-2^31-2^31-1），最大值为Integer.MAX_VALUE，即2147483647，最小值为Integer.MIN_VALUE -2147483648。</p><p>Integer.MIN_VALUE取反或者取绝对值呢仍为Integer.MIN_VALUE，因为绝对值2147483648超过Integer.MAX_VALUE 2147483647。</p><p><strong>因此有如下重要结论：</strong><br>​<br>​    Math.abs(Integer.MIN_VALUE) = Integer.MIN_VALUE<br>​    Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</p><p>解法一：无耻解法2333</p><pre><code class="java">public static double Power(double base, int exponent) {    return Math.pow(base, exponent);}</code></pre><p>解法二：逐个base相乘即可</p><pre><code class="java">public static double Power(double base, int exponent) {    double res = 1;    boolean positive = true;    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE    if(exponent==Integer.MIN_VALUE){        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不ååå行，必须为偶数参与二分)    }    if(exponent&lt;0){        positive = false;    }    exponent = Math.abs(exponent);    while(exponent!=0){        exponent--;        res*=base;    }    return positive?res:(1/res);}</code></pre><p>解法三，效率更高：</p><pre><code class="java">//a^n = a^(n/2)*a^(n/2)public static double Power(double base, int exponent) {    double res = 1;    boolean positive = true;//exponent正负的标记位    //Math.abs(Integer.MIN_VALUE) =  Integer.MIN_VALUE    //Integer.MAX_VALUE + 1 = Integer.MIN_VALUE    if(exponent==Integer.MIN_VALUE){        exponent = exponent + 2;//防止最小值的负数取反越界，这里加2来个近似(加4也可以但加1不行，必须为偶数参与二分)    }    if(exponent&lt;0){        positive = false;        exponent = -exponent;    }    while(exponent!=0){        if((exponent&amp;1)==1){//exponent是奇数            res*=base;            exponent--;        }else{//exponent是偶数，二分，减少乘法次数，效率更高            base*=base;            exponent/=2;        }    }    return positive?res:(1/res);}public static void main(String[] args){    System.out.println(Power(2, -2147483648));}</code></pre><p><a name="32"></a></p><h2 id="32-打印从1到最大的n位数"><a href="#32-打印从1到最大的n位数" class="headerlink" title="32.打印从1到最大的n位数"></a>32.打印从1到最大的n位数</h2><p>《剑指offer》p114</p><p>题目：打印从1到最大的n位数（本题是大数问题，当n位数很多时，只能用其他的数据结构来存储我们的非常大的数字）</p><p>思路：使用数组，采用数字全排列的方法。如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。当然打印的时候，我们应该不输出左边的0</p><p>解法一：递归实现全排列，顺序打印（代码比较简单，但可能会栈溢出）</p><pre><code class="java">public class Hello{    public static void main(String[] args){        printOneToNBit(3);    }    //打印从1到最大的n位数，就是一个n个数的全排列，用递归实现    static void printOneToNBit(int n){        int[] number = new int[n]; //n位的数组存放数字的全排列        for(int i=0; i&lt;10; ++i){            number[0] = i;            OneToNBit(number, n, 0);        }    }    //递归实现数字全排列    static void OneToNBit(int[] number, int n, int index){        //递归结束条件，已经完成一个数字全排列，打印出来        if(index == n-1){            printNumber(number);            return;        }        index++;        for(int i=0; i&lt;10; ++i){            number[index] = i;            OneToNBit(number, n, index);        }    }    //打印一个数组排列，左边的0都不输出    static void printNumber(int[] number){        boolean notFirst = false;        for(int i=0; i&lt;number.length; ++i){            if(number[i]!=0){                notFirst = true;            }            if(notFirst){                System.out.print(number[i]);            }        }        System.out.println();    }}</code></pre><p>解法二：字符串存数字，采用循环，不断加1。这个思路在两个数相加（大数问题）等题目中可以用到。</p><pre><code class="java">//打印从1到最大的n位数public static void printOneToNBit(int n){    //大数问题，用字符串来存数字    StringBuilder num = new StringBuilder();    for(int i=0; i&lt;n; ++i){        num.append(&quot;0&quot;);    }    while(!addOne(num)){        printNum(num);//字符串每次加1，然后打印,直到n位的最大数    }}//字符串每次加1，然后打印,直到n位的最大数public static boolean addOne(StringBuilder num){    int cnt = 0;//前一位的进位    for(int i=num.length()-1; i&gt;=0; --i){        int temp = num.charAt(i)-&#39;0&#39;+cnt;//第i位上的数字        if(i==num.length()-1){//个位加1            temp++;        }        if(temp==10){//如果有进位，操作如下            if(i==0){//如果当前是最高位且有进位，说明已经到达是最大数，return true                return true;            }            num.setCharAt(i, &#39;0&#39;);//进位后当前位为0            cnt = 1;//进位1        }        else{//如果没进位            num.setCharAt(i, (char)(&#39;0&#39;+temp));            break;//没有进位了，跳出循环即可        }    }    return false;}//打印数字，左边的0不打印public static void printNum(StringBuilder num){    boolean leftCnt = true;    for(int i=0; i&lt;num.length(); ++i){        char temp = num.charAt(i);        if(temp!=&#39;0&#39;) {            leftCnt = false;        }        if(!leftCnt){            System.out.print(temp);        }    }    System.out.println();}public static void main(String[] args){    printOneToNBit(3);}</code></pre><p><a name="33"></a></p><h2 id="33-删除链表中重复的节点-两道"><a href="#33-删除链表中重复的节点-两道" class="headerlink" title="33.删除链表中重复的节点(两道)"></a>33.删除链表中重复的节点(两道)</h2><pre><code>1.Remove Duplicates from Sorted List((保留一个重复节点)---leetcode832.Remove Duplicates from Sorted List 2(不保留重复节点)---《剑指offer》p122、leetcode82</code></pre><h3 id="1-Remove-Duplicates-from-Sorted-List"><a href="#1-Remove-Duplicates-from-Sorted-List" class="headerlink" title="1.Remove Duplicates from Sorted List"></a>1.Remove Duplicates from Sorted List</h3><p>leetcode 83</p><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点保留一个，返回链表头指针。</p><p>Example:</p><pre><code>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3Output: 1-&gt;2-&gt;3</code></pre><p>代码：</p><pre><code class="java">public ListNode deleteDuplicates(ListNode head) {    if(head==null || head.next==null){        return head;    }    ListNode cur = head;    while(cur.next!=null){        if(cur.next.val==cur.val){            cur.next = cur.next.next;        }else{            cur = cur.next;        }    }    return head;}</code></pre><h3 id="2-Remove-Duplicates-from-Sorted-List-II"><a href="#2-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="2.Remove Duplicates from Sorted List II"></a>2.Remove Duplicates from Sorted List II</h3><p>《剑指offer》p122、leetcode82</p><p>题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p>思路：</p><blockquote><p>1.需要两个指针，一个指向前一个节点pre，另一个指向当前节点p。如果遇到相等的节点，p向后移动，pre不动，存下此时相等数值tempVal方便后面的比较，直到遇到p和p.next不相等，pre就可以指向当前的p。</p><p>2.注意：链表开头可能就开始有重复的节点，所以设置一个哨兵guard(0)，</p></blockquote><pre><code class="java">public static  ListNode deleteDuplication(ListNode pHead){    //链表为空或只有一个节点，返回pHead    if(pHead==null || pHead.next==null){        return pHead;    }    //设置哨兵    ListNode guard = new ListNode(0);    guard.next = pHead;    ListNode pre = guard;//重复节点的前一个节点    ListNode cur = guard.next; //用于遍历的节点    //遍历链表    while(cur!=null){        if(cur.next!=null &amp;&amp; cur.next.val==cur.val){//后一节点==当前节点            int temp = cur.val;//存储重复的值，用于后边比较            while(cur!=null &amp;&amp; cur.val==temp){//如果重复                cur = cur.next;            }            pre.next = cur;        }        else{//后一节点!=当前节点            pre = pre.next;            cur = cur.next;        }    }    return guard.next;}</code></pre><p><a name="34"></a></p><h2 id="34-正则表达式匹配"><a href="#34-正则表达式匹配" class="headerlink" title="34.正则表达式匹配"></a>34.正则表达式匹配</h2><p>《剑指offer》p124、leetcode 10</p><p>题目：请实现一个函数用来匹配包括’.’和’*‘的正则表达式。*表示前面字符0~无穷个，.表示任意一个字符。要求全部，匹配，不是部分匹配。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配</p><p>思路：二维DP问题。这道题的核心是分析’<em>‘，DP[i][j]代表计算str[:i]与patten[:j]匹不匹配.最终要得到的结果就是dp[s.length()][p.length()]，转移方程如下(时间复杂度O(m\</em>n)，空间复杂度O(n)):</p><pre><code>dp[i][j] = dp[i - 1][j - 1], 如果s[i] == p[j] || p[j] == &#39;.&#39;=dp[i][j - 2], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] != p[j - 1](只能匹配0次)=dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j], 如果s[i] != p[j] &amp;&amp; p[j] == &#39;*&#39; &amp;&amp; s[i] == p[j - 1](匹配0\1\多次)返回：dp[s.length()][p.length()]</code></pre><p>代码：</p><pre><code class="java">//正则匹配. *。思路：二维DP。public boolean isMatch(String s, String p) {    if(s == null || p == null) return false;    boolean[][] dp = new boolean[s.length()+1][p.length()+1];    dp[0][0] = true;    for(int i = 0; i &lt; p.length(); i++){        if (p.charAt(i) == &#39;*&#39; &amp;&amp; dp[0][i-1]) {            dp[0][i+1] = true;        }    }    for(int i = 0; i &lt; s.length(); i++){        for(int j = 0; j &lt; p.length(); j++){            if(s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;){                dp[i+1][j+1] = dp[i][j];            }            if(p.charAt(j) == &#39;*&#39;){                if(s.charAt(i) != p.charAt(j-1) &amp;&amp; p.charAt(j-1) != &#39;.&#39;){                    dp[i+1][j+1] = dp[i+1][j-1];                }else{                    dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];                }            }        }    }    return dp[s.length()][p.length()];}public static void main(String[] args){    char[] str = new char[]{&#39;a&#39;,&#39;a&#39;,&#39;a&#39;};    char[] pattern = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;*&#39;, &#39;a&#39;, &#39;c&#39;, &#39;*&#39;, &#39;a&#39;};    char[] str2 = new char[]{&#39;a&#39;,&#39;b&#39;};    char[] pattern2 = new char[]{&#39;.&#39;,&#39;*&#39;,&#39;c&#39;};    String s = &quot;ab&quot;;    String p = &quot;.*c&quot;;//这对测试用例解决了一个大bug，很好    System.out.println(isMatch(s,p));}</code></pre><p><a name="35"></a></p><h2 id="35-表示数值的字符串"><a href="#35-表示数值的字符串" class="headerlink" title="35.表示数值的字符串"></a>35.表示数值的字符串</h2><p>《剑指offer》p127、leetcode 65</p><p>题目：请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><p>思路：+A.Be+C，对字符串分别判断A、B、C部分是否存在且是否正确，都正确则返回true。注意边界条件：</p><p>1.整数部分判断，整数部分可以没有，但没有则必须：</p><pre><code>有小数部分，小数点+小数部分--&gt;  -.123正确, -.错误 没有小数点，也没有小数部分--&gt;  -正确</code></pre><p>2.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)</p><p>3.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)</p><pre><code class="java">public class Solution{    //+A.Be+C    public static boolean isNumeric(char[] str) {        if(str==null || str.length==0){            return false;        }        //遍历字符串        int index = 0;        //1.正负号判断        if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){            index++;        }        //2.整数部分判断(整数部分可以没有 但没有则必须要有小数部分，-.123正确, -.错误)        boolean num = false;//是否有整数部分        int indexTemp = readNum(str, index);        if(indexTemp&gt;index){//有整数部分            num = true;        }        index = indexTemp;        //3.判断小数部分,小数部分前面如果有整数则小数部分可以没有，小数部分前面如果没有整数则必须要有小数部分(-.123正确, -.错误 .5正确 .错误, 100.正确)        if(index&lt;str.length &amp;&amp; str[index]==&#39;.&#39;){            index++;            indexTemp = readNum(str, index);            if(!num &amp;&amp; indexTemp==index){//小数部分前面如果没有整数则必须要有小数部分                return false;            }            index = indexTemp;            num = true;        }        //4.判断e部分，如果有e部分则e有且必须有后面的整数，同时有且必须有前面的数字(e9是错误的, .e9是正确的)        if(index&lt;str.length &amp;&amp; (str[index]==&#39;e&#39;||str[index]==&#39;E&#39;) ){            if(!num){//e部分前面没有数字，false (e9错误)                return false;            }            index++;            if(index==str.length){//有e但没有后面的整数部分，false                return false;            }            if(str[index]==&#39;+&#39; || str[index]==&#39;-&#39;){                index++;            }            indexTemp = readNum(str, index);            if(indexTemp==index){//有e但没有后面的整数部分，false                return false;            }            index = indexTemp;        }        if(index!=str.length){//如果都判断完了，字符串还有字符，false            return false;        }        return true;    }    //遍历读取数字部分，返回不是数字的索引    public static int readNum(char[] str, int index){        while(index&lt;str.length){            int temp = str[index]-&#39;0&#39;;            if(temp&lt;0 || temp&gt;9){//不是数字                return index;            }            else{//是数字                index++;            }        }        return index;    }    public static void main(String[] args){        String s1 = &quot;.5&quot;;//Expected:true        String s2 = &quot;.&quot;;//Expected:false        String s = &quot;100.&quot;;//Expected:true        String s4 = &quot;-&quot;;//Expected:true        System.out.println(isNumeric(s4.trim().toCharArray()));    }}</code></pre><p><a name="36"></a></p><h2 id="36-调整数组顺序使奇数位于偶数前面-3道"><a href="#36-调整数组顺序使奇数位于偶数前面-3道" class="headerlink" title="36.调整数组顺序使奇数位于偶数前面(3道)"></a>36.调整数组顺序使奇数位于偶数前面(3道)</h2><pre><code>《剑指offer》p129(需要保持顺序不变)leetcode 905(不用保持顺序)leetcode 328(调整链表的奇偶顺序)</code></pre><h3 id="《剑指offer》p129-需要保持顺序不变"><a href="#《剑指offer》p129-需要保持顺序不变" class="headerlink" title="《剑指offer》p129(需要保持顺序不变)"></a>《剑指offer》p129(需要保持顺序不变)</h3><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>思路：遍历一遍数组，记下奇数偶数个数；建立新数组temp后，再遍历一遍原数组，奇数偶数分开放到新数组temp中；将新数组temp的值赋给原数组array。时间o(n)，空间o(n)</p><pre><code class="java">public static void reOrderArray(int [] array) {    if(array==null || array.length&lt;2){        return;    }    int cntOdd = 0;//记录奇数个数    for(int i: array){//遍历一遍数组，记下奇数偶数个数        if((i&amp;1)==1){            cntOdd++;        }    }    int oddIndex = 0;//奇数index    int evenIndex = cntOdd;//偶数index    int[] tempArray = new int[array.length];    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，奇数偶数分开放到新数组temp中        if((array[i]&amp;1)== 1){            tempArray[oddIndex++] = array[i];        }        else{            tempArray[evenIndex++] = array[i];        }    }    for(int i=0; i&lt;array.length; ++i){//再遍历一遍数组，将新数组temp的值赋给原数组array        array[i] = tempArray[i];    }}</code></pre><h3 id="Sort-Array-By-Parity"><a href="#Sort-Array-By-Parity" class="headerlink" title="Sort Array By Parity"></a>Sort Array By Parity</h3><p>leetcode 905</p><p>题目：偶数在前，奇数在后，不用保持顺序</p><p>Example :</p><pre><code>Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</code></pre><p>思路：既然不用保持顺序，那么就不用空间o(n)的辅助了，思路：遍历一遍数组，两个指针变量，partition思想</p><pre><code class="java">//偶数在前，奇数在后，不用保持顺序。思路：遍历一遍数组，两个指针变量，partition思想public static int[] sortArrayByParity(int[] A) {    if(A==null || A.length&lt;2){        return A;    }    int storeEven = 0;//遍历一遍数组，把偶数放在前面。storeEven左边都是偶数    for(int i=0; i&lt;A.length; ++i){        if((A[i]&amp;1)==0){            swap(A, storeEven++, i);        }    }    return A;}public static void swap(int[] A, int i, int j){    int temp = A[i];    A[i] = A[j];    A[j] = temp;}</code></pre><h3 id="Odd-Even-Linked-List"><a href="#Odd-Even-Linked-List" class="headerlink" title="Odd Even Linked List"></a>Odd Even Linked List</h3><p>leetcode 328</p><p>题目：Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p>题目大意：奇数号节点在前，偶数号节点在后，同时要求时间o(n)，空间o(1)</p><p>Example 1:</p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL    </code></pre><p>Example 2:</p><pre><code>Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULLOutput: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><p>思路：拆分成两个链表，奇数号链表、偶数号链表，最后再合成即可</p><pre><code class="java">public ListNode oddEvenList(ListNode head) {    if(head==null || head.next==null || head.next.next==null){        return head;    }    //奇数号链表    ListNode oddHead = head;    ListNode oddP = oddHead;    //偶数号链表    ListNode evenHead = head.next;    ListNode evenP = evenHead;    //遍历并拆分原链表    ListNode cur = oddP.next.next;    oddP.next = null;    evenP.next = null;    ListNode temp;    while(cur!=null &amp;&amp; cur.next!=null){        //奇数号节点        temp = cur;        cur = cur.next;        oddP.next = temp;        oddP = oddP.next;        oddP.next = null;        //偶数号节点        temp = cur;        cur = cur.next;        evenP.next = temp;        evenP = evenP.next;        evenP.next = null;    }    if(cur!=null){//如果还剩一个奇数号节点        oddP.next = cur;        oddP = oddP.next;        oddP.next = null;    }    //连接奇偶两个链表    oddP.next = evenHead;    return oddHead;}</code></pre><p><a name="37"></a></p><h2 id="37-链表中倒数第k个结点-两道"><a href="#37-链表中倒数第k个结点-两道" class="headerlink" title="37.链表中倒数第k个结点(两道)"></a>37.链表中倒数第k个结点(两道)</h2><pre><code>《剑指offer》p134--返回倒数第k个结点《左神》p35==leetcode19--删除倒数第k个结点</code></pre><h3 id="1-返回倒数第k个结点"><a href="#1-返回倒数第k个结点" class="headerlink" title="1.返回倒数第k个结点"></a>1.返回倒数第k个结点</h3><p>《剑指offer》p134</p><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：双指针，遍历一遍链表即可。时间o(n),空间o(1)</p><pre><code class="java">public static ListNode FindKthToTail(ListNode head,int k) {    if(head==null || k&lt;=0){        return null;    }    ListNode right = head;//先出发，走k-1个节点    ListNode left = head;//后出发，直到right.next为null时left即为所求    //1.right先走k-1个节点    while(k!=1){        right = right.next;        if(right==null){            return null;//链表的节点数都不够k个，更没有倒数第k个节点了        }        k--;    }    //2.left、right一起走，直到right.next==null    while(right.next!=null){        left = left.next;        right = right.next;    }    return left;}</code></pre><h3 id="2-删除倒数第k个节点"><a href="#2-删除倒数第k个节点" class="headerlink" title="2.删除倒数第k个节点"></a>2.删除倒数第k个节点</h3><p>《左神》35==leetcode19，思路差不多，删除时应该首先遍历到倒数第k+1个节点，且需要设置哨兵</p><pre><code class="java">//删除倒数第n个节点，则需要找到倒数第n+1个节点，需要设置哨兵public ListNode removeNthFromEnd(ListNode head, int n) {    if(head==null || n&lt;=0){        return null;    }    //1.设置哨兵    ListNode guard = new ListNode(0);    guard.next = head;    //2.找到倒数第n+1个节点    ListNode right = guard;//先出发，走n-1个节点    ListNode left = guard;//后出发，直到right.next为null时left即为所求    //1.right先走n个节点    while(n!=0){        right = right.next;        n--;    }    //2.left、right一起走，直到right.next==null，此时left指向倒数第n+1个节点    while(right.next!=null){        left = left.next;        right = right.next;    }    //3.删除倒数第k个节点    left.next = left.next.next;    return guard.next;}</code></pre><p><a name="38"></a></p><h2 id="38-判断链表是否有环-两道"><a href="#38-判断链表是否有环-两道" class="headerlink" title="38.判断链表是否有环(两道)"></a>38.判断链表是否有环(两道)</h2><h3 id="1-判断链表是否有环"><a href="#1-判断链表是否有环" class="headerlink" title="1.判断链表是否有环"></a>1.判断链表是否有环</h3><p>leetcode 141</p><p>题目：Given a linked list, determine if it has a cycle in it.</p><p>思路：每次fast走两步，low走一步，如果两者相遇则有环，如果遇到null则无环</p><pre><code class="java">public boolean hasCycle(ListNode head) {    if(head==null){        return false;    }    //判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环    ListNode right = head;//走两步    ListNode left = head;//走一步    while(right!=null &amp;&amp; right.next!=null){        right = right.next.next;        left = left.next;        if(right==left){//如果相遇，则有环            return true;        }    }    return false;}</code></pre><h3 id="2-判断链表是否有环，有则返回环的入口结点"><a href="#2-判断链表是否有环，有则返回环的入口结点" class="headerlink" title="2.判断链表是否有环，有则返回环的入口结点"></a>2.判断链表是否有环，有则返回环的入口结点</h3><p>《剑指offer》p139、leetcode 142</p><p>题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>思路：</p><blockquote><p>1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环</p><p>如果有环：前后指针相遇的地方一定在环中，此时遍历这个环计算环的节点数k，之后从头遍历链表，前指针比后指针多走k步，前后指针再次相遇时即为为环的入口节点</p></blockquote><pre><code class="java">class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}//给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。public ListNode EntryNodeOfLoop(ListNode pHead){    if(pHead==null){        return null;    }    //1.判断链表是否有环。思路：两个指针，一个走两步，一个走一步，如果能遇上则有环    ListNode right = pHead;//走两步    ListNode left = pHead;//走一步    boolean haveCycle = false; //是否有环    while(right!=null &amp;&amp; right.next!=null){        right = right.next.next;        left = left.next;        if(right==left){//如果相遇，则有环            haveCycle = true;            break;        }    }    if(!haveCycle){//如果没环，返回null        return null;    }    //2.有环，找出环的入口节点。    //  思路：2.1遍历环计算环中节点个数k个；    //       2.2从头遍历链表，两个指针，一个先走k，两个一起走直到相遇即为入口节点    //2.1遍历环计算环中节点个数k个    int cycleNum = 1; //环中节点个数    while(right.next!=left){        cycleNum++;        right = right.next;    }    //2.2从头遍历链表，两个指针，一个先走cycleNum-1个节点，两个一起走直到相遇时left即为入口节点    right = pHead;    left = pHead;    while(cycleNum!=1){//right先走cycleNum-1个节点        right = right.next;        cycleNum--;    }    while(right.next!=left){//right、left两个一起走，直到相遇时的left节点即为所求        right = right.next;        left = left.next;    }    return left;}</code></pre><p><a name="39"></a></p><h2 id="39-两个单链表相交的第一个公共节点-2道"><a href="#39-两个单链表相交的第一个公共节点-2道" class="headerlink" title="39.两个单链表相交的第一个公共节点(2道)"></a>39.两个单链表相交的第一个公共节点(2道)</h2><pre><code>两个链表的第一个公共节点(无环)--《剑指offer》p253、leetcode 160两个链表的第一个公共节点(可能有环，需自己判断)--《左神》62，掌握这一道题就够了</code></pre><h3 id="1-两个链表的第一个公共节点-无环"><a href="#1-两个链表的第一个公共节点-无环" class="headerlink" title="1.两个链表的第一个公共节点(无环)"></a>1.两个链表的第一个公共节点(无环)</h3><p>《剑指offer》p253、leetcode 160</p><p>题目：输入两个链表，链表无环，找出它们的第一个公共结点。如果不相交返回null</p><p>思路：</p><p>法一：因为要从两个链表的尾部往前一一判断，因此需要借助两个栈的辅助。java栈的实现可以用LinkedList。时间o(m+n)，空间o(m+n)</p><p>法二(更简单的办法)：链表长度差。首先遍历两个链表得到他们的长度，就能知道哪个链表比较长，以及长的链表比短的链表多几个结点。在第二次遍历的时候，在较长的链表上先走若干步，接着再同时在两个链表上遍历，找到第一个相同的结点就是他们的第一个公共结点。时间o(m+n)，空间o(1)</p><pre><code class="java">//返回两个无环链表相交的第一个节点，如果不相交返回nullpublic static ListNode FindFirstNoCycleCommonNode(ListNode head1, ListNode head2){    if(head1==null || head2==null){        return null;    }    //1.计算两个链表的长度    int len1 = 1;    int len2 = 1;    ListNode p1 = head1;    ListNode p2 = head2;    while(p1.next!=null){        len1++;        p1 = p1.next;    }    while(p2.next!=null){        len2++;        p2 = p2.next;    }    if(p1!=p2){//两个链表的最后一个节点不相同，说明不相交        return null;    }    //2.计算长度差k，让长链表先走k步    ListNode longList = len1&gt;=len2?head1:head2;    ListNode shortList = longList==head1?head2:head1;    int k = Math.abs(len1-len2);    while(k!=0){        longList = longList.next;        k--;    }    //3.两个链表一起走，直到找到相交的第一个节点    while(longList!=null &amp;&amp; shortList!=null){        if(longList==shortList){            return longList;        }        longList = longList.next;        shortList = shortList.next;    }    return null;//不相交}</code></pre><h3 id="2-两个链表的第一个公共节点-可能有环，需自己判断"><a href="#2-两个链表的第一个公共节点-可能有环，需自己判断" class="headerlink" title="2.两个链表的第一个公共节点(可能有环，需自己判断)"></a>2.两个链表的第一个公共节点(可能有环，需自己判断)</h3><p>《左神》62，掌握这一道题就够了</p><p>题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null</p><p>思路：</p><p>1.判断两个链表是否有环</p><pre><code>1.1 若一个链表有环，另一个链表无环，则不可能相交，返回null1.2 都无环则判断两个无环链表的第一个公共节点，没有返回null</code></pre><p>2.若有环，判断两个有环链表的第一个公共节点。</p><pre><code>2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null</code></pre><p>代码：</p><pre><code class="java">class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}public class Solution{    /**     * 题目：返回两个链表的第一个公共节点(可能有环，需自己判断)，没有的话返回null     * 思路：     *   1.判断两个链表是否有环，都无环则判断两个无环链表的第一个公共节点，没有返回null     *   2.判断两个有环链表的第一个公共节点。     *     2.1找两个有环链表的入口节点p1/p2，若p1==p2则交点在发生在环前，与无环链表公共节点求法类似(长度差，分别先后走找交点)     *     2.2若p1!=p2交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null     */    public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) {        if(head1==null || head2==null){            return null;        }        ListNode beginNodeOfCycle1 = hasCycle(head1);//链表head1是否有环，无环返回null，有环返回入口节点        ListNode beginNodeOfCycle2 = hasCycle(head2);//链表head2是否有环，无环返回null，有环返回入口节点        //1.两个链表都无环，判断两个无环链表的第一个公共节点，没有返回null        if (beginNodeOfCycle1==null &amp;&amp; beginNodeOfCycle2==null) {            return noCycleCommonNode(head1, head2);        }        //2.两个链表都有环        if (beginNodeOfCycle1!=null &amp;&amp; beginNodeOfCycle2!=null) {            //2.1beginNodeOfCycle1==beginNodeOfCycle2,交点在发生在环前,与无环链表公共节点求法类似(长度差，分别先后走找交点)            if(beginNodeOfCycle1==beginNodeOfCycle2){                ListNode p1 = head1;                ListNode p2 = head2;                int len1 = 0;                int len2 = 0;                while(p1!=beginNodeOfCycle1){                    len1++;                    p1 = p1.next;                }                while(p2!=beginNodeOfCycle2){                    len2++;                    p2 = p2.next;                }                ListNode longHead = len1&gt;=len2 ? head1 : head2;                ListNode shortHead = longHead==head1 ? head2 : head1;                int k = Math.abs(len1-len2);                while(k!=0){//长链表先走k步                    longHead = longHead.next;                    k--;                }                while(longHead!=beginNodeOfCycle1 &amp;&amp; shortHead!=beginNodeOfCycle2){//两个链表一起走                    if(longHead==shortHead){//找到公共节点                        return longHead;                    }                    longHead = longHead.next;                    shortHead = shortHead.next;                }            }            //2.2beginNodeOfCycle11=beginNodeOfCycle2,交点发生在环中,从p1开始遍历环，如果遇到p2则找到交点即为p2，否则没有交点返回null            else{                while(beginNodeOfCycle1.next!=beginNodeOfCycle1){                    beginNodeOfCycle1 = beginNodeOfCycle1.next;                    if(beginNodeOfCycle1==beginNodeOfCycle2){//环中找到了第一个公共节点，返回                        return beginNodeOfCycle1;                    }                }                return null;//环中没有公共节点，即两个有环链表独立不相交的            }        }        //一个链表有环，一个链表无环，返回null        return null;    }    //判断一个链表是否有环，没环返回null，如果有环返回入口节点    public ListNode hasCycle(ListNode pHead){        ListNode p1 = pHead;//每次走两步        ListNode p2 = pHead;//每次走一步        boolean hasCycle = false;        while(p2.next!=null &amp;&amp; p1.next.next!=null){            p2 = p2.next.next;            p1 = p1.next;            if(p1==p2){                hasCycle = true;//两个指针相遇则有环                break;            }        }        if(hasCycle){//链表有环，返回入口节点            //1.计算环的节点个数            ListNode temp = p1;            int k = 1;            while(p1.next!=temp){                k++;                p1 = p1.next;            }            //2.right指针从链表头先走k步            ListNode right = pHead;            ListNode left = pHead;            while(k!=0){                right = right.next;                k--;            }            //3.left从头和right一起走，直到相遇            while(left!=right){                left = left.next;                right = right.next;            }            return left;//找到入口节点并返回        }        return null;//链表无环，返回null    }    //判断两个无环链表的第一个公共节点，没有则返回null    public ListNode noCycleCommonNode(ListNode head1, ListNode head2){        //长度差，一个先走k步，然后同时走，看是否有公共节点        if(head1==null || head2==null){            return null;        }        ListNode p1 = head1;        ListNode p2 = head2;        int len1 = 1;        int len2 = 1;        while(p1.next!=null){            len1++;            p1 = p1.next;        }        while(p2.next!=null){            len2++;            p2 = p2.next;        }        if(p1!=p2){//两个链表的最后一个节点不等，则没有公共节点，返回null            return null;        }        ListNode longHead = len1&gt;=len2 ? head1 : head2;        ListNode shortHead = longHead==head1 ? head2 : head1;        int k = Math.abs(len1-len2);        while(k!=0){//长链表先走k步            longHead = longHead.next;            k--;        }        while(longHead!=null &amp;&amp; shortHead!=null){//两个链表一起走            if(longHead==shortHead){//找到公共节点                return longHead;            }            longHead = longHead.next;            shortHead = shortHead.next;        }        return null;//没有公共节点，返回null    }}</code></pre><p><a name="40"></a></p><h2 id="40-合并两个排序的链表"><a href="#40-合并两个排序的链表" class="headerlink" title="40.合并两个排序的链表"></a>40.合并两个排序的链表</h2><p>《剑指offer》p145、leetcode21、《左神》84</p><p>题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>思路：正常的遍历两个链表结点，每次将较小的节点插到新链表的尾部即可。设置哨兵</p><pre><code class="java">//合并两个有序的链表，设置一个哨兵public ListNode Merge(ListNode list1,ListNode list2) {    ListNode guard = new ListNode(0);    ListNode p = guard;    ListNode temp;    while(list1!=null &amp;&amp; list2!=null){        if(list1.val&lt;=list2.val){            temp = list1;            list1 = list1.next;        }        else{            temp = list2;            list2 = list2.next;        }        temp.next = null;        p.next = temp;        p = p.next;    }    if(list1!=null){        p.next = list1;    }    if(list2!=null){        p.next = list2;    }    return guard.next;}</code></pre><p><a name="41"></a></p><h2 id="41-树的子结构"><a href="#41-树的子结构" class="headerlink" title="41.树的子结构"></a>41.树的子结构</h2><p>《剑指offer》p148、leetcode 572</p><p>题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>思路：分为两步。第一步，先序遍历树A，在树A中找到和树B的根节点值相同的节点R；第二步，判断树A中以R为根节点的子树是不是包含和树B一样的结构</p><pre><code class="java">class TreeNode {     int val = 0;     TreeNode left = null;     TreeNode right = null;     public TreeNode(int val) {        this.val = val;     }}//两个二叉树A、B，判断B是否是A的子结构。思路：先序遍历A，找到与B的根节点相同的节点，判断子结构是否相同public boolean HasSubtree(TreeNode root1,TreeNode root2) {    if(root1==null || root2==null){        return false;    }    if(root1.val==root2.val){        if(isSame(root1, root2)){            return true;        }    }    return HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);}public boolean isSame(TreeNode root1, TreeNode root2){    if(root2==null){        return true;    }    if(root1==null){        return false;    }    if(root1.val==root2.val){        return isSame(root1.left, root2.left) &amp;&amp; isSame(root1.right, root2.right);    }    return false;}</code></pre><p><a name="42"></a></p><h2 id="42-二叉树的翻转-镜像-与对称-2道"><a href="#42-二叉树的翻转-镜像-与对称-2道" class="headerlink" title="42.二叉树的翻转(镜像)与对称(2道)"></a>42.二叉树的翻转(镜像)与对称(2道)</h2><pre><code>《剑指offer》p157--二叉树的翻转(转换成镜像二叉树)leetcode 101、《剑指offer》p159--判断二叉树是否是对称</code></pre><h3 id="1-二叉树的翻转-镜像"><a href="#1-二叉树的翻转-镜像" class="headerlink" title="1.二叉树的翻转(镜像)"></a>1.二叉树的翻转(镜像)</h3><p>《剑指offer》p157</p><p>题目：操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>思路：前序遍历树的每一个结点，对每个节点的左右子树互换，递归下去即可。</p><pre><code class="java">//操作给定的二叉树，将其变换为源二叉树的镜像。思路：左右子树互换，递归下去即可public void Mirror(TreeNode root) {    if(root==null){        return;    }    TreeNode temp = root.left;    root.left = root.right;    root.right = temp;    Mirror(root.left);    Mirror(root.right);}</code></pre><h3 id="2-对称的二叉树"><a href="#2-对称的二叉树" class="headerlink" title="2.对称的二叉树"></a>2.对称的二叉树</h3><p>《剑指offer》p159、leetcode 101 </p><p>题目：判断一颗二叉树是不是对称的</p><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p><pre><code>    1   / \  2   2 / \ / \3  4 4  3</code></pre><p>思路：根左右与根右左的递归判断即可。</p><p>从根开始，先判断其左右孩子，如果都不存在则为true</p><p>如果只有一个为空或者两个指向的val值不同则为false</p><p>当根的左右孩子节点相同时，再判断其左孩子的左孩子和右孩子的右孩子、左孩子的右孩子和右孩子的左孩子</p><pre><code class="java">//判断一颗二叉树是不是对称的。思路：根左右与根右左的递归判断即可public boolean isSymmetrical(TreeNode pRoot){    if(pRoot==null){        return true;    }    if(pRoot.left==null &amp;&amp; pRoot.right==null){        return true;    }    if(pRoot.left!=null &amp;&amp; pRoot.right!=null){        return isSymmetricalDetail(pRoot.left, pRoot.right);    }    return false;}public boolean isSymmetricalDetail(TreeNode root1, TreeNode root2){    if(root1==null &amp;&amp; root2==null){        return true;    }    if(root1==null || root2==null){        return false;    }    if(root1.val==root2.val){        return isSymmetricalDetail(root1.left, root2.right) &amp;&amp; isSymmetricalDetail(root1.right, root2.left);    }    return false;}</code></pre><p><a name="43"></a></p><h2 id="43-顺时针打印矩阵"><a href="#43-顺时针打印矩阵" class="headerlink" title="43.顺时针打印矩阵"></a>43.顺时针打印矩阵</h2><p>《剑指offer》p161、leetcode 54 spiral Matrix(螺旋矩阵)</p><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p>思路：先定义好打印一圈的函数，然后根据矩阵大小确定需要打印几圈。</p><pre><code class="java">import java.util.ArrayList;public class Solution{    //顺时针打印矩阵。思路：先定义打印一圈的函数，再确定打印几圈    public static ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) {        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();        if(matrix==null){            return res;        }        int m = matrix.length;        int n = matrix[0].length;        int startI = 0;        int startJ = 0;        int endI = m-1;        int endJ = n-1;        int cycleNum = (int)Math.ceil((double)Math.min(m,n)/2);//一共打印cycleNum圈        while(cycleNum!=0){//循环打印cycleNum圈            printOneCycle(matrix, startI, startJ, endI, endJ, res);            startI++;            startJ++;            endI--;            endJ--;            cycleNum--;        }        return res;    }    //定义打印一圈的函数。限定一圈的边界需要两个参数，圈的左上角元素和右下角元素的坐标    public static void printOneCycle(int[][] matrix, int startI, int startJ, int endI, int endJ, ArrayList&lt;Integer&gt; res){        //1.打印圈的上边，每圈都有        int temp = startJ;        while(temp&lt;=endJ) {            res.add(matrix[startI][temp]);            temp++;        }        //2.打印圈的右边，必须两行以上        temp = startI+1;        while(endI&gt;startI &amp;&amp; temp&lt;=endI){            res.add(matrix[temp][endJ]);            temp++;        }        //3.打印圈的下边，必须两行以上、两列以上        temp = endJ-1;        while(endI&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;=startJ){            res.add(matrix[endI][temp]);            temp--;        }        //4.打印圈的左边，必须三行以上、两列以上        temp = endI - 1;        while(endI-1&gt;startI &amp;&amp; endJ&gt;startJ &amp;&amp; temp&gt;startI){            res.add(matrix[temp][startJ]);            temp--;        }    }    public static void main(String[] args){        int[][] matrix = new int[][]{{1,2,3,4},                                    {5,6,7,8},                                    {9,10,11,12},                                    {13,14,15,16}};        System.out.println(printMatrix(matrix));    }}</code></pre><p><a name="44"></a></p><h2 id="44-包含min函数的栈"><a href="#44-包含min函数的栈" class="headerlink" title="44.包含min函数的栈"></a>44.包含min函数的栈</h2><p>《剑指offer》p165、leetcode155</p><p>题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））</p><p>思路：如果只用一个元素保存最小的元素，那么当最小的元素被弹出后，就没有办法得到剩余元素中最下的元素。因此引入辅助栈，每次将最小元素（之前的最小元素和新压入的元素两者的较小者）都保存起来放到辅助栈里。</p><pre><code class="java">import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stk = new Stack&lt;&gt;();    Stack&lt;Integer&gt; minStk = new Stack&lt;&gt;(); //辅助栈，每次push时都压入当前最小值（node与minStk栈顶元素中的较小者）    public void push(int node) {        stk.push(node);        if(minStk.empty() || node &lt; minStk.peek()){            minStk.push(node);        }        else{            minStk.push(minStk.peek());        }    }    public void pop() {        stk.pop();        minStk.pop();    }    public int top() {        return stk.peek();    }    public int min() {        return minStk.peek();    }}</code></pre><p><a name="45"></a></p><h2 id="45-栈的压入、弹出序列"><a href="#45-栈的压入、弹出序列" class="headerlink" title="45.栈的压入、弹出序列"></a>45.栈的压入、弹出序列</h2><p>《剑指offer》p168、leetcode 946</p><p>题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>思路：借助一个辅助栈来模拟入栈弹栈过程。每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环（直到出栈序列遍历完返回true）；如果不等：入栈后面的数字（直到入栈序列遍历完还没找到则false）</p><pre><code class="java">//每次都入栈一个数字，并且循环比较(栈顶与出栈序列当前元素),如果相等:弹栈继续下一次循环；如果不等：入栈后面的数字public static boolean IsPopOrder(int [] pushA,int [] popA) {    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();    int len = pushA.length;    int pushAIndex = 0;    int popAIndex = 0;    while(popAIndex&lt;len){        if(stack.isEmpty() || popA[popAIndex]!=stack.peek()){            if(pushAIndex==len){ //直到入栈序列遍历完还没找到则false                return false;            }            stack.push(pushA[pushAIndex]);            pushAIndex++;        }else{            if(!stack.isEmpty()){                stack.pop();                popAIndex++;            }        }    }    return true;//直到出栈序列遍历完返回true}</code></pre><p><a name="46"></a></p><h2 id="46-二叉树的层序遍历-3道"><a href="#46-二叉树的层序遍历-3道" class="headerlink" title="46.二叉树的层序遍历(3道)"></a>46.二叉树的层序遍历(3道)</h2><pre><code>二叉树的层序遍历--《剑指offer》p171二叉树的层序遍历，按行打印--《剑指offer》p174、leetcode 102、leetcode107二叉树的层序遍历，之字形按行打印--《剑指offer》p176、leetcode 103</code></pre><h3 id="1-二叉树的层序遍历"><a href="#1-二叉树的层序遍历" class="headerlink" title="1.二叉树的层序遍历"></a>1.二叉树的层序遍历</h3><p>《剑指offer》p171</p><p>题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路：借助队列实现层序遍历</p><pre><code class="java">//二叉树的层序遍历。思路：辅助队列public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        res.add(temp.val);        if(temp.left!=null){            queue.offer(temp.left);        }        if(temp.right!=null){            queue.offer(temp.right);        }    }    return res;}</code></pre><h3 id="2-二叉树的层序遍历，按行打印"><a href="#2-二叉树的层序遍历，按行打印" class="headerlink" title="2.二叉树的层序遍历，按行打印"></a>2.二叉树的层序遍历，按行打印</h3><p>《剑指offer》p174、leetcode 102、leetcode107</p><p>题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数。</p><pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCntArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(pRoot==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(pRoot);    int curCnt = 1;    int nextCnt = 0;    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        resTemp.add(temp.val);        curCnt--;        if(temp.left!=null){            queue.offer(temp.left);            nextCnt++;        }        if(temp.right!=null){            queue.offer(temp.right);            nextCnt++;        }        if(curCnt==0){            res.add(resTemp);            resTemp = new ArrayList&lt;&gt;();            curCnt = nextCnt;            nextCnt = 0;        }    }    return res;}</code></pre><h3 id="3-二叉树的层序遍历，之字形按行打印"><a href="#3-二叉树的层序遍历，之字形按行打印" class="headerlink" title="3.二叉树的层序遍历，之字形按行打印"></a>3.二叉树的层序遍历，之字形按行打印</h3><p>《剑指offer》p176、leetcode 103</p><p>题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p>思路：在既有层序遍历上添加两个变量，分别记录当前层的节点数和下一层的节点数；且辅助奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)</p><pre><code class="java">//二叉树的层序遍历，每一层输出一行。思路：辅助队列，两个变量来计数当前层和下一层的节点个数curCnt\nextCntArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(pRoot==null){        return res;    }    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(pRoot);    int curCnt = 1;    int nextCnt = 0;    ArrayList&lt;Integer&gt; resTemp = new ArrayList&lt;&gt;();    boolean odd = true; //奇偶行的标志位，奇数行从左到右，偶数行从右到左(Collections.reverse即可)    while(!queue.isEmpty()){        TreeNode temp = queue.poll();        resTemp.add(temp.val);        curCnt--;        if(temp.left!=null){            queue.offer(temp.left);            nextCnt++;        }        if(temp.right!=null){            queue.offer(temp.right);            nextCnt++;        }        if(curCnt==0){            if(!odd){//当前行是偶数行，从右往左，reverse下                Collections.reverse(resTemp);            }            res.add(resTemp);            resTemp = new ArrayList&lt;&gt;();            curCnt = nextCnt;            nextCnt = 0;            odd = !odd;//下一行的奇偶是!odd        }    }    return res;}</code></pre><p><a name="47"></a></p><h2 id="47-递归与非递归实现二叉树前序、中序、后序遍历"><a href="#47-递归与非递归实现二叉树前序、中序、后序遍历" class="headerlink" title="47.递归与非递归实现二叉树前序、中序、后序遍历"></a>47.递归与非递归实现二叉树前序、中序、后序遍历</h2><p>《左神》88、 leetcode144、94、145</p><p>题目：递归与非递归实现二叉树前序、中序、后序遍历</p><h3 id="1-前序："><a href="#1-前序：" class="headerlink" title="1.前序："></a>1.前序：</h3><pre><code class="java">//递归实现前序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; preorderTraversal(TreeNode root) {    if(root==null){        return res;    }    res.add(root.val);    if(root.left!=null){        res = preorderTraversal(root.left);    }    if(root.right!=null){        res = preorderTraversal(root.right);    }    return res;}//非递归实现前序遍历public List&lt;Integer&gt; preorderTraversal(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            res.add(temp.val);//压栈之前先访问            stack.push(temp);            temp = temp.left;        }        else{            temp = stack.pop().right;        }    }    return res;}</code></pre><h3 id="2-中序"><a href="#2-中序" class="headerlink" title="2.中序"></a>2.中序</h3><pre><code class="java">//递归实现中序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; inorderTraversal(TreeNode root) {    if(root==null){        return res;    }    if(root.left!=null){        res = inorderTraversal(root.left);    }    res.add(root.val);    if(root.right!=null){        res = inorderTraversal(root.right);    }    return res;}​//非递归实现中序遍历public List&lt;Integer&gt; inorderTraversal(TreeNode root) {     List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){         return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            stack.push(temp);            temp = temp.left;        }        else{            temp = stack.pop();            res.add(temp.val);            temp = temp.right;        }    }    return res;}</code></pre><p>​    </p><h3 id="3-后序"><a href="#3-后序" class="headerlink" title="3.后序"></a>3.后序</h3><pre><code class="java">//递归实现后序遍历ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();public ArrayList&lt;Integer&gt; postorderTraversal(TreeNode root){    if(root==null){        return res;    }    if(root.left!=null){        res = postorderTraversal(root.left);    }    if(root.right!=null){        res = postorderTraversal(root.right);    }    res.add(root.val);    return res;}//非递归实现后序遍历。思路：1.根右左压栈，利用中间栈output来存储逆后序遍历的结果 + 2.最后再一起输出即可public List&lt;Integer&gt; postorderTraversal(TreeNode root) {    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    if(root==null){        return res;    }    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();//定义栈,存根节点    Stack&lt;TreeNode&gt; output = new Stack&lt;&gt;();//还需要一个辅助栈来存储逆后序遍历的结果    TreeNode temp = root;    while(temp!=null || !stack.isEmpty()){        if(temp!=null){            stack.push(temp);            output.push(temp);            temp = temp.right;        }        else{            temp = stack.pop().left;        }    }    while(!output.isEmpty()){        res.add(output.pop().val);    }    return res;}</code></pre><p><a name="48"></a></p><h2 id="48-判断数组是否为二叉搜索树的后续遍历序列"><a href="#48-判断数组是否为二叉搜索树的后续遍历序列" class="headerlink" title="48.判断数组是否为二叉搜索树的后续遍历序列"></a>48.判断数组是否为二叉搜索树的后续遍历序列</h2><p>《剑指offer》p179.</p><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>思路：后序遍历序列是左右根，所以先取数组中最后一个数，作为根节点。</p><pre><code>1.找根2.找根左右的左右分界线(从左往右第一个比根大的即为右)3.右可以没有，如果有右，则右中不含比根小的，否则false4.递归判断下去</code></pre><p>代码：</p><pre><code class="java">//题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果,假设输入的数组的任意两个数字都互不相同。/** * 思路： *   1.找根 *   2.找根左右的左右分界线(从左往右第一个比根大的即为➡右) *   3.右可以没有，如果有右，则右中不含比根小的，否则false *   4.递归判断下去 */​    public boolean VerifySquenceOfBST(int [] sequence) {​        if(sequence==null || sequence.length==0){​            return false;​        }​        if(sequence.length==1){​            return true;​        }​        return VerifySquenceOfBSTDetail(sequence, 0, sequence.length-1);​    }​    public boolean VerifySquenceOfBSTDetail(int[] sequence, int start, int end){​        if(start&gt;end){​            return false;​        }​        if(start==end){​            return true;​        }​        //1.找根​        int root = sequence[end];​​        //2.找左右分界线​        int rightIndex = start;​        int temp = start;​        while(temp&lt;end){​            if(sequence[temp]&gt;root){//第一个比root大的节点即为右​                rightIndex = temp;​                break;​            }​            temp++;​        }​        if(temp==end){//只有左，没有右，则递归判断左即可​            return VerifySquenceOfBSTDetail(sequence, start, end-1);​        }​    //3.有右，则右中不能含比根小的，否则返回false    temp = rightIndex;    while(temp&lt;end){        if(sequence[temp]&lt;root){//右中含比根小的，返回false            return false;        }        temp++;    }    //4.递归判断左、右序列即可    if(rightIndex==start){//只有左，没有右，递归判断右即可        return VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);    }    else{//有左有右        return VerifySquenceOfBSTDetail(sequence, start, rightIndex-1) &amp;&amp; VerifySquenceOfBSTDetail(sequence, rightIndex, end-1);    }}</code></pre><p><a name="49"></a></p><h2 id="49-二叉树中和为指定值的路径-2道"><a href="#49-二叉树中和为指定值的路径-2道" class="headerlink" title="49.二叉树中和为指定值的路径(2道)"></a>49.二叉树中和为指定值的路径(2道)</h2><pre><code>leetcode 112--二叉树中和为指定值的一条路径《剑指offer》p182、leetcode 113--二叉树中和为指定值的所有路径(回溯法)</code></pre><h3 id="1-Path-Sum"><a href="#1-Path-Sum" class="headerlink" title="1.Path Sum"></a>1.Path Sum</h3><p>leetcode 112</p><p>题目：二叉树中和为指定值的一条路径。</p><p>思路：正常递归遍历即可。</p><pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的一条路径。List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();public boolean hasPathSum(TreeNode root, int sum) {    if(root==null){        return false;    }    sum -= root.val;    if(root.left==null &amp;&amp; root.right==null &amp;&amp; sum==0){//当前节点为叶节点且路径和==sum，true        return true;    }    return hasPathSum(root.left,sum) || hasPathSum(root.right, sum);}</code></pre><h3 id="2-Path-Sum-2"><a href="#2-Path-Sum-2" class="headerlink" title="2.Path Sum 2"></a>2.Path Sum 2</h3><p>《剑指offer》p182、leetcode 113</p><p>题目：二叉树中和为指定值的所有路径。输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p>思路：回溯法。遍历树每一条到叶子节点的路径，找寻符合条件的路径。到叶子节点如果还没有找到路径，就要回退到父节点继续寻找，依次类推。</p><pre><code class="java">//打印出二叉树中结点值的和为输入整数的满足条件的所有路径。思路：递归+回溯法ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//存放所有路径ArrayList&lt;Integer&gt; tempPath = new ArrayList&lt;&gt;();//存放当前路径public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {    if(root==null){        return res;    }    target -= root.val;    tempPath.add(root.val);    if(root.left==null &amp;&amp; root.right==null &amp;&amp; target==0){//当前节点是叶节点且路径和==target，满足条件        res.add(new ArrayList&lt;&gt;(tempPath));    }    FindPath(root.left, target);    FindPath(root.right, target);    tempPath.remove(tempPath.size()-1);//回溯点    return res;}</code></pre><p><a name="50"></a></p><h2 id="50-复杂链表的复制"><a href="#50-复杂链表的复制" class="headerlink" title="50.复杂链表的复制"></a>50.复杂链表的复制</h2><p>《剑指offer》p187、《左神》56、leetcode138</p><p>题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p>思路：分而治之，复杂问题分成小问题一一解决。时间o(n) 空间o(1)<br>1、遍历链表并复制结点，复制的结点在相应节点之后：a-&gt;b-&gt;c-&gt;d-&gt;e为a-&gt;a’-&gt;b-&gt;b’-&gt;c-&gt;c’-&gt;d-&gt;d’-&gt;e-&gt;e’<br>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;<br>3、拆分链表，将链表拆分为原链表和复制后的链表</p><pre><code class="java">class RandomListNode {    public int label;    public RandomListNode next, random;    public RandomListNode(int x) {        this.label = x;    }};public class Solution2 {    public RandomListNode copyRandomList(RandomListNode head) {        if(head==null){            return null;        }        RandomListNode p = head;        //1.遍历链表，复制节点        while(p!=null){            RandomListNode newNode = new RandomListNode(p.label);            newNode.next = p.next;            p.next = newNode;            p = p.next.next;        }        //2.遍历链表，复制random指针        p = head;        while(p!=null){            if(p.random!=null){                p.next.random = p.random.next;            }            p = p.next.next;        }        //3.拆分链表，将复制链表拆出来        p = pHead;        RandomListNode newHead = new RandomListNode(0);//新链表的哨兵        RandomListNode newP = newHead;        while(p!=null){            RandomListNode temp = p.next;            p.next = p.next.next;            temp.next = null;            newP.next = temp;            newP = newP.next;            p = p.next;        }    return newHead.next;    }}</code></pre><p><a name="51"></a></p><h2 id="51-二叉搜索树与双向链表-两道"><a href="#51-二叉搜索树与双向链表-两道" class="headerlink" title="51.二叉搜索树与双向链表(两道)"></a>51.二叉搜索树与双向链表(两道)</h2><h3 id="1-二叉搜索树转双向链表"><a href="#1-二叉搜索树转双向链表" class="headerlink" title="1.二叉搜索树转双向链表"></a>1.二叉搜索树转双向链表</h3><p>《剑指offer》p191、leetcode426、《左神》74</p><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>思路：中序遍历+记录有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序，因此需要辅助保存当前链表最后一个节点。</p><pre><code class="java">class TreeNode {    public int val;    public TreeNode left;    public TreeNode right;    public TreeNode(int x){        val = x;        this.left = null;        this.right = null;    }}public class Solution2 {    public TreeNode Convert(TreeNode root){        if(root==null){            return null;        }        TreeNode lastPointer = null;//当前有序双向链表的最后一个节点        lastPointer = ConvertDetail(lastPointer, root);        while(lastPointer.left!=null){            lastPointer = lastPointer.left;        }        return lastPointer;    }    //中序遍历，返回当前有序链表的最后一个节点。二叉搜索树的中序遍历是有序，且遍历到根节点时左子树形成的链表已经是有序的了    private TreeNode ConvertDetail(TreeNode lastPointer, TreeNode root){        if(root==null){            return lastPointer;        }        if(root.left!=null){            lastPointer = ConvertDetail(lastPointer, root.left);        }        root.left = lastPointer;        if(lastPointer!=null){            lastPointer.right = root;        }        lastPointer = root;        if(root.right!=null){            lastPointer = ConvertDetail(lastPointer, root.right);        }        return lastPointer;    }}</code></pre><h3 id="2-有序数组转平衡二叉树"><a href="#2-有序数组转平衡二叉树" class="headerlink" title="2.有序数组转平衡二叉树"></a>2.有序数组转平衡二叉树</h3><p>leetcode 108</p><p>题目：Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><p>思路：数组中间的数做root，递归二分即可。</p><pre><code class="java">//有序数组转成平衡二叉树。思路：数组中间的数做root，递归二分即可public TreeNode sortedArrayToBST(int[] nums) {    if(nums==null || nums.length==0){        return null;    }    return sortedArrayToBSTDetail(nums, 0, nums.length-1);}public TreeNode sortedArrayToBSTDetail(int[] nums, int start, int end){    if(start&lt;0 || end&gt;=nums.length || start&gt;end){        return null;    }    int mid = (start+end)/2;    TreeNode root = new TreeNode(nums[mid]);    root.left = sortedArrayToBSTDetail(nums, start, mid-1);    root.right = sortedArrayToBSTDetail(nums, mid+1, end);    return root;}</code></pre><p><a name="52"></a></p><h2 id="52-序列化二叉树"><a href="#52-序列化二叉树" class="headerlink" title="52.序列化二叉树"></a>52.序列化二叉树</h2><p>《剑指offer》p194、leetcode 297(序列化反序列化二叉树）、leetcode 449(序列化反序列化平衡二叉树)</p><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。</p><p>思路：序列化：前序遍历，遇到子节点为空用”$”代替；反序列化：按照前序遍历序列化的顺序进行反推。</p><pre><code class="java">//请实现两个函数，分别用来序列化和反序列化二叉树//1.序列化：前序遍历，遇到空节点为空用&quot;null&quot;代替public String serialize(TreeNode root) {    StringBuilder res = new StringBuilder();    serializeDetail(root, res);    return res.toString();}//这样分开的话，递归的时候不用保存全局变量res，防止二叉树太深导致的递归栈溢出public void serializeDetail(TreeNode root, StringBuilder res){    if(root==null){        res.append(&quot;null,&quot;);        return;    }    res.append(root.val + &quot;,&quot;);    serializeDetail(root.left, res);    serializeDetail(root.right, res);}//2.反序列化：按照前序遍历序列化的顺序进行反推,将String转成ArrayList&lt;String&gt;方便删除同时节省空间public TreeNode deserialize(String data) {    if(data==null || data.length()==0){        return null;    }    String[] str = data.split(&quot;,&quot;);    ArrayList&lt;String&gt; strr = new ArrayList&lt;&gt;(Arrays.asList(str));    return deserializeDetail(strr);}public TreeNode deserializeDetail(ArrayList&lt;String&gt; strr){    if(strr.size()==0){        return null;    }    String temp = strr.get(0);    strr.remove(0);    if(temp.equals(&quot;null&quot;)){        return null;    }    TreeNode root = new TreeNode(Integer.valueOf(temp));    root.left = deserializeDetail(strr);    root.right = deserializeDetail(strr);    return root;}</code></pre><p><a name="53"></a></p><h2 id="53-全排列-组合问题-五道"><a href="#53-全排列-组合问题-五道" class="headerlink" title="53.全排列/组合问题(五道)"></a>53.全排列/组合问题(五道)</h2><pre><code>1.字符串的全排列(abc,acb...)--《剑指offer》p1972.无重复数字的全排列--leetcode 463.有重复数字的全排列--leetcode 474.八皇后问题--《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)5.字符串s1的全排列是否在s2字符串中--leetcode 567</code></pre><h3 id="1-字符串的全排列"><a href="#1-字符串的全排列" class="headerlink" title="1.字符串的全排列"></a>1.字符串的全排列</h3><p>《剑指offer》p197</p><p>题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p><p>例如输入字符串abc，则打印由字符a,b,c所能排列出来的所有字符串：abc,acb,bac,bca,cab,cba。注意aac aac只能有一个，需要过滤重复</p><p>思路：递归。我们求整个字符串的排列，可以看成两步：首先求出所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换……</p><pre><code class="java">//字符串的全排列public ArrayList&lt;String&gt; Permutation(String str) {    ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();    if(str==null || str.length()==0){        return res;    }    PermutationDetail(res, str.toCharArray(), 0);    Collections.sort(res);//最后排序一下，按字典序输出    return res;}public void PermutationDetail(ArrayList&lt;String&gt; res, char[] str, int index){    if(index==str.length){//递归出口        String temp = String.valueOf(str);        if(!res.contains(temp)){//过滤重复            res.add(String.valueOf(str));        }        return;    }    for(int i=index; i&lt;str.length; ++i){        swap(str, i, index);//每次递归将index位置字符与后面所有字符进行分别交换        PermutationDetail(res, str, index+1);//当前位置交换后进行下一位上的排列递归        swap(str, i, index);    }}public void swap(char[] str, int i, int j){    char temp = str[i];    str[i] = str[j];    str[j] = temp;}</code></pre><h3 id="2-无重复数字的全排列"><a href="#2-无重复数字的全排列" class="headerlink" title="2.无重复数字的全排列"></a>2.无重复数字的全排列</h3><p>leetcode 46</p><p>题目：和字符串的全排列一样，换汤不换药。给定一个无重复数字的序列，返回这些数所能排列出所有序列。</p><pre><code>Input: [1,2,3]Output:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p>代码：</p><pre><code class="java">//数字的全排列public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    permuteDetail(res, nums, 0);    return res;}public void permuteDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        Integer[] temp = new Integer[nums.length];        for(int i= 0;i&lt;nums.length;i++){            temp[i]= nums[i];//int-&gt;Integer        }        res.add(Arrays.asList(temp));    }    for(int i=index; i&lt;nums.length; ++i){        swap(nums, i, index);//每次递归将index位置字符与后面所有字符进行分别交换        permuteDetail(res, nums, index+1);//当前位置交换后进行下一位上的排列递归        swap(nums, i, index);    }}public void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}</code></pre><h3 id="3-有重复数字的全排列"><a href="#3-有重复数字的全排列" class="headerlink" title="3.有重复数字的全排列"></a>3.有重复数字的全排列</h3><p>leetcode 47</p><p>题目：给定一个有重复数字的序列，返回这些数所能排列出所有序列。注意需要把重复的全排列给过滤掉</p><p>思路：有重复的数字的全排列。为了过滤重复，对于同一个值，只交换一次，否则跳过。为了保证这一点，辅助<strong>hash表</strong>来过滤重复的元素，如果重复则跳过不交换即可。</p><pre><code class="java">//有重复数组的全排列。需要过滤重复，思路：用hash即可，不用排序public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(nums==null || nums.length==0){        return res;    }    permuteUniqueDetail(res, nums, 0);    return res;}public void permuteUniqueDetail(List&lt;List&lt;Integer&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        Integer[] itg = new Integer[nums.length];        for(int i=0; i&lt;nums.length; ++i){//int-&gt;Integer            itg[i] = nums[i];        }        List&lt;Integer&gt; temp = Arrays.asList(itg);        res.add(temp);    }    Set&lt;Integer&gt; used = new HashSet&lt;&gt;();//hashSet记录已经访问过的数，避免重复排列    for(int i=index; i&lt;nums.length; ++i){        if(used.add(nums[i])){//对于同一个值，只交换一次，否则跳过。            swap(nums, index, i);            permuteUniqueDetail(res, nums, index+1);            swap(nums, index, i);        }    }}public void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}</code></pre><h3 id="4-八皇后问题"><a href="#4-八皇后问题" class="headerlink" title="4.八皇后问题"></a>4.八皇后问题</h3><p>《剑指offer》p200(返回摆法总数)、leetcode 52 N-Queens 2(返回摆法总数)、leetcode 51 N-Queens(返回所有的摆法)</p><p>题目：在n*n的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角斜线上。下图中的每个黑色格子表示一个皇后，这就是一种符合条件的摆放方法。请求出总共有多少种摆法或者输出八皇后摆法。</p><p>思路：八皇后问题(不能同一行、列、对角线)。<strong>思路：转化为数字的全排列问题。总体思路: 0-n全排列的总数 - check(全排列出现同时在对角线上的)。</strong></p><p>详细思路：八个皇后的任意两个不能处在同一行，那么这肯定是每一个皇后占据一行。于是我们可以定义一个数组ColumnIndex[8]，数组中第i个数字表示位于第i行的皇后的列号。先把ColumnIndex的八个数字分别用0-7初始化，接下来我们要做的事情就是对数组ColumnIndex做全排列。由于我们是用不同的数字初始化数组中的数字，因此任意两个皇后肯定不同列。我们只需要判断得到的每一个排列对应的八个皇后是不是在同一对角斜线上，也就是数组的两个下标i和j，是不是i-j==ColumnIndex[i]-Column[j]或者j-i==ColumnIndex[i]-ColumnIndex[j]。</p><pre><code class="java">//八皇后问题(不能同一行、列、对角线)。思路：转化为数字的全排列问题：76548321-&gt;皇后分别在：第一行的7，第二行的6...public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    if(n&lt;1){        return res;    }    int[] nums = new int[n];//将八皇后问题转成不重复数字全排列问题    for(int i=0; i&lt;n; ++i){//0-n个数字全排列之前初始化        nums[i] = i;    }    solveNQueensDetail(res, nums, 0);//全排列并且判断是否满足八皇后，满足的排列存入结果    return res;}//全排列并判断是否满足八皇后(不能出现在同一对角线)public static void solveNQueensDetail(List&lt;List&lt;String&gt;&gt; res, int[] nums, int index){    if(index==nums.length){//递归出口        if(!check(nums)){//不满足八皇后(同一对角线)            return;        }        List&lt;String&gt; tempList = new ArrayList&lt;&gt;();        for(int i=0; i&lt;nums.length; ++i){//将八皇后排列转成输出格式--&gt;..Q.            StringBuilder sb = new StringBuilder();            int cnt = nums[i];            int ct = 0;            while(ct&lt;cnt){                sb.append(&quot;.&quot;);                ct++;            }            sb.append(&quot;Q&quot;);            ct++;            while(ct&lt;nums.length){                sb.append(&quot;.&quot;);                ct++;            }            tempList.add(sb.toString());        }        res.add(tempList);        return;    }    for(int i=index; i&lt;nums.length; ++i){        swap(nums, index, i);        solveNQueensDetail(res, nums, index+1);        swap(nums, index, i);    }}public static void swap(int[] nums, int i, int j){    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;}//判断是否同一对角线public static boolean check(int[] nums){//检查一种排列是否出现在同一对角线，是则不是八皇后排列    for(int i=0; i&lt;nums.length-1; ++i){        for (int j=i+1; j&lt;nums.length; ++j){            if( Math.abs(i-j)==Math.abs(nums[i]-nums[j]) ){                return false;            }        }    }    return true;}</code></pre><h3 id="5-字符串s1的全排列是否在s2字符串中"><a href="#5-字符串s1的全排列是否在s2字符串中" class="headerlink" title="5.字符串s1的全排列是否在s2字符串中"></a>5.字符串s1的全排列是否在s2字符串中</h3><p>leetcode 567 Permutation in String</p><p>题目：Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><pre><code>Input:s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;Output:TrueExplanation: s2 contains one permutation of s1 (&quot;ba&quot;).</code></pre><p>思路：</p><p>方法1：最简单最暴力的方法其实就是找到s1的所有<strong>全排列</strong>，然后在s2中查找是否这些全排列字符串在s2中。但是这种方法<strong>耗时太大，会导致超时</strong>。</p><p>方法2：<strong>滑动窗口</strong><br>其实不需要找到s1的全排列，因为我们只需要考虑s2中是否包含s1中同样个数的字符，并且这些字符是连在一起的就行了。因此，我们可以使用一个滑动窗口，在s2上滑动。在这个滑动窗口中的字符及其个数是否刚好等于s1中的字符及其个数，此外滑动窗口保证了这些字符是连在一起的。</p><p>具体思路：辅助两个map键值对来模拟滑动窗口中的字符情况，由于都是小写字母，不用map，直接用int[26]来模拟map即可</p><p>注意：判断两个数组是否相等<code>Arrays.equals(int[] num1, int[] num2);</code></p><pre><code class="java">public static boolean checkInclusion(String s1, String s2) {    if(s1==null || s1.length()==0){        return true;    }    if(s2==null || s2.length()==0 || s1.length()&gt;s2.length()){        return false;    }    int[] map1 = new int[26];//s1的字符键值对    int[] map2 = new int[26];//s2上滑动窗口的字符键值对    for(int i=0; i&lt;s1.length(); ++i){//记录s1的字符map        map1[s1.charAt(i)-&#39;a&#39;]++;    }    for(int i=0; i&lt;s2.length(); ++i){//遍历s2，滑动窗口        map2[s2.charAt(i)-&#39;a&#39;]++;        if((i+1)&gt;=s1.length()){//滑动窗口            if(Arrays.equals(map1, map2)){//如果两个map包含的字符一样，则找到了s2中的s1的全排列                return true;            }            else{//否则，滑动窗口map2删除最左边的元素                map2[s2.charAt(i-s1.length()+1)-&#39;a&#39;]--;            }        }    }    return false;}</code></pre><p><a name="54"></a></p><h2 id="54-打印出给定字符串中字符的所有组合"><a href="#54-打印出给定字符串中字符的所有组合" class="headerlink" title="54.打印出给定字符串中字符的所有组合"></a>54.打印出给定字符串中字符的所有组合</h2><p>题目：”abc”-&gt;打印a,b,c,ab,ac,bc,abc</p><p>思路：在字符串位置的index到chs.length()-1中找number个数，组合成字符串放在list中，每次递归到chs[index]字符时，都有两种选择：</p><p>1.放进组合，在begin+1到chs.length()-1中找number-1个数；</p><p>2.不放进组合，在begin+1到chs.length()-1中找number个数</p><pre><code class="java">public static void combine(char[] chs){    if(chs==null || chs.length==0){        return;    }    if(chs.length==1){        System.out.println(chs[0]);    }    List&lt;Character&gt; tempList = new ArrayList&lt;&gt;();    for(int i=1; i&lt;=chs.length; ++i){//组合数字的个数[1~chs.length]        combineDetail(chs, i, 0, tempList);    }}//从index开始找combineNum个数字的组合，并打印public static void combineDetail(char[] chs, int combineNum, int index, List&lt;Character&gt; tempList){    if(combineNum==0){ //找到一种number个字符的组合，将list-&gt;String打印出来并回溯        System.out.println(tempList.toString());        return;    }    if(index==chs.length){//递归出口: 找完number个字符的所有组合，返回        return;    }    //当前位置的数字放进组合，则往后需要找combineNum-1个数    tempList.add(chs[index]);    combineDetail(chs, combineNum-1, index+1, tempList);    //当前位置的数字不放进组合，则往后需要找combineNum个数    tempList.remove(Character.valueOf(chs[index]));//回溯    combineDetail(chs, combineNum, index+1, tempList);}public static void main(String[] args) {    char[] nums = new char[]{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};    combine(nums);}out:[a][b][c][a, b][a, c][b, c][a, b, c]</code></pre><p><a name="55"></a></p><h2 id="55-大-小根堆–优先队列实现-两道"><a href="#55-大-小根堆–优先队列实现-两道" class="headerlink" title="55.大/小根堆–优先队列实现(两道)"></a>55.大/小根堆–优先队列实现(两道)</h2><pre><code>找出数组中最小的k个数(优先队列大根堆)--《剑指offer》p209找出数组中第k大的数(优先队列小根堆)--leetcode 215</code></pre><p>注：java优先队列默认小根堆</p><h3 id="1-找出数组中最小的k个数-优先队列大根堆"><a href="#1-找出数组中最小的k个数-优先队列大根堆" class="headerlink" title="1.找出数组中最小的k个数(优先队列大根堆)"></a>1.找出数组中最小的k个数(优先队列大根堆)</h3><p>《剑指offer》p209</p><p>题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。</p><p>思路：辅助一个k长的优先队列大根堆，遍历数组的同时每次用大根堆替换k长容器的值(适合海量不能修改数组的数据)—&gt;o(nlogk)。<strong>大根堆的实现用优先队列大根堆</strong></p><pre><code class="java">//找出数组中最小的k个数(优先队列大根堆)。思路：用优先队列的大根堆。时间o(nlogk)，空间o(k)public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) {    if(input==null || input.length==0 || k&lt;1 || k&gt;input.length){        return new ArrayList&lt;&gt;();    }    //由于java默认小根堆，所以定义一个k长的大根堆    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;(k, new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return o2 - o1;        }    });    for (int i=0; i&lt;input.length; ++i){        if(i&lt;k){            queue.offer(input[i]);        }        else{            if(queue.peek()&gt;input[i]){//把大的数都出堆，留下最小的k个数                queue.poll();                queue.offer(input[i]);            }        }    }    return new ArrayList&lt;&gt;(queue);//treeSet-&gt;ArrayList&lt;Integer&gt;}</code></pre><h3 id="2-找出数组中第k大的数-优先队列小根堆"><a href="#2-找出数组中第k大的数-优先队列小根堆" class="headerlink" title="2.找出数组中第k大的数(优先队列小根堆)"></a>2.找出数组中第k大的数(优先队列小根堆)</h3><p>leetcode 215 Kth Largest Element in an Array</p><p>题目：Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.You may assume k is always valid, 1 ≤ k ≤ array’s length.</p><p>Example 1:</p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p>思路：辅助用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)</p><pre><code class="java">//返回数组中第k大的数,k总是有效的。思路：用优先队列的小根堆，而不是大根堆。时间o(nlogk)，空间o(k)public int findKthLargest(int[] nums, int k) {    Queue&lt;Integer&gt; queue = new PriorityQueue&lt;&gt;();//默认小根堆    for (int i=0; i&lt;nums.length; ++i){        if(i&lt;k){            queue.offer(nums[i]);        }        else{            if(queue.peek()&lt;nums[i]){//注意这里要比较一下，不满足就不用出堆                queue.poll();                queue.offer(nums[i]);            }        }    }    return queue.poll();}</code></pre><p><a name="56"></a></p><h2 id="56-数据流中的中位数"><a href="#56-数据流中的中位数" class="headerlink" title="56.数据流中的中位数"></a>56.数据流中的中位数</h2><p>《剑指offer》p209、leetcode 295</p><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><p>思路：对于数据流，对应的就是在线算法了，一道很经典的题目就是在1亿个数中找到最大的前100个数，这是一道堆应用题，找最大的前100个数，那么我们就创建一个大小为100的最小化堆，每来一个元素就与堆顶元素比较，因为堆顶元素是目前前100大数中的最小数，前来的元素如果比该元素大，那么就把原来的堆顶替换掉。那么对于这一道题呢？如果单纯的把所有元素放到一个数组里，每次查找中位数最快也要O(n)，综合下来是O(n^2)的复杂度。<br>我们可以利用上面例子中的想法：动态查找考虑堆，中位数左边的数比它小，右边的数比它大。故用一个最大堆实现左边的数据容器，用一个最小堆实现右边的数据容器，因为要找中位数所以也要保证两边容器的数据个数差不超过1。</p><p>java堆的实现用优先队列</p><pre><code class="java">import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;public class Solution {    //左边的大根堆，存比中位数小的数    private Queue&lt;Integer&gt; bigHeap = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {        @Override        public int compare(Integer o1, Integer o2) {            return o2-o1;        }    });    //右边的小根堆，存比中位数大的数    private Queue&lt;Integer&gt; smallHeap = new PriorityQueue&lt;&gt;();    //优先放左边的大根堆，左边的大根堆与右边的小根堆的size只能差1    public void Insert(Integer num) {        if( bigHeap.size()==smallHeap.size() ){//放左边大根堆            if(!smallHeap.isEmpty() &amp;&amp; smallHeap.peek()&lt;num) {//如果num比右边的小根堆的peek大，应该交换下放到右边                bigHeap.offer(smallHeap.poll());                smallHeap.offer(num);            }else{                bigHeap.offer(num);            }        }        else if( bigHeap.size()&gt;smallHeap.size() ){//放右边小根堆            if(bigHeap.peek()&gt;num){//如果num比左边的大根堆的peek小，应该交换下放到左边                smallHeap.offer(bigHeap.poll());                bigHeap.offer(num);            }else{                smallHeap.offer(num);            }        }    }    public Double GetMedian() {        if( bigHeap.size()&gt;smallHeap.size() ){            return (double)bigHeap.peek();        }        else{            return  ((double)bigHeap.peek() + (double)smallHeap.peek()) / 2;        }    }    public static void main(String[] args){        Solution s = new Solution();        int[] nums = new int[]{5,2,3,4,1,6,7,0,8};        for(int i=0; i&lt;nums.length; ++i){            s.Insert(nums[i]);        }        System.out.println(s.GetMedian());    }}</code></pre><p><a name="57"></a></p><h2 id="57-数组中最大连续子序列的和"><a href="#57-数组中最大连续子序列的和" class="headerlink" title="57.数组中最大连续子序列的和"></a>57.数组中最大连续子序列的和</h2><p>《剑指offer》p218、leetcode 53</p><p>题目：给一个数组，返回它的最大连续子序列的和</p><p>思路：</p><p>法一：动态规划。DP[i]表示以i结尾的数组，目前最大连续子序列的和是DP[i]。递推公式：DP[i] = max{DP[i-1] + A[i],A[i]}</p><p>法二：更高效。动态规划需要额外数组存，所以本题改进不用额外的空间，直接<strong>辅助两个变量遍历一遍数组即可</strong>。两个变量：tempMax记录数组中每一段和大于0的连续子数组，整个数组有很多个这样的tempMax；最后的resultMax是这些tempMax最大的</p><pre><code class="java">//有负数的数组中，连续子序列的最大和为多少。思路：辅助两个变量，resMax,tempMax，当tempMax&lt;=0时，tempMax=0public int FindGreatestSumOfSubArray(int[] array) {    int resMax = array[0];    int tempMax = 0;    for(int i=0; i&lt;array.length; ++i){        tempMax += array[i];        resMax = Math.max(resMax, tempMax);        if(tempMax&lt;=0){//当tempMax&lt;=0，那当前这段连续子数组就不要了，tempMax重置为0            tempMax = 0;        }    }    return resMax;}</code></pre><p><a name="58"></a></p><h2 id="58-1到n整数中1出现的次数"><a href="#58-1到n整数中1出现的次数" class="headerlink" title="58.1到n整数中1出现的次数"></a>58.1到n整数中1出现的次数</h2><p>《剑指offer》p221、leetcode 233</p><p>题目：求1 到 n 中1出现的次数。e.g.1~13的整数中1出现的次数：1、10、11、12、13因此共出现5次</p><p>思路：按位进行讨论计算。对数字的每一位单独拿出讨论，按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可。</p><p><strong>计算规则：</strong></p><pre><code>​若weight为0，则1出现次数为round*base若weight为1，则1出现次数为round*base+former+1​若weight大于1，则1出现次数为round*base+base​​```详细请参考[从1到n整数中1出现的次数：O(logn)算法](https://blog.csdn.net/yi_afly/article/details/52012593)​```java//求出1到n出现1的次数。思路：按数位计算每一位上1出现的次数，将一个数n分成round\weight\former\base，按公式计算即可public static int NumberOf1Between1AndN_Solution(int n) {    int res = 0;    int round = n;    int weight;    int former;    int base = 1;    while(round!=0){        weight = round%10;        round /= 10;        former = n%base;        res += round*base;//res += weight*base        if(weight==1){//res += former + 1            res += former + 1;        }        else if(weight&gt;1){//res += base            res += base;        }        base *= 10;    }    return res;}</code></pre><p><a name="59"></a></p><h2 id="59-正整数序列中的第n个数字"><a href="#59-正整数序列中的第n个数字" class="headerlink" title="59.正整数序列中的第n个数字"></a>59.正整数序列中的第n个数字</h2><p>《剑指offer》p221、leetcode 400</p><p>题目：在整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n个数字，n是正数且在32为整形范围内(n &lt; 231)。e.g.第5位是5，第13位是1</p><p>思路：一位数0-9数字在序列中占10位，两位数10-99数字在序列中占2<em>90=180位，三位数100-999有3</em>900=2700位。当n=1001时，n-10-180=811&gt;0 &amp;&amp; n-10-180-2700&lt;0，且811=3*270+1，说明第n位在三位数的100之后第270个数字即370的中间一位，即7。</p><pre><code class="java">//正整数序列中的第n个数字。思路：public static int findNthDigit(int n) {    if(n&lt;10){        return n;    }    int digitLen = 2; //当前区间的位数，如：10~99的2    int start = 10; //当前区间的起始数，如：10~99的10    int base = 90; //当前区间的所有位数，如10~99的90    n -= 9;    while(n!=0){        int objectNum = (int)Math.ceil((double)n/digitLen) + start -1;//定位到了目标数字        if(objectNum&lt;(start*10)){//目标数字就在当前区间,这样判断是为了防止int溢出            int loc = n%digitLen; //定位到目标数字的第几位，从左往右            if(loc==0){                loc = digitLen-1;            }            else{                loc = loc-1;            }            String num = String.valueOf(objectNum);            return num.charAt(loc)-&#39;0&#39;;        }        else{//目标数字在下一个区间            n -= (base*digitLen);            digitLen++;            start *= 10;            base *= 10;        }    }    return -1;}</code></pre><p><a name="60"></a></p><h2 id="60-把数组排成最小的数"><a href="#60-把数组排成最小的数" class="headerlink" title="60.把数组排成最小的数"></a>60.把数组排成最小的数</h2><p>《剑指offer》p227、leetcode 179</p><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p>注意：</p><p>我们要判断一个数字的最高位上的数字，故最方便的方法是：数字转成字符串。</p><p>且数字拼接过程很可能大数溢出int类型，更要用字符串拼接比较</p><p>思路：</p><p><strong>1.先把数组中的整数转换成字符串，2.然后用compareTo中定义比较规则，3.并根据该规则调用库函数sort()排序，4.最后把排序后数字字符串依次打印出来即为所求最小的数字。时间复杂度就是排序的时间复杂度o(nlogn)</strong></p><pre><code class="java">//把数组排成最小的数public static String PrintMinNumber(int [] numbers) {    //1.int[] --&gt; String[]    String[] strings = new String[numbers.length];    for(int i=0; i&lt;numbers.length; ++i){        strings[i] = numbers[i]+&quot;&quot;;    }    //2.定义字符串排序的比较规则    Comparator&lt;String&gt; com = new Comparator&lt;String&gt;() {        @Override        public int compare(String o1, String o2) {            String s1 = o1 + o2;            String s2 = o2 + o1;            return s1.compareTo(s2);        }    };    //3.对String[]排序    Arrays.sort(strings, com);    //4.拼接字符串    StringBuilder sb = new StringBuilder();    for(int i=0; i&lt;strings.length; ++i){        sb.append(strings[i]);    }    if(sb.charAt(0)==&#39;0&#39;){//&quot;0000&quot;--&gt;&quot;0&quot;        return &quot;0&quot;;    }    return sb.toString();}</code></pre><p><a name="61"></a></p><h2 id="61-求把一个数字翻译成不同字符串的个数-DP"><a href="#61-求把一个数字翻译成不同字符串的个数-DP" class="headerlink" title="61.求把一个数字翻译成不同字符串的个数(DP)"></a>61.求把一个数字翻译成不同字符串的个数(DP)</h2><p>《剑指offer》p231、leetcode 91</p><p>题目: 求把数字翻译成字符串的个数。0-&gt;a,1-&gt;b…11-&gt;l,25-&gt;z。求一个数字有多少种不同的翻译方法。e.g.258-&gt;2,58、25,8</p><p>题目分析：这道题要求解码方法，跟之前那道 Climbing Stairs 爬梯子问题 非常的相似，但是还有一些其他的限制条件，比如说一位数时不能为0，两位数不能大于26，其十位上的数也不能为0，除去这些限制条件，跟爬梯子基本没啥区别，也勉强算特殊的斐波那契数列，当然需要用动态规划DP来解。</p><p>思路：DP问题。f(i)为第i位开始到最右边结束的数字的翻译个数。–&gt;动态规划题，解题分析步骤如下。</p><p><strong>1.从左往右DP分析</strong>：定义f(i)为从i至字符串s最右边结束的不同字符串的个数，因此所求为f(0)。<strong>f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)</strong></p><p><strong>2.详细的DP方程：</strong> f(i) = </p><pre><code>0,   s[i]==‘0’f(i+2),   s[i+1]==‘0’ &amp;&amp; (s[i]==‘1’ || s[i]==‘2’)0,   s[i+1]==‘0’ &amp;&amp; (else)f(i+1)+f(i+2),   s[i+1]!=&#39;0&#39; &amp;&amp; s[i]==‘1’ || （s[i]==‘2’ &amp;&amp; s[i+1]-‘0’&lt;=6)f(i+1),     s[i+1]!=&#39;0&#39; &amp;&amp; (else)</code></pre><p>且递归结束条件为:</p><pre><code>i==s.length  return 1;s[i]==&#39;0&#39;  return 0;</code></pre><p><strong>3.从右往左循环实现</strong> 递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题</p><p>代码一：按dp方程直接翻译的递归代码</p><pre><code class="java">//求把一个数字翻译成不同字符串的个数public static int numDecodings(String s) {    if(s==null || s.length()==0){        return 0;    }    return numDecodingsDetail(s.toCharArray(), 0);}//从右往左，每次递归表示从String s中的index至最右边字符串结束，可翻译成不同字符串的个数//f(i) = f(i+1) + f(i+2)(f(i+2)要建立在[i,i+1]是个字母的情况下)public static int numDecodingsDetail(char[] chs, int index){    if(index&lt;chs.length &amp;&amp; chs[index]==&#39;0&#39;){        return 0;    }    if(index&lt;chs.length-1){        if(chs[index+1]==&#39;0&#39;){//后一个为0，必须与后一个连成字母，不满足为0            if(chs[index]==&#39;1&#39; || chs[index]==&#39;2&#39;){//与后一个连成字母                return numDecodingsDetail(chs,index+2);            }            else{//匹配错误，返回0                return 0;            }        }        else{//后一个不为0，可以不与后一个连成字母，同时如果连成字母需要判断            if(chs[index]==&#39;1&#39; || (chs[index]==&#39;2&#39; &amp;&amp; chs[index+1]&lt;=&#39;6&#39;)){//自成一派+与后一个连成字母                return numDecodingsDetail(chs, index+1) + numDecodingsDetail(chs,index+2);            }            else {//不能与后一个连成字母，只能自成一派                return numDecodingsDetail(chs, index+1);            }        }    }    return 1;//index==chs.length 递归结束}代码二：递归实现存在很多重复计算，因此从右往左循环计算，大问题化成小问题（这个代码是按照剑指offer的题目来的，A-0,Z-25）//求把一个数字翻译成不同字符串的个数public static int numDecodings(String s) {    if(s==null || s.length()==0){        return 0;    }    //1.把数字每一位拆分，存到数组中    char[] chs = s.toCharArray();    //2.从右往左，res[]存放动态规划循环计算的每一个f(i)结果，最后要返回的是res[0]    int[] res = new int[chs.length];    //每次计算f(i)时的临时计数器    int tempCount = 0;    for(int i=chs.length-1; i&gt;=0; --i){//从右往左循环计算        if(i==chs.length-1) {            tempCount = 1; //如果是最右边的数字时，初始化翻译个数=1        }        else{//f(i) = f(i+1)            tempCount = res[i+1];        }        //f(i) = f(i+1) + g(i,i+1)*f(i+2)        if(i&lt;chs.length-1){//判断后一个字母的情况            int temp = Integer.parseInt(&quot;&quot;+chs[i]+chs[i+1]);            if(temp&gt;=10 &amp;&amp; temp&lt;=25){//可以连成字母                if((i+2)&lt;chs.length){                    tempCount += res[i+2];//f(i+1)+f(i+2)                }                else{                    tempCount += 1;                }            }        }        res[i] = tempCount;    }    return res[0];}</code></pre><p><a name="62"></a></p><h2 id="62-礼物的最大价值"><a href="#62-礼物的最大价值" class="headerlink" title="62.礼物的最大价值"></a>62.礼物的最大价值</h2><p>《剑指offer》p233、leetcode 64</p><p>题目：礼物的最大价值。</p><p>在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。</p><p>从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。</p><p>例如，对于如下棋盘：</p><pre><code>1*  10  3  812*  2  9  65*  *7  4  113  7*  16*  5*</code></pre><p>res = 1+12+5+7+7+16+5 = 53</p><p>思路：</p><p>典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)</p><p>递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]</p><p>循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]</p><pre><code class="java">/** 题目：礼物的最大价值。 * 在一个m*n的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于0）。 * 从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。 * 例如，对于如下棋盘： *      1*    10   3    8        12*   2    9    6        5*    *7    4    11        3    7*    16*   5*    res = 1+12+5+7+7+16+5 = 53 思路：    典型的动态规划。定义f(i,j)表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值(从左上到右下的顺序)，最后求f(m-1,n-1)    递归分析：f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]    循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1] */public class Solution{    public static void main(String[] args){        int[][] gift = {{1,10,3,8},{12,2,9,6},{5,7,4,11},{3,7,16,5}};        System.out.println(maxValue(gift, 4, 4)); //out:53    }    public static int maxValue(int[][] gift, int m, int n){        /**         * @Description: m*n大小的棋盘gift[][]         * 递归分析f(i,j) = max(f(i-1,j), f(i,j-1)) + gift[i,j]         * 循环计算：int[][] maxValue辅助，返回maxValue[m-1][n-1]         */        if(gift==null || m&lt;=0 || n&lt;=0){            return 0;        }        int[][] maxValue = new int[m][n];        for(int i=0; i&lt;m; ++i){ //从左上往右下进行循环计算            for(int j=0; j&lt;n; ++j){                int temp = 0;                if((i-1)&gt;=0){                    temp = Math.max(temp, maxValue[i-1][j]);                }                if((j-1)&gt;=0){                    temp = Math.max(temp, maxValue[i][j-1]);                }                maxValue[i][j] = temp + gift[i][j];            }        }        return maxValue[m-1][n-1];    }}</code></pre><p>优化改进空间复杂度，使用一维数组<br>•题目中可知，坐标(i,j)的最大礼物价值仅仅取决于坐标为(i-1,j)和(i,j-1)两个格子；<br>•因此第i-2行以上的最大价值没有必要保存下来。<br>•使用一维数组保存，数组的长度为gift的列数：(0…j-1)保存的是(i,0)…(i,j-1)的最大价值；(j…cols-1)保存的是(i-1,j)…(i-1,cols-1)的最大价值。即：数组前j个数字分别是当前第i行前j个格子的maxvule,而之后的数字分别保存前面第i-1行n-j个格子的maxVlue。</p><pre><code class="java">//leetcode 64 Minimum Path Sum的代码，一样的public int minPathSum(int[][] grid) {    if(grid==null || grid.length==0 || grid[0].length==0){        return 0;    }    int m = grid.length;    int n = grid[0].length;    int[] min = new int[n];//辅助一维数组，数组的长度为grid的列数    for(int i=0; i&lt;m; ++i){        for(int j=0; j&lt;n; ++j){            if(i == 0){//第一行                if(j==0){//第一列                    min[j] = grid[i][j];                }                else {                    min[j] = grid[i][j] + min[j-1];                }            }            else{//后面几行                if(j==0){//第一列                    min[j] = min[j] + grid[i][j];                }                else{                    min[j] = Math.min(min[j-1], min[j]) + grid[i][j];                }            }        }    }    return min[n-1];}</code></pre><p><a name="63"></a></p><h2 id="63-最长不含重复字符的子字符串长度"><a href="#63-最长不含重复字符的子字符串长度" class="headerlink" title="63.最长不含重复字符的子字符串长度"></a>63.最长不含重复字符的子字符串长度</h2><p>《剑指offer》p236、leetcode 3</p><p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p><p>思路：</p><p>不重复子串可能有多个，而最长不重复子串长度只有一个唯一的值。</p><p><strong>遍历一遍字符串，同时借助辅助hashMap</strong>记录字符是否出现及上一次出现的位置。时间o(n)，空间o(n)</p><p>三个变量：</p><p>int resMax = 0; //记录最长的不重复字符子串的长度</p><p>int tempMax = 0; //记录当前不重复字符子串的长度</p><p>int startIndex = 0; //记录当前不重复字符子串的开始位置，初始化为0</p><pre><code class="java">//Longest Substring Without Repeating Characters最长不含重复字符的子字符串长度//思路：遍历一遍字符串，辅助hashMap存字符是否出现过或上一次出现的位置。时间o(n), 空间o(n)public int lengthOfLongestSubstring(String s) {    if(s==null || s.length()==0){        return 0;    }    if(s.length()==1){        return 1;    }    int resMax = 0;//最终返回的最大长度    int tempMax = 0;//当前的最大长度    int startIndex = 0;//当前最大长度的起始位置    //1.辅助hashMap存字符是否出现过或上一次出现的位置    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();    //2.遍历一遍字符串    for(int i=0; i&lt;s.length(); ++i){        char temp = s.charAt(i);        //如果字符没出现过或字符上一次出现的位置在startIndex的前面，那么当前字符有效，计算更新相应长度即可        if(!hashMap.containsKey(temp) || hashMap.get(temp)&lt;startIndex){            tempMax = i-startIndex+1;            resMax = Math.max(tempMax, resMax);        }else{//当前字符重复了            startIndex = hashMap.get(temp)+1; //下次的startIndex为重复字符上一次出现位置的下一个位置        }        hashMap.put(temp, i);//不管重复与否，都要更新字符出现的位置    }    return resMax;}</code></pre><p><a name="64"></a></p><h2 id="64-丑数-两道"><a href="#64-丑数-两道" class="headerlink" title="64.丑数(两道)"></a>64.丑数(两道)</h2><pre><code>判断一个数是否为丑数--leetcode 263求第N个丑数是几--《剑指offer》p240</code></pre><h3 id="1-判断一个数是否为丑数"><a href="#1-判断一个数是否为丑数" class="headerlink" title="1.判断一个数是否为丑数"></a>1.判断一个数是否为丑数</h3><p>leetcode 263</p><p>题目：给定一个数，判断是否为丑数(丑数定义:只含因子2、3、5的正数，1也算丑数)</p><pre><code>Input: 6Output: trueExplanation: 6 = 2 × 3</code></pre><p>思路：就正常判断因子即可。</p><pre><code class="java">//判断一个数是否为丑数public boolean isUgly(int num) {    if(num&lt;1) {        return false;    }    if(num==1){        return true;    }    while(num%2==0){        num /= 2;    }    while(num%3==0){        num /= 3;    }    while(num%5==0){        num /= 5;    }    if(num==1){        return true;    }    return false;}</code></pre><h3 id="2-求第N个丑数是几"><a href="#2-求第N个丑数是几" class="headerlink" title="2.求第N个丑数是几"></a>2.求第N个丑数是几</h3><p>《剑指offer》p240</p><p>题目：把只包含质因子2、3和5的数称作丑数。例如6、8都是丑数，但14不是，因为它包含质因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p>思路：</p><p>空间换时间。丑数一定是丑数<em>2/</em>3/*5得来的，直接用数组存下1到index的丑数</p><p>关键是怎么保证每一个丑数的大小顺序的–&gt;三个变量：index2、index3、index5</p><p>每次该放下一个丑数时，三个变量分别记录了当前可以<em>2/</em>3/*5的最小的丑数位置</p><p>每次分别对这三个位置上的丑数<em>2</em>3*5后找出最小的一个，即为当前的丑数，之后更新三个变量即可</p><pre><code class="java">//丑数public static int GetUglyNumber_Solution(int index) {    if(index&lt;=0){        return 0;    }    if(index==1){        return 1;    }    int[] res = new int[index+1];//存1到index的丑数，返回res[index]    res[1] = 1;    int index2 = 1;    int index3 = 1;    int index5 = 1;    for(int i=2; i&lt;=index; ++i){        res[i] = min(res[index2]*2, res[index3]*3, res[index5]*5);//该放res[i]丑数了，找三个中最小的        while(res[index2]*2&lt;=res[i]){//更新三个变量            index2++;        }        while(res[index3]*3&lt;=res[i]){            index3++;        }        while(res[index5]*5&lt;=res[i]){            index5++;        }    }    return res[index];}public static int min(int a, int b, int c){    int temp = a&lt;b ? a : b;    return temp&lt;c ? temp : c;}</code></pre><p><a name="65"></a></p><h2 id="65-第一个只出现一次的字符"><a href="#65-第一个只出现一次的字符" class="headerlink" title="65.第一个只出现一次的字符"></a>65.第一个只出现一次的字符</h2><pre><code>第一个只出现一次的字符(数组)--《剑指offer》p243、leetcode 387第一个只出现一次的字符(字符流)--《剑指offer》p247</code></pre><p>题目：给定数组或是输入一个字符流，返回第一个只出现一次的的字符位置。在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。</p><pre><code>e.g.输入&quot;abaccdeff&quot; --&gt; 则输出&#39;b&#39;</code></pre><p>思路：不管是数组还是字符流，都用这个思路。<strong>遍历一遍str，辅助hashMap，value记录字符出现第一次的位置，若字符重复出现，则value记录-1。最后再遍历一遍hashMap，找除了-1之外的最小value即可所求</strong>。时间o(n)，空间o(256)</p><p>数据是数组的代码：</p><pre><code class="java">//给定数组的代码，字符流的情况一样的。思路：遍历一遍str，辅助hashMap记录字符出现的位置，再遍历一遍hashMap即可。时间o(n)，空间o(256)public int firstUniqChar(String str) {    HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;();//key:字符，value:字符出现一次value为上次出现的位置，字符出现多次value存-1    //1.遍历字符串,辅助hashMap记录字符出现的位置    for(int i=0; i&lt;str.length(); ++i){        char temp = str.charAt(i);        if(!hashMap.containsKey(temp)){//字符只出现一次，存出现的位置            hashMap.put(temp,i);        }        else{//字符出现多次，存-1            hashMap.put(temp, -1);        }    }    //2.遍历hashMap来找第一次只出现一次的字符    int res = Integer.MAX_VALUE;    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){        if(entry.getValue()!=-1){            res = Math.min(res, entry.getValue());//找最小的只出现一次的字符位置        }    }    return res==Integer.MAX_VALUE ? -1 : res;}数据是字符流的代码：public class Solution{    private int[] chIndex;    private static int cnt = 0; //计数当前输入到第几个数了，初始为0    public Solution(){        chIndex = new int[256];//初始化哈希数组，每个字符都未出现，    }    //Insert one char from stringstream    public void Insert(char ch){        cnt++;        if(chIndex[ch]==0) {//之前未出现过，则更新值为当前位置，说明出现了第一次            chIndex[ch] = cnt;        }        else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2            chIndex[ch] = -1;        }    }    //return the first appearence once char in current stringstream    public char FirstAppearingOnce(){        int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置        char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符        for(int i=0; i&lt;256; ++i){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)            if(chIndex[i]&gt;0 &amp;&amp; chIndex[i]&lt;minIndex){                minIndex = chIndex[i];                resChar = (char)i;            }        }        return resChar;    }}</code></pre><p>当然，本题中hashMap可以用256的数组，也可以用hashMap</p><pre><code class="java">private HashMap&lt;Character, Integer&gt; hashMap;private static int cnt = 0; //计数当前输入到第几个数了，初始为0public Solution(){    hashMap = new HashMap&lt;&gt;();}//Insert one char from stringstreampublic void Insert(char ch){    cnt++;    if(!hashMap.containsKey(ch)) {//之前未出现过，则更新值为当前位置，说明出现了第一次        hashMap.put(ch, cnt);    }    else{ //之前出现过，因为要找的是只出现一次的，故之后这个字符已经无意义了，要找更新值为-2        hashMap.put(ch, -1);    }}//return the first appearence once char in current stringstreampublic char FirstAppearingOnce(){    int minIndex = Integer.MAX_VALUE; //记录最早出现一次字符的位置    char resChar = &#39;#&#39;; //记录最早出现只出现一次的那个字符    for(Map.Entry&lt;Character, Integer&gt; entry: hashMap.entrySet()){//遍历哈希数组，找出只出现一次的字符(数组值&gt;0)且数组值最小的(即为最早出现的)        if(entry.getValue()!=-1 &amp;&amp; entry.getValue()&lt;minIndex){            minIndex = entry.getValue();            resChar = entry.getKey();        }    }    return resChar;}</code></pre><p><a name="66"></a></p><h2 id="66-归并排序相关-3道"><a href="#66-归并排序相关-3道" class="headerlink" title="66.归并排序相关(3道)"></a>66.归并排序相关(3道)</h2><pre><code>数组的归并排序数组中的逆序对个数(2道)--《剑指offer》p249、leetcode 493单链表的归并排序--leetcode 148</code></pre><h3 id="1-数组的归并排序"><a href="#1-数组的归并排序" class="headerlink" title="1.数组的归并排序"></a>1.数组的归并排序</h3><p>经典的归并排序算法，时间o(nlog)，空间o(n)</p><p>来源<a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></p><pre><code class="java">import java.util.Arrays;public class Solution {    //归并排序。思路：分而治之，先分后治,辅助数组temp[]    public static void mergeSort(int[] nums){        if(nums==null || nums.length&lt;2){            return;        }        int[] temp = new int[nums.length]; //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间        mergeSortDetail(nums, 0, nums.length-1, temp);    }    //分    private static void mergeSortDetail(int[] nums, int left, int right, int[] temp){        if(left&lt;right){//一个数字不用merge，只有两个以上才merge            int mid = (left+right)/2;            mergeSortDetail(nums, left, mid, temp);//左边归并排序，使得左子序列有序            mergeSortDetail(nums, mid+1, right, temp);//右边归并排序，使得右子序列有序            merge(nums, left, mid, right, temp);//将两个有序子数组合并操作        }    }    //治    private static void merge(int[] nums, int left, int mid, int right, int[] temp){        int tempIndex = 0;//temp数组的当前位置        int i = left; //左序列的索引        int j = mid+1; //右序列的索引        while(i&lt;=mid &amp;&amp; j&lt;=right){//将左、右序列的元素有序的放进temp数组中            temp[tempIndex++] = nums[i]&lt;=nums[j] ? nums[i++] : nums[j++];        }        while(i&lt;=mid){//将左边剩余元素填充进temp中            temp[tempIndex++] = nums[i++];        }        while(j&lt;=right){//将右边剩余元素填充进temp中            temp[tempIndex++] = nums[j++];        }        //将temp中的元素全部拷贝到nums原数组中        tempIndex = 0;        while(left&lt;=right){            nums[left++] = temp[tempIndex++];        }    }    public static void main(String []args){        int[] nums = {9,8,7,6,5,4,3,2,1};        mergeSort(nums);        System.out.println(Arrays.toString(nums));    }}</code></pre><h3 id="2-数组中的逆序对-2道"><a href="#2-数组中的逆序对-2道" class="headerlink" title="2.数组中的逆序对(2道)"></a>2.数组中的逆序对(2道)</h3><pre><code>《剑指offer》p249Reverse Pairs--leetcode 493 </code></pre><h4 id="2-1-求出数组中逆序对的个数"><a href="#2-1-求出数组中逆序对的个数" class="headerlink" title="2.1 求出数组中逆序对的个数"></a>2.1 求出数组中逆序对的个数</h4><p>《剑指offer》p249</p><p>思路：用归并排序思想，在归并排序的过程中计数逆序对。时间o(nlogn)，空间o(n)，稳定。先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数（也就是逆序数），这三个过程加起来就是整体的逆序数目了。</p><p>注意:归并排序merge过程中的<strong>从右往左排序的巧妙思想</strong>！</p><pre><code class="java">//数组中逆序对的总数。思路：归并排序思想// 先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数public static int InversePairs(int [] array) {    if(array==null || array.length&lt;2){        return 0;    }    int[] temp = new int[array.length];    return InversePairsDetail(array, 0, array.length-1, temp)%1000000007;}public static int InversePairsDetail(int[] array, int left, int right, int[] temp){    int res = 0;    if(left&lt;right){        int mid = (left+right)/2;        res += InversePairsDetail(array, left, mid, temp);//左边的逆序数        res += InversePairsDetail(array, mid+1, right, temp);//右边的逆序数        res += merge(array, left, mid, right, temp);//左边与右边的逆序数    }    return res%1000000007;}public static int merge(int[] array, int left, int mid, int right, int[] temp){    int res = 0;    int i = mid;//左序列指针，从右往左    int j = right;//右序列指针，从右往左    int tempIndex = right;//临时数组指针，从右往左    while(i&gt;=left &amp;&amp; j&gt;mid){        if(array[i]&gt;array[j]){//是一个逆序对，且前面的比后面的大，又找到很多个逆序对            temp[tempIndex--] = array[i--];            res += (j-mid);//又找到很多个逆序对            res %= 1000000007;        }        else{            temp[tempIndex--] = array[j--];        }    }    while(i&gt;=left){//前面的数组还有        temp[tempIndex--] = array[i--];    }    while(j&gt;mid){//后面的数组还有        temp[tempIndex--] = array[j--];    }    tempIndex = right; //最后还是要完成排序    while(left&lt;=right){        array[right--] = temp[tempIndex--];    }    return res%1000000007;}</code></pre><h4 id="2-2-Reverse-Pairs"><a href="#2-2-Reverse-Pairs" class="headerlink" title="2.2 Reverse Pairs"></a>2.2 Reverse Pairs</h4><p>leetcode 493 </p><p>题目：和上面的逆序数有点不一样，Given an array nums, we call (i, j) an important reverse pair if i &lt; j and <strong>nums[i] &gt; 2*nums[j].</strong></p><pre><code>Input: [1,3,2,3,1]Output: 2</code></pre><p>思路：还是逆序对的归并排序思想，只不过找逆序对的算法不同，因此简要修改判断即可</p><pre><code class="java">//数组中逆序对的总数。思路：归并排序思想//先求前面一半数组的逆序数，再求后面一半数组的逆序数，然后求前面一半数组比后面一半数组中大的数的个数public int reversePairs(int[] nums) {    if(nums==null || nums.length&lt;2){        return 0;    }    int[] temp = new int[nums.length];    return InversePairsDetail(nums, 0, nums.length-1, temp);}public int InversePairsDetail(int[] array, int left, int right, int[] temp){    int res = 0;    if(left&lt;right){        int mid = (left+right)/2;        res += InversePairsDetail(array, left, mid, temp);//左边排序，且计算左边的逆序对个数        res += InversePairsDetail(array, mid+1, right, temp);//右边排序，且计算右边的逆序对个数        //merge左右两边排序前，计算左右两边的逆序对个数        for (int i = left, j = mid+1; i &lt;= mid &amp;&amp; j &lt;= right;){            if (array[i] &gt; (long) array[j] * 2){//long必须有                res += mid - i + 1;                j++;            }            else i++;        }        merge(array, left, mid, right, temp);//左右两边归并排序    }    return res;}//正常的左右两边归并排序public void merge(int[] array, int left, int mid, int right, int[] temp){    int i = mid;//左序列指针，从右往左    int j = right;//右序列指针，从右往左    int tempIndex = right;//临时数组指针，从右往左    while(i&gt;=left &amp;&amp; j&gt;mid){        if(array[i]&gt;array[j]){            temp[tempIndex--] = array[i--];        }        else{            temp[tempIndex--] = array[j--];        }    }    while(i&gt;=left){//前面的数组还有        temp[tempIndex--] = array[i--];    }    while(j&gt;mid){//后面的数组还有        temp[tempIndex--] = array[j--];    }    tempIndex = right; //最后还是要完成排序    while(left&lt;=right){        array[right--] = temp[tempIndex--];    }}</code></pre><h3 id="3-单链表的归并排序"><a href="#3-单链表的归并排序" class="headerlink" title="3.单链表的归并排序"></a>3.单链表的归并排序</h3><p>leetcode 148 </p><p>见 <a href="#93.0">93.0单链表的归并排序</a></p><p><a name="67"></a></p><h2 id="67-二叉搜索树的第k小节点-中序遍历"><a href="#67-二叉搜索树的第k小节点-中序遍历" class="headerlink" title="67.二叉搜索树的第k小节点(中序遍历)"></a>67.二叉搜索树的第k小节点(中序遍历)</h2><p>《剑指offer》p269、leetcode 230</p><p>题目：给定一棵二叉搜索树，请找出其中的第k小的结点。如（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p><p>思路：中序遍历即可。时间o(n)，空间o(1)</p><pre><code class="java">//二叉搜索树中第k小节点。将k存到数组中便于修改传参，对二叉树中序遍历判断即可 TreeNode KthNode(TreeNode pRoot, int k){    if(pRoot==null || k&lt;1){        return null;    }    int[] ks = new int[1];    ks[0] = k;    return KthNodeDetail(pRoot, ks);}TreeNode KthNodeDetail(TreeNode pRoot, int[] ks){    TreeNode res = null;    if(pRoot.left!=null){        res = KthNodeDetail(pRoot.left, ks);    }    if(res!=null){        return res;    }    ks[0]--;    if(ks[0]==0){        return pRoot;    }    if(pRoot.right!=null){        res = KthNodeDetail(pRoot.right, ks);    }    return res;}</code></pre><p><a name="68"></a></p><h2 id="68-二叉树的深度-两道"><a href="#68-二叉树的深度-两道" class="headerlink" title="68.二叉树的深度(两道)"></a>68.二叉树的深度(两道)</h2><pre><code>    求二叉树的深度--leetcode104    判断是否为平衡二叉树--leetcode110</code></pre><h3 id="1-求二叉树的深度"><a href="#1-求二叉树的深度" class="headerlink" title="1.求二叉树的深度"></a>1.求二叉树的深度</h3><p>leetcode104、《剑指offer》p271</p><p>思路：递归</p><pre><code class="java">public int treeDepth(TreeNode head){    if(head==null){        return 0;    }    return Math.max( treeDepth(head.left)+1, treeDepth(head.right)+1 );}</code></pre><h3 id="2-判断是否为平衡二叉树"><a href="#2-判断是否为平衡二叉树" class="headerlink" title="2.判断是否为平衡二叉树"></a>2.判断是否为平衡二叉树</h3><p>leetcode110、《剑指offer》p271</p><p>题目：给一个二叉树，判断是否为平衡二叉树</p><p>思路1：遍历树，对每一个节点进行判断是否满足平衡树的条件—&gt;递归重复判断计算，不可取</p><pre><code class="java">//判断是否为平衡二叉树public boolean IsBalanced_Solution(TreeNode root) {    if(root==null){        return true;    }    int left = getDepth(root.left);    int right = getDepth(root.right);    if(Math.abs(left-right)&lt;2){        return IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right);    }    return false;}//求二叉树的深度public int getDepth(TreeNode root){    if(root==null){        return 0;    }    return 1 + Math.max(getDepth(root.left), getDepth(root.right));}</code></pre><p>思路2：后序遍历(左右根)，从下往上依次判断每个节点是否满足平衡二叉树的条件。这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算—&gt;可取</p><pre><code class="java">//判断是否为平衡二叉树。好的方法:后序遍历(左右根),从下往上依次判断每个节点是否满足平衡二叉树的条件。// 这样每个节点的高度只会算一次，避免自上而下递归判断的重复计算public boolean IsBalanced_Solution(TreeNode root) {    if(root==null){        return true;    }    if(IsBalanced_Solution(root.left) &amp;&amp; IsBalanced_Solution(root.right)){        int left = getDepth(root.left);        int right = getDepth(root.right);        if(Math.abs(left-right)&lt;2){            return true;        }    }    return false;}//求二叉树的深度public int getDepth(TreeNode root){    if(root==null){        return 0;    }    return 1 + Math.max(getDepth(root.left), getDepth(root.right));}</code></pre><p><a name="69"></a></p><h2 id="69-数组中和为s的数字-四道"><a href="#69-数组中和为s的数字-四道" class="headerlink" title="69.数组中和为s的数字(四道)"></a>69.数组中和为s的数字(四道)</h2><pre><code>数组中和为s的两个数字(有序数组)--《剑指offer》p280数组中和为s的两个数字(无序数组)--leetcode 1打印出和为s的所有连续正数序列--《剑指offer》p280求和为s的所有连续正数序列的总数(转化为找因子的思想)--leetcode 829</code></pre><h3 id="1-数组中和为s的两个数字-有序数组"><a href="#1-数组中和为s的两个数字-有序数组" class="headerlink" title="1.数组中和为s的两个数字(有序数组)"></a>1.数组中和为s的两个数字(有序数组)</h3><p>《剑指offer》p280</p><p>题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>思路：从数组两端向中间扫，时间o(n)，空间o(1)，当然因为有序可以加一点二分的思想减少比较次数。</p><pre><code class="java">public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) {    ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();    int resMax = Integer.MAX_VALUE;    int left = 0;    int right = array.length-1;    //left、right往中间扫    while(left&lt;right){        int mid = left + (right-left)/2;        if(array[mid]&gt;=sum){//二分判断，需要往左边找            right = mid - 1;            continue;        }        int temp = array[left] + array[right];        if(temp==sum){            if(array[left]*array[right]&lt;resMax){//看是否乘积最小                resMax = array[left]*array[right];                if(!res.isEmpty()){                    res.clear();                }                res.add(array[left]);                res.add(array[right]);            }        }        if(temp &lt; sum){//左边的数++            left++;        }        else{//右边的数--            right--;        }    }    return res;}</code></pre><h3 id="2-数组中和为s的两个数字-无序数组"><a href="#2-数组中和为s的两个数字-无序数组" class="headerlink" title="2.数组中和为s的两个数字(无序数组)"></a>2.数组中和为s的两个数字(无序数组)</h3><p>leetcode 1</p><p>题目：Given an array of integers(无序), return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>思路：因为数组无序，因此需要辅助map，时间o(n)，空间o(n)</p><pre><code class="java">public int[] twoSum(int[] nums, int target) {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i=0; i&lt;nums.length; ++i){        int temp = target - nums[i];        if(map.containsKey(temp)){           return new int[]{map.get(temp), i};        }        map.put(nums[i], i);    }    return new int[]{0,0};}</code></pre><h3 id="3-打印出和为s的所有连续正数序列"><a href="#3-打印出和为s的所有连续正数序列" class="headerlink" title="3.打印出和为s的所有连续正数序列"></a>3.打印出和为s的所有连续正数序列</h3><p>《剑指offer》p280、leetcode 829</p><p>输入一个整数s，打印出所有和为s的连续正数序列(至少含有两个数)</p><p>如：输入15，1+2+3+4+5=4+5+6=7+8=15，因此输出{1,2,3,4,5},{4,5,6},{7,8}三个序列</p><p>思路：</p><p>思路：</p><pre><code>    从递增数组中两个和为s的数得到启示，设置两个变量，一个记录当前序列的最小的数small，一个记录当前序列的最大的数big。    初始化small=0,big=1    若是当前的正数序列之和小于S，big++    若是当前的正数序列之和大于S，small++    因为和为s的序列至少包括两个数，所以small要小于等于s的一半</code></pre><p>代码：</p><pre><code class="java">//和为s的连续整数序列public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) {    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    if(sum&lt;3){        return res;    }    int small = 1;    int big = 2;    int tempRes = small+big;//当前序列的和    ArrayList&lt;Integer&gt; tempList = new ArrayList&lt;&gt;();//缓存当前序列    tempList.add(small);    tempList.add(big);    while(small &lt;= sum/2){//至少两个数的和为sum，所以small不能超过sum的一半        if(tempRes&lt;=sum){            if(tempRes==sum){                res.add(new ArrayList&lt;&gt;(tempList));            }            big++;            tempRes += big;            tempList.add(big);        }        else if(tempRes&gt;sum){            tempRes-=small;            tempList.remove((Object)small);            small++;        }    }    return res;}</code></pre><h3 id="4-求和为s的所有连续正数序列的总数-转化为找因子的思想"><a href="#4-求和为s的所有连续正数序列的总数-转化为找因子的思想" class="headerlink" title="4.求和为s的所有连续正数序列的总数(转化为找因子的思想)"></a>4.求和为s的所有连续正数序列的总数(转化为找因子的思想)</h3><p>leetcode 829</p><p>题目：Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? 和为s的连续整数序列一共有多少种。和为s的连续整数序列一共有多少种，题目中N特别大，o(n)会超时，因此必须o(logn)。</p><pre><code>    Input: 5    Output: 2    Explanation: 5 = 5 = 2 + 3</code></pre><p>思路：变型求和公式转化问题，时间o(logn)，空间o(1)。</p><p>详细思路： 连续数列的求和公式–&gt;（n1+n2)*(n2-n1+1)=2*N，(n1&lt;n2)，其中(n1+n2)和(n2-n1+1)一定要是2*N的因子，因此<strong>转化成求2*N的因子的问题</strong>，将时间复杂度控制在了O(logn)</p><pre><code class="java">public int consecutiveNumbersSum(int N) {    int res = 1;//一共有res种方法，本身也算一种，因此初始为1    int target = 2*N;    int index = (int)Math.sqrt(target);    for(int i=2; i&lt;=index; ++i){//从2遍历到index找target的因子，直接优化到了o(logn)        if(target%i==0){//i是target的一个因子            //两元一次方程解出n1、n2，注意n1&lt;n2            int n2 = (i+target/i-1)/2;            int n1 = target/i-n2;            if(n1&lt;n2 &amp;&amp; (n1 + n2)*(n2 - n1 + 1)==target){//找到一个从n1~n2的连续序列和为s                res++;            }        }    }    return res;}</code></pre><p><a name="70"></a></p><h2 id="70-翻转字符串-两道"><a href="#70-翻转字符串-两道" class="headerlink" title="70.翻转字符串(两道)"></a>70.翻转字符串(两道)</h2><pre><code>    给定一句话，翻转这句话的单词顺序(单词不变)--《剑指offer》p284、leetcode 151    左旋转字符串(abcXYZdef循环左移3位--&gt;XYZdefabc)--《剑指offer》p284</code></pre><h3 id="1-翻转一句话的单词顺序-单词不变"><a href="#1-翻转一句话的单词顺序-单词不变" class="headerlink" title="1.翻转一句话的单词顺序(单词不变)"></a>1.翻转一句话的单词顺序(单词不变)</h3><p>《剑指offer》p284、leetcode 151</p><p>题目：给定一句话，翻转这句话的单词顺序(单词不变)</p><p>思路：先split(“ “)成数组，再反着拼装即可。时间o(n)，空间o(n)</p><pre><code class="java">public String reverseWords(String s) {    String[] strs = s.split(&quot; &quot;);    StringBuilder res = new StringBuilder();    for(int i=strs.length-1; i&gt;=0; --i){        if(strs[i].equals(&quot;&quot;)){            continue;        }        res.append(strs[i] + &quot; &quot;);    }    return res.toString().trim();}</code></pre><h3 id="2-左旋转字符串"><a href="#2-左旋转字符串" class="headerlink" title="2.左旋转字符串"></a>2.左旋转字符串</h3><p>《剑指offer》p284</p><p>题目：左旋转字符串(abcXYZdef循环左移3位–&gt;XYZdefabc)</p><p>思路1(不可取): 用substring()函数拼接即可，当然substring()会依赖辅助空间。</p><pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabcpublic static String LeftRotateString(String str,int n) {    if(n&lt;1 || str==null || str.length()&lt;2){        return str;    }    return str.substring(n) + str.substring(0,n);}</code></pre><p>思路2(可取): 当不能用substring()去依赖辅助空间时，直接在原字符串上修改。分成需要移位的左边和剩下右边的两部分，<strong>先将这两部分分别翻转，然后再整个翻转即可</strong>。时间o(n)，空间o(1)</p><pre><code class="java">//循环左移字符串,abcXYZdef左移3位--&gt;XYZdefabcpublic static String LeftRotateString(String str,int n) {    if(n&lt;1 || str==null || str.length()&lt;2){        return str;    }    char[] chs = str.toCharArray();    reverse(chs, 0, n-1);    reverse(chs, n, chs.length-1);    reverse(chs,0,chs.length-1);    return String.valueOf(chs);}//翻转一个字符串：首尾向中间扫，字符互换即可private static void reverse(char[] str, int start, int end){    if(start&gt;=end){        return;    }    while(start&lt;end){        char temp = str[start];        str[start] = str[end];        str[end] = temp;        start++;        end--;    }}</code></pre><p><a name="71"></a></p><h2 id="71-滑动窗口最大值-双端队列"><a href="#71-滑动窗口最大值-双端队列" class="headerlink" title="71.滑动窗口最大值(双端队列)"></a>71.滑动窗口最大值(双端队列)</h2><p>《剑指offer》p288、《左神》19、leetcode239</p><p>题目：滑动窗口的最大值。给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。如{2,3,4,2,6,2,5,1}及滑动窗口的大小3，最大值分别为{4,4,6,6,6,5}</p><p>思路：双端队列。滑动窗口先进先出因此借助双端队列，使用队列保存数组的下标，从头遍历数组，根据如下规则进行入队、出队：  </p><pre><code>0. 如果队列为空，则当前数字入队列1. 如果当前数字大于队列尾，则删除队列尾，然后当前数字入队列2. 如果当前数字小于等于队列尾，则当前数字入队列3. 如果队列头超出滑动窗口范围，则删除队列头4. 这样能始终保证队头为当前的最大值5. 时间o(n)，空间o(k)</code></pre><p>代码：</p><pre><code>//滑动窗口最大值--&gt;双端队列public static int[] maxSlidingWindow(int[] nums, int k) {    if(nums==null || nums.length==0 || k&lt;1 || k&gt;nums.length){        return new int[0];    }    int[] res = new int[nums.length-k+1];//滑动窗口最大值    int resCnt = 0;    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();//双端队列,存的不是数组元素，而是下标，便于判断滑动窗口位置    for (int i=0; i&lt;nums.length; ++i){//遍历数组        if(!deque.isEmpty() &amp;&amp; deque.getFirst()+k==i){//进行滑动窗口:双端队列的头部已经不在窗口中，头部出队            deque.pollFirst();        }        while(!deque.isEmpty() &amp;&amp; nums[i]&gt;nums[deque.getLast()]){//如果当前数比双端队列的尾部大，则一直pollLast，直到当前数比尾部小或相等            deque.pollLast();        }        deque.offerLast(i);        if(i+1&gt;=k){//存储当前窗口最大值            res[resCnt++] = nums[deque.getFirst()];        }    }    return res;}</code></pre><p><a name="72"></a></p><h2 id="72-打印n个骰子所有可能的点数和及概率"><a href="#72-打印n个骰子所有可能的点数和及概率" class="headerlink" title="72.打印n个骰子所有可能的点数和及概率"></a>72.打印n个骰子所有可能的点数和及概率</h2><p>《剑指offer》p294.</p><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s，输入n，打印出s的所有可能的值出现的概率。示例如下(n=2)：</p><pre><code>2个骰子，点数和为2出现的概率为: 0.0277777777777777762个骰子，点数和为3出现的概率为: 0.055555555555555552个骰子，点数和为4出现的概率为: 0.083333333333333332个骰子，点数和为5出现的概率为: 0.1111111111111111...</code></pre><p>递归思路：</p><pre><code class="python">def getsumcount(self, number, summ):    if number &lt; 1 or summ &lt; number or summ &gt; 6 * number:        return 0    if number == 1:        return 1    resCount = 0    resCount = self.getsumcount(number-1, summ-1)+self.getsumcount(number-1, summ-2)+self.getsumcount(number-1, summ-3)+self.getsumcount(number-1, summ-4)+self.getsumcount(number-1, summ-5)+self.getsumcount(number-1, summ-6)    return resCountdef po(self, number):    total = pow(6, number)    for i in range(number, 6*number+1):        res = self.getsumcount(number, i)        ratio = res/total        print(i, ratio)</code></pre><p>循环思路：<strong>先算所有出现的点数和及出现次数，再算概率(出现次数/6^number)。一个一个骰子往上加，辅助两个数组交替着存所有出现的点数和为n的出现次数，resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]</strong></p><p>详细思路(可以不看了，初学看)：n个骰子的总点数，最小为n，最大为6n，n个骰子出现的所有点数排列的个数为6^n。我们先统计每一个点数和出现的次数，定义一个长度为6n-n+1的数组，和为s的点数出现的次数保存到数组的第s-n个元素里;然后把每一个点数和出现的次数除以6^n，就能求出每个点数和出现的概率。因此本题重点是统计每一个点数和出现的次数，不难发现这是一种递归的思路，自下而上循环实现,从1个骰子开始，每次加一个骰子计算。用两个数组来存储骰子点数和的每一种出现的次数。在一次循环中，第一个数组中的第n个数字表示骰子和为n出现的次数。在下一次循环中我们加上一个新的骰子，此时和为n的骰子出现的次数应该等于上一次循环中骰子点数和为n-1、n-2、n-3、n-4、n-5与n-6的次数的综合，所以我们把另一个数组的第n个数字设为前一个数组对应的第n-1、n-2、n-3、n-4、n-5与n-6之和。</p><p>代码:</p><pre><code class="java">//n个骰子的所有出现的点数和及概率。思路：两个数组存所有出现的点数和及出现次数，再算概率。//详细思路:一个一个骰子往上加，点数和为n的出现次数resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]public static void printSumRatio(int number){    if(number&lt;1){        return;    }    //1.辅助两个数组并初始化    int[][] res = new int[2][6*number+1];//定义两个数组，交换着统计number个骰子所有可能的点数和出现的次数，数组长度为6*n+1    int resFlag = 0;//交换数组的标志位    for(int i=1; i&lt;=6; ++i){//当1个骰子时，初始化res数组        res[resFlag][i] = 1;    }    //2.交换着使用两个数组，统计number个骰子所有点数和出现的次数    for(int i=2; i&lt;=number; ++i){//一个一个骰子往上加        for(int j=1; j&lt;i; ++j){//当有i个骰子时，[1,i)的点数和为0，全部清空            res[1-resFlag][j] = 0;        }        for(int j=i; j&lt;=6*i; ++j){//当有i个骰子时,给[i,6*i]赋值            for(int k=1; k&lt;=6&amp;&amp;j&gt;k; ++k){                res[1-resFlag][j] += res[resFlag][j-k];//resTemp[n]=res[n-1]+res[n-2]+res[n-3]+res[n-4]+res[n-5]+res[6]            }        }        resFlag = 1-resFlag;//交换数组，改变flag    }    //3.计算并打印number个骰子所有可能的点数和及概率    double totalCount = Math.pow(6, number);//number个骰子出现的不同情况的总次数为6^n次方    for(int i=number; i&lt;=6*number; ++i){        double ratio = (double)res[resFlag][i]/totalCount;//点数和为res[i]的概率        System.out.println(number + &quot;个骰子，点数和为&quot; + i + &quot;出现的概率为&quot; + ratio);    }}public static void main(String[] args){    printSumRatio(2);    //out:    //2个骰子，点数和为2出现的概率为0.027777777777777776    //2个骰子，点数和为3出现的概率为0.05555555555555555    //2个骰子，点数和为4出现的概率为0.08333333333333333    //2个骰子，点数和为5出现的概率为0.1111111111111111    //2个骰子，点数和为6出现的概率为0.1388888888888889    //2个骰子，点数和为7出现的概率为0.16666666666666666    //2个骰子，点数和为8出现的概率为0.1388888888888889    //2个骰子，点数和为9出现的概率为0.1111111111111111    //2个骰子，点数和为10出现的概率为0.08333333333333333    //2个骰子，点数和为11出现的概率为0.05555555555555555    //2个骰子，点数和为12出现的概率为0.027777777777777776}</code></pre><p><a name="73"></a></p><h2 id="73-扑克牌中的顺子-2道"><a href="#73-扑克牌中的顺子-2道" class="headerlink" title="73.扑克牌中的顺子(2道)"></a>73.扑克牌中的顺子(2道)</h2><pre><code>整个数组是否为一个顺子(同时有大小王)--《剑指offer》p298.整个数组分组后每组都要为顺子--leetcode 846</code></pre><h3 id="1-整个数组是否为一个顺子-同时有大小王"><a href="#1-整个数组是否为一个顺子-同时有大小王" class="headerlink" title="1.整个数组是否为一个顺子(同时有大小王)"></a>1.整个数组是否为一个顺子(同时有大小王)</h3><p>《剑指offer》p298.</p><p>题目：扑克牌中的顺子：从扑克牌中随机抽5张牌,判断是不是顺子(即这5张牌是不是连续的)。2-10为数字本身，A为1，J、Q、K 为11、12、13，大小王可以看成任意的数字(解题时可以看成0)。</p><p>思路：</p><pre><code>0.定义长度为numbers的数组(这里不限于解决5张,判断numbers张牌是否为顺子);1.数组排序；2.统计数组中0的个数;3.统计排序后数组相邻数字间的空缺数(eg数字57间空缺1);4.2、3两步统计的0个数大于等于空缺数--&gt;顺子，否则不是顺子</code></pre><p>代码：</p><pre><code class="java">//判断扑克牌顺子(2张及以上连续),大小王0可以代表任意牌。思路：数组排序,记录大小王的个数，遍历数组判断是否为顺子即可public static boolean isContinuous(int [] numbers) {    if(numbers==null || numbers.length&gt;13 || numbers.length&lt;2){        return false;    }    //1.数组排序    Arrays.sort(numbers);    //2.记录大小王的个数并判断是否为顺子    int superCnt = 0;//记录大小王的个数    int superCntCopy = 0;//保存大小王个数    for(int i=0; i&lt;numbers.length-1; ++i){        if(numbers[i]==0){//是大小王            superCnt++;            superCntCopy++;        }        else if(numbers[i]==numbers[i+1]){//相等，即出现对儿，不是顺子            return false;        }        else if(numbers[i]+1==numbers[i+1]){//连续            continue;        }        else if(numbers[i]+1!=numbers[i+1]){//遇到不连续的牌，看看能不能凑个王            if( (numbers[i+1]-numbers[i]-1) &lt;= superCnt ){//可以用王凑                superCnt -= (numbers[i+1]-numbers[i]-1);            }else{//不够王了                return false;            }        }    }    //3.王太多还剩下几张王，放在牌头与牌尾后还剩下王，则不是顺子    if(superCnt&gt;0 &amp;&amp; superCnt&gt;(numbers[superCntCopy]-numbers[numbers.length-1]+12)){        return false;    }    return true;}</code></pre><h3 id="2-整个数组分组后每组都要为顺子"><a href="#2-整个数组分组后每组都要为顺子" class="headerlink" title="2.整个数组分组后每组都要为顺子"></a>2.整个数组分组后每组都要为顺子</h3><p>leetcode 846</p><p>题目：Alice has a hand of cards, given as an array of integers. Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards. Return true if and only if she can.</p><pre><code>Input: hand = [1,2,3,6,2,3,4,7,8], W = 3Output: trueExplanation: Alice&#39;s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</code></pre><p>思路：1.hand长度不能整除W，false;2.hand排序;3.由于[1,2,3],[2,3,4]也可以，需要<strong>辅助数组缓存访问标记</strong>用于后续判断;4.遍历数组一组一组进行判断</p><pre><code class="java">public boolean isNStraightHand(int[] hand, int W) {    //1.hand长度不能整除W，false    if(hand==null || hand.length==0 || W&lt;1 || W&gt;hand.length || hand.length%W!=0){        return false;    }    //2.hand排序    Arrays.sort(hand);    //3.辅助数组缓存访问标记用于后续判断    boolean[] visited = new boolean[hand.length];    //4.遍历数组一组一组进行判断    int cnt = W;    for(int i=0; i&lt;hand.length; ++i){        if(!visited[i]){//如果没有被访问过之前，以此为新group的起始位置开始寻找一个group            visited[i] = true;            int left = i;            int right = i+1;            while(cnt!=1){//寻找一个group                if(right&gt;=hand.length){//找完了hand都没凑成一个group,false                    return false;                }                if(!visited[right]){                    if(hand[left]+1&lt;hand[right]){//断层太大，不可能连续了，false                        return false;                    }                    else if(hand[left]+1==hand[right]){//前后连续                        visited[right] = true;                        left = right;                        cnt--;                    }                }                right++;            }            //找完了一个group，重置cnt            cnt = W;        }    }    return true;//找完了所有group，没有返回false说明都符合条件,true}</code></pre><p><a name="74"></a></p><h2 id="74-圆圈中剩下的数-约瑟夫环问题"><a href="#74-圆圈中剩下的数-约瑟夫环问题" class="headerlink" title="74.圆圈中剩下的数(约瑟夫环问题)"></a>74.圆圈中剩下的数(约瑟夫环问题)</h2><p>《剑指offer》p300、《左神》43、leetcode 292</p><p>题目：圆圈中最后剩下的数字。0,1…n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈中删除第m个数字，求出这个圆圈里剩下的最后一个数字。e.g n=5([0,1,2,3,4]),m=3,out:3</p><p>思路1：用<strong>双端队列</strong>模拟这个循环环的问题，每排除一个数需要m步运算，n个数就需要O(mn)，空间复杂度为O(n)</p><pre><code class="java">//圆圈中剩下的数。思路:用双端队列模拟这个过程，时间o(nm),空间o(n)public static int LastRemaining_Solution(int n, int m) {    if(m&lt;1 || n&lt;1){        return -1;    }    if(n==1){        return 1;    }    //1.辅助o(n)双端队列    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    for(int i=0; i&lt;n; ++i){        deque.offerLast(i);    }    //2.模拟弹出过程,直到双端队列中剩下一个数为止    int cnt = m;    while(deque.size()&gt;1){        cnt--;        if(cnt==0){//弹出一个数，重置cnt            deque.pollFirst();            cnt = m;        }        else{            deque.offerLast(deque.pollFirst());        }    }    return deque.pollFirst();}</code></pre><p>思路2(更好)：分析这个题的数学规律，直接求解:<code>f(n,m)=[(f(n-1,m)+m]%n</code>，时间o(n)，空间o(1)。</p><pre><code class="java">//f(n,m)=[(f(n-1,m)+m]%n//f(n,m)=0(n=1);f(n,m)=[(f(n-1,m)+m)%n](n&gt;1)public int LastRemaining_Solution(int n, int m) {    if(m&lt;1 || n&lt;1){        return -1;    }    int res = 0;    for(int i=2; i&lt;=n; ++i){        res = (res+m)%i;    }    return res;}</code></pre><p><a name="75"></a></p><h2 id="75-股票的最大利润问题-四道"><a href="#75-股票的最大利润问题-四道" class="headerlink" title="75.股票的最大利润问题(四道)"></a>75.股票的最大利润问题(四道)</h2><pre><code>只允许买卖一次股票，求最大收益--《剑指offer》p304、leetcode 121允许多次买卖，求最大收益--《剑指offer》p304、leetcode 122只允许买卖两次股票，求最大收益--leetcode 123只允许买卖k次股票，求最大收益--leetcode 188</code></pre><h3 id="1-只允许买卖一次股票，求最大收益"><a href="#1-只允许买卖一次股票，求最大收益" class="headerlink" title="1.只允许买卖一次股票，求最大收益"></a>1.只允许买卖一次股票，求最大收益</h3><p>《剑指offer》p304</p><p>题目：只允许买卖一次股票，求最大收益</p><p>思路：以当前股票为基准，找到之前的最小值，用来更新最大利润。时间o(n)</p><pre><code class="java">//股票的最大利润，只允许买卖一次股票，求最大收益。思路:两个变量即可，每天都尝试卖一次，不断更新最大利润。时间o(n),空间o(1)public int maxProfit(int[] prices) {    if(prices==null || prices.length&lt;2){        return 0;    }    int min = prices[0];//存之前最小的股价    int resMax = 0; //存最大的利润    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润        resMax = Math.max(resMax, prices[i]-min);        if(prices[i]&lt;min){            min = prices[i];        }    }    return resMax;}</code></pre><h3 id="2-允许多次买卖，求最大收益"><a href="#2-允许多次买卖，求最大收益" class="headerlink" title="2.允许多次买卖，求最大收益"></a>2.允许多次买卖，求最大收益</h3><p>《剑指offer》p304、leetcode 122</p><p>题目：允许多次买卖，求最大收益</p><p>思路：每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)</p><pre><code class="java">//股票的最大利润，允许多次买卖，求最大收益。思路:每次都头一天买，第二天卖出，把所有利润为正的加起来即为最大利润。时间o(n),空间o(1)public int maxProfit(int[] prices) {    if(prices==null || prices.length&lt;2){        return 0;    }    int resMax = 0; //存最大的利润    for(int i=1; i&lt;prices.length; ++i){//遍历股价，每天都尝试卖一次，不断更新最大利润        int temp = prices[i]-prices[i-1];        if(temp&gt;0){            resMax += temp;        }    }    return resMax;}</code></pre><h3 id="3-只允许买卖两次股票，求最大收益"><a href="#3-只允许买卖两次股票，求最大收益" class="headerlink" title="3.只允许买卖两次股票，求最大收益"></a>3.只允许买卖两次股票，求最大收益</h3><p>leetcode 123</p><p>题目：只允许买卖两次股票，求最大收益</p><p>思路：3、4两题可以用DP解决，但是这里用更巧妙的方法，直接看第4题即可，本题的解法就是第4题的k=2</p><h3 id="4-只允许买卖k次股票，求最大收益"><a href="#4-只允许买卖k次股票，求最大收益" class="headerlink" title="4.只允许买卖k次股票，求最大收益"></a>4.只允许买卖k次股票，求最大收益</h3><p>leetcode 188</p><p>题目：只允许买卖k次股票，求最大收益</p><p>思路：3、4两题都用二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益。</p><pre><code class="java">//k次买卖的最大股票收益。思路：二维dp。dp[i][j]表示截止第j天进行i次交易的最大收益public int maxProfit(int k, int[] prices) {    int len = prices.length;    if (k &gt;= len / 2) return quickSolve(prices);//可以最多次买卖，求最大收益即可    int[][] t = new int[k + 1][len];    for (int i = 1; i &lt;= k; i++) {        int tmpMax =  -prices[0];//tmpMax就是自己的钱包，就是当前的收益        for (int j = 1; j &lt; len; j++) {            t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax);//卖            tmpMax =  Math.max(tmpMax, t[i - 1][j - 1] - prices[j]);//买        }    }    return t[k][len - 1];}//允许多次买卖，把所有的收益都加起来即可private int quickSolve(int[] prices) {    int len = prices.length, profit = 0;    for (int i = 1; i &lt; len; i++)        // as long as there is a price gap, we gain a profit.        if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1];    return profit;}</code></pre><p><a name="76"></a></p><h2 id="76-求1-2-3-…-n"><a href="#76-求1-2-3-…-n" class="headerlink" title="76.求1+2+3+…+n"></a>76.求1+2+3+…+n</h2><p>《剑指offer》p307.</p><p>题目：求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>思路：递归。</p><p>这里可以通过递归的方式进行计算，<strong>但是很疑问的地方在于如何结束递归</strong><br>​<br>这里可以有多种的方式，基本方向是采用逻辑与或的方式来计算，</p><p><strong>用或运算通过n==0来短路，这样在n=0的时候不需要计算递归的值</strong></p><pre><code class="java">public static int Sum_Solution(int n) {    int res = 0;    boolean b = n==0 || (res=n+Sum_Solution(n-1))&gt;0;    return res;}</code></pre><p><a name="77"></a></p><h2 id="77-构建乘积数组"><a href="#77-构建乘积数组" class="headerlink" title="77.构建乘积数组"></a>77.构建乘积数组</h2><p>《剑指offer》p312、leetcode 238</p><p>题目：给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],</p><p>其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。</p><p>思路1(不可取)：如果没有不能使用除法的限制,可以用公式B[i]=A[0]*A[1]*…..*A[n-1]/A[i]表示,使用除法时要特别注意A[i]等于0的情况。时间o(n)，空间o(1)，但是这里不能用除法</p><p>思路2(不可取)：现在要求不能使用除法，一个直观的解法是用连乘n-1个数字得到B[i]，时间o(n^2)</p><p>思路3(可取)：辅助一个数组temp[]的思想(但这里就用B做辅助数组)，时间o(n),空间o(1)</p><p>1.先从后往前存储(temp[i]=A[i]*A[i+1]*…A[length-1])，此时先将B[]看成辅助数组temp[]</p><p>2.再从前往后计算(tempRes=A[0],B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]…)</p><p>代码：</p><pre><code class="java">public int[] multiply(int[] A) {    if(A==null || A.length==0){        return new int[0];    }    int[] B = new int[A.length];//存放结果，但从后往前计算时先将B看成辅助数组    //1.1.先从后往前存储(temp[i]=A[i]*A[i+1]*...A[length-1])，此时先将B[]看成辅助数组    B[A.length-1] = A[A.length-1];    for(int i=A.length-2; i&gt;=0; i--){        B[i] = B[i+1] * A[i];    }    //2.再从前往后计算(tempRes=1,B[0]=tempRes*temp[i-1],B[1]=tempRes*A[1]*temp[i]...)    int tempRes = 1;    for(int i=0; i&lt;A.length-1; ++i){        B[i] = tempRes * B[i+1];        tempRes *= A[i];    }    B[A.length-1] = tempRes;//最后一个元素    return B;}</code></pre><p><a name="78"></a></p><h2 id="78-普通二叉树中两个节点的最低公共祖先"><a href="#78-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="78.普通二叉树中两个节点的最低公共祖先"></a>78.普通二叉树中两个节点的最低公共祖先</h2><p>《剑指offer》p326、leetcode 236</p><p>题目：普通二叉树中两个节点的最低公共祖先</p><p>思路1(不可取)：从root开始寻找</p><p>如果当前节点的左子节点是两个节点的祖先(应该继续对左子节点判断)</p><p>如果当前节点的右子节点是两个节点的祖先(应该继续对右子节点判断)</p><p>当前结点不同时为两个结点的祖先(一边一个)，即为最低公共祖先</p><p>这种方法自上而下重复遍历，不太好</p><pre><code class="java">class TreeNode {    int val;    TreeNode left = null;    TreeNode right = null;    TreeNode(int val) {        this.val = val;    }}public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if (hasNode(root.left, p) &amp;&amp; hasNode(root.left, q)) {        return lowestCommonAncestor(root.left, p, q);    } else if (hasNode(root.right, p) &amp;&amp; hasNode(root.right, q)) {        return lowestCommonAncestor(root.right, p, q);    }    return root;}//遍历以root为根的树，判断是否含有节点ppublic boolean hasNode(TreeNode root, TreeNode p) {    if (root == null) {        return false;    }    if (root == p) {        return true;    }    return hasNode(root.left, p) || hasNode(root.right, p);}</code></pre><p>思路2(可取)：遍历两次树，分别找出从root到两个节点的路径(用两个List存下来)，变成求两个list中的最后一个公共结点</p><pre><code class="java">//普通二叉树中两个节点的最低公共祖先public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q){    if(root==null || p==null || q==null){        return null;    }    ArrayList&lt;TreeNode&gt; arrayListP = new ArrayList&lt;&gt;();    ArrayList&lt;TreeNode&gt; arrayListQ = new ArrayList&lt;&gt;();//两个List存路径    if(!findPath(root,p,arrayListP) || !findPath(root,q,arrayListQ)){//没找到p、q        return null;    }    int index = 0;    while(index&lt;arrayListP.size() &amp;&amp; index&lt;arrayListQ.size()){//对两个路径list找最后一个公共节点        if(arrayListP.get(index)!=arrayListQ.get(index)){            break;        }        index++;    }    return index==0 ? root: arrayListP.get(index-1);}//遍历二叉树，找root到target节点的路径(路径存在res中)，如果没找到target返回truepublic boolean findPath(TreeNode root, TreeNode target, ArrayList&lt;TreeNode&gt; res){    if(root==null){        return false;    }    res.add(root);    if(root==target){        return true;    }    if (findPath(root.left, target, res) || findPath(root.right, target, res)){        return true;    }    res.remove(res.size()-1);//回溯    return false;}</code></pre><p><a name="79"></a></p><h2 id="79-把字符串转换成整数"><a href="#79-把字符串转换成整数" class="headerlink" title="79.把字符串转换成整数"></a>79.把字符串转换成整数</h2><p>《剑指offer》p318、leetcode 8</p><p>题目：把字符串(包括数字字母符号,可以为空)转换成整数，不符合条件返回0。<br>即实现Integer.valueOf(string)的功能，要求不能使用字符串转换整数的库函数</p><p>思路：字符串转换成数组，res用long，从前往后遍历即可，本题核心是对以下情况的处理</p><p>要点：</p><pre><code>1.字母判断2.溢出3.正负号</code></pre><p>代码：</p><pre><code class="java">public int myAtoi(String str){    if(str==null || str.trim().length()==0){        return 0;    }    char[] chs = str.trim().toCharArray();//转换成数组    boolean isPositive = true;//正负号    int index = 0;    long res = 0;    if(chs[index]==&#39;+&#39; || chs[index]==&#39;-&#39;){        isPositive = chs[index]==&#39;-&#39; ? false : true;        index++;    }    while(index&lt;chs.length){        int temp = chs[index]-&#39;0&#39;;        if(temp&lt;0||temp&gt;9){//是否是数字判断            return 0;//这里在leetoce中应该为break，题目要求有一点点不一样        }        res = res*10L + (long)temp;        index++;        if(isPositive==true){//溢出判断            if(res&gt;Integer.MAX_VALUE){                return Integer.MAX_VALUE;            }        }        else{            if(res*(-1L)&lt;Integer.MIN_VALUE){                return Integer.MIN_VALUE;            }        }    }    return isPositive==true ? (int)res : (int)res*(-1);//正负号判断}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令</title>
      <link href="/2018/07/23/linux-orders/"/>
      <url>/2018/07/23/linux-orders/</url>
      
        <content type="html"><![CDATA[<p>linux命令学习总结</p><a id="more"></a><h2 id="linux标准输入输出2-gt-amp-1"><a href="#linux标准输入输出2-gt-amp-1" class="headerlink" title="linux标准输入输出2&gt;&amp;1"></a>linux标准输入输出2&gt;&amp;1</h2><ul><li>linux中有三种标准输入输出，分别是STDIN，STDOUT，STDERR，对应的数字是0，1，2。<code>2&gt;&amp;1，指将标准输出、标准错误指定为同一输出路径</code></li><li>STDIN是标准输入，默认从键盘读取信息；STDOUT是标准输出，默认将输出结果输出至终端；STDERR是标准错误，默认将输出结果输出至终端。</li><li>由于STDOUT与STDERR都会默认显示在终端上，为了区分二者的信息，就有了编号的0，1，2的定义，用1表示STDOUT，2表示STDERR。</li><li>若要将所有标准输出及标准错误都输出至文件，可用&amp;表示全部1和2的信息，eg：<code>find /etc -name passwd &amp;&gt;find.all 或 find /etc -name passwd &gt;find.all 2&gt;&amp;1</code></li><li><code>2&gt;&amp;1 |less</code> 表示将标准错误重定向至标准输出，并用less进行分页显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu虚拟机共享文件夹</title>
      <link href="/2018/07/23/linux-virtual/"/>
      <url>/2018/07/23/linux-virtual/</url>
      
        <content type="html"><![CDATA[<h2 id="VBox虚拟机下Mac与ubuntu共享文件夹"><a href="#VBox虚拟机下Mac与ubuntu共享文件夹" class="headerlink" title="VBox虚拟机下Mac与ubuntu共享文件夹"></a>VBox虚拟机下Mac与ubuntu共享文件夹</h2><blockquote><ol><li>mac电脑下载并安装VBoxAdditions，网址：<a href="http://download.virtualbox.org/virtualbox/5.2.16/Oracle_VM_VirtualBox_Extension_Pack-5.1.12.vbox-extpack" target="_blank" rel="noopener">http://download.virtualbox.org/virtualbox/5.2.16/Oracle_VM_VirtualBox_Extension_Pack-5.1.12.vbox-extpack</a></li></ol></blockquote><blockquote><ol start="2"><li>在虚拟机ubuntu系统中下载VBoxAdditions，网址：<a href="http://download.virtualbox.org/virtualbox/5.2.16/VBoxGuestAdditions_5.1.12.iso，下载完成后在虚拟机中直接运行安装" target="_blank" rel="noopener">http://download.virtualbox.org/virtualbox/5.2.16/VBoxGuestAdditions_5.1.12.iso，下载完成后在虚拟机中直接运行安装</a></li></ol></blockquote><blockquote><ol start="3"><li>在vbox软件中设置共享目录：点击设置-&gt;共享文件夹&gt;增加一个共享路径，并设置为固定分配、自动挂载</li></ol></blockquote><blockquote><ol start="4"><li>在ubuntu中启用共享文件夹：</li></ol></blockquote><blockquote><p>   sudo mkdir /mnt/share</p></blockquote><blockquote><p>   mount -t vboxsf 3中的共享文件夹名 /mnt/share</p></blockquote><blockquote><ol start="5"><li>成功：完美实现了两个系统间的复制粘贴与文件共享</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3连接MySQL</title>
      <link href="/2018/07/19/python-mysql-connect/"/>
      <url>/2018/07/19/python-mysql-connect/</url>
      
        <content type="html"><![CDATA[<h2 id="Python3与MySQL数据库连接"><a href="#Python3与MySQL数据库连接" class="headerlink" title="Python3与MySQL数据库连接"></a>Python3与MySQL数据库连接</h2><pre><code>#!/usr/bin/python3import pymysql# 打开数据库连接db = pymysql.connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;,&quot;database_name&quot; )# 使用 cursor() 方法创建一个游标对象 cursorcursor = db.cursor()# 使用 execute()  方法执行 SQL 查询 cursor.execute(&quot;SELECT VERSION()&quot;)# 使用 fetchone() 方法获取单条数据.data = cursor.fetchone()print (&quot;Database version : %s &quot; % data)# 关闭数据库连接db.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http请求过程、方式</title>
      <link href="/2018/07/18/http-request/"/>
      <url>/2018/07/18/http-request/</url>
      
        <content type="html"><![CDATA[<p>简要总结了http请求过程与请求方式</p><a id="more"></a><h2 id="完整的http请求过程–7步"><a href="#完整的http请求过程–7步" class="headerlink" title="完整的http请求过程–7步"></a>完整的http请求过程–7步</h2><p>1.建立tcp连接</p><p>2.Web浏览器向Web服务器发送请求命令</p><p>3.Web浏览器发送请求头信息</p><p>4.Web服务器应答</p><p>5.Web服务器发送应答头信息</p><p>6.Web服务器向浏览器发送数据</p><p>7.Web服务器关闭tcp连接    </p><h2 id="一个http请求一般由四部分组成"><a href="#一个http请求一般由四部分组成" class="headerlink" title="一个http请求一般由四部分组成"></a>一个http请求一般由四部分组成</h2><p>1.http请求的方法：get请求还是post请求<br>2.正在请求的url，就是发起请求的地址</p><p>3.请求头，包含一些客户端环境信息，身份验证信息等</p><p>4.请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等</p><h2 id="一个http响应一般由三部分组成"><a href="#一个http响应一般由三部分组成" class="headerlink" title="一个http响应一般由三部分组成"></a>一个http响应一般由三部分组成</h2><p>1.一个数字和文字组成的状态码，用来显示请求成功还是失败</p><p>2.响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等</p><p>3.响应体，也就是响应正文</p><h2 id="get与post"><a href="#get与post" class="headerlink" title="get与post"></a>get与post</h2><ul><li><p>get：</p><p>  一般用于信息获取</p><p>  使用url传递参数（用get发送用户名密码是非常不安全的）</p><p>  对所发送信息的数量也有限制，一般在2000个字符</p></li><li><p>post：</p><p>  一般用于修改服务器上的资源</p><p>  对所发送信息的数量无限制</p></li></ul><h2 id="http请求中GET和POST的区别"><a href="#http请求中GET和POST的区别" class="headerlink" title="http请求中GET和POST的区别"></a>http请求中GET和POST的区别</h2><ul><li>GET - 从指定的服务器中获取数据</li><li>POST - 提交数据给指定的服务器处理</li></ul><p>GET请求：请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。</p><p>POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。</p><p>因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</p>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中shell调用</title>
      <link href="/2018/07/18/python-shell/"/>
      <url>/2018/07/18/python-shell/</url>
      
        <content type="html"><![CDATA[<h2 id="python前后端调用另辟蹊径–shell脚本调用"><a href="#python前后端调用另辟蹊径–shell脚本调用" class="headerlink" title="python前后端调用另辟蹊径–shell脚本调用"></a>python前后端调用另辟蹊径–shell脚本调用</h2><p>再经过了前面的flask前后端调用的一天bug洗礼后，有个问题仍旧难以解决，大概就是flask是python的web服务，理论上来说是要打开网页进行交互，网页与后台传参也可以用上述的ajax传递。但是，鄙人的这个神奇的项目需求是要我有起点终点，现在调用百度api，返回地图规划路径，但是调用过程中不能用鼠标单击网页api，自动|后台|悄悄的调用，我只要得到返回的规划路径str就可以了，谁要你打开网页显示出来路径的信息啊，只要文字不要二维的路径图案。于是乎，我先后尝试了</p><blockquote><p>1.基于flask框架下的ajax传参，gg：不打开网页，但是网页是动态的，必须打开才可以ajax获取</p></blockquote><blockquote><p>2.基于flask框架下，在路由index()方法中用多进程的方式分别调用百度api、获取api计算后的str路径，gg：因为index()必须返回页面，而这个页面正是我index()方法中要调用的，脑袋疼。。。</p></blockquote><blockquote><p>3.基于flask框架下，在flask的main方法下写，gg: 神奇的flask在调用app.run()后根本他么不执行后面的语句，原因后想也比较好理解，因为是flask啊，启动后就是web服务啊，要什么main函数后面的逻辑。。。</p></blockquote><blockquote><p>4.还有些其他很小的尝试，均失败无法实现，关键这个需求还很难描述百度，吃饭回来后冷静下来好好想了想，发现就是两步调用百度api、获取api计算后的str路径，而这两步我都实现了，只是被神奇的flask羁绊住了，只是因为后期有个需求需要用flask，我还不能更换框架，于是，无意中我知道python调用Shell脚本的有两种方法：os.system(cmd)或os.popen(cmd)，然后直接将上述两步写到两个脚本，用总得main去调用执行这两个脚本即可，细节介绍如下，脑瓜疼了半天终于解决了~</p></blockquote><h2 id="python调用Shell脚本"><a href="#python调用Shell脚本" class="headerlink" title="python调用Shell脚本"></a>python调用Shell脚本</h2><p>有两种方法：<code>os.system(cmd) 或 os.popen(cmd)</code></p><p>前者返回值是脚本的退出状态码0、1；后者的返回值是脚本执行过程中的输出内容。下面是示例:</p><pre><code>#先运行flask调用百度api的脚本os.system(&quot;python init.py&amp;&quot;)time.sleep(3)#再访问http://127.0.0.1:5000页面，得到目标字符串data.readline()data = os.popen(&quot;python init2.py&quot;)print(data.readline())#终止os.system后台调用的程序os.system(&quot;pkill python init.py&amp;&quot;)</code></pre><h2 id="前端JSON解析–JSON-parse"><a href="#前端JSON解析–JSON-parse" class="headerlink" title="前端JSON解析–JSON.parse"></a>前端JSON解析–JSON.parse</h2><pre><code>var data = &#39;{&quot;staff&quot;: 123, &quot;asd&quot;:&quot;asd&quot;}&#39;;var jsonobj = JSON.parse(data); alert(obj.staff); </code></pre><p>JSON格式化和校验工具：<a href="http://jsonlint.com" target="_blank" rel="noopener">JSONLint</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS模板</title>
      <link href="/2018/04/08/dfs-template/"/>
      <url>/2018/04/08/dfs-template/</url>
      
        <content type="html"><![CDATA[<p>这是一篇关于DFS深度优先搜索算法的总结笔记</p><a id="more"></a><h1 id="DFS思想"><a href="#DFS思想" class="headerlink" title="DFS思想"></a>DFS思想</h1><p>参考：<a href="https://blog.csdn.net/u011437229/article/details/53188837" target="_blank" rel="noopener">BFS和DFS算法原理（通俗易懂版）</a></p><h1 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h1><pre><code class="c++">#include &lt;iostream&gt;using namespace std;/** *DFS思想：一直往深处走，直到找到解或者走不下去为止 *实现：采用递归，使用栈保存未被检测的结点，结点按照深度优先的次序被访问并依次被压入栈中，并以相反的次序出栈进行新的检测。 *该DFS框架以2D坐标范围为例，来体现DFS算法的实现思想。*/const int maxn=100;bool vst[maxn][maxn]; // 访问标记int map[maxn][maxn]; // 坐标范围int dir[4][2]={{0,1}, {0,-1}, {1,0}, {-1,0}}; // 方向向量，(x,y)周围的四个方向：dir[0]上，dir[1]下，dir[2]右，dir[3]左bool CheckEdge(int x,int y) // 边界条件和约束条件的判断{    if(!vst[x][y]) // 该节点之前没被访问过，满足条件，可访问        return 1;    else // 与约束条件冲突        return 0;}void dfs(int x,int y){    vst[x][y]=1; // 标记该节点被访问过    if(map[x][y] == 1) // 出现目标态G    {         // 做相应处理        return;    }    for(int i=0;i&lt;4;i++) //遍历(x, y)上下左右四个方向进行搜索    {        if(CheckEdge(x+dir[i][0],y+dir[i][1])) // 按照规则生成下一个节点            dfs(x+dir[i][0],y+dir[i][1]);    }    return; // 没有下层搜索节点，回溯}int main(){    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的主键外键索引</title>
      <link href="/2018/04/08/mysql-key-index/"/>
      <url>/2018/04/08/mysql-key-index/</url>
      
        <content type="html"><![CDATA[<p>这是一篇数据库的主键、外键、索引的学习笔记</p><a id="more"></a><h2 id="数据库的主键外键索引"><a href="#数据库的主键外键索引" class="headerlink" title="数据库的主键外键索引"></a>数据库的主键外键索引</h2><h3 id="主键、外键和索引的区别？"><a href="#主键、外键和索引的区别？" class="headerlink" title="主键、外键和索引的区别？"></a>主键、外键和索引的区别？</h3><p>  |主键|外键|索引<br>—|—|—|—<br>定义|唯一标识一条记录，不能有重复的，不允许为空|表的外键是另一表的主键, 外键可以有重复的, 可以是空值|该字段没有重复值，但可以有一个空值<br>作用|用来保证数据完整性|用来和其他表建立联系用的|是提高查询排序的速度<br>个数|主键只能有一个|一个表可以有多个外键|一个表可以有多个惟一索引</p><h3 id="聚集索引和非聚集索引的区别？"><a href="#聚集索引和非聚集索引的区别？" class="headerlink" title="聚集索引和非聚集索引的区别？"></a>聚集索引和非聚集索引的区别？</h3><p>聚集索引一定是唯一索引。但唯一索引不一定是聚集索引。  </p><p>聚集索引，在索引页里直接存放数据，而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。</p><h2 id="mysql中key-、primary-key-、unique-key-与index区别"><a href="#mysql中key-、primary-key-、unique-key-与index区别" class="headerlink" title="mysql中key 、primary key 、unique key 与index区别"></a>mysql中key 、primary key 、unique key 与index区别</h2><p>来源：<a href="https://www.cnblogs.com/jpfss/p/8308656.html" target="_blank" rel="noopener">mysql中key 、primary key 、unique key 与index区别</a> + <a href="https://www.cnblogs.com/as3lib/p/6632749.html" target="_blank" rel="noopener">mysql中key 、primary key 、unique key 与index区别</a> + <a href="http://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="noopener">MySQL 索引-菜鸟教程</a></p><ul><li><p>key的用途：主要是用来加快查询速度的。</p></li><li><p>unique Key是唯一键，而Primary key是主键<br>Primary key 与Unique Key都是唯一性约束。但二者有很大的区别：</p><p>  1、Primary key的1个或多个列 必须为NOT NULL，如果列为NULL，在增加PRIMARY KEY时，列自动更改为NOT NULL。而UNIQUE KEY 对列没有此要求。</p><p>  2、一个表只能有一个PRIMARY KEY，但可以有多个UNIQUE KEY。</p></li><li><p>MySQL 中Index 与Key 的区别:</p><p>  <strong>key</strong> 是数据库的物理结构，它包含两层意义，一是<strong>约束</strong>（偏重于约束和规范数据库的结构完整性），二是<strong>索引</strong>（辅助查询用的）</p><p>  index是数据库的物理结构，它只是辅助查询的，它创建时会在另外的表空间（mysql中的innodb表空间）以一个类似目录的结构存储。索引要分类的话，分为前缀索引、全文本索引等；<br>因此，<strong>索引只是索引，它不会去约束索引的字段的行为（那是key要做的事情）</strong>。如，create table t(id int, index inx_tx_id  (id));</p><p>  请详看<a href="https://www.cnblogs.com/jianmingyuan/p/6740090.html" target="_blank" rel="noopener">key和index区别</a></p><p>  Key即键值，是关系模型理论中的一部份，比如有主键（Primary Key)，外键（Foreign Key）等，用于数据完整性检否与唯一性约束等。</p><p>  而Index则处于实现层面，比如可以对表的任意列建立索引，那么当建立索引的列处于SQL语句中的Where条件中时，就可以得到快速的数据定位，从而快速检索。</p><p>  至于Unique Index，则只是属于Index中的一种而已，建立了Unique Index表示此列数据不可重复，猜想MySQL对Unique Index类型的索引可以做进一步特殊优化吧。 </p></li></ul><pre><code>于是乎，在设计表的时候，Key只是要处于模型层面的，而当需要进行查询优化，则对相关列建立索引即可。 另外，在MySQL中，对于一个Primary Key的列，MySQL已经自动对其建立了Unique Index，无需重复再在上面建立索引了。总结： (1).我们说索引分类，分为主键索引、唯一索引、普通索引(这才是纯粹的index)等，也是基于是不是把index看作了key。</code></pre><p>  比如 create table t(id int, unique index inx_tx_id  (id));  –index当作了key使用</p><pre><code>(2).最重要的也就是，不管如何描述，理解index是纯粹的index，还是被当作key，当作key时则会有两种意义或起两种作用。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL事务</title>
      <link href="/2018/04/08/mysql-transaction/"/>
      <url>/2018/04/08/mysql-transaction/</url>
      
        <content type="html"><![CDATA[<p>这是一篇MySQL事务的学习笔记</p><a id="more"></a><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p><a href="http://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener">2min看完强推_MySQL 事务-菜鸟教程</a></p><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><ul><li><p>在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。</p></li><li><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p></li><li><p>事务用来管理 insert,update,delete 语句</p></li></ul><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><p>在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><p>MYSQL 事务处理主要有两种方法：</p><ul><li>1、用 BEGIN, ROLLBACK, COMMIT来实现</li></ul><pre><code>BEGIN 开始一个事务ROLLBACK 事务回滚COMMIT 事务确认</code></pre><ul><li>2、直接用 SET 来改变 MySQL 的自动提交模式:</li></ul><pre><code>SET AUTOCOMMIT=0 禁止自动提交SET AUTOCOMMIT=1 开启自动提交</code></pre><p>事务的两个例子：</p><p><img src="https://img.braincao.cn/blogimg/1583560979.jpg" alt="1583560979"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语法</title>
      <link href="/2018/04/08/sql-grammar/"/>
      <url>/2018/04/08/sql-grammar/</url>
      
        <content type="html"><![CDATA[<p>这是一篇sql语法的总结笔记</p><a id="more"></a><h2 id="sql语法表"><a href="#sql语法表" class="headerlink" title="sql语法表"></a>sql语法表</h2><table><thead><tr><th><strong>语句</strong></th><th><strong>语法</strong></th></tr></thead><tbody><tr><td>AND / OR</td><td>SELECT column_name(s)   FROM table_name   WHERE condition   AND|OR condition</td></tr><tr><td>ALTER TABLE (add column)</td><td>ALTER TABLE table_name    ADD column_name datatype</td></tr><tr><td>ALTER TABLE (drop column)</td><td>ALTER TABLE table_name    DROP COLUMN column_name</td></tr><tr><td>AS (alias for column)</td><td>SELECT column_name AS column_alias   FROM table_name</td></tr><tr><td>AS (alias for table)</td><td>SELECT column_name   FROM table_name AS table_alias</td></tr><tr><td>BETWEEN</td><td>SELECT column_name(s)   FROM table_name   WHERE column_name   BETWEEN value1 AND value2</td></tr><tr><td>CREATE DATABASE</td><td>CREATE DATABASE database_name</td></tr><tr><td>CREATE INDEX</td><td>CREATE INDEX index_name   ON table_name (column_name)</td></tr><tr><td>CREATE TABLE</td><td>CREATE TABLE table_name   (   column_name1 data_type,   column_name2 data_type,   …….   )</td></tr><tr><td>CREATE UNIQUE INDEX</td><td>CREATE UNIQUE INDEX index_name   ON table_name (column_name)</td></tr><tr><td>CREATE VIEW</td><td>CREATE VIEW view_name AS   SELECT column_name(s)   FROM table_name   WHERE condition</td></tr><tr><td>DELETE FROM</td><td>DELETE FROM table_name    (<strong>Note:</strong> Deletes the entire table!!)  <em>or</em>  DELETE FROM  table_name   WHERE condition</td></tr><tr><td>DROP DATABASE</td><td>DROP DATABASE database_name</td></tr><tr><td>DROP INDEX</td><td>DROP INDEX table_name.index_name</td></tr><tr><td>DROP TABLE</td><td>DROP TABLE table_name</td></tr><tr><td>GROUP BY</td><td>SELECT column_name1,SUM(column_name2)   FROM table_name   GROUP BY column_name1</td></tr><tr><td>HAVING  HAVING 是用来限制GROUP BY子句的结构的；<strong>HAVING作用于GROUP BY 之后的每一个group</strong>。</td><td>SELECT column_name1,SUM(column_name2)   FROM table_name   GROUP BY column_name1   HAVING SUM(column_name2) condition value</td></tr><tr><td>IN</td><td>SELECT column_name(s)   FROM table_name   WHERE column_name   IN (value1,value2,..)</td></tr><tr><td>INSERT INTO</td><td>INSERT INTO table_name   VALUES (value1, value2,….)  <em>or</em>  INSERT INTO  table_name   (column_name1, column_name2,…)   VALUES (value1, value2,….)</td></tr><tr><td>LIKE</td><td>SELECT column_name(s)   FROM table_name   WHERE column_name   LIKE pattern (% _ [] [^])</td></tr><tr><td>ORDER BY</td><td>SELECT column_name(s)   FROM table_name   ORDER BY column_name [ASC|DESC]</td></tr><tr><td>SELECT</td><td>SELECT column_name(s)   FROM table_name</td></tr><tr><td>SELECT *</td><td>SELECT *   FROM table_name</td></tr><tr><td>SELECT DISTINCT</td><td>SELECT DISTINCT column_name(s)   FROM table_name</td></tr><tr><td>SELECT INTO   (used to create backup copies of tables)</td><td>SELECT *   INTO new_table_name   FROM original_table_name  <em>or</em>  SELECT  column_name(s)   INTO new_table_name   FROM original_table_name</td></tr><tr><td>TRUNCATE TABLE   (deletes only the data inside the table)</td><td>TRUNCATE TABLE table_name</td></tr><tr><td>UPDATE</td><td>UPDATE table_name   SET column_name=new_value   [, column_name=new_value]   WHERE column_name=some_value</td></tr><tr><td>WHERE</td><td>SELECT column_name(s)   FROM table_name   WHERE condition</td></tr></tbody></table><h2 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h2><p>mysql添加列必须说明数据类型，删除列可以省略column</p><pre><code>错误:alter table employee add memoalter table employee add column正确：alter table employee drop column agealter table employee drop age</code></pre><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>select * from message limit 5,5; //从第5条开始取，取5条</p><h2 id="批量删除多条记录–in"><a href="#批量删除多条记录–in" class="headerlink" title="批量删除多条记录–in"></a>批量删除多条记录–in</h2><p>DELETE FROM message WHERE commandid IN (640,634,633);</p><h2 id="统计SQL语句查询出来的条数"><a href="#统计SQL语句查询出来的条数" class="headerlink" title="统计SQL语句查询出来的条数"></a>统计SQL语句查询出来的条数</h2><p>SELECT COUNT(*) FROM micro_message.COMMAND;</p><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><p>INSERT INTO COMMAND (COMMAND,DESCRIPTION) VALUES(‘HAHA’, ‘ASDASD’),(‘SAD’,’SADAS’)</p><h2 id="sql语句顺序"><a href="#sql语句顺序" class="headerlink" title="sql语句顺序"></a>sql语句顺序</h2><p>select, from, where, group by, having, order by, limit</p><p>where增加分组前的限定，having增加分组后的限定</p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>UNION 语句：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）</p><p>UNION ALL 语句：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）</p><pre><code>SELECT 列名称 FROM 表名称 UNION SELECT 列名称 FROM 表名称 ORDER BY 列名称；SELECT 列名称 FROM 表名称 UNION ALL SELECT 列名称 FROM 表名称 ORDER BY 列名称；</code></pre><h2 id="排序order-by"><a href="#排序order-by" class="headerlink" title="排序order by"></a>排序order by</h2><p>默认是asc</p><p>如果字符集采用的是 gbk(汉字编码字符集)，直接在查询语句后边添加 ORDER BY：</p><pre><code>SELECT * FROM runoob_tblORDER BY runoob_title asc;</code></pre><p>如果字符集采用的是 utf8(万国码)，需要先对字段进行转码然后排序：</p><pre><code>SELECT * FROM runoob_tblORDER BY CONVERT(runoob_title using gbk) desc;</code></pre><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>GROUP BY 语句根据一个或多个列对结果集进行分组。</p><p>在分组的列上我们可以使用 COUNT, SUM, AVG,等函数。</p><p>1.group by 可以实现一个最简单的去重查询，假设想看下有哪些员工，除了用 distinct,还可以用：</p><pre><code>SELECT name FROM employee_tbl GROUP BY name;</code></pre><p>2.分组后的条件使用 HAVING 来限定，WHERE 是对原始数据进行条件限制。几个关键字的使用顺序为 where 、group by 、having、order by ，例如：</p><pre><code>SELECT coalesce(name, &#39;总数&#39;)as name1 ,sum(singin) as sum1 FROM employee_tbl GROUP BY name having sum1&gt;5 order by sum1 desc;</code></pre><p>其中coalesce(a,b,c)用来设置一个可以取代 NUll 的名称：如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（没意义）。</p><h2 id="join–Mysql连接的使用"><a href="#join–Mysql连接的使用" class="headerlink" title="join–Mysql连接的使用"></a>join–Mysql连接的使用</h2><p>之前都是在一张表中读取数据，但是在真正的应用中经常需要从多个数据表中读取数据， JOIN就是在两个或多个表中查询数据。</p><p>JOIN 按照功能大致分为如下三类：</p><p>INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。省略 INNER 使用 JOIN，效果一样</p><p>LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。</p><p>RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</p><h3 id="SQL联合查询-主表与子表联合查询-–left-join-on"><a href="#SQL联合查询-主表与子表联合查询-–left-join-on" class="headerlink" title="SQL联合查询(主表与子表联合查询)–left join on"></a>SQL联合查询(主表与子表联合查询)–left join on</h3><pre><code>SELECT A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B ON A.COMMAND_ID=B.COMMAND_ID WHERE A.COMMAND_ID=&#39;查看&#39;;</code></pre><p>1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</p><p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p><p>这个问题请看这个<a href="https://blog.csdn.net/weixin_36174051/article/details/80377061" target="_blank" rel="noopener">LEFT JOIN 使用时的注意事项</a>、<a href="https://blog.csdn.net/xingfeng0501/article/details/7816703" target="_blank" rel="noopener">left join on and 与 left join on where的区别</a></p><h3 id="inner-join-与-left-join-之间的区别"><a href="#inner-join-与-left-join-之间的区别" class="headerlink" title="inner join 与 left join 之间的区别"></a>inner join 与 left join 之间的区别</h3><p>来源: <a href="https://www.cnblogs.com/assasion/p/7768931.html" target="_blank" rel="noopener">inner join 与 left join 之间的区别</a></p><p>left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 </p><p>right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录</p><p>inner join(等值连接) 只返回两个表中联结字段相等的行</p><p>下面的这条语句是：根据seckillId查询SuccessKilled实体(也携带Seckill秒杀商品对象实体)，即查询的同时也为SuccessKilled中属性为Seckill的实体对象赋值</p><pre><code class="sql">&lt;!--mybatis把结果映射到SuccessKilled，同时映射属性seckill属性--&gt;SELECT  sk.seckillId,  sk.user_phone,  sk.state,  sk.create_time,  s.seckillId &quot;seckill.seckill_id&quot;,  s.name &quot;seckill.name&quot;,  s.number &quot;seckill.number&quot;,  s.start_time &quot;seckill.start_time&quot;,  s.end_time &quot;seckill.end_time&quot;,  s.create_time &quot;seckill.create_time&quot;FROM success_killed sk INNER JOIN seckill sON sk.seckill_id = s.seckill_idWHERE sk.seckillId = #{seckillId}</code></pre><h2 id="MySQL-NULL-值处理"><a href="#MySQL-NULL-值处理" class="headerlink" title="MySQL NULL 值处理"></a>MySQL NULL 值处理</h2><p>不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。</p><p>IS NULL: 当列的值是 NULL,此运算符返回 true。</p><p><code>select a2 is null from aaa where a1=&#39;a&#39;;</code></p><p><code>SELECT * FROM runoob_test_tbl WHERE runoob_count IS NULL;</code></p><p>IS NOT NULL: 当列的值不为 NULL, 运算符返回 true。</p><p>&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为 NULL 时返回 true。</p><h2 id="like-与-正则表达式"><a href="#like-与-正则表达式" class="headerlink" title="like 与 正则表达式"></a>like 与 正则表达式</h2><p>e.g.</p><p><code>like &#39;%a$&#39;</code>、<code>like &#39;a_.{0,2}&#39;</code></p><h2 id="ALTER命令"><a href="#ALTER命令" class="headerlink" title="ALTER命令"></a>ALTER命令</h2><p>当我们需要修改数据表名或者修改数据表字段时，就需要使用到MySQL ALTER命令。</p><p>1.修改表名:</p><pre><code>ALTER TABLE testalter_tbl RENAME TO alter_tbl;</code></pre><p>2.删除，添加或修改表字段:</p><pre><code>ALTER TABLE testalter_tbl ADD i INT;//添加列i到数据表字段的末尾。ALTER TABLE testalter_tbl DROP i;//删除表中名i的列ALTER TABLE testalter_tbl ADD i INT FIRST;//添加第一列名iALTER TABLE testalter_tbl DROP i;//删除表中名i的列ALTER TABLE testalter_tbl ADD i INT AFTER c;//在列c后添加列名i</code></pre><p>使用MySQL提供的关键字 FIRST (设定位第一列)， AFTER 字段名（设定位于某个字段之后）。</p><p>3.修改字段类型及名称</p><pre><code>ALTER TABLE testalter_tbl CHANGE i j BIGINT;</code></pre><h2 id="MySQL-复制表"><a href="#MySQL-复制表" class="headerlink" title="MySQL 复制表"></a>MySQL 复制表</h2><p>完整的复制MySQL数据表，步骤如下：</p><p>1.使用 SHOW CREATE TABLE 命令获取创建数据表(CREATE TABLE) 语句，该语句包含了原数据表的结构，索引等。</p><pre><code>mysql&gt; SHOW CREATE TABLE runoob_tbl \G;*************************** 1. row ***************************       Table: runoob_tblCreate Table: CREATE TABLE `runoob_tbl` (  `runoob_id` int(11) NOT NULL auto_increment,  `runoob_title` varchar(100) NOT NULL default &#39;&#39;,  `runoob_author` varchar(40) NOT NULL default &#39;&#39;,  `submission_date` date default NULL,  PRIMARY KEY  (`runoob_id`),  UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)) ENGINE=InnoDB 1 row in set (0.00 sec)ERROR:No query specified</code></pre><p>2.复制以下命令显示的SQL语句，修改数据表名，并执行SQL语句，通过以上命令 将完全的复制数据表结构。</p><pre><code>CREATE TABLE `clone_tbl` (  -&gt; `runoob_id` int(11) NOT NULL auto_increment,  -&gt; `runoob_title` varchar(100) NOT NULL default &#39;&#39;,  -&gt; `runoob_author` varchar(40) NOT NULL default &#39;&#39;,  -&gt; `submission_date` date default NULL,  -&gt; PRIMARY KEY  (`runoob_id`),  -&gt; UNIQUE KEY `AUTHOR_INDEX` (`runoob_author`)-&gt; ) ENGINE=InnoDB;Query OK, 0 rows affected (1.80 sec)</code></pre><p>3.如果你想复制表的内容，你就可以使用 INSERT INTO … SELECT 语句来实现。</p><pre><code>INSERT INTO clone_tbl (runoob_id,-&gt;                     runoob_title,-&gt;                     runoob_author,-&gt;                     submission_date)    -&gt; SELECT runoob_id,runoob_title,    -&gt;        runoob_author,submission_date    -&gt; FROM runoob_tbl;Query OK, 3 rows affected (0.07 sec)Records: 3  Duplicates: 0  Warnings: 0</code></pre><h2 id="mysql获取元数据"><a href="#mysql获取元数据" class="headerlink" title="mysql获取元数据"></a>mysql获取元数据</h2><p>1.使用 SHOW TABLES 或 SHOW DATABASES 语句来获取数据库和数据表列表</p><p>2.获取服务器元数据：</p><pre><code>SELECT VERSION( )    服务器版本信息SELECT DATABASE( )    当前数据库名 (或者返回空)SELECT USER( )    当前用户名SHOW STATUS    服务器状态SHOW VARIABLES    服务器配置变量</code></pre><h2 id="AUTO-INCREMENT–MySQL-序列相关"><a href="#AUTO-INCREMENT–MySQL-序列相关" class="headerlink" title="AUTO_INCREMENT–MySQL 序列相关"></a>AUTO_INCREMENT–MySQL 序列相关</h2><p><a href="http://www.runoob.com/mysql/mysql-using-sequences.html" target="_blank" rel="noopener">MySQL 序列-菜鸟教程</a></p><h2 id="MySQL-处理重复数据"><a href="#MySQL-处理重复数据" class="headerlink" title="MySQL 处理重复数据"></a>MySQL 处理重复数据</h2><p><a href="http://www.runoob.com/mysql/mysql-handling-duplicates.html" target="_blank" rel="noopener">MySQL 处理重复数据-菜鸟教程</a></p><p>统计表中 first_name 和 last_name的重复记录数:</p><pre><code>SELECT COUNT(*) as repetitions, last_name, first_nameFROM person_tblGROUP BY last_name, first_nameHAVING repetitions &gt; 1;</code></pre><p>过滤重复数据:</p><pre><code>SELECT DISTINCT last_name, first_nameFROM person_tbl;也可以使用 GROUP BY 来读取数据表中不重复的数据：SELECT last_name, first_nameFROM person_tblGROUP BY (last_name, first_name);</code></pre><p>删除重复数据:</p><p>1:</p><pre><code>mysql&gt; CREATE TABLE tmp SELECT last_name, first_name, sex FROM person_tbl  GROUP BY (last_name, first_name, sex);mysql&gt; DROP TABLE person_tbl;mysql&gt; ALTER TABLE tmp RENAME TO person_tbl;</code></pre><p>2:也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录</p><pre><code>mysql&gt; ALTER IGNORE TABLE person_tbl-&gt; ADD PRIMARY KEY (last_name, first_name);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习概念入门</title>
      <link href="/2018/03/21/deep-learning/"/>
      <url>/2018/03/21/deep-learning/</url>
      
        <content type="html"><![CDATA[<p>研究生是cv方向，也发了一篇四区sci，工作后计划不在此方向发展，但如果今后需要用到，还是要尽快拾起来。此文档记录机器学习、深度学习、增强学习概念入门</p><a id="more"></a><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>有监督学习：监督式学习的常见应用场景如分类问题和回归问题。常见监督式学习算法有决策树（ID3，C4.5算法等），朴素贝叶斯分类器，最小二乘法，逻辑回归（Logistic Regression），支持向量机（SVM），K最近邻算法（KNN，K-NearestNeighbor），线性回归（LR，Linear Regreesion），人工神经网络（ANN，Artificial Neural Network），集成学习以及反向传递神经网络（Back Propagation Neural Network）等等。</p><p>非监督学习（Unsupervised Learing）是另一种研究的比较多的学习方法，它与监督学习的不同之处，在于我们事先没有任何训练样本，而需要直接对数据进行建模。是否有监督（Supervised），就看输入数据是否有标签（Label）。输入数据有标签（即数据有标识分类），则为有监督学习，没标签则为无监督学习（非监督学习）。在很多实际应用中，并没有大量的标识数据进行使用，并且标识数据需要大量的人工工作量，非常困难。我们就需要非监督学习根据数据的相似度，特征及相关联系进行模糊判断分类。</p><p>半监督学习：应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，这些算法首先试图对未标识数据进行建模，在此基础上再对标识的数据进行预测。如自训练算法(self-training)、多视角算法(Multi-View)、生成模型（Enerative Models）、图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM）等。</p><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。 而强化学习更多的应用在机器人控制及其他需要进行系统控制的领域。</p><p>强化学习（Reinforcement Learning）也叫再励学习、评价学习，在智能控制和机器人领域有许多应用。输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式。在强化学习下，输入数据直接反馈到模型，模型必须对此立刻作出调整。常见算法包括 Q-Learning、TD 算法（时间差分学习，Temporal Difference）、SARSA 算法。</p><p>强化学习灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、模拟优化方法、多主体系统学习、群体智能、统计学以及遗传算法。 它的本质就是解决“决策（decision making）”问题，即学会自动进行决策。它在没有任何label告诉算法应该怎么做的情况下，通过先尝试做出一些行为——然后得到一个结果，通过判断这个结果是对还是错来对之前的行为进行反馈。由这个反馈来调整之前的行为，通过不断的调整算法能够学习到在什么样的情况下选择什么样的行为可以得到最好的结果。</p><p>重点：强化学习其实就是自动进行决策，并且可以做连续决策。强化学习有很多应用，比如自动直升机，机器人控制，市场决策，工业控制，无人驾驶，AlphaGo，玩游戏，还在制造业、库存处理、电商、广告、推荐、金融、医疗等与我们生活息息相关的领域也有应用。例如一家日本公司 Fanuc，工厂机器人在拿起一个物体时，会捕捉这个过程的视频，记住它每次操作的行动，操作成功还是失败了，积累经验，下一次可以更快更准地采取行动。</p><p>举个例子：在向用户推荐新闻文章的任务中，非监督式会找到用户先前已经阅读过类似的文章并向他们推荐其一，而强化学习将通过向用户先推荐少量的新闻，并不断获得来自用户的反馈，最后构建用户可能会喜欢的文章的“知识图”。</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>深度学习（Deep Learning）是机器学习的一种，是它的一个大的分支，深度学习的概念由Hinton等人于2006年提出，深度学习的概念源于人工神经网络的研究。</p><p>深度学习实际上指的的深度神经网络学习，普通神经网络由于训练代价较高，一般只有3-4层，而深度神经网络由于采用了特殊的训练方法加上一些技术算法，可以达到8-10层。深度神经网络能够捕捉到数据中的深层联系，从而能够得到更精准的模型，而这些联系不容易被普通的机器学习方法所发觉。</p><p>用官方的含义就是：含多隐层的多层感知器就是一种深度学习结构。</p><p>深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示</p><p>同机器学习方法一样，深度机器学习方法也有监督学习与无监督学习之分。不同的学习框架下建立的学习模型很是不同。</p><p>例如，卷积神经网络（Convolutional neural networks，简称CNNs）就是一种深度的监督学习下的机器学习模型，而深度置信网（Deep Belief Nets，简称DBNs）就是一种无监督学习下的机器学习模型。</p><p>深度学习整个过程就是数据收集、数据清洗处理、传入数据进行训练模型和学习优化、经过不断优化调节后形成高准确率的识别分类模型，供相应的领域进行传入相关数据进行应用分类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>机器学习和深度学习的核心就是数据、算法（模型函数）、算力（计算机运算能力）。</p><p>我们研究的核心就是算法，也就是针对某一应用需求场景，选择各种合适的函数公式进行构建和叠加形成一个处理数据的模型（也就是常说的训练数据模型）。</p><p>这个模型的作用是什么？就是能够将我们的普通数据输入进去，经过这个模型处理后，输出数据或者一个结果，这个输出的就是供我们参考或者使用的。</p><p>那我们怎么评判这个模型的好坏？例如每年 ImageNet 都会进行比赛，那么评判的结果就是你这个模型算法进行数据分析和处理的准确度。例如人脸识别，有的算法识别率 80%，有的达到 98%。那么这个高识别率的模型算法就要好一些。我们需要改进的也就是这个模型算法（也就是调优），其中就会涉及到权重（Weight）和损失函数（Loss）。当然损失函数越低说明我们的算法处理数据越接近最佳结果。</p><h2 id="再举个例子"><a href="#再举个例子" class="headerlink" title="再举个例子"></a>再举个例子</h2><p>我们进行预测某天天气的状况，这是一个需求。</p><p>某天天气的状况，会受到很多因素的影响，例如季节、地理位置、时间、人为因素等等，这些因素可能会有几十个。在深度学习模型里，这些影响结果的因素我们称之为特征。我们可以通过一些有标签的天气数据去输入到我们的模型里，不断的给各个特征设置权重、损失函数，不断的进行调优。最后形成能够很好的准确预测天气的一个模型。</p><p>我们在进行机器学习和深度学习的核心，就是在算法这块，也就是设计处理问题（数据）的模型。模型需要针对不同的问题和需求进行合理的选择或者搭配。会涉及到很多数学公式和函数。其实这些数学函数在一些框架里已经囊括了，如tensorflow，python 的 numpy 库。我们需要的就是通过训练数据进行模型测试训练，调优，再应用。</p><p>先有需求和目的：这个模型是干嘛的，处理什么问题的。输入的数据什么样的，想要有什么输出结果才是最好的，能够达到我们想要的目的的。是数据和需求驱动我们选择什么样的模型和函数算法。确定了大概的方案模型和算法函数，我们就要给模型不断的喂数据进行调整优化，使他能够输出更加准确的数据处理结果，也就是常说的训练模型。当模型通过数据训练好了后，我们就可以进行应用了，喂给它真实的数据进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm框架的问题汇总</title>
      <link href="/2018/03/21/java-ssm-error-summary/"/>
      <url>/2018/03/21/java-ssm-error-summary/</url>
      
        <content type="html"><![CDATA[<p>此文档为maven组建ssm框架的问题汇总</p><a id="more"></a><h2 id="创建表sql语句导入数据库时报错-Invalid-default-value-for-“字段名”"><a href="#创建表sql语句导入数据库时报错-Invalid-default-value-for-“字段名”" class="headerlink" title="创建表sql语句导入数据库时报错 Invalid default value for “字段名”"></a>创建表sql语句导入数据库时报错 Invalid default value for “字段名”</h2><p><a href="https://blog.csdn.net/qq_26245325/article/details/78916363" target="_blank" rel="noopener">Mysql ERROR 1067: Invalid default value for 字段</a></p><h2 id="编码问题导致jdbc查询数据库查询不到值"><a href="#编码问题导致jdbc查询数据库查询不到值" class="headerlink" title="编码问题导致jdbc查询数据库查询不到值"></a>编码问题导致jdbc查询数据库查询不到值</h2><p>问题：编码问题导致jdbc查询数据库查询不到值。</p><p>解决：在jdbc的数据库连接地址后面加<br>?useUnicode=true&amp;characterEncoding=UTF-8，否则查询不到，编码问题。</p><pre><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//下面一定要再jdbc的数据库连接地址后面加?useUnicode=true&amp;characterEncoding=UTF-8，否则查询不到，编码问题Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/micro_message?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);</code></pre><h2 id="Idea-重命名或复制一个项目"><a href="#Idea-重命名或复制一个项目" class="headerlink" title="Idea 重命名或复制一个项目"></a>Idea 重命名或复制一个项目</h2><p>目前找到的最好的方法：</p><p>一、重命名一个项目</p><p>在Idea 项目关闭状态下，在Finder里重命名文件夹，并删除.idea 文件夹下的 workspace.xml (此文件不删的话有些项目配置会有问题)。<br>Idea 菜单 File - Open… 打开重命名后的项目，在Project Structure中设置如下：</p><p>如果是Web 项目，需要重命名模块module name；</p><p>重命名项目名Project Name(这个不改也没什么影响)；</p><p>在artifact中删掉错的，再添加正确的artifact，见下图；</p><p><img src="https://img.braincao.cn/blogimg/1583753868.png" alt="1583753868"></p><p>大功告成，配置Tomcat即可。</p><h2 id="复制整个项目"><a href="#复制整个项目" class="headerlink" title="复制整个项目"></a>复制整个项目</h2><p>复制之前可先删除target 文件夹，里面是项目编译后的文件(每次启动Tomcat 都会生成)，其中的jar 包体积较大。</p><p>在Finder直接复制整个项目文件夹，可直接粘贴在同一个项目目录，修改项目文件夹名称即可；当然也可复制到另一个项目目录。<br>删除.idea 文件夹下的 workspace.xml (此文件不删的话有些项目配置会有问题)。<br>(与上面重命名项目的第2步完全一样) 菜单 File - Open… 打开复制出来的项目文件夹(图同上)，如果是Web 项目，需要重命名模块，操作是在项目名上shift+F6 (Rename Module)；菜单File - Project Structure - Project Name, 重命名项目(但不改好象也没什么影响)，图同上；并在 Project Structure 查看 artifact，删掉错的，再添加正确的artifact，图同上；然后再配置Tomcat 即可。</p><h2 id="重命名整个Idea-工作空间"><a href="#重命名整个Idea-工作空间" class="headerlink" title="重命名整个Idea 工作空间"></a>重命名整个Idea 工作空间</h2><p>如果Idea 工作空间文件夹含空格，可能导致某些程序错误，比如用this.getClass().getResource(“/“).getPath() 得到的路径，空格会被自动转换成”20%”，再使用这个路径就找不到了。所以可以将整个Idea 工作空间重命名，然后直接打开里面的项目的话，Maven 报错无法载入，这个还是workspace.xml 的问题，所以要把整个Idea 工作空间内的workspace.xml 都删了，再打开项目。</p><h2 id="获取包路径下的xml文件，Could-not-find-resource-com-xml"><a href="#获取包路径下的xml文件，Could-not-find-resource-com-xml" class="headerlink" title="获取包路径下的xml文件，Could not find resource com/*/.xml"></a>获取包路径下的xml文件，Could not find resource com/<em>*/</em>.xml</h2><p>问题：在eclipse中，把资源文件放在src文件夹下，是可以找到的；<br>但是在idea中，直接把资源文件放在src文件夹下，如果不进行设置，是不能被找到的。例如使用Mybatis，mapper文件都是放在包路径下，和实体一个层级，使用IDEA时就会报错</p><p>解决：配置maven的pom文件配置，在pom文件中找到节点，添加下列代码：</p><pre><code class="html">&lt;build&gt;      &lt;resources&gt;          &lt;resource&gt;              &lt;directory&gt;src/main/java&lt;/directory&gt;              &lt;includes&gt;                  &lt;include&gt;**/*.xml&lt;/include&gt;              &lt;/includes&gt;          &lt;/resource&gt;      &lt;/resources&gt;  &lt;/build&gt; </code></pre><p>*/.xml是通配符，匹配src/main/java目录下所有的xml文件，将其映射为资源文件，这样，IDEA就会加载该xml文件。</p><h2 id="log4j-properties找不到"><a href="#log4j-properties找不到" class="headerlink" title="log4j.properties找不到"></a>log4j.properties找不到</h2><p>问题：No appenders could be found for logger (org.apache.ibatis.logging.LogFactory).</p><ul><li><p>如果不是web项目，有main函数的那种，则：</p><p>  1、在main函数中加入<code>BasicConfigurator.configure();</code></p><p>  2、把log4j.properties放在src目录下，这样才能被找到</p></li><li><p>如果是有web的那种正常项目，一下两步解决：</p><p>  1、将写好的log4j.properties放在WEB-INF目录下(如/WEB-INF/class/log4j.properties)</p><p>  2、在web.xml中加入下面的配置：        </p></li></ul><pre><code class="html">&lt;!--以下两个是log4j的配置相关--&gt;&lt;context-param&gt;&lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;&lt;param-value&gt;/WEB-INF/class/log4j.properties&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;&lt;listener-class&gt;  org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><h2 id="Bootstrap-模态框（Modal）带参数传值实例"><a href="#Bootstrap-模态框（Modal）带参数传值实例" class="headerlink" title="Bootstrap 模态框（Modal）带参数传值实例"></a>Bootstrap 模态框（Modal）带参数传值实例</h2><p>来自：<a href="https://blog.csdn.net/linhaiyun_ytdx/article/details/77417702" target="_blank" rel="noopener">Bootstrap 模态框（Modal）带参数传值实例</a>，完美的解决了我的问题hiahia</p><p>模态框（Modal）是覆盖在父窗体上的子窗体。通常，目的是显示来自一个单独的源的内容，可以在不离开父窗体的情况下有一些互动。子窗体可提供信息、交互等。</p><pre><code>为了实现父窗体与其的交互，通常需要向其传值，实现带参数的传递，查看数据的唯一性。例如下面窗体：点击任意一个模态框（&quot;回复&quot;按钮）,如果不做任何处理，则会出现回复混淆，甚至程序出错的情况。</code></pre><p><img src="https://img.braincao.cn/blogimg/1583753886.png" alt="1583753886"></p><p>为了实现其回复的唯一性和带参传值的功能，需要做以下处理<br><img src="https://img.braincao.cn/blogimg/1583753904.png" alt="1583753904"><br><img src="https://img.braincao.cn/blogimg/1583753912.png" alt="1583753912"><br><img src="https://img.braincao.cn/blogimg/1583753918.png" alt="1583753918"></p><p>实现的效果：</p><p><img src="https://img.braincao.cn/blogimg/1583753951.png" alt="1583753951"></p><p>我的示例如下：</p><h2 id="启动tomcat时发现占用端口"><a href="#启动tomcat时发现占用端口" class="headerlink" title="启动tomcat时发现占用端口"></a>启动tomcat时发现占用端口</h2><p>mac上终端操作：</p><p>第一步：使用lsof -i tcp:1099 查看时那个应用占用了1099端口(换成你想找的端口)</p><p>第二部：使用kill pid 即可，这里的pid是第一步所查询到结果</p><h2 id="tomcat终端关闭-shutdown-sh时报错"><a href="#tomcat终端关闭-shutdown-sh时报错" class="headerlink" title="tomcat终端关闭./shutdown.sh时报错"></a>tomcat终端关闭./shutdown.sh时报错</h2><p>问题报错：Could not contact localhost:8005. Tomcat may not be running.</p><p>直接重装tomcat</p><h2 id="bootstrap-使用-glyphicon图标不显示"><a href="#bootstrap-使用-glyphicon图标不显示" class="headerlink" title="bootstrap 使用 glyphicon图标不显示"></a>bootstrap 使用 glyphicon图标不显示</h2><p>来源 <a href="http://www.runoob.com/bootstrap/bootstrap-glyphicons.html" target="_blank" rel="noopener">Bootstrap 字体图标(Glyphicons)</a></p><p>解决：引入cdn的bootstrap、jquery即可</p><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;  &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="使用jQuery-cookie插件获取cookie值失败"><a href="#使用jQuery-cookie插件获取cookie值失败" class="headerlink" title="使用jQuery cookie插件获取cookie值失败"></a>使用jQuery cookie插件获取cookie值失败</h2><p>问题：js中<code>var killPhone = $.cookie(&quot;killPhone&quot;);</code>取不到值，原来是 <code>$.cookie is not a function</code>就是说</p><p>解决：出现这种问题有3中可能</p><p>1是没有导入cookie相关的库文件</p><p>2是cookie的库文件和jquery库文件的先后顺序问题， 必须先导入jquery库文件后到其他库文件 </p><p>3一个页面由于二次或多次引入了jquery插件导致。</p><p>我们问题原因是手残导入2次jquery库文件，orz。。。</p><h2 id="JS-监听回车事件"><a href="#JS-监听回车事件" class="headerlink" title="JS 监听回车事件"></a>JS 监听回车事件</h2><pre><code>//监听回车事件document.onkeydown = function(e){    if(e.keyCode === 13){        $(&quot;#killPhoneButton&quot;).click();    }};</code></pre><h2 id="one代替cilck"><a href="#one代替cilck" class="headerlink" title="one代替cilck"></a>one代替cilck</h2><p>用one绑定而不是click的好处就是：只绑定一次点击事件。防止一个用户不停的点秒杀，都发送服务端造成崩溃</p><pre><code>$    (&quot;#killBtn&quot;).one(&quot;click&quot;,function(){});</code></pre><h2 id="modal中的input输入框自动获取焦点"><a href="#modal中的input输入框自动获取焦点" class="headerlink" title="modal中的input输入框自动获取焦点"></a>modal中的input输入框自动获取焦点</h2><p>解决：在jsp中的input属性中加入autofocus即可</p><pre><code class="html">&lt;input type=&quot;text&quot;  name=&quot;killPhone&quot; autofocus class=&quot;form-control&quot; id=&quot;killPhoneKey&quot; placeholder=&quot;填手机号&quot;/&gt;</code></pre><h2 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h2><p>命令sudo lsof -i tcp:port（port替换成端口号，比如6379）可以查看该端口被什么程序占用，并显示PID，方便KILL</p><p>e.g. </p><p><code>sudo lsof -i tcp:80</code></p><h2 id="查看进程监听的端口号"><a href="#查看进程监听的端口号" class="headerlink" title="查看进程监听的端口号"></a>查看进程监听的端口号</h2><p>linux：sudo netstat -ltnp |grep xxx</p><p>mac:</p><pre><code>sudo lsof -i -n -P | grep 45046  (所查询的进程pid是45046)sudo lsof -i -n -P | grep memcached  (所查询的进程名是memcached)</code></pre><p>-i:列出符合条件的进程<br>-P 表示不显示端口俗称，直接显示端口号http-&gt;80<br>不加 sudo 只能查看以当前用户运行的程序，所以必须加</p><h2 id="mac启动php-fpm"><a href="#mac启动php-fpm" class="headerlink" title="mac启动php-fpm"></a>mac启动php-fpm</h2><p><code>sudo php-fpm -D</code></p><p>4.mac终端执行php脚本</p><p><code>php test.php</code></p><h2 id="phpinfo怎么用"><a href="#phpinfo怎么用" class="headerlink" title="phpinfo怎么用"></a>phpinfo怎么用</h2><p><code>php -r &#39;phpinfo();’即可</code></p><p>或者启动apache，在apache目录中建一个info.php页面</p><pre><code>&lt;?php    phpinfo();?&gt;</code></pre><p>然后浏览器输入localhost/info.php即可</p><p>另外 php -m可以看到php相关扩展</p><h2 id="php-fpm启动，重启，终止操作"><a href="#php-fpm启动，重启，终止操作" class="headerlink" title="php-fpm启动，重启，终止操作"></a>php-fpm启动，重启，终止操作</h2><p>php 5.3.3 以后的php-fpm 不再支持 php-fpm 以前具有的 /usr/local/php/sbin/php-fpm (start|stop|reload)等命令，所以不要再看这种老掉牙的命令了，需要使用信号控制：</p><p>master进程可以理解以下信号</p><p>INT, TERM 立刻终止<br>QUIT 平滑终止<br>USR1 重新打开日志文件<br>USR2 平滑重载所有worker进程并重新载入配置和二进制模块</p><p>1.启动php-fpm:</p><p><code>/usr/local/opt/php@7.2/sbin//php-fpm</code></p><p>2.重启、关闭</p><p>来源:<a href="http://www.4wei.cn/archives/1002061" target="_blank" rel="noopener">php-fpm - 启动参数及重要配置详解</a></p><p>方法一：</p><p>先查看ps aux | grep php-fpm看master进程号，即root用户下的进程号</p><p>kill -USR2 pid即可</p><p>方法二：</p><p>上面方案一般是没有生成php-fpm.pid文件时使用，如果要生成php-fpm.pid，使用下面这种方案：</p><p>上面master进程可以看到，matster使用的是/usr/local/php/etc/php-fpm.conf这个配置文件，cat /usr/local/php/etc/php-fpm.conf 发现：</p><pre><code>[global]; Pid file; Note: the default prefix is /usr/local/php/var; Default Value: none;pid = run/php-fpm.pid</code></pre><p>pid文件路径应该位于/usr/local/var/run/php-fpm.pid,由于注释掉，所以没有生成，我们把注释去除，再kill -USR2 42891 重启php-fpm,便会生成pid文件，下次就可以使用以下命令重启,关闭php-fpm了：</p><pre><code>php-fpm 关闭：kill -INT &#39;cat /usr/local/var/run/php-fpm.pid&#39;php-fpm 重启：kill -USR2 &#39;cat /usr/local/var/run/php-fpm.pid&#39;</code></pre><p>daemon进程kill不掉不断重启的解决方法：</p><p>1./Library/LaunchDaemons/中删除<a href="mailto:homebrew.mxcl.php@7.2.plist">homebrew.mxcl.php@7.2.plist</a>文件，这个是mac下的自启文件，删了就不会自启了</p><p>2.把<a href="http://www.conf中的www换成xxx都可以。原因是www.conf头部定义了新建一个线程池www，如果user/group也是www的话那就在www下正常运行，但是这样就没法在braincao下甚至root下kill进程了，因此需要把user/group设置为不是www的，这样启动php-fpm就会忽略user/group，也就不会在www下启动而是在briancao下启动，这样就能kill进程了" target="_blank" rel="noopener">www.conf中的www换成xxx都可以。原因是www.conf头部定义了新建一个线程池www，如果user/group也是www的话那就在www下正常运行，但是这样就没法在braincao下甚至root下kill进程了，因此需要把user/group设置为不是www的，这样启动php-fpm就会忽略user/group，也就不会在www下启动而是在briancao下启动，这样就能kill进程了</a></p><pre><code>;user = www;group = wwwuser = root  (braincao或xxx都可以)group = root  (braincao或xxx都可以)</code></pre><p>3.设置完后就可以正常的像启动、重启kill -usr2 pid、关闭kill -int pid了，注意pid是最小的那个pid。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm框架的问题汇总</title>
      <link href="/2018/03/21/mac-tricks/"/>
      <url>/2018/03/21/mac-tricks/</url>
      
        <content type="html"><![CDATA[<p>此文档记录mac一些操作技巧，提升开发效率</p><a id="more"></a><h2 id="mac系统的权限问题"><a href="#mac系统的权限问题" class="headerlink" title="mac系统的权限问题"></a>mac系统的权限问题</h2><p>遇到MacOS sierra系统的/usr下各种root操作出现“Operation not permitted”的问题，关闭 Rootless即可。重启按住 Command+R，进入恢复模式，打开Terminal:</p><p><code>csrutil disable</code></p><p>重启即可。如果要恢复默认：</p><p><code>csrutil enable</code></p><h2 id="mac用户组"><a href="#mac用户组" class="headerlink" title="mac用户组"></a>mac用户组</h2><p>OS X 内置会有staff wheel admin这三种常见的用户组，分别介绍一下</p><ol><li><p>staff : 所有创建用户都会属于这个用户组，提供最基本的对该用户目录~/<em>(/User/</em>)的rwx权限，其他的一般只有r或者rx权限。比如我建立一个用户叫做lizhuoli，那么我会在一个staff组里面，对/User/lizhuoli/*有rwx权限。</p></li><li><p>admin :默认创建的所有用户也会属于这个admin用户组，在它里面的用户可以通过 <code>su</code> 或者 <code>sudo</code> 切换到root用户，只要执行以后输入这个用户的密码即可，而不需要知道root密码。</p></li><li><p>wheel :唯一只拥有一个用户root，意思是root用户的专属用户组。</p></li></ol><p>结论</p><p>苹果新系统的Rootless防止用户误操作，或者防止一些软件能直接获取到root权限对系统造成危害。</p><p>说白了就是不想让用户去碰涉及系统内核的一些东西。把用户当傻子培养是苹果一贯策略。</p><p>sudo和su到root权限都不能对一些文件造成更改了。</p><p>想更改也很简单。重启，开机按住cmd+r，进入恢复模式的终端。然后使用命令csrutil disable关闭rootless</p><p>不过这就多了一份被恶意软件攻击的潜在威胁，建议此时打开Mac App Store 和被认可的开发者或者纯粹的Mac App Store限制。</p><h2 id="不同用户组下的文件"><a href="#不同用户组下的文件" class="headerlink" title="不同用户组下的文件"></a>不同用户组下的文件</h2><ol><li><p>一个用户(user)对于一个文件有三种状态，可读(r)、可写(w)、可执行(x)，一个文件会有一个所属用户，所属用户组。还会有文件属主权限、同组用户权限、其他用户权限这三种标识符用来定义一个文件对一个用户的权限集合。</p></li><li><p>为了达到多个用户的权限管理，每个用户会在一个或者多个用户组(group)中，一个用户组可以有多个用户</p></li><li><p>root用户是一个特殊用户（超级用户），拥有对所有文件的rwx权限（可读可写可执行）</p></li><li><p>UNIX系统是纯粹基于文件的，换言之你的网络读取，驱动程序，分区表什么的其实都会以文件的形式存在</p></li></ol><h2 id="mac硬盘分区相关"><a href="#mac硬盘分区相关" class="headerlink" title="mac硬盘分区相关"></a>mac硬盘分区相关</h2><p>MS-DOS（FAT）格式，可以共同兼容Mac OS系统和Windows系统的读写，但单个文件不能大于4GB，适合在 Mac 和 PC 之间共享文件。</p><p>NTFS 格式，在 Mac 上只读——注意是只读。而且在 Mac 上也不能将硬盘格式化为 NTFS。但是在 MS-DOS(FAT) 式下无法存储的 &gt;4GB 的文件可以在此存储，适合存放高清电影和大型软件。 </p><p>exFAT文件系统也能共同兼容Mac OS系统和Windows系统，但是，exFAT作为FAT32的升级版，目前还不太稳定，如果文件系统不够稳定，就存在着分区表丢失，数据丢失等隐患，建议大家谨慎使用。</p><p>将一个硬盘分为3个分区，一个区专门做Time Machine的备份：格式是MAC OS（日志）；一个区做成与Windows系统兼容的MS-DOS(FAT)格式，方便倒存共享数据(但是由于经常数据大于4g所以我不用这个，我还是用ntfs，然后用第三方应用来读写即可，如paragon ntfs for mac)；最后一个区域是Mac专属的数据存放区域，存储我的图片和音乐、视频等Mac常用的重要数据：格式：MAC OS（日志）。</p><p>分区名：macTimeMachine、mac、win</p><h2 id="mac上所有python管理"><a href="#mac上所有python管理" class="headerlink" title="mac上所有python管理"></a>mac上所有python管理</h2><h3 id="1-几个目录"><a href="#1-几个目录" class="headerlink" title="1.几个目录"></a>1.几个目录</h3><table><thead><tr><th align="center">来源</th><th align="center">python安装路径</th></tr></thead><tbody><tr><td align="center">系统默认</td><td align="center">/System/Library/Frameworks/Python.framework/Versions/2.7</td></tr><tr><td align="center">brew安装</td><td align="center">/usr/local/Cellar</td></tr><tr><td align="center">anaconda</td><td align="center">/anaconda3/bin/</td></tr><tr><td align="center">官网pkg安装</td><td align="center">/Library/Frameworks/Python.framework/Versions/2.7</td></tr></tbody></table><h3 id="2-现存mac上的所有python及pip路径"><a href="#2-现存mac上的所有python及pip路径" class="headerlink" title="2.现存mac上的所有python及pip路径"></a>2.现存mac上的所有python及pip路径</h3><p><strong>python：</strong></p><p>/usr/bin下mac自带python: /usr/bin/python<br>/usr/bin下mac自带python2.7: /usr/bin/python2.7<br>/usr/local/bin下python3: /usr/local/bin/python3<br>/usr/local/bin下python3.6: /usr/local/bin/python3.6<br>conda下python3: /anaconda3/bin/python3<br>conda下python3.6: /anaconda3/bin/python3.6<br>conda下虚拟环境python2.7:  /anaconda3/envs/tensorflow11027/bin/<br>conda下虚拟环境python3.6: /anaconda3/envs/python3/bin/</p><p><strong>pip:(pip安装的包路径在相应目录下的lib/site-packages中)：</strong></p><p>/usr/local/bin下pip3: /usr/local/bin/pip3<br>/usr/local/bin下pip3.6: /usr/local/bin/pip3.6<br>conda下pip: /anaconda3/envs/tensorflow11027/bin/pip<br>conda下pip2: /anaconda3/envs/tensorflow11027/bin/pip2<br>conda下pip2.7: /anaconda3/envs/tensorflow11027/bin/pip2.7<br>conda下虚拟环境pip2:/anaconda3/envs/tensorflow11027/bin/pip2<br>conda下虚拟环境pip3:/anaconda3/envs/tensorflow11027/bin/pip</p><h3 id="3-以上这么多python版本和路径，用conda的虚拟环境进行2与3的切换"><a href="#3-以上这么多python版本和路径，用conda的虚拟环境进行2与3的切换" class="headerlink" title="3.以上这么多python版本和路径，用conda的虚拟环境进行2与3的切换"></a>3.以上这么多python版本和路径，用conda的虚拟环境进行2与3的切换</h3><p>这个问题即如何更改默认的Anaconda python环境？通过修改<del>/.bashrc或</del>/.bash_profile即可，只要把默认的python、pip路径设置好，版本也就定了，安装包的路径也就在相应的lib下，并且conda的虚拟环境也可以任意更改删除，便于管理。</p><pre><code>将默认的conda root环境# added by Anaconda3 5.1.0 installer#export PATH=&quot;/anaconda3/bin:$PATH&quot;更改为以conda创建的虚拟环境，这里创建的环境为基于python2.7的tensorflow11027# set python3 as defaultexport PATH=&quot;/anaconda3/envs/tensorflow11027/bin:$PATH&quot;更改之后pip也在相应的tensorflow11027环境中，pip安装包的路径也在这里，很好管理</code></pre><p>###4.pip包安装与卸载</p><pre><code>安装pycurl包pip install pycurl列出已经安装的python包pip list输出pycurl包的信息pip show pycurl卸载pycurl包pip uninstall pycurl更新过期的包：pip list --outdated     #列出所有过期的库pip install --upgrade 库名     #更新想要更新的包</code></pre><p>###5.pip安装使用国内源</p><p>通过几次ｐiｐ的使用，对于默认的pip源的速度实在无法忍受，于是便搜集了一些国内的pip源，如下：</p><pre><code>阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣 http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</code></pre><p>使用方法很简单，直接 -i 加 url 即可！如下：</p><pre><code>pip install web.py -i http://pypi.douban.com/simple如果有报错，请使用命令：pip install web.py -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</code></pre><p>如果想配置成默认的源，需要创建或修改配置文件（一般都是创建），linux的文件在~/.pip/pip.conf，修改内容为：</p><pre><code>[global]index-url = http://pypi.douban.com/simple[install]trusted-host=pypi.douban.com</code></pre>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用maven配置ssm框架</title>
      <link href="/2018/03/21/java-ssm-maven-build/"/>
      <url>/2018/03/21/java-ssm-maven-build/</url>
      
        <content type="html"><![CDATA[<p>此文档总结了在maven中组建ssm框架的相关配置</p><a id="more"></a><h2 id="0-创建好maven后首先需要改web-xml的表头"><a href="#0-创建好maven后首先需要改web-xml的表头" class="headerlink" title="0.创建好maven后首先需要改web.xml的表头"></a>0.创建好maven后首先需要改web.xml的表头</h2><pre><code class="html">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;         metadata-complete=&quot;true&quot;&gt;  &lt;!--注意这里要把maven新建项目时自动生成的web.xml头部替换成上面的头部，修改servlet版本，这里为3.1，这样就能自动支持spring EL--&gt;&lt;/web-app&gt;</code></pre><h2 id="0-5-maven目录结构"><a href="#0-5-maven目录结构" class="headerlink" title="0.5 maven目录结构"></a>0.5 maven目录结构</h2><pre><code class="html">src  main    java    resources    sql    webapps  test</code></pre><h2 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1.pom.xml"></a>1.pom.xml</h2><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.braincao&lt;/groupId&gt;  &lt;artifactId&gt;seckill&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;name&gt;seckill Maven Webapp&lt;/name&gt;  &lt;!-- FIXME change it to the project&#39;s website --&gt;  &lt;url&gt;http://www.example.com&lt;/url&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;    &lt;junit.version&gt;4.11&lt;/junit.version&gt;    &lt;slf4j-api.version&gt;1.7.12&lt;/slf4j-api.version&gt;    &lt;logback-core.version&gt;1.1.1&lt;/logback-core.version&gt;    &lt;mysql-connector-java.version&gt;5.1.35&lt;/mysql-connector-java.version&gt;    &lt;c3p0.version&gt;0.9.1.2&lt;/c3p0.version&gt;    &lt;mybatis.version&gt;3.3.0&lt;/mybatis.version&gt;    &lt;mybatis-spring.version&gt;1.2.3&lt;/mybatis-spring.version&gt;    &lt;standard.version&gt;1.1.2&lt;/standard.version&gt;    &lt;jstl.version&gt;1.2&lt;/jstl.version&gt;    &lt;jackson-databind.version&gt;2.5.4&lt;/jackson-databind.version&gt;    &lt;javax.servlet-api.version&gt;3.1.0&lt;/javax.servlet-api.version&gt;    &lt;spring-core.version&gt;4.1.7.RELEASE&lt;/spring-core.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;!-- 单元测试：使用junit4，支持注解 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;${junit.version}&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- 1.日志      java日志：slf4j,log4j,logback,common-logging      slf4j: 是规范/接口      日志实现：log4j,logback,common-logging      本案例使用：slf4j+logback --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;      &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;      &lt;version&gt;${slf4j-api.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-core&lt;/artifactId&gt;      &lt;version&gt;${logback-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--实现slf4j接口并整合--&gt;    &lt;dependency&gt;      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;      &lt;version&gt;${logback-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--2.数据库相关依赖--&gt;    &lt;!--mysql driver--&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;${mysql-connector-java.version}&lt;/version&gt;      &lt;scope&gt;runtime&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!--c3p0连接池--&gt;    &lt;dependency&gt;      &lt;groupId&gt;c3p0&lt;/groupId&gt;      &lt;artifactId&gt;c3p0&lt;/artifactId&gt;      &lt;version&gt;${c3p0.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--DAO框架:mybatis依赖--&gt;    &lt;!--mybatis--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;      &lt;version&gt;${mybatis.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--mybatis自身实现的spring整合依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;      &lt;version&gt;${mybatis-spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--3.Servlet web相关依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;taglibs&lt;/groupId&gt;      &lt;artifactId&gt;standard&lt;/artifactId&gt;      &lt;version&gt;${standard.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;jstl&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;${jstl.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;      &lt;version&gt;${jackson-databind.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;      &lt;version&gt;${javax.servlet-api.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--4.Spring依赖--&gt;    &lt;!--1)Spring核心依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--2)Spring dao层依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--3)Spring web依赖: Spring Web+Spring MVC--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--4)Spring test依赖--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;${spring-core.version}&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;seckill&lt;/finalName&gt;    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;      &lt;plugins&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;          &lt;version&gt;3.0.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;          &lt;version&gt;3.7.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;          &lt;version&gt;2.20.1&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;          &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;          &lt;version&gt;2.5.2&lt;/version&gt;        &lt;/plugin&gt;        &lt;plugin&gt;          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;          &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/plugin&gt;      &lt;/plugins&gt;    &lt;/pluginManagement&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><h2 id="2-mybatis-config-xml"><a href="#2-mybatis-config-xml" class="headerlink" title="2.mybatis-config.xml"></a>2.mybatis-config.xml</h2><p>表头可以在mybatis中文官网中找到</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!--配置全局属性--&gt;    &lt;settings&gt;        &lt;!--默认为false，设为true后我们使用jdbc的getGeneratedKeys可以获取数据库的自增主键值--&gt;        &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt;        &lt;!--默认为true，使用列别名替换列名            select name as title from table--&gt;        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;        &lt;!--开启驼峰命名转换:table(create_time) -&gt; entity(createTime)--&gt;        &lt;setting name=&quot;mapUnderscoreCamelCase&quot; value=&quot;true&quot;/&gt;    &lt;/settings&gt;    &lt;!--其他的mybatis配置如连接数据库等都在mybatis与spring整合中一起配置--&gt;&lt;/configuration&gt;</code></pre><h2 id="3-配置完mybatis-config后写mapper-xml"><a href="#3-配置完mybatis-config后写mapper-xml" class="headerlink" title="3.配置完mybatis-config后写mapper.xml"></a>3.配置完mybatis-config后写mapper.xml</h2><p>这里放3个示例mapper.xml，同样表头可以在mybatis中文官网示例中找到.</p><p>mapper.xml目的:为DAO接口方法提供sql语句配置</p><p>mapper.xml中参数多个的时候可以不写，dao层用的时候可以通过@param(“xxx”)来自动识别</p><p>mapper.xml中返回值如果是列表，写列表里面的类型即可</p><p>mapper.xml中类型不用写包名，配置时配置就行</p><![CDATA[<=]]><p>是XML转义用的</p><p>示例1：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.braincao.dao.SeckillDao&quot;&gt;    &lt;!--目的:为DAO接口方法提供sql语句配置--&gt;    &lt;!--参数多个的时候可以不写;返回值如果是列表，写列表里面的类型即可--&gt;    &lt;!--&lt;![CDATA[&lt;=]]&gt;是XML转义用的--&gt;    &lt;update id=&quot;reduceNumber&quot;&gt;        UPDATE          seckill        SET          number = number - 1        WHERE          seckill_id = #{seckillId}          and start_time &lt;![CDATA[&lt;=]]&gt; #{createTime}          and end_time &gt;= #{createTime}          and number &gt; 0    &lt;/update&gt;    &lt;select id=&quot;queryById&quot; parameterType=&quot;long&quot; resultType=&quot;Seckill&quot;&gt;        SELECT seckillId,name,number,start_time,end_time,create_time        FROM seckill        WHERE seckillId = #{seckillId}    &lt;/select&gt;    &lt;select id=&quot;queryAll&quot; resultType=&quot;Seckill&quot;&gt;        SELECT seckillId,name,number,start_time,end_time,create_time        FROM seckill        ORDER BY create_time DESC        limit #{offset}, #{limit}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>示例2：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.braincao.dao.SeckillDao&quot;&gt;    &lt;!--目的:为DAO接口方法提供sql语句配置--&gt;    &lt;!--参数多个的时候可以不写，dao层用的时候可以通过@param(&quot;xxx&quot;)来自动识别;返回值如果是列表，写列表里面的类型即可;类型不用写包名，配置时配置就行--&gt;    &lt;!--&lt;![CDATA[&lt;=]]&gt;是XML转义用的--&gt;    &lt;insert id=&quot;insertSuccessKilled&quot;&gt;        &lt;!--INSERT ignore INTO:主键冲突时不报错，而是返回0--&gt;        INSERT ignore INTO success_killed(seckill_id, user_phone)        VALUES (#{seckillId}, #{userPhone})    &lt;/insert&gt;    &lt;!--根据seckillId查询SuccessKilled实体(也携带Seckill秒杀商品对象实体)--&gt;    &lt;!--mybatis把结果映射到SuccessKilled，同时映射属性seckill属性--&gt;    &lt;!--由此可以看出，mybatis可以很自由的控制sql--&gt;    &lt;select id=&quot;queryByIdWithSeckill&quot; resultType=&quot;SuccessKilled&quot;&gt;        SELECT          sk.seckillId,          sk.user_phone,          sk.state,          sk.create_time,          s.seckillId &quot;seckill.seckill_id&quot;,          s.name &quot;seckill.name&quot;,          s.number &quot;seckill.number&quot;,          s.start_time &quot;seckill.start_time&quot;,          s.end_time &quot;seckill.end_time&quot;,          s.create_time &quot;seckill.create_time&quot;        FROM success_killed sk INNER JOIN seckill s        ON sk.seckill_id = s.seckill_id        WHERE sk.seckillId = #{seckillId}    &lt;/select&gt;&lt;/mapper&gt;</code></pre><p>示例3：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名加sql映射文件名，这样就能够保证namespace的值是唯一的--&gt;&lt;mapper namespace=&quot;com.braincao.dao.ICommandDao&quot;&gt;    &lt;!--确定映射关系，此命名空间下，id=CommandResult的resultMap所映射实体类是Command--&gt;    &lt;resultMap type=&quot;com.braincao.bean.Command&quot; id=&quot;CommandResult&quot;&gt;        &lt;!--左边数据库名，右边model实体名--&gt;        &lt;id column=&quot;A_ID&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;COMMAND&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;command&quot;/&gt;        &lt;result column=&quot;DESCRIPTION&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;description&quot;/&gt;        &lt;!--一对多的映射关系：主表包含字表的集合； 如果是多对一的话同样的，只是collection换成了association--&gt;        &lt;collection resultMap=&quot;CommandContentMapper.CommandContentResult&quot; property=&quot;commandContentList&quot;/&gt;    &lt;/resultMap&gt;    &lt;!--分页功能:后台list.jsp根据查询条件查询消息列表:parameterType表示传入的参数类型--&gt;    &lt;select id=&quot;queryListCommand&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;CommandResult&quot;&gt;        SELECT A.ID A_ID,A.COMMAND,A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B        ON A.ID=B.COMMAND_ID        &lt;where&gt;            &lt;if test=&quot;command.command!=null and !&amp;quot;&amp;quot;.equals(command.command.trim())&quot;&gt;AND A.COMMAND = #{command.command}&lt;/if&gt;            &lt;if test=&quot;command.description!=null and !&amp;quot;&amp;quot;.equals(command.description.trim())&quot;&gt;AND A.DESCRIPTION LIKE &#39;%&#39; #{command.description} &#39;%&#39;&lt;/if&gt;        &lt;/where&gt;        ORDER BY A.ID LIMIT #{page.dbIndex}, #{page.dbNumber}    &lt;/select&gt;    &lt;!--拦截器实现分页功能:后台list.jsp根据查询条件查询消息列表:parameterType表示传入的参数类型--&gt;    &lt;!--看源码后发现parameterType会自动先统一转成小写，并且map、list等直接写也行不用写包名，所以下面的MAp实验是成功的--&gt;    &lt;select id=&quot;queryListCommandByPage&quot; parameterType=&quot;MAp&quot; resultMap=&quot;CommandResult&quot;&gt;        SELECT A.ID A_ID,A.COMMAND,A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B        ON A.ID=B.COMMAND_ID        &lt;where&gt;            &lt;if test=&quot;command.command!=null and !&amp;quot;&amp;quot;.equals(command.command.trim())&quot;&gt;AND A.COMMAND = #{command.command}&lt;/if&gt;            &lt;if test=&quot;command.description!=null and !&amp;quot;&amp;quot;.equals(command.description.trim())&quot;&gt;AND A.DESCRIPTION LIKE &#39;%&#39; #{command.description} &#39;%&#39;&lt;/if&gt;        &lt;/where&gt;        ORDER BY A.ID    &lt;/select&gt;    &lt;!--前台initTalk.jsp根据查询条件查询消息列表:parameterType表示传入的参数类型--&gt;    &lt;select id=&quot;queryListContent&quot; parameterType=&quot;com.braincao.bean.Command&quot; resultMap=&quot;CommandResult&quot;&gt;        SELECT A.ID A_ID,A.COMMAND,A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B        ON A.ID=B.COMMAND_ID        &lt;where&gt;            &lt;if test=&quot;command!=null and !&amp;quot;&amp;quot;.equals(command.trim())&quot;&gt;AND A.COMMAND = #{command}&lt;/if&gt;            &lt;if test=&quot;description!=null and !&amp;quot;&amp;quot;.equals(description.trim())&quot;&gt;AND A.DESCRIPTION LIKE &#39;%&#39; #{description} &#39;%&#39;&lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;    &lt;!--根据条件查询消息列表的总条数--&gt;    &lt;select id=&quot;count&quot; parameterType=&quot;com.braincao.bean.Command&quot; resultType=&quot;int&quot;&gt;        SELECT COUNT(*) FROM COMMAND        &lt;where&gt;            &lt;if test=&quot;command!=null and !&amp;quot;&amp;quot;.equals(command.trim())&quot;&gt;AND COMMAND = #{command}&lt;/if&gt;            &lt;if test=&quot;description!=null and !&amp;quot;&amp;quot;.equals(description.trim())&quot;&gt;AND DESCRIPTION LIKE &#39;%&#39; #{description} &#39;%&#39;&lt;/if&gt;        &lt;/where&gt;    &lt;/select&gt;    &lt;!--新增一条指令--&gt;    &lt;insert id=&quot;addCommand&quot; parameterType=&quot;com.braincao.bean.Command&quot;&gt;        INSERT INTO COMMAND (COMMAND,DESCRIPTION) VALUES(#{command},#{description})    &lt;/insert&gt;    &lt;!--修改指令及描述--&gt;    &lt;update id=&quot;updateCommand&quot; parameterType=&quot;com.braincao.bean.Command&quot;&gt;        UPDATE COMMAND SET COMMAND=#{command},DESCRIPTION=#{description} WHERE ID=#{id}    &lt;/update&gt;    &lt;!--根据id删除指定的一条指令--&gt;    &lt;delete id=&quot;deleteOne&quot; parameterType=&quot;int&quot;&gt;        DELETE FROM COMMAND WHERE ID = #{_parameter}    &lt;/delete&gt;    &lt;!--根据id批量删除消息--&gt;    &lt;delete id=&quot;deleteBatch&quot; parameterType=&quot;java.util.List&quot;&gt;        DELETE FROM COMMAND WHERE ID in        (        &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; separator=&quot;,&quot;&gt;            #{item}        &lt;/foreach&gt;        )    &lt;/delete&gt;&lt;/mapper&gt;</code></pre><h2 id="4-spring-dao-xml"><a href="#4-spring-dao-xml" class="headerlink" title="4.spring-dao.xml"></a>4.spring-dao.xml</h2><p>放在resources目录下，配置整合spring-mybatis：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--配置整合spring-mybatis过程,classpath就是java与resources下面的--&gt;    &lt;!--1. 配置数据库相关参数 引入外部jdbc.properties属性文件，properties属性:${url}--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;    &lt;!--2. 数据库连接池，这里为c3p0--&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;        &lt;!--配置连接池属性--&gt;        &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt;        &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt;        &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;        &lt;!--c3p0连接池私有属性，一般不配置，由于本案例高并发因此个性化配置--&gt;        &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt;        &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt;        &lt;!--关闭连接后不自动commit，默认为false--&gt;        &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt;        &lt;!--获取连接超时时间--&gt;        &lt;property name=&quot;checkoutTimeout&quot; value=&quot;1000&quot;/&gt;        &lt;!--当获取连接失败重试次数--&gt;        &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt;    &lt;/bean&gt;    &lt;!--3. 配置sqlSessionFactory对象--&gt;    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;!--注入数据库连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;!--配置mybatis全局配置文件:mybatis-config.xml--&gt;        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt;        &lt;!--扫描entity包，方便在mapper.xml中直接使用类名--&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.braincao.entity&quot;/&gt;        &lt;!--扫描sql配置文件:mapper需要的xml文件，这样不用在mybatis-config.xml中一个一个添加mapper.xml--&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;/&gt;    &lt;/bean&gt;    &lt;!--4. 配置扫描DAO接口包，动态实现DAO接口，注入到spring容器中--&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;!--注入sqlSessionFactory--&gt;        &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt;        &lt;!--给出需要扫描的DAO接口包--&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;com.braincao.dao&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h2 id="5-Service层接口与实现"><a href="#5-Service层接口与实现" class="headerlink" title="5.Service层接口与实现"></a>5.Service层接口与实现</h2><p>service层接口：</p><pre><code class="html">package com.braincao.service;import com.braincao.dto.Exposer;import com.braincao.dto.SeckillExecution;import com.braincao.entity.Seckill;import com.braincao.exception.RepeatKillException;import com.braincao.exception.SeckillCloseException;import com.braincao.exception.SeckillException;import java.util.List;/** * 业务接口：Service层接口应站在使用者角度设计接口 * */public interface SeckillService {    /**     * 查询所有秒杀商品     * @param void     * @return List&lt;Seckill&gt;     */    List&lt;Seckill&gt; getSeckillList();    /**     * 根据id查询一个秒杀商品     * @param seckillId     * @return Seckill     */    Seckill getById(long seckillId);    /**     * 用户根据id查询该秒杀商品的秒杀接口地址时:     * 秒杀开启时输出秒杀接口地址，未开启时输出系统时间+秒杀开启时间     * @param seckillId     * @return  秒杀接口地址。用dto传输层的实体来封装秒杀接口地址,dto方便web层拿到秒杀暴露接口相关数据     */    Exposer exportSeckillUrl(long seckillId);    /**     * 执行秒杀操作     * @param seckillId,userPhone,md5     *        md5用来验证是否是同一用户操作，如果md5变了，说明用户被篡改     * @return dto传输层的实体来封装秒杀操作的返回实体，包含成功、失败     * 当秒杀失败时输出自定义运行期异常RepeatKillException     */    SeckillExecution executeSeckill(long seckillId, long userPhone, String md5)        throws SeckillException, SeckillCloseException, RepeatKillException;}service层实现：package com.braincao.service.impl;import com.braincao.dao.SeckillDao;import com.braincao.dao.SuccessKilledDao;import com.braincao.dto.Exposer;import com.braincao.dto.SeckillExecution;import com.braincao.entity.Seckill;import com.braincao.entity.SuccessKilled;import com.braincao.enums.SeckillStateEnum;import com.braincao.exception.RepeatKillException;import com.braincao.exception.SeckillCloseException;import com.braincao.exception.SeckillException;import com.braincao.service.SeckillService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.util.DigestUtils;import java.util.Date;import java.util.List;/** * @FileName: SeckillServiceImpl * @Author: braincao * @Date: 2018/11/27 15:40 * @Description: Service层接口的实现 * md5:对任意长度字符串返回一个特定长度的加密编码，不可逆 * 所有编译期异常转化为运行期异常，这样spring声明式事务会帮我们做roll back *///@Component / @Service / @Dao / @Controller@Servicepublic class SeckillServiceImpl implements SeckillService {    //slf4j规范接口的日志    private Logger logger = LoggerFactory.getLogger(this.getClass());    //spring注入Service依赖：spring注入的DAO层对象 @Autowired / @Resource / @Inject    @Autowired    private SeckillDao seckillDao;    //spring注入的DAO层对象    @Autowired    private SuccessKilledDao successKilledDao;    //盐值字符串，用于混淆md5。越复杂越好，用户猜不到    private final String slat = &quot;asdc#$!EFSD$#%$GWVDSQ#!$#%$#T~~@#$^GV&quot;;    //对seckillId生成md5的过程    private String getMD5(long seckillId){        String base = seckillId + &quot;/&quot; + slat;        String md5 = DigestUtils.md5DigestAsHex(base.getBytes());//用base二进制生成md5        return md5;    }    //查询所有秒杀商品    @Override    public List&lt;Seckill&gt; getSeckillList() {        return seckillDao.queryAll(0,4);    }    //根据id查询一个秒杀商品    @Override    public Seckill getById(long seckillId) {        return seckillDao.queryById(seckillId);    }    //用户根据id查询该秒杀商品的秒杀接口地址时:    //秒杀开启时输出秒杀接口地址，未开启时输出系统时间+秒杀开启时间    @Override    public Exposer exportSeckillUrl(long seckillId) {        Seckill seckill = seckillDao.queryById(seckillId);//拿到目标的秒杀商品        //1.如果目标商品为null        if(seckill==null){            return new Exposer(false, seckillId);        }        Date startTime = seckill.getStartTime();        Date endTime = seckill.getEndTime();        Date date = new Date(); //系统的当前时间        //2.如果秒杀未开始或已经结束        if(date.getTime()&lt;startTime.getTime() || date.getTime()&gt;endTime.getTime()){            return new Exposer(false,seckillId,date.getTime(),startTime.getTime(),endTime.getTime());        }        //3.如果秒杀开始，暴露接口地址        String md5 = getMD5(seckillId);        return new Exposer(true, md5, seckillId);    }    //执行秒杀操作，使用注解来声明式事务    @Override    @Transactional    public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, SeckillCloseException, RepeatKillException {        //md5验证，如果不对则抛出异常，秒杀失败，防止用户私自篡改        if(md5==null || !md5.equals(getMD5(seckillId))){            throw new SeckillException(&quot;seckill data rewrite&quot;);        }        //执行秒杀逻辑:减库存 + 记录购买行为，对里面抛出的异常进行try/catch并记录到日志，汇总后向外只抛一个总异常就好        Date date = new Date();        try{            //减库存            int updateCount = seckillDao.reduceNumber(seckillId, date);            if(updateCount&lt;=0){//减库存失败，秒杀结束                throw new SeckillCloseException(&quot;seckill is closed&quot;);            }else{                //减库存成功，记录购买行为                int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone);                if(insertCount&lt;=0){//重复秒杀                    throw new RepeatKillException(&quot;Repeat seckill&quot;);                }else{                    //秒杀成功                    SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId,userPhone);                    return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, successKilled);                }            }        }catch(SeckillCloseException e1){            throw e1;        }catch (RepeatKillException e2){            throw e2;        }catch (Exception e){            logger.error(e.getMessage(), e);            //所有编译期异常转化为运行期异常，这样spring声明式事务会帮我们做roll back            throw new SeckillException(&quot;seckill inner error: &quot; + e.getMessage());        }    }}</code></pre><h2 id="6-spring-service-xml"><a href="#6-spring-service-xml" class="headerlink" title="6.spring-service.xml"></a>6.spring-service.xml</h2><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/mvc/spring-tx.xsd&quot;&gt;    &lt;!--扫描service包下所有使用注解的类型 @Component @Service @Dao @Controller @自定义--&gt;    &lt;context:component-scan base-package=&quot;com.braincao.service&quot;/&gt;    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!--注入数据库连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    &lt;/bean&gt;    &lt;!--配置基于注解的声明式事务        设置为默认使用注解来管理事务行为--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/beans&gt;</code></pre><h2 id="7-logback-xml"><a href="#7-logback-xml" class="headerlink" title="7.logback.xml"></a>7.logback.xml</h2><p>resources下的logback.xml，是实现slf4j接口规范的日志管理。配置示例可以从logback官网上找到。</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration debug=&quot;true&quot;&gt;    &lt;!--打印格式：默认往ConsoleAppender控制台打印，打印格式如下配置--&gt;    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!-- encoders are  by default assigned the type             ch.qos.logback.classic.encoder.PatternLayoutEncoder --&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!--打印级别，默认为debug--&gt;    &lt;root level=&quot;debug&quot;&gt;        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;    &lt;/root&gt;&lt;/configuration&gt;</code></pre><h2 id="8-单元测试"><a href="#8-单元测试" class="headerlink" title="8.单元测试"></a>8.单元测试</h2><p>DAO层–SeckillDaoTest.java:</p><pre><code class="html">package com.braincao.dao;import com.braincao.entity.Seckill;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import javax.annotation.Resource;import java.util.Date;import java.util.List;import static org.junit.Assert.*;//配置spring和junit整合(@RunWith)，这样junit启动时会加载springIOC容器，拿到相应的bean@RunWith(SpringJUnit4ClassRunner.class)//告诉junit spring的配置文件(这里测试dao，是spring-dao.xml)@ContextConfiguration({&quot;classpath:spring/spring-dao.xml&quot;})public class SeckillDaoTest {    //用resource注解来注入seckillDao依赖    @Resource    private SeckillDao seckillDao;    @Test    public void queryById() {        long id = 1000;        Seckill seckill = seckillDao.queryById(id);        System.out.println(seckill.getName());        System.out.println(seckill);    }    @Test    public void queryAll() {        List&lt;Seckill&gt; seckills = seckillDao.queryAll(0,100);        //这里注意：java没有保存形参的记录，多个参数时会将offset-&gt;arg0，        // 因此在dao层接口中参数前需要加@Param(&quot;offset&quot;)，否则会报错        for(Seckill seckill: seckills){            System.out.println(seckill);        }    }    @Test    public void reduceNumber() {        Date createTime = new Date();        int updateCount = seckillDao.reduceNumber(1000L,createTime);        System.out.println(updateCount);    }service层(带logger输出控制台)---SeckillServiceTest.java:package com.braincao.service;import com.braincao.dto.Exposer;import com.braincao.dto.SeckillExecution;import com.braincao.entity.Seckill;import com.braincao.exception.RepeatKillException;import com.braincao.exception.SeckillCloseException;import org.junit.Test;import org.junit.runner.RunWith;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;//配置spring和junit整合(@RunWith)，这样junit启动时会加载springIOC容器，拿到相应的bean@RunWith(SpringJUnit4ClassRunner.class)//告诉junit spring的配置文件(这里测试dao，是spring-dao.xml)@ContextConfiguration({&quot;classpath:spring/spring-dao.xml&quot;,                        &quot;classpath:spring/spring-service.xml&quot;})public class SeckillServiceTest {    //日志，因为测试service方法时存在秒杀失败抛出异常，所以把这些输出放在日志中    private final Logger logger = LoggerFactory.getLogger(this.getClass());    //用@Autowired注解来注入seckillService依赖    @Autowired    private SeckillService seckillService;    //查询所有秒杀商品    @Test    public void getSeckillList() {        List&lt;Seckill&gt; seckillList = seckillService.getSeckillList();        logger.info(&quot;list={}&quot;, seckillList);//{}是占位符，把后面的object放到占位符中    }    //根据id查询一个秒杀商品    @Test    public void getById() {        long id = 1000;        Seckill seckill = seckillService.getById(id);        logger.info(&quot;seckill={}&quot;, seckill);    }    //集成测试代码完整逻辑，将接口地址暴露和执行秒杀操作两个一起集成测试，    // 这样md5值就中间可用，可重复执行测试    @Test    public void testSeckillLogic() throws Exception {        long id = 1000;        Exposer exposer = seckillService.exportSeckillUrl(id);        if(exposer.isExposed()){            logger.info(&quot;exposer={}&quot;, exposer);            long userPhone = 15652965935L;            String md5 = exposer.getMd5();            try{                SeckillExecution seckillExecution = seckillService.executeSeckill(id, userPhone, md5);                logger.info(&quot;seckillResult={}&quot;, seckillExecution);            }catch (RepeatKillException e){                logger.error(e.getMessage());            }catch (SeckillCloseException e){                logger.error(e.getMessage());            }        }        else{            //秒杀未开启            logger.warn(&quot;exposer={}&quot;, exposer);        }    }}</code></pre><h2 id="9-另一种手写的单元测试"><a href="#9-另一种手写的单元测试" class="headerlink" title="9.另一种手写的单元测试"></a>9.另一种手写的单元测试</h2><p>UintTestBase:</p><pre><code class="html">import org.junit.After;import org.junit.Before;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.util.StringUtils;public class UnitTestBase {    private ClassPathXmlApplicationContext context;    private String stringXmlPath;    public UnitTestBase() {    }    public UnitTestBase(String stringXmlPath) {        this.stringXmlPath = stringXmlPath;    }    @Before    public void before() {        if (StringUtils.isEmpty(this.stringXmlPath)) {            stringXmlPath = &quot;classPath*:spring-*.xml&quot;;        }        try {//context就是一个bean容器            context = new ClassPathXmlApplicationContext(stringXmlPath.split(&quot;[,\\s]+&quot;));            context.start();        } catch (Exception e) {            e.printStackTrace();        }    }    @After    public void after() {        context.destroy();    }    @SuppressWarnings(&quot;unchecked&quot;)    protected &lt;T extends Object&gt; T getBean(String beanId) {        return (T) context.getBean(beanId);    }    protected &lt;T extends Object&gt; T getBean(Class&lt;T&gt; clazz) {        return (T) context.getBean(clazz);    }}AppTest：import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.BlockJUnit4ClassRunner;import sevice.AccountService;@RunWith(BlockJUnit4ClassRunner.class)public class AppTest extends UnitTestBase{    public AppTest(){        super(&quot;classpath:applicationContext.xml&quot;);    }    @Test    public void testJdbcDaoSupport(){        AccountService accountService = super.getBean(&quot;accountService&quot;);        accountService.transfer(&quot;aaa&quot;, &quot;bbb&quot;, 50);    }}</code></pre><p>##10.Spring-MVC配置</p><p>SpringMVC是基于DispatcherServlet的，DispatcherServlet是继承自HttpServlet的，HttpServlet是在web.xml文件中声明的。关于Spring-MVC我们需要配置两个东西。</p><p>1.resources包下的spring-web.xml</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;    &lt;!--配置整合springMVC过程,classpath就是java与resources下面的--&gt;    &lt;!--1.开启springMVC注解模式--&gt;    &lt;!--简化配置：        1)自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter        2)提供一系列：数据绑定，数字和日期的format,@NumberFormat,@DataTimeFormat,        xml,json默认读写支持。    --&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--2.静态资源默认sevlet配置            1)加入对静态资源的处理：js,gif,png            2)允许使用&quot;/&quot;做整体映射    --&gt;    &lt;mvc:default-servlet-handler/&gt;    &lt;!-- 3.配置ViewResolver，这里配置jsp格式的。          对转向页面的路径解析，spring mvc的这个ViewResolver就是将相同的后端数据给前端不同的呈现(jsp格式数据\JSON格式数据等)。        可以用多个ViewResolver,使用order属性排序,InternalResourceViewResolver放在最后    --&gt;    &lt;!--json格式的，但这里先不用--&gt;    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;--&gt;        &lt;!--&lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt;--&gt;        &lt;!--&lt;property name=&quot;mediaTypes&quot;&gt;--&gt;            &lt;!--&lt;map&gt;--&gt;                &lt;!--&lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;--&gt;                &lt;!--&lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;--&gt;                &lt;!--&lt;entry key=&quot;htm&quot; value=&quot;text/html&quot; /&gt;--&gt;            &lt;!--&lt;/map&gt;--&gt;        &lt;!--&lt;/property&gt;--&gt;        &lt;!--&lt;property name=&quot;defaultViews&quot;&gt;--&gt;            &lt;!--&lt;list&gt;--&gt;                &lt;!--&amp;lt;!&amp;ndash; JSON View &amp;ndash;&amp;gt;--&gt;                &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&gt;&lt;/bean&gt;--&gt;            &lt;!--&lt;/list&gt;--&gt;        &lt;!--&lt;/property&gt;--&gt;        &lt;!--&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot; /&gt;--&gt;    &lt;!--&lt;/bean&gt;--&gt;    &lt;!--jsp格式的，InternalResourceViewResolver放在最后--&gt;    &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;    &lt;!--4.扫描web相关的bean，就是自己开发的Controller--&gt;    &lt;context:component-scan base-package=&quot;com.braincao.web&quot;/&gt;&lt;/beans&gt;</code></pre><p>2.web.xml</p><pre><code class="html">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;         version=&quot;3.1&quot;         metadata-complete=&quot;true&quot;&gt;  &lt;!--注意这里要把maven新建项目时自动生成的web.xml头部替换成上面的头部，修改servlet版本为3.1，这样就能自动支持spring EL--&gt;  &lt;!--修改--&gt;  &lt;display-name&gt;Spring MVC Demo Study&lt;/display-name&gt;  &lt;!--Spring MVC核心: 配置DispatcherServlet，不同的拦截需求可以有多个DispatcherServlet--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;!-- 可以像如下自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml--&gt;    &lt;!--配置springMVC需要加载的配置文件        spring-dao.xml,spring-service.xml,spring-web.xml        mybatis-&gt;spring-&gt;springMVC    --&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring/spring-*.xml&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;    &lt;!--默认匹配所有请求，并映射到此dispatcher--&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;  &lt;!--&amp;lt;!&amp;ndash;Spring应用上下文，理解层次化的ApplicationContext&amp;ndash;&amp;gt;--&gt;  &lt;!--&lt;context-param&gt;--&gt;    &lt;!--&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;--&gt;    &lt;!--&lt;param-value&gt;/WEB-INF/configs/applicationContext.xml&lt;/param-value&gt;--&gt;  &lt;!--&lt;/context-param&gt;--&gt;  &lt;!--&amp;lt;!&amp;ndash;Spring监听&amp;ndash;&amp;gt;--&gt;  &lt;!--&lt;listener&gt;--&gt;    &lt;!--&lt;listener-class&gt;--&gt;      &lt;!--org.springframework.web.context.ContextLoaderListener--&gt;    &lt;!--&lt;/listener-class&gt;--&gt;  &lt;!--&lt;/listener&gt;--&gt;  &lt;!--&amp;lt;!&amp;ndash;springmvc过滤器，作为处理乱码等问题的拦截器&amp;ndash;&amp;gt;--&gt;  &lt;!--&lt;filter&gt;--&gt;    &lt;!--&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;--&gt;    &lt;!--&lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;--&gt;    &lt;!--&lt;init-param&gt;--&gt;      &lt;!--&lt;param-name&gt;encoding&lt;/param-name&gt;--&gt;      &lt;!--&lt;param-value&gt;utf8&lt;/param-value&gt;--&gt;    &lt;!--&lt;/init-param&gt;--&gt;  &lt;!--&lt;/filter&gt;--&gt;  &lt;!--&lt;filter-mapping&gt;--&gt;    &lt;!--&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;--&gt;    &lt;!--&amp;lt;!&amp;ndash;匹配所有请求&amp;ndash;&amp;gt;--&gt;    &lt;!--&lt;url-pattern&gt;*&lt;/url-pattern&gt;--&gt;  &lt;!--&lt;/filter-mapping&gt;--&gt;&lt;/web-app&gt;</code></pre><h2 id="11-Controller层"><a href="#11-Controller层" class="headerlink" title="11.Controller层"></a>11.Controller层</h2><p>实现Restful接口的Controller层：接受请求与参数，跳转页面的控制，并且返回参数都是已经dto传输层封装好的类型</p><p>SeckillController.java:</p><pre><code class="html">package com.braincao.web;import com.braincao.dto.Exposer;import com.braincao.dto.SeckillExecution;import com.braincao.dto.SeckillResult;import com.braincao.entity.Seckill;import com.braincao.enums.SeckillStateEnum;import com.braincao.exception.RepeatKillException;import com.braincao.exception.SeckillCloseException;import com.braincao.service.SeckillService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import java.util.Date;import java.util.List;/** * @FileName: SeckillController * @Author: braincao * @Date: 2018/11/28 20:16 * @Description: 实现Restful接口的Controller层：接受请求与参数，跳转页面的控制，并且返回参数都是已经dto传输层封装好的类型 */@Controller//url: 模块/资源/{id}/细分@RequestMapping(&quot;/seckill&quot;)public class SeckillController {    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    private SeckillService seckillService;    //获取所有秒杀商品列表页    @RequestMapping(value=&quot;/list&quot;, method = RequestMethod.GET)    public String list(Model model){        List&lt;Seckill&gt; seckillList = seckillService.getSeckillList();        model.addAttribute(&quot;list&quot;, seckillList);        //jsp页面 + model数据 = ModelAndView        //跳转到/WEB-INF/jsps/list.jsp        return &quot;list&quot;;    }    //获取单个秒杀商品的详情页    @RequestMapping(value=&quot;/{seckillId}/detail&quot;, method = RequestMethod.GET)    public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model){        if(seckillId==null){            return &quot;redirect:/seckill/list&quot;; //重定向        }        Seckill seckill = seckillService.getById(seckillId);        if(seckill==null){            return &quot;forward:/seckill/list&quot;;        }        model.addAttribute(&quot;seckill&quot;, seckill);        //jsp页面 + model数据 = ModelAndView        //跳转到/WEB-INF/jsps/detail.jsp        return &quot;detail&quot;;    }    //获取秒杀地址。接收ajaxPOST请求，返回json格式。produces解决乱码问题    @RequestMapping(value = &quot;/{seckillId}/exposer&quot;,            method = RequestMethod.POST,            produces = {&quot;application/json;charset=UTF-8&quot;})    @ResponseBody    public SeckillResult&lt;Exposer&gt; exposer(@PathVariable(&quot;seckillId&quot;)long seckillId){        SeckillResult&lt;Exposer&gt; result;        try{            Exposer exposer = seckillService.exportSeckillUrl(seckillId);            result = new SeckillResult&lt;&gt;(true, exposer);        }catch (Exception e){            logger.error(e.getMessage());            result = new SeckillResult&lt;&gt;(false,e.getMessage());        }        return result;    }    //执行秒杀的ajax请求，返回json。CookieValue是通过cookie获取手机号，如果不存在也不报错，交给程序try/catch    @RequestMapping(value = &quot;/{seckillId}/{md5}/execution&quot;,            method = RequestMethod.POST,            produces = {&quot;application/json;charset=UTF-8&quot;})    @ResponseBody    public SeckillResult&lt;SeckillExecution&gt; exposer(            @PathVariable(&quot;seckillId&quot;)Long seckillId,            @PathVariable(&quot;md5&quot;) String md5,            @CookieValue(value = &quot;killPhone&quot;, required = false)Long userPhone){        if(userPhone==null){            return new SeckillResult&lt;SeckillExecution&gt;(false,&quot;用户未注册&quot;);        }        try{            SeckillExecution seckillExecution = seckillService.executeSeckill(seckillId,userPhone,md5);            return new SeckillResult&lt;SeckillExecution&gt;(true,seckillExecution);        }catch (RepeatKillException e) {            SeckillExecution seckillExecution = new SeckillExecution(seckillId, SeckillStateEnum.REPEAT_KILL);            return new SeckillResult&lt;SeckillExecution&gt;(true,seckillExecution);        }catch (SeckillCloseException e){            SeckillExecution seckillExecution = new SeckillExecution(seckillId, SeckillStateEnum.END);            return new SeckillResult&lt;SeckillExecution&gt;(true,seckillExecution);        }catch (Exception e){            logger.error(e.getMessage(),e);            SeckillExecution seckillExecution = new SeckillExecution(seckillId, SeckillStateEnum.INNER_ERROR);            return new SeckillResult&lt;SeckillExecution&gt;(true,seckillExecution);        }    }    //前端获取系统时间，ajax请求    @RequestMapping(value = &quot;/time/now&quot;, method = RequestMethod.GET)    @ResponseBody    public SeckillResult&lt;Long&gt; time(){        Date now = new Date();        return new SeckillResult&lt;Long&gt;(true, now.getTime());    }}</code></pre><h2 id="12-jsp主页面-js"><a href="#12-jsp主页面-js" class="headerlink" title="12.jsp主页面 + .js"></a>12.jsp主页面 + .js</h2><p>detail.jsp：</p><pre><code class="html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@include file=&quot;common/taglib.jsp&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;%    String path = request.getContextPath();    String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;秒杀详情页&lt;/title&gt;    &lt;!--静态包含jsp，将所引的jsp部分会合并过来--&gt;    &lt;%@include file=&quot;common/head.jsp&quot;%&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;panel panel-default text-center&quot;&gt;            &lt;div class=&quot;panel-heading&quot;&gt;                &lt;h1&gt;${seckill.name}&lt;/h1&gt;            &lt;/div&gt;            &lt;div class=&quot;panel-body&quot;&gt;                &lt;h2 class=&quot;text-danger&quot;&gt;                    &lt;!--显示time图标--&gt;                    &lt;span class=&quot;glyphicon glyphicon-time&quot;&gt;&lt;/span&gt;                    &lt;!--展示倒计时--&gt;                    &lt;span class=&quot;glyphicon&quot; id=&quot;seckill-box&quot;&gt;&lt;/span&gt;                &lt;/h2&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;!--登录弹出层，输入电话--&gt;    &lt;div id=&quot;killPhoneModal&quot; class=&quot;modal fade&quot;&gt;        &lt;div class=&quot;modal-dialog&quot;&gt;            &lt;div class=&quot;modal-content&quot;&gt;                &lt;div class=&quot;modal-header&quot;&gt;                    &lt;h3 class=&quot;modal-title text-center&quot;&gt;                        &lt;span class=&quot;glyphicon glyphicon-phone&quot;&gt;&lt;/span&gt;                        秒杀前请输入用户手机号                    &lt;/h3&gt;                &lt;/div&gt;                &lt;div class=&quot;modal-body&quot;&gt;                    &lt;div class=&quot;row&quot;&gt;                        &lt;div class=&quot;col-xs-8 col-xs-offset-2&quot;&gt;                            &lt;input type=&quot;text&quot; name=&quot;killPhone&quot; autofocus class=&quot;form-control&quot; id=&quot;killPhoneKey&quot; placeholder=&quot;填手机号&quot;/&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;modal-footer&quot;&gt;                    &lt;!--验证信息--&gt;                    &lt;span id=&quot;killPhoneMessage&quot; class=&quot;glyphicon&quot;&gt;&lt;/span&gt;                    &lt;button type=&quot;button&quot; id=&quot;killPhoneButton&quot; class=&quot;btn btn-success&quot;&gt;                        &lt;span class=&quot;glyphicon glyphicon-phone&quot;&gt;&lt;/span&gt;                        Submit                    &lt;/button&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;!--引入的插件用cdn链接:cookie插件、倒计时插件--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery.countdown/2.2.0/jquery.countdown.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=path%&gt;/resources/js/seckill.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function(){        //使用EL表达式传入参数，初始化页面        seckill.detail.init({            seckillId: ${seckill.seckillId},            startTime: ${seckill.startTime.time}, //startTime是date类型，转成毫秒            endTime: ${seckill.endTime.time}        });    });&lt;/script&gt;&lt;/html&gt;seckill.js://存放主要交互逻辑js代码//javascript模块化封装，不要写成一坨var seckill = {    //封装所有秒杀相关的url    URL:{        now:function(){            return &quot;/seckill/time/now&quot;        },        exposer:function(seckillId){            return &quot;/seckill/&quot; + seckillId + &quot;/exposer&quot;;        },        execution:function(seckillId, md5){            return &quot;/seckill/&quot; + seckillId + &quot;/&quot; + md5 + &quot;/execution&quot;;        }    },    //秒杀开始时的秒杀逻辑:获取秒杀地址，控制显示逻辑，执行秒杀    handlerSeckill:function(seckillId, node){        node.hide().html(&quot;&lt;button class=&#39;btn btn-primary btn-lg&#39; id=&#39;killBtn&#39;&gt;开始秒杀&lt;/button&gt;&quot;);//隐藏按钮        //通过ajaxPOST请求获取秒杀接口地址        $.post(seckill.URL.exposer(seckillId), {}, function(result){            if(result &amp;&amp; result[&quot;success&quot;]){                var exposer = result[&quot;data&quot;];                if(exposer[&quot;exposed&quot;]){                    //开启秒杀                    //获取秒杀地址                    var md5 = exposer[&quot;md5&quot;];                    var killUrl = seckill.URL.execution(seckillId, md5);//拿到服务器返回的秒杀接口地址                    console.log(&quot;killUrl: &quot; + killUrl);//输出到控制台                    //用one绑定而不是click的好处就是：只绑定一次点击事件                    // 防止一个用户不停的点秒杀，都发送服务端造成崩                    $(&quot;#killBtn&quot;).one(&quot;click&quot;,function(){                        //执行秒杀请求                        //1.点击后按钮变灰色，禁用按钮                        $(this).addClass(&quot;disabled&quot;);                        //2.发送ajaxPOST请求，执行秒杀                        $.post(killUrl,{},function(result){                            if(result &amp;&amp; result[&quot;success&quot;]){                                var killResult = result[&quot;data&quot;];                                var state = killResult[&quot;state&quot;];                                var stateInfo = killResult[&quot;stateInfo&quot;];                                //3.显示秒杀结果                                node.html(&quot;&lt;span class=&#39;label label-success&#39;&gt;&quot; + stateInfo + &quot;&lt;/span&gt;&quot;);                            }                        });                    });                    node.show();                }            }            else{                console.log(&quot;result: &quot; + result);            }        });    },    //验证手机号    validatePhone:function(phone){      if(phone &amp;&amp; phone.length===11 &amp;&amp; !isNaN(phone)){          return true;      }else{          return false;      }    },    //倒计时的时间判断    countdown: function(seckillId, nowTime, startTime, endTime){        var seckillBox = $(&quot;#seckill-box&quot;);        //时间判断        if(nowTime&gt;endTime){            //秒杀结束            seckillBox.html(&quot;秒杀结束!&quot;);        }        else if(nowTime&lt;startTime){            //秒杀未开始，计时事件绑定，用countdown插件倒计时            var killTime = new Date(startTime+1000);            seckillBox.countdown(killTime,function(event){//countdown插件的函数                //时间格式                var format = event.strftime(&quot;秒杀倒计时：%D天 %H时 %M分 %S秒&quot;);                seckillBox.html(format);                /*倒计时结束后回调事件*/            }).on(&quot;finish.countdown&quot;, function(){                //获取秒杀地址，控制显示逻辑，执行秒杀                seckill.handlerSeckill(seckillId, seckillBox);            });        }        else{            //秒杀开始            seckill.handlerSeckill(seckillId, seckillBox);        }    },    //详情页秒杀逻辑    detail:{        //详情页初始化        init:function(params){            //详情页初始化：手机验证和登录 + 计时交互            //在cookie中查找手机号            var killPhone = $.cookie(&quot;killPhone&quot;);            //1.验证手机号            if(!seckill.validatePhone(killPhone)){                //手机号不存在，显示弹出层，开始绑定phone                var killPhoneModal = $(&quot;#killPhoneModal&quot;);                killPhoneModal.modal({                    show:true,                    backdrop:&quot;static&quot;, //禁止位置关闭:点别的地方关不掉                    keyboard:false //关闭键盘事件:按esc关不掉                });                //监听回车事件:回车也同样进行下面的click                document.onkeydown = function(e){                    if(e.keyCode === 13){                        $(&quot;#killPhoneButton&quot;).click();                    }                };                $(&quot;#killPhoneButton&quot;).click(function(){                    var inputPhone = $(&quot;#killPhoneKey&quot;).val();                    console.log(&quot;inputPhone&quot; + inputPhone);                    if(seckill.validatePhone(inputPhone)){                        //手机号写入cookie，名字为killPhone，值为用户输入的正确手机号，有效期为7天，只在/seckill路径下有效                        $.cookie(&quot;killPhone&quot;, inputPhone, {expires:7,path:&quot;/seckill&quot;});                        //刷新页面                        window.location.reload();                    }                    else{//手机号填写错误，这个过程先hide再show，这样用户看不到中间渲染的过程，更好的体验                        $(&quot;#killPhoneMessage&quot;).hide().html(&quot;&lt;lable class=&#39;label label-danger&#39;&gt;手机号填写错误!&lt;/lable&gt;&quot;).show(300);                    }                })            }            //2.已经登录，开始计时交互            //通过ajaxGET请求获取服务器时间/time/now，ajax请求返回的数据是json格式的result            var seckillId = params[&quot;seckillId&quot;];            var startTime = params[&quot;startTime&quot;];            var endTime = params[&quot;endTime&quot;];            $.get(seckill.URL.now(), {}, function(result){                if(result &amp;&amp; result[&quot;success&quot;]){                    var nowTime = result[&quot;data&quot;];//拿到服务器时间                    //时间判断，计时交互                    seckill.countdown(seckillId,nowTime,startTime, endTime);                }                else{                    console.log(&quot;result: &quot; + result);                }            });        }    }};</code></pre><p>附上jsp主页面依赖的其他jsp：</p><p>head.jsp:</p><pre><code class="html">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;&lt;!--移动设备自适应--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;!--响应式图像:可以让图像按比例缩放，不超过其父元素的尺寸--&gt;&lt;!--img src=&quot;...&quot; class=&quot;img-responsive&quot; alt=&quot;响应式图像&quot;--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=path%&gt;/resources/js/bootstrap-table.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=path%&gt;/resources/css/bootstrap-table.css&quot;/&gt;</code></pre><p>taglib.jsp:</p><pre><code class="html">&lt;!--引入jstl标签库--&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim总结</title>
      <link href="/2018/03/21/vim/"/>
      <url>/2018/03/21/vim/</url>
      
        <content type="html"><![CDATA[<p>此文档记录vim一些操作技巧，提升开发效率</p><a id="more"></a><h2 id="修改vimrc配置文件出现的权限问题"><a href="#修改vimrc配置文件出现的权限问题" class="headerlink" title="修改vimrc配置文件出现的权限问题"></a>修改vimrc配置文件出现的权限问题</h2><p>解决方法：</p><p>/usr/share/vim/vimrc 这个每次系统升级就会被覆盖</p><p>所以vim ~/.vimrc 在你的home目录创建一个.vimrc就好了，以后都在这个里面改就行</p><p>然后<code>echo $MYVIMRC</code>看看你的设置是否成功</p><h2 id="vim主题更换"><a href="#vim主题更换" class="headerlink" title="vim主题更换"></a>vim主题更换</h2><p>想更换vim的default主题，换成molokai.vim主题</p><pre><code>在终端输入$ ls /usr/share/vim/vim80/colors查看是否有上面提到的某些配色，所有配色均是以.vim结束的，如果有的话，再输入：$ cd ~/到用户主目录，然后输入$ vim .vimrc创建配置文件，将vim的内容设置如下：set nu  colorscheme molokai  syntax on</code></pre><p>mac下vim的16种配色的<a href="http://blog.csdn.net/myhelperisme/article/details" target="_blank" rel="noopener">主题方案</a>，把molokai换成对应的名字即可</p>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 综合技术 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm框架学习笔记</title>
      <link href="/2018/03/21/java-ssm-learning/"/>
      <url>/2018/03/21/java-ssm-learning/</url>
      
        <content type="html"><![CDATA[<p>此文档记录研二学习ssm框架的知识点笔记</p><a id="more"></a><h2 id="SSM简介"><a href="#SSM简介" class="headerlink" title="SSM简介"></a>SSM简介</h2><p>最初：jsp + servlet + jdbc</p><p>现在：springmvc + spring + mybatis</p><p>官网地址：</p><p>logback配置：<a href="https://logback.qos.ch/manual/configuration.html" target="_blank" rel="noopener">https://logback.qos.ch/manual/configuration.html</a></p><p>spring-api-doc：<a href="https://docs.spring.io/spring/docs/" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/</a></p><p>mybatis中文官网：<a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/index.html</a></p><h2 id="Bean容器初始化"><a href="#Bean容器初始化" class="headerlink" title="Bean容器初始化"></a>Bean容器初始化</h2><p><img src="https://img.braincao.cn/blogimg/1583753997.jpg" alt="1583753997"></p><h2 id="一、Spring常用的三种注入方式"><a href="#一、Spring常用的三种注入方式" class="headerlink" title="一、Spring常用的三种注入方式"></a>一、Spring常用的三种注入方式</h2><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：setter设值注入，构造注入，基于注解的注入。<br><img src="https://img.braincao.cn/blogimg/1583754027.jpg" alt="1583754027"><br><img src="https://img.braincao.cn/blogimg/1583754035.jpg" alt="1583754035"></p><h2 id="基于注解的注入"><a href="#基于注解的注入" class="headerlink" title="基于注解的注入"></a>基于注解的注入</h2><p>基于注解的注入：注解方式注册bean，注入依赖 </p><ul><li>主要有<strong>四种</strong>注解可以注册bean，每种注解可以任意使用，只是语义上有所差异：</li></ul><pre><code>@Component：可以用于注册所有bean​@Repository：主要用于注册dao层的bean​@Controller：主要用于注册控制层的bean​@Service：主要用于注册服务层的bean</code></pre><ul><li>描述依赖关系主要有<strong>两种</strong>：</li></ul><p>@Resource：java的注解，默认以byName的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用@Qualifier注解（spring注解）指定某个具体名称的bean。<br>​<br>​```<br>@Resource<br>@Qualifier(“userDaoMyBatis”)<br>private IUserDao userDao;</p><p>public UserService(){</p><p>}</p><pre><code>@Autowired：spring注解，默认也是以byName的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byType的方式去查找，如果查找到多个，用@Qualifier注解限定具体使用哪个。</code></pre><p>@Autowired<img src="" alt="">    @Qualifier(“userDaoJdbc”)<br>​    private IUserDao userDao;<br>​<br>​```</p><h2 id="二、spring学习之AOP"><a href="#二、spring学习之AOP" class="headerlink" title="二、spring学习之AOP"></a>二、spring学习之AOP</h2><p>入门请参考：<a href="https://blog.csdn.net/daguanjia11/article/details/49278003" target="_blank" rel="noopener">Spring AOP入门Demo</a><br>、<a href="https://www.cnblogs.com/flowwind/p/4782606.html" target="_blank" rel="noopener">Java Spring AOP用法</a></p><h2 id="AOP实现方式"><a href="#AOP实现方式" class="headerlink" title="AOP实现方式"></a>AOP实现方式</h2><p>1.预编译</p><ul><li>AspectJ</li></ul><p>2.运行期动态代理(JDK动态代理、CGLib动态代理)</p><ul><li>SpringAOP、JbossAOP</li></ul><h2 id="Schema-based-AOP-基于XML配置实现的SpringAOP"><a href="#Schema-based-AOP-基于XML配置实现的SpringAOP" class="headerlink" title="Schema-based AOP(基于XML配置实现的SpringAOP)"></a>Schema-based AOP(基于XML配置实现的SpringAOP)</h2><p>Spring 所有的切面和通知器都必须放在一个&lt;aop:config&gt;内(可以包含多个&lt;aop:config&gt;元素)，每一个&lt;aop:config&gt;可以包含pointcut, advisor和aspect元素(它们必须按照这个顺序声明)</p><pre><code class="HTML">&lt;bean id=&quot;car&quot; class=&quot;com.braincao.aop.car.Car&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;carLogger&quot; class=&quot;com.braincao.aop.car.CarLogger&quot;&gt;&lt;/bean&gt;  &lt;aop:config&gt;        &lt;!--指定切面--&gt;        &lt;aop:aspect id=&quot;carLoggerAOP&quot; ref=&quot;carLogger&quot;&gt;            &lt;!--定义切点--&gt;            &lt;aop:pointcut id=&quot;go&quot; expression=&quot;execution(* com.braincao.aop.car.Car.go(..))&quot;&gt;&lt;/aop:pointcut&gt;            &lt;!--定义连接点--&gt;            &lt;aop:after-returning method=&quot;beforeRun&quot; pointcut-ref=&quot;go&quot;&gt;&lt;/aop:after-returning&gt;            &lt;aop:after method=&quot;afterRun&quot; pointcut-ref=&quot;go&quot;&gt;&lt;/aop:after&gt;        &lt;/aop:aspect&gt;  &lt;/aop:config&gt;</code></pre><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>由Spring创建了一个car对象。Spring在创建该对象时，发现它的一个方法被配置成了切点（pointcut），所以，在实例化该对象时，会创建一个<strong>代理对象</strong>，<strong>当切点方法go()执行时，会被Spring创建的代理对象所拦截</strong>，运行go方法之前，会调用所对应的切面类CarLogger的前置方法beforeRun()，然后调用Car.go()方法，再然后就调用切面类CarLogger的后置方法afterRun()。 </p><h2 id="基于注解实现的SpringAOP"><a href="#基于注解实现的SpringAOP" class="headerlink" title="基于注解实现的SpringAOP"></a>基于注解实现的SpringAOP</h2><p>略</p><h2 id="看完关于ioc-bean装载和aop之后的思考"><a href="#看完关于ioc-bean装载和aop之后的思考" class="headerlink" title="看完关于ioc,bean装载和aop之后的思考"></a>看完关于ioc,bean装载和aop之后的思考</h2><p>IOC即DI,不必调用者自己去new被调用对象，而是通过spring IOC容器把配置好的bean对象注入，可以通过设置注入即setter方法和构造器注入。bean装载可以通过xml配置设定，也可以同过设定扫描路径，然后通过注解来让容器识别到要装载的bean。aop面向切面编程，切面与业务是垂直的，不同业务往往都要做一些公共的类似的额外操作，在业务之前做，或在业务之后做，或在业务出了异常时做，或者在业务前后都要做，甚至这些要做的额外操作要用到业务本身的输入参数和业务完成的输出结果。比如业务一般都得记录日志，比如涉及数据更新的业务完成后都得伴随数据库操作，账户各种操作前都要验证用户权限，这些业务伴随的操作往往大致相似，如果每个业务都要写这些操作，特别繁琐，把这些操作提出来就成了切面，与业务分离。xml 和API方式都可以实现aop配置,pointcut是业务，aspect是切面，它俩怎么交互执行，怎么传参和调用结果，都可以通过xml和API方式实现。另外还有配置代理这一块比较蒙逼。最牛逼的是，之前看得傻了眼那么繁琐和复杂的xml,api方式用简单直观的aspectj方式竟然能等效实现，用的纯Java标签，在xml 里设一下自动代理。不过仅仅@Aspect容器不识别，要加上@Component 才识别。我觉得标签简直就是福音，差点我就被吓的放弃了。我以为一辈子就只能写xml了。orz。。。</p><p>1、若代理类有接口，使用JDK代理。也可以通过设置proxyTargetClass为true,强制使用CGLIB代理</p><p>1、若代理类无接口，使用CGLIB代理</p><p>3、如果proxyInterfaces属性被设置为一个或者多个全限定接口名，则使用JDK代理；如果该属性没有被设置，但是目标类实现了接口，也使用JDK代理。</p><h2 id="三、Spring事务管理"><a href="#三、Spring事务管理" class="headerlink" title="三、Spring事务管理"></a>三、Spring事务管理</h2><p>事务：指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败</p><p>Spring事务管理主要包含3个接口</p><ul><li><p>PlatformTransactionManager–事务管理器</p></li><li><p>TransactionDefinition–事务定义信息(隔离、传播、超时、只读)</p></li><li><p>TransactionStatus–事务具体运行状态</p></li></ul><p>以上三个接口详细看Spring api即可，下面简要介绍几个重点知识。</p><h3 id="PlatformTransactionManager–事务管理器"><a href="#PlatformTransactionManager–事务管理器" class="headerlink" title="PlatformTransactionManager–事务管理器"></a>PlatformTransactionManager–事务管理器</h3><p><img src="https://img.braincao.cn/blogimg/1583754072.png" alt="1583754072"></p><h3 id="TransactionDefinition–事务定义信息-隔离、传播、超时、只读"><a href="#TransactionDefinition–事务定义信息-隔离、传播、超时、只读" class="headerlink" title="TransactionDefinition–事务定义信息(隔离、传播、超时、只读)"></a>TransactionDefinition–事务定义信息(隔离、传播、超时、只读)</h3><p>事务的传播行为：web层-&gt;业务层(Service)-&gt;持久层(DAO)</p><p><img src="https://img.braincao.cn/blogimg/1583754081.jpg" alt="1583754081"></p><h3 id="TransactionStatus–事务具体运行状态"><a href="#TransactionStatus–事务具体运行状态" class="headerlink" title="TransactionStatus–事务具体运行状态"></a>TransactionStatus–事务具体运行状态</h3><p>略</p><h3 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h3><p>spring支持两种方式事务管理：</p><ul><li><p>编程式事务管理</p><p>  在实际应用中很少使用，通过TransactionTemplate手动管理事务</p></li><li><p>使用<strong>XML配置声明式事务</strong></p><p>  开发中推荐使用(代码侵入性最小)，spring的声明式事务是通过<strong>AOP</strong>实现的</p></li></ul><h2 id="spring事务实践–转账案例"><a href="#spring事务实践–转账案例" class="headerlink" title="spring事务实践–转账案例"></a>spring事务实践–转账案例</h2><p>具体可看 <a href="https://www.imooc.com/video/9330" target="_blank" rel="noopener">转账案例</a></p><h2 id="声明式事务管理的三种方式"><a href="#声明式事务管理的三种方式" class="headerlink" title="声明式事务管理的三种方式"></a>声明式事务管理的三种方式</h2><p>详情参考<a href="https://www.imooc.com/video/9333" target="_blank" rel="noopener">声明式事务管理的三种方式</a></p><p>声明式事务管理的三种方式：基于TransactionProxyFactoryBean的方式(很少使用)，基于AspectJ的配置方式(经常)，以及基于注解的方式(经常)。</p><h3 id="基于TransactionProxyFactoryBean的方式"><a href="#基于TransactionProxyFactoryBean的方式" class="headerlink" title="基于TransactionProxyFactoryBean的方式"></a>基于TransactionProxyFactoryBean的方式</h3><p><img src="https://img.braincao.cn/blogimg/1583754099.jpg" alt="1583754099"></p><p>基于TransactionProxyFactoryBean的方式不常用，因为要对需要事务的每个类都设置一个代理类，繁琐</p><h3 id="基于AspectJ的配置方式"><a href="#基于AspectJ的配置方式" class="headerlink" title="基于AspectJ的配置方式"></a>基于AspectJ的配置方式</h3><pre><code class="html">    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!--配置连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--配置事务的通知(事务增强)(基于aspectj声明式事务管理)--&gt;    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;        &lt;tx:attributes&gt;            &lt;!--                propagation      :传播事务行为                isolation        :事务隔离级别                read             :只读                rollback-for     :发生哪些异常回滚                no-rollback-for  :发生哪些异常不回滚            --&gt;            &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!--配置aop--&gt;    &lt;aop:config&gt;        &lt;!--配置切入点 AccountService+表示所有其子类--&gt;        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* transactiondemo02.service.AccountService+.*(..))&quot;&gt;&lt;/aop:pointcut&gt;        &lt;!--配置切面:表示在pointcut切入点上应用txAdvice增强--&gt;        &lt;!--advisor表示有一个切入点的，aspect表示有多个切入点的--&gt;        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot;&gt;&lt;/aop:advisor&gt;    &lt;/aop:config&gt;</code></pre><h3 id="基于注解的事务管理配置方式"><a href="#基于注解的事务管理配置方式" class="headerlink" title="基于注解的事务管理配置方式"></a>基于注解的事务管理配置方式</h3><p>很明显这个更简单啊！</p><p>xml:</p><pre><code class="html">    &lt;!--配置事务管理器--&gt;    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;!--配置连接池--&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!--开启注解事务--&gt;    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</code></pre><p>ServiceImpl:  </p><pre><code class="html">    //注解式的事务管理    @Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT))    public class AccountServiceImpl implements AccountService {</code></pre><p>@Transactional的属性：</p><p>​```<br>propagation      :传播事务行为<br>isolation        :事务隔离级别<br>readOnly         :只读<br>rollbackFor      :发生哪些异常回滚<br>noRollbackFor    :发生哪些异常不回滚</p><pre><code>## 四、Spring MVCmvc: Model-Viewer-Controllermvc的核心思想是业务数据**抽取**同业务数据**呈现**相**分离**。前端控制器Front Controller(MVC)![1583754122](https://img.braincao.cn/blogimg/1583754122.jpg)Spring MVC为我们提供了一个基于组件和松耦合的MVC实现框架。在使用Java中其它MVC框架多年之后，面对Spring MVC有一种相见恨晚的感觉。Spring MVC是如此的优雅，轻盈与简洁， 让人从其它框架的桎梏解脱出来。SpringMVC是一个基于DispatcherServlet的MVC框架，每一个请求最先访问的都是DispatcherServlet，DispatcherServlet负责转发每一个Request请求给相应的Handler，Handler处理以后再返回相应的视图(View)和模型(Model)，返回的视图和模型都可以不指定，即可以只返回Model或只返回View或都不返回。SpringMVC是基于DispatcherServlet的，DispatcherServlet是继承自HttpServlet的，HttpServlet是在web.xml文件中声明的。(相关配置请左转至: maven_pom等相关配置)![1583754147](https://img.braincao.cn/blogimg/1583754147.png)如图，其中我们最主要写的就是Controller，其他的基本都是框架的东西。### Spring MVC具体的项目实践详情参考下面，重点学习了四大块:- 基本的controller编写- 数据绑定- 文件上传- json协同视频：[Spring MVC实操](https://www.imooc.com/video/7681)视频太慢并且已经看完，复习直接看这个人的同步笔记即可[Spring MVC起步](https://www.cnblogs.com/zjfjava/p/6746704.html)这个视频我自己学习实践的同步工程也已上传到github了，直接看自己的项目工程即可**[springmvc_demoproject](https://github.com/braincao/springmvc_demoproject)**注意：项目工程的WEB-INF下所有文件是私有的，必须经过后端调用才能访问到的，如果要公共访问的东西需要放在webapps目录下### controller三种方式controller的多种操作：基本的controller编写、数据绑定、文件上传、json协同```javapackage com.braincao.controller;import com.braincao.model.Course;import com.braincao.service.CourseService;import org.apache.commons.io.FileUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.File;import java.io.IOException;import java.util.Map;@Controller@RequestMapping(&quot;/courses&quot;)public class CourseController {    private CourseService courseService;    @Autowired    public void setCourseService(CourseService courseService) {        this.courseService = courseService;    }    //法一：本方法将处理http://localhost:8080/courses/view?courseId=123    //此方法url中必须指定?courseId=xxx的参数名courseId，参数名不可自适应改变，不好    // @RequestParam 和@PathVariable绑定了请求中的参数。@RequestParam(&quot;courseId&quot;)显式指明参数    @RequestMapping(value = &quot;/view&quot;, method = RequestMethod.GET)    public String viewCourse(@RequestParam(&quot;courseId&quot;) Integer courseId, Model model){//Model就是spring mvc的部分        Course course = courseService.getCoursebyId(courseId);        model.addAttribute(course);//将查询到的course放到model中        return &quot;course_overview&quot;;//返回jsps目录下的course_overview.jsp    }    //法二：这个方法就不用指定参数名courseId了，自动识别/view2/后面的东西并放到mvc中    @RequestMapping(value = &quot;/view2/{courseId}&quot;, method = RequestMethod.GET)    public String viewCourse2(@PathVariable(&quot;courseId&quot;) Integer courseId, Map&lt;String, Object&gt; model){//Model就是spring mvc的部分        Course course = courseService.getCoursebyId(courseId);        model.put(&quot;course&quot;, course);//将查询到的course放到model中        return &quot;course_overview&quot;;//返回jsps目录下的course_overview.jsp    }    //法三：上面两种方法都是spring mvc方法，下面这个是传统的HttpServletRequest方法    //处理/courses/view3?courseId=123形式的url    @RequestMapping(value = &quot;/view3&quot;, method = RequestMethod.GET)    public String viewCourse3(HttpServletRequest request){        Integer courseId = Integer.valueOf(request.getParameter(&quot;courseId&quot;));        Course course = courseService.getCoursebyId(courseId);        request.setAttribute(&quot;course&quot;, course);//将查询到的course放到model中        return &quot;course_overview&quot;;//返回jsps目录下的course_overview.jsp    }    //绑定binding：将请求中的字段(前端)按照名字匹配原则填入模型对象(后端)    //处理/courses/create?add形式的url来创建表单,表示一个参数params = &quot;add&quot;    @RequestMapping(value = &quot;/create&quot;, method=RequestMethod.GET, params = &quot;add&quot;)    public String createCourse(){        return &quot;admin_create/edit&quot;;//二级目录也能行哦    }    //绑定binding法一：不用@ModelAttribute    @RequestMapping(value = &quot;/save&quot;, method = RequestMethod.POST)    public String doSave(Course course){        //这里进行业务操作，比如数据库持久化        course.setCourseId(456);        return &quot;redirect:view2/&quot; + course.getCourseId();//请求重定向：因为这里提交表单后courseId更新了，需要请求重定向，这样就完成更新    }    //绑定binding法二：用@ModelAttribute也可以    @RequestMapping(value = &quot;/save2&quot;, method = RequestMethod.POST)    public String doSave2(@ModelAttribute Course course){        //这里进行业务操作，比如数据库持久化        course.setCourseId(456);        return &quot;redirect:view2/&quot; + course.getCourseId();//请求重定向：因为这里提交表单后courseId更新了，需要请求重定向，这样就完成更新    }    //文件上传的controller    @RequestMapping(value = &quot;/upload&quot;, method = RequestMethod.GET)    public String showUploadPage(){        return &quot;admin_upload/edit&quot;;    }    @RequestMapping(value = &quot;/doUpload&quot;, method = RequestMethod.POST)    public String showUploadPage(@RequestParam(&quot;file&quot;) MultipartFile file) throws IOException {//file从页面上来        if(!file.isEmpty()){//无损的(InputStream)将上传的文件保存到指定目录下，并返回success界面            FileUtils.copyInputStreamToFile(file.getInputStream(), new File(&quot;/Users/braincao&quot;, System.currentTimeMillis()+file.getOriginalFilename()));        }        return &quot;admin_upload/success&quot;;    }    //JSON格式的前后端交互之一：给定courseId，返回对应课程的json数据，给前端展示    @RequestMapping(value=&quot;/{courseId}&quot;, method = RequestMethod.GET)    public @ResponseBody Course getCourseInJson(@PathVariable Integer courseId){        return courseService.getCoursebyId(courseId);    }    //上面方法的第二种实现(泛型实现)。这两种都可以    @RequestMapping(value=&quot;/jsontype/{courseId}&quot;, method = RequestMethod.GET)    public ResponseEntity&lt;Course&gt; getCourseInJson2(@PathVariable Integer courseId){        Course course = courseService.getCoursebyId(courseId);        return new ResponseEntity&lt;Course&gt;(course, HttpStatus.OK);    }    //JSON格式的前后端交互之二：异步方式获取数据，前端通过js代码(ajax)来整合页面，    // 即前端写个框架本来没数据，运行时异步加载获取数据填充到界面中，    // 且注意前端的这个加载页面一定要放在webapps下，WEB-INF是私有的不能访问    // 现在用上面两个已实现的json交互方法进行：前端异步加载后端json数据的demo。给定json数据，返回对应课程的信息，前端展示信息界面    //启动tomcat后直接浏览器访问http://localhost:8080/courses_json.jsp?courseId=123即可}</code></pre><h3 id="Ajax异步获取服务端json数据并动态加载前端页面"><a href="#Ajax异步获取服务端json数据并动态加载前端页面" class="headerlink" title="Ajax异步获取服务端json数据并动态加载前端页面"></a>Ajax异步获取服务端json数据并动态加载前端页面</h3><p>启动tomcat后直接浏览器访问<a href="http://localhost:8080/courses_json.jsp?courseId=123即可" target="_blank" rel="noopener">http://localhost:8080/courses_json.jsp?courseId=123即可</a></p><p>webapps目录下的courses_json.jsp：</p><pre><code class="html">    &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;!--将jstl标签库引入此.jsp文件，简化jsp开发--&gt;    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD//XHTML 1.0 Transitional//EN&quot;    &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;    &lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;        &lt;title&gt;前端异步加载后端json数据的demo&lt;/title&gt;        &lt;%--这个css样式我没有，展示就简朴一点吧&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=request.getContextPath()%&gt;/resources/css/main.css&quot; type=&quot;text/html&quot;&gt;--%&gt;        &lt;!--引入本地jQuery--&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/resources/js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;script&gt;        jQuery(function($){            var urlStr = &quot;&lt;%=request.getContextPath()%&gt;/courses/&lt;%=request.getParameter(&quot;courseId&quot;)%&gt;&quot;;            //alert(&quot;Before Call: &quot; + urlStr);            $.ajax({//通过ajax异步从服务端拿到json数据并动态加载页面                method: &quot;GET&quot;,                url: urlStr,                success: function(data, status, jqXHR){                    //alert(&quot;Success: &quot; + data);                    var course = data;                    var path = &quot;&lt;%=request.getContextPath()%&gt;/&quot;;                    $(&quot;.course_title&quot;).text(course.courseTitle);                    $(&quot;.course_info&quot;).text(course.courseDesc);                    $(&quot;.course_imgPath&quot;).attr(&quot;src&quot;, path+course.imgPath);                    $(&quot;#course_duration&quot;).text(course.courseDuration);                }            });//end ajax        });    &lt;/script&gt;    &lt;body&gt;    &lt;p&gt;This is MvcHome, your world!&lt;/p&gt;    &lt;h3 class=&quot;course_title&quot;&gt;&lt;/h3&gt;    &lt;h3 class=&quot;course_info&quot;&gt;&lt;/h3&gt;    &lt;h3 id=&quot;course_duration&quot;&gt;&lt;/h3&gt;    &lt;div&gt;&lt;img class=&quot;course_imgPath&quot;/&gt;&lt;/div&gt;    &lt;/body&gt;    &lt;/html&gt;</code></pre><h2 id="springmvc拦截器"><a href="#springmvc拦截器" class="headerlink" title="springmvc拦截器"></a>springmvc拦截器</h2><p>拦截器是指通过统一拦截从浏览器发往服务器的请求来完成功能的增强，解决请求的共性问题(乱码、权限验证等问题)</p><p>springmvc过滤器也能起到一定的拦截器作用</p><p>拦截器的实现：</p><ul><li>1.编写拦截器类实现HandlerInterceptor接口(WebRequestInterceptor接口也可以，但不常用)</li><li>2.将拦截器注册进SpringMVC框架中(mvc-dispatcher-servlet.xml)</li><li>3.配置拦截器的拦截规划</li></ul><p>过滤器与拦截器的区别：</p><ul><li><p>过滤器Filter依赖于Servlet容器，基于回调函数，过滤范围大</p></li><li><p>拦截器Interceptor依赖于框架容器，基于反射机制，只拦截请求</p></li></ul><h2 id="MyBatis入门"><a href="#MyBatis入门" class="headerlink" title="MyBatis入门"></a>MyBatis入门</h2><p><a href="https://www.imooc.com/learn/154" target="_blank" rel="noopener">通过自动回复机器人学Mybatis</a></p><h3 id="mybatis的特点"><a href="#mybatis的特点" class="headerlink" title="mybatis的特点"></a>mybatis的特点</h3><p>1.sql语句与代码分离。优点：便于管理和维护；缺点：不便于调试，需要借助日志工具获得信息</p><p>2.用标签控制动态sql语句的拼接。优点：用标签代替编写逻辑代码；缺点：拼接复杂sql语句时，没有代码灵活，比较复杂</p><p>3.结果集与java对象的自动映射。优点：保证名称相同可自动映射；缺点：对开发人员所写的sql依赖性很强</p><p>4.编写原生sql。优点：接近JDBC，很灵活；缺点：对sql语句依赖很高(不同数据库sql语句可能不相同)，半自动，数据库移植不方便</p><h4 id="案例分析："><a href="#案例分析：" class="headerlink" title="案例分析："></a>案例分析：</h4><ul><li><p>基本功能</p><p>  接受发送指令</p><p>  根据指令自动回复对应的内容</p></li><li><p>模块划分</p><p>  回复内容列表</p><p>  回复内容维护–后台新建、更改、删除指令及对应回复的维护界面</p><p>  对话功能</p><p>  回复内容删除</p></li><li><p>项目开发流程(当然，每个人的开发顺序可能都不同)</p></li></ul><p><img src="https://img.braincao.cn/blogimg/1583754163.jpg" alt="1583754163"></p><h3 id="一、实战第一步–回复内容列表模块"><a href="#一、实战第一步–回复内容列表模块" class="headerlink" title="一、实战第一步–回复内容列表模块"></a>一、实战第一步–回复内容列表模块</h3><p>在没有 Mybatis的情况下，完整的<strong>Jsp + Servlet + Jdbc</strong>实现案例中的回复内容列表模块，流程如下。</p><p>1.数据库建表</p><p>2.写一个jsp前端界面</p><p>3.servlet：</p><ul><li><p>web.xml中注册一个servlet并建立映射请求</p></li><li><p>写一个servlet类继承HttpServlet，重写doGet、doPost方法，用：访问数据库并把数据传给jsp。</p></li></ul><p>4.代码重构下：bean装数据实体、dao层jdbc数据库增删改查、service业务操作、servlet是前后端页面控制</p><p>下面是最简单完整的<strong>Jsp + Servlet + Jdbc</strong>实现代码，工程名MicroMessage_jdbc。</p><p><img src="https://img.braincao.cn/blogimg/1583754180.jpg" alt="1583754180"></p><p>bean.Message:<br>​<br>​```java<br>package com.braincao.bean;</p><p>/**</p><ul><li>@FileName: Message</li><li>@Author: braincao</li><li>@Date: 2018/11/18 23:18</li><li>@Description: 与数据库信息对应的实体类</li><li>一个表对应一个类、表中的一个列属性对应一个成员</li><li>/</li></ul><p>public class Message {<br>    //主键<br>    private String id;</p><pre><code>//指令名称private String  command;//描述private String description;//内容private String content;public String getId() {    return id;}public void setId(String id) {    this.id = id;}public String getCommand() {    return command;}public void setCommand(String command) {    this.command = command;}public String getDescription() {    return description;}public void setDescription(String description) {    this.description = description;}public String getContent() {    return content;}public void setContent(String content) {    this.content = content;}</code></pre><p>}</p><pre><code>dao.MessageDao:```javapackage com.braincao.dao;import com.braincao.bean.Message;import java.sql.*;import java.util.ArrayList;import java.util.List;/** * @FileName: MessageDao * @Author: braincao * @Date: 2018/11/19 15:42 * @Description: 使用jdbc访问数据库，和message表相关的数据库操作 */public class MessageDao {    /**     * 根据查询条件查询消息列表     * @param : 查询条件：command指令名称、description描述     * @return : 根据查询条件查询到的结果     */    public List&lt;Message&gt; queryListMessage(String command, String description){        List&lt;Message&gt; messageList = new ArrayList&lt;&gt;();//把查询出来的结果放在这里        try {            //连接jdbc数据库            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            //下面一定要再jdbc的数据库连接地址后面加?useUnicode=true&amp;characterEncoding=UTF-8，否则查询不到，编码问题            Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://127.0.0.1:3306/micro_message?useUnicode=true&amp;characterEncoding=UTF-8&quot;, &quot;root&quot;, &quot;123456&quot;);            //拼接查询语句            StringBuilder sql = new StringBuilder(&quot;SELECT ID, COMMAND, DESCRIPTION, CONTENT FROM message WHERE 1=1&quot;);            List&lt;String&gt; paramList = new ArrayList&lt;&gt;();            if(command!=null &amp;&amp; !&quot;&quot;.equals(command.trim())){//查询                sql.append(&quot; AND COMMAND= ?&quot;);                paramList.add(command);            }            if(description!=null &amp;&amp; !&quot;&quot;.equals(description.trim())){//查询                sql.append(&quot; AND DESCRIPTION LIKE &#39;%&#39; ? &#39;%&#39;&quot;);//%是sql的通配符，类似于*                paramList.add(description);            }            PreparedStatement statement = conn.prepareStatement(sql.toString());//防止sql注入            for(int i=0; i&lt;paramList.size(); ++i){//给之前的sql语句中的 ? 赋值                statement.setString(i+1, paramList.get(i));            }            //执行sql查询语句，将查询到的结果添加到messageList列表中            ResultSet rs = statement.executeQuery();            while(rs.next()){                Message message = new Message();                message.setId(rs.getString(&quot;ID&quot;));                message.setCommand(rs.getString(&quot;COMMAND&quot;));                message.setDescription(rs.getString(&quot;DESCRIPTION&quot;));                message.setContent(rs.getString(&quot;CONTENT&quot;));                messageList.add(message);            }        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (SQLException e) {            e.printStackTrace();        }        //返回查询结果        return messageList;    }}</code></pre><p>service.ListService:</p><pre><code class="java">package com.braincao.service;import com.braincao.bean.Message;import com.braincao.dao.MessageDao;import java.util.List;/** * @FileName: ListService * @Author: braincao * @Date: 2018/11/19 15:50 * @Description: 和message表相关的业务操作 */public class ListService {    public List&lt;Message&gt; queryListMessage(String command, String description){        MessageDao messageDao = new MessageDao();        return messageDao.queryListMessage(command, description);    }}servlet.ListServlet:package com.braincao.servlet;import com.braincao.service.ListService;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @FileName: ListServlet * @Author: braincao * @Date: 2018/11/18 21:15 * @Description: 列表页面初始化控制的servlet，使用jdbc访问数据库 */@SuppressWarnings(&quot;serial&quot;)public class ListServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        //设置编码格式        req.setCharacterEncoding(&quot;UTF-8&quot;);        //接受页面的值        String command = req.getParameter(&quot;command&quot;);        String description = req.getParameter(&quot;description&quot;);        //向页面传值        req.setAttribute(&quot;command&quot;, command);        req.setAttribute(&quot;description&quot;, description);        //查询消息列表并传给前端页面        ListService listService = new ListService();        req.setAttribute(&quot;messageList&quot;, listService.queryListMessage(command, description));        req.getRequestDispatcher(&quot;/WEB-INF/jsps/back/list.jsp&quot;).forward(req, resp);//把数据传给前端jsp    }    @Override    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        this.doGet(req, resp);    }}</code></pre><p>前端list.jsp：</p><pre><code class="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD//XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;    &lt;title&gt;留言评论功能&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=request.getContextPath()%&gt;/resources/css/base.css&quot;/&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=request.getContextPath()%&gt;/resources/css/jquery.datetimepicker.css&quot;/&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=request.getContextPath()%&gt;/resources/css/plan.css&quot;/&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/resources/js/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/resources/js/jquery.datetimepicker.full.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/resources/js/store.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%=request.getContextPath()%&gt;/resources/js/plan2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=&quot;background: #e1e9eb;&quot;&gt;&lt;form id=&quot;form&quot; action=&quot;&lt;%=request.getContextPath()%&gt;/list.action&quot; method=&quot;post&quot;&gt;    &lt;div class=&quot;right&quot;&gt;        &lt;div class=&quot;current&quot;&gt;当前位置: &lt;a href=&quot;javascript:void(0)&quot; style=&quot;color:#6e6e6e;&quot;&gt;哈哈&lt;/a&gt;&lt;/div&gt;        &lt;div class=&quot;rightCont&quot;&gt;            &lt;p class=&quot;g_title fix&quot;&gt;内容列表: &lt;a class=&quot;btn03&quot; href=&quot;#&quot;&gt;新增&lt;/a&gt;&lt;/p&gt;            &lt;table class=&quot;tab1&quot;&gt;                &lt;tbody&gt;                &lt;tr&gt;                    &lt;td width=&quot;90&quot; align=&quot;right&quot;&gt;指令名称: &lt;/td&gt;                    &lt;td&gt;                        &lt;input name=&quot;command&quot; type=&quot;text&quot; class=&quot;allInput&quot; value=&quot;${command}&quot;/&gt;                    &lt;/td&gt;                    &lt;td name=&quot;description&quot; width=&quot;90&quot; align=&quot;right&quot;&gt;描述: &lt;/td&gt;                    &lt;td&gt;                        &lt;input name=&quot;description&quot; type=&quot;text&quot; class=&quot;allInput&quot; value=&quot;${description}&quot;/&gt;                    &lt;/td&gt;                    &lt;td width=&quot;85&quot; align=&quot;right&quot;&gt;&lt;input type=&quot;submit&quot; class=&quot;tabSub&quot; value=&quot;查询&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;/tbody&gt;            &lt;/table&gt;            &lt;div class=&quot;zuxun fix&quot;&gt;                &lt;table class=&quot;tab2&quot; width=&quot;100%&quot;&gt;                    &lt;tbody align=&quot;center&quot;&gt;                    &lt;!--表格中第一行的表头--&gt;                    &lt;tr  style=&quot;background-color: #33aaff&quot;&gt;                        &lt;th&gt;&lt;input type=&quot;checkbox&quot; id=&quot;all&quot; onclick=&quot;#&quot;/&gt;&lt;/th&gt;                        &lt;th&gt;序号&lt;/th&gt;                        &lt;th&gt;指令名称&lt;/th&gt;                        &lt;th&gt;描述&lt;/th&gt;                        &lt;th&gt;操作&lt;/th&gt;                    &lt;/tr&gt;                    &lt;!--表格的数据部分，隔行换色--&gt;                    &lt;c:forEach items=&quot;${messageList}&quot; var=&quot;message&quot; varStatus=&quot;status&quot;&gt;                        &lt;tr &lt;c:if test=&quot;${status.index%2!=0}&quot;&gt;style=&quot;background-color: #33aaff&quot;&lt;/c:if&gt; &gt;                            &lt;!--th是表格中第一行的表头--&gt;                            &lt;td&gt;&lt;input type=&quot;checkbox&quot;/&gt;&lt;/td&gt;                            &lt;td&gt;${status.index + 1}&lt;/td&gt;                            &lt;td&gt;${message.command}&lt;/td&gt;                            &lt;td&gt;${message.description}&lt;/td&gt;                            &lt;td&gt;                                &lt;a href=&quot;#&quot;&gt;修改&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;                                &lt;a href=&quot;#&quot;&gt;删除&lt;/a&gt;                            &lt;/td&gt;                        &lt;/tr&gt;                    &lt;/c:forEach&gt;                    &lt;/tbody&gt;                &lt;/table&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/form&gt;&lt;/body&gt;</code></pre><p>web.xml代码:</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot;          xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee          http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt;&lt;!--注意这里要把maven新建项目时自动生成的web.xml头部替换成上面的头部，这样就能自动支持spring EL--&gt;  &lt;display-name&gt;Mybatis Demo Study&lt;/display-name&gt;  &lt;!--注册一个servlet，用于列表页面初始化控制--&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.braincao.servlet.ListServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;ListServlet&lt;/servlet-name&gt;    &lt;!--将/list.action的URL请求映射到ListServlet--&gt;    &lt;url-pattern&gt;/list.action&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;</code></pre><h3 id="二、实战第二部–Mybatis实践"><a href="#二、实战第二部–Mybatis实践" class="headerlink" title="二、实战第二部–Mybatis实践"></a>二、实战第二部–Mybatis实践</h3><p>上面完成了在没有 Mybatis的情况下，完整的Jsp + Servlet + Jdbc实现案例中的回复内容列表模块。现在<strong>将JDBC部分替换为 Mybatis</strong>，实践如下。</p><p>mybatis作用</p><p><img src="https://img.braincao.cn/blogimg/1583754197.jpg" alt="1583754197"></p><p>mybatis特点：只需要给出参数+sql语句即可，剩下的数据表与实体的映射自动实现</p><h4 id="Mybatis之SqlSession"><a href="#Mybatis之SqlSession" class="headerlink" title="Mybatis之SqlSession"></a>Mybatis之SqlSession</h4><ul><li><p>SqlSession的作用</p><p>  1.向sql语句传入参数</p><p>  2.执行sql语句</p><p>  3.获取执行sql语句的结果</p><p>  4.事务的控制</p></li><li><p>如何得到SqlSession：</p><p>  1.通过配置文件获取数据库连接相关信息</p><p>  2.通过配置信息构建SqlSessionFactory</p><p>  3.通过SqlSessionFactory打开数据库会话</p></li></ul><p>Mybatis的配置文件conf.xml：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;!-- 配置数据库连接信息 --&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;XDP&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre><h4 id="OGNL表达式"><a href="#OGNL表达式" class="headerlink" title="OGNL表达式"></a>OGNL表达式</h4><p>在MessageMapper.xml中的sql语句中，要进行if、foreach等判断时，不能直接在&lt;&gt;中写，这时用强大的OGNL表达式(和jstl表达式类似)，它可以直接在标签中引入java语句。</p><p><img src="https://img.braincao.cn/blogimg/1583754226.jpg" alt="1583754226"></p><p><img src="https://img.braincao.cn/blogimg/1583754242.jpg" alt="1583754242"></p><p>注意的是原java语句中的&amp;&amp;，空字符串”” 等在标签中需要转义。如：<code>&quot; --&gt; &amp;quot;</code>  <a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener">这是常用对照表</a></p><p>MessageMapper.xml中select按照给定条件查询的语句如下：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名加sql映射文件名，这样就能够保证namespace的值是唯一的--&gt;&lt;mapper namespace=&quot;com.braincao.configs.sql.MessageMapper&quot;&gt;    &lt;!--确定映射关系，此命名空间下，id=MessageResult的resultMap所映射实体类是Message--&gt;    &lt;resultMap type=&quot;com.braincao.bean.Message&quot; id=&quot;MessageResult&quot;&gt;        &lt;!--左边数据库名，右边model实体名--&gt;        &lt;id column=&quot;ID&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;COMMAND&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;command&quot;/&gt;        &lt;result column=&quot;DESCRIPTION&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;description&quot;/&gt;        &lt;result column=&quot;CONTENT&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;content&quot;/&gt;    &lt;/resultMap&gt;    &lt;!--根据查询条件查询消息列表:parameterType是sql中参数的类型--&gt;    &lt;select id=&quot;queryListMessage&quot; parameterType=&quot;com.braincao.bean.Message&quot; resultMap=&quot;MessageResult&quot;&gt;        SELECT ID, COMMAND, DESCRIPTION, CONTENT FROM message WHERE 1=1        &lt;if test=&quot;command!=null and !&amp;quot;&amp;quot;.equals(command.trim())&quot;&gt;AND COMMAND = #{command}&lt;/if&gt;        &lt;if test=&quot;description!=null and !&amp;quot;&amp;quot;.equals(description.trim())&quot;&gt;AND DESCRIPTION LIKE &#39;%&#39; #{description} &#39;%&#39;&lt;/if&gt;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h4 id="log4j调试日志管理"><a href="#log4j调试日志管理" class="headerlink" title="log4j调试日志管理"></a>log4j调试日志管理</h4><p>xml中sql语句如果报错需要调试，没法像java代码一样打断点调试，这时就需要log4j了。<a href="https://www.cnblogs.com/wangzhuxing/p/7753420.html" target="_blank" rel="noopener">Log4J日志整合及配置详解</a></p><pre><code>#默认输出路径，下面指定为输出到控制台log4j.rootLogger=debug,logfile #debug是输出级别，logfile是输出的文件名(自定义)log4j.appender.logfile=org.apache.log4j.ConsoleAppender #定义上面的logfile是输出到控制台ConsoleAppenderlog4j.appender.logfile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logfile.layout.ConversionPattern=%d [%t] %-5p [%c] - %m %nlog4j.logger.org.apache=info #这是个性化，在指定包下的日志输出级别，会覆盖rootLogger的级别</code></pre><p>ConversionPattern=%d [%t] %-5p [%c] - %m %n。</p><p>%d时间，%t所处的线程名称，%-5p级别(-5表示至少占5个字，不足5个空格补齐，-5补齐的空格在右边，5-表示补齐的空格在左边),%c所在类的全名，%m附加信息，%n换行 </p><p>输出级别：</p><pre><code>#输出级别依次从低到高，如为debug，则四个全部输出log.debug(&quot;asf&quot;);log.info(message);log.warn(message);log.error(message);</code></pre><h4 id="重要-总结下项目分层后的逻辑"><a href="#重要-总结下项目分层后的逻辑" class="headerlink" title="重要!_总结下项目分层后的逻辑"></a>重要!_总结下项目分层后的逻辑</h4><p>setvlet：接收页面的值、像页面传值、如果有业务逻辑需要处理调用service进行处理</p><p>service：接收servlet传过来的处理要求，进行业务处理，如果有需要则调用相应的dao层</p><p>dao：完成与数据库的操作，这个过程用mybatis的sqlsession完成，具体的sql语句在mapper.xml中写</p><p>几个注意：</p><p>1.service处理的每个业务都要对应一个servlet，每个servlet都要在web.xml中注册</p><p>2.数据库中查询与增加、删除、修改操作不同，后三个修改数据库后sqlSession需要commit才会提交一个事务</p><h4 id="jsp、js文件"><a href="#jsp、js文件" class="headerlink" title="jsp、js文件"></a>jsp、js文件</h4><p>js中ajax的url要用路径，需要basePath,那么jsp调用js方法时不用传递参数，可以在jsp文件中埋一个hidden标签，之后在js中直接通过id就能找到basePath的参数，如下：</p><pre><code class="html">&lt;!--埋一个hidden便签，用于js调用--&gt;&lt;input type=&quot;hidden&quot; value=&quot;&lt;%= basePath %&gt;&quot; id=&quot;basePath&quot;/&gt;</code></pre><p>1.jsp文件：</p><pre><code class="html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;    &lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;    &lt;title&gt;微信公众号&lt;/title&gt;    &lt;!--讨论区滚动条begin--&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;%= basePath %&gt;resources/css/jscrollpane1.css&quot; /&gt;    &lt;script src=&quot;&lt;%= basePath %&gt;resources/js/common/jquery.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;    &lt;!-- the mousewheel plugin --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= basePath %&gt;resources/js/common/jquery.mousewheel.js&quot;&gt;&lt;/script&gt;    &lt;!-- the jScrollPane script --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= basePath %&gt;resources/js/common/jquery.jscrollpane.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= basePath %&gt;resources/js/common/scroll-startstop.events.jquery.js&quot;&gt;&lt;/script&gt;    &lt;!--讨论区滚动条end--&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= basePath %&gt;resources/js/front/talk.js&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;input type=&quot;hidden&quot; value=&quot;&lt;%= basePath %&gt;&quot; id=&quot;basePath&quot;/&gt;        &lt;br/&gt;        &lt;div class=&quot;talk&quot;&gt;            &lt;div class=&quot;talk_title&quot;&gt;&lt;span&gt;正在与公众号对话&lt;/span&gt;&lt;/div&gt;            &lt;div class=&quot;talk_record&quot;&gt;                &lt;div id=&quot;jp-container&quot; class=&quot;jp-container&quot;&gt;                    &lt;div class=&quot;talk_recordbox&quot;&gt;                        &lt;div class=&quot;user&quot;&gt;&lt;img src=&quot;&lt;%= basePath %&gt;images/thumbs/talk_recordbox.jpg&quot;/&gt;公众号&lt;/div&gt;                        &lt;div class=&quot;talk_recordtextbg&quot;&gt;&amp;nbsp;&lt;/div&gt;                        &lt;div class=&quot;talk_recordtext&quot;&gt;                            &lt;h3&gt;客官，来啦，坐吧！回复[查看]收取更多精彩内容。&lt;/h3&gt;                            &lt;span class=&quot;talk_time&quot;&gt;2018年11月20日21:30:07&lt;/span&gt;                        &lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;talk_recordboxme&quot;&gt;                        &lt;div class=&quot;user&quot;&gt;&lt;img src=&quot;&lt;%= basePath %&gt;images/thumbs/talk_recordboxme.jpg&quot;/&gt;公众号&lt;/div&gt;                        &lt;div class=&quot;talk_recordtextbg&quot;&gt;&amp;nbsp;&lt;/div&gt;                        &lt;div class=&quot;talk_recordtext&quot;&gt;                            &lt;h3&gt;查看&lt;/h3&gt;                            &lt;span class=&quot;talk_time&quot;&gt;2018年11月20日21:30:07&lt;/span&gt;                        &lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;            &lt;div class=&quot;talk_word&quot;&gt;                &amp;nbsp;                &lt;input class=&quot;add_face&quot; id=&quot;facial&quot; type=&quot;button&quot; title=&quot;添加表情&quot; value=&quot;&quot; /&gt;                &lt;input id=&quot;content&quot; class=&quot;messages emotion&quot;   /&gt;                &lt;input class=&quot;talk_send&quot; onclick=&quot;send();&quot; type=&quot;button&quot; title=&quot;发送&quot; value=&quot;发送&quot; /&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div style=&quot;text-align:center;margin:50px 0; font:normal 14px/24px &#39;MicroSoft YaHei&#39;;&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>2.前端jsp页面中需要的.js文件：</p><p>.js文件包含jsp中点击等操作触发的ajax动态查询后台加载页面的方法：</p><pre><code class="java">/** * 发送消息。前端界面输入文字，用ajax将文字传给后端，返回的回复动态加载到前端页面 * @param basePath */function send() {    var content = $(&quot;#content&quot;).val();//获取id为content文本框的文字    if(!content) {        alert(&quot;请输入内容！&quot;);        return;    }    $.ajax({        url : $(&quot;#basePath&quot;).val() + &quot;AutoReplyServlet.action&quot;,        type : &quot;POST&quot;,        dataType : &quot;text&quot;,//dataType期望服务端给我的响应类型        timeout : 10000,//超时时间        success : function (data) {//成功回调函数            appendDialog(&quot;talk_recordboxme&quot;,&quot;My账号&quot;,content); //在对话框中显示我发送的文字            appendDialog(&quot;talk_recordbox&quot;,&quot;公众号&quot;,data);//在对话框中显示后台的回复            $(&quot;#content&quot;).val(&quot;&quot;);//清空发送框中的文字            render();//这个东西是输入后在对话框中显示后计算是否需要出现滚动条的方法，知道干啥的就行了忽略这里的细节        },        data : {&quot;content&quot;:content}//向服务端发送ajax请求的参数    });</code></pre><h4 id="页面中点击按钮弹出一个带有输入框的对话框"><a href="#页面中点击按钮弹出一个带有输入框的对话框" class="headerlink" title="页面中点击按钮弹出一个带有输入框的对话框"></a>页面中点击按钮弹出一个带有输入框的对话框</h4><p>不用看下面的代码了，直接bootstrap-modal，遇到这个需求的最大收获就是学到了bootstrap框架，简直神器。</p><pre><code class="html">&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;My Test Document&lt;/title&gt;&lt;style&gt;.box{    width:50%; margin-top:10%; margin:auto; padding:28px;    height:350px; border:1px #111 solid;    display:none;            /* 默认对话框隐藏 */}.box.show{display:block;} .box .x{ font-size:18px; text-align:right; display:block;}.box input{width:80%; font-size:18px; margin-top:18px;}&lt;/style&gt;&lt;/head&gt;  &lt;body&gt;     &lt;h2&gt;测试&lt;/h2&gt;    &lt;input type=&quot;button&quot; onClick=&quot;msgbox(1)&quot; value=&quot;点击弹出输入框&quot;&gt;    &lt;script&gt;          function msgbox(n){            document.getElementById(&#39;inputbox&#39;).style.display=n?&#39;block&#39;:&#39;none&#39;;     /* 点击按钮打开/关闭 对话框 */        }     &lt;/script&gt;       &lt;div id=&#39;inputbox&#39; class=&quot;box&quot;&gt;        &lt;a class=&#39;x&#39; href=&#39;&#39;; onclick=&quot;msgbox(0); return false;&quot;&gt;关闭&lt;/a&gt;        &lt;input type=&quot;text&quot;&gt;        &lt;input type=&quot;text&quot;&gt;        &lt;input type=&quot;button&quot; value=&quot;确定&quot;&gt;     &lt;/div&gt;&lt;/body&gt;</code></pre><h4 id="input-默认提示文字，点击清空，移出时恢复提示"><a href="#input-默认提示文字，点击清空，移出时恢复提示" class="headerlink" title="input 默认提示文字，点击清空，移出时恢复提示"></a>input 默认提示文字，点击清空，移出时恢复提示</h4><pre><code class="html">    &lt;input type=&quot;text&quot; value=&quot;模糊型号查询&quot; onfocus=&quot;if(value==&#39;模糊型号查询&#39;) {value=&#39;&#39;}&quot; onblur=&quot;if (value==&#39;&#39;) {value=&#39;模糊型号查询&#39;}&quot; name=&quot;keyword&quot; size=&quot;30&quot; style=&quot;color:#e5e1e1;&quot;/&gt;</code></pre><h4 id="SQL联合查询-主表与子表联合查询-–left-join-on"><a href="#SQL联合查询-主表与子表联合查询-–left-join-on" class="headerlink" title="SQL联合查询(主表与子表联合查询)–left join on"></a>SQL联合查询(主表与子表联合查询)–left join on</h4><pre><code class="sql">SELECT A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B ON A.COMMAND_ID=B.COMMAND_ID WHERE A.COMMAND_ID=&#39;查看&#39;;</code></pre><p>这里需要注意一个问题，请看这个<a href="https://blog.csdn.net/weixin_36174051/article/details/80377061" target="_blank" rel="noopener">LEFT JOIN 使用时的注意事项</a>、<a href="https://blog.csdn.net/xingfeng0501/article/details/7816703" target="_blank" rel="noopener">left join on and 与 left join on where的区别</a></p><p>具体的实践如下，一个CommandMapper.xml文件：</p><p>注意 <code>&lt;id column=&quot;A_ID&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;</code> 中的A_ID不能是ID</p><p>代码：</p><pre><code class="html">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名加sql映射文件名，这样就能够保证namespace的值是唯一的--&gt;&lt;mapper namespace=&quot;CommandMapper&quot;&gt;&lt;!--确定映射关系，此命名空间下，id=CommandResult的resultMap所映射实体类是Command--&gt;&lt;resultMap type=&quot;com.braincao.bean.Command&quot; id=&quot;CommandResult&quot;&gt;    &lt;!--左边数据库名，右边model实体名--&gt;    &lt;id column=&quot;A_ID&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot;/&gt;    &lt;result column=&quot;COMMAND&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;command&quot;/&gt;    &lt;result column=&quot;DESCRIPTION&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;description&quot;/&gt;    &lt;!--一对多的映射关系：主表包含字表的集合--&gt;    &lt;collection resultMap=&quot;CommandContentMapper.CommandContentResult&quot; property=&quot;commandContentList&quot;/&gt;&lt;/resultMap&gt;&lt;!--根据查询条件查询消息列表:parameterType表示传入的参数类型--&gt;&lt;select id=&quot;queryListCommand&quot; parameterType=&quot;com.braincao.bean.Command&quot; resultMap=&quot;CommandResult&quot;&gt;    SELECT A.ID A_ID,A.COMMAND,A.DESCRIPTION,B.CONTENT FROM COMMAND A LEFT JOIN COMMAND_CONTENT B    ON A.ID=B.COMMAND_ID    &lt;where&gt;        &lt;if test=&quot;command!=null and !&amp;quot;&amp;quot;.equals(command.trim())&quot;&gt;AND A.COMMAND = #{command}&lt;/if&gt;        &lt;if test=&quot;description!=null and !&amp;quot;&amp;quot;.equals(description.trim())&quot;&gt;AND A.DESCRIPTION LIKE &#39;%&#39; #{description} &#39;%&#39;&lt;/if&gt;    &lt;/where&gt;&lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="通过自动回复机器人学Mybatis—加强版–开始学习"><a href="#通过自动回复机器人学Mybatis—加强版–开始学习" class="headerlink" title="通过自动回复机器人学Mybatis—加强版–开始学习"></a>通过自动回复机器人学Mybatis—加强版–开始学习</h3><p>来源：<a href="https://www.imooc.com/learn/260" target="_blank" rel="noopener">通过自动回复机器人学Mybatis—加强版</a></p><h4 id="设计模式之代理模式"><a href="#设计模式之代理模式" class="headerlink" title="设计模式之代理模式"></a>设计模式之代理模式</h4><p>这个知识的学习至关重要，对后面的mybatis接口编程、spring-aop思想理解都有帮助，来源:<a href="https://www.imooc.com/learn/214" target="_blank" rel="noopener">模式的秘密—代理模式</a></p><p>代理模式定义：为其他对象提供一种代理以控制对这个对象的访问。</p><p>代理两种实现方式：静态代理、动态代理</p><p>静态代理又有两种实现方式：继承方式、聚合方式，其中聚合方式更适合静态代理。</p><h5 id="聚合方式的静态代理"><a href="#聚合方式的静态代理" class="headerlink" title="聚合方式的静态代理"></a>聚合方式的静态代理</h5><p>一个接口，实现了一个类，现在想对这个类进行代理，方便增加额外的服务。那么就创建一个代理类，实现相同的接口，用构造方法将原始接口传参进去，直接增加额外服务即可。如下：</p><pre><code class="java">package com.braincao.proxy;/** * @FileName: Car2 * @Author: braincao * @Date: 2018/11/23 16:06 * @Description: 相同的接口Moveable * CarLogProxy实现相同接口Moveable---使用聚合方式(一个类中调用另一个类)的静态代理 */public class CarLogProxy implements Moveable {    private Moveable moveable;    public CarLogProxy(Moveable moveable){        this.moveable = moveable;    }    @Override    public void move() {//为Car原始类增加额外功能        System.out.println(&quot;日志开始....&quot;);        moveable.move();        System.out.println(&quot;日志结束...&quot;);    }    public static void main(String[] args){//测试        Moveable car = new CarLogProxy(new Car());        car.move();    }}</code></pre><p>静态代理，每一个额外服务(日志记录、时间记录)都需要新建一个代理类，对汽车的日志记录和对火车的日志记录都需要新建，解决这个问题的方式就是动态代理。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理：动态产生代理，实现对不同类、不同方法的代理。动态代理也有两种：jdk动态代理、cglib动态代理</p><p>1.jdk动态代理</p><pre><code class="java">package com.braincao.jdkproxy;import com.braincao.proxy.Car;import com.braincao.proxy.Car3;import com.braincao.proxy.Moveable;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @FileName: TimeHandler * @Author: braincao * @Date: 2018/11/23 17:18 * @Description: jdk动态代理 */public class TimeHandler implements InvocationHandler{    private Object target;    public TimeHandler(Object target) {        this.target = target;    }    /*     * 参数：     * proxy--被代理对象     * method--被代理对象的方法     * args--被代理对象的方法的参数     * 返回：     * Object 被代理对象的方法的返回值     */    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        //开车起始时间        long startTime = System.currentTimeMillis();        System.out.println(&quot;汽车开始行驶....&quot;);        method.invoke(target);        //开车终止时间        long endTime = System.currentTimeMillis();        System.out.println(&quot;汽车停止行驶....行驶时间：&quot; + (endTime-startTime) + &quot;ms&quot;);        return null;    }    //动态代理测试    public static void main(String[] args){        Car car = new Car();        InvocationHandler h = new TimeHandler(car);        /**         * 生成代理类。         * 参数：         * loader 类的加载器         * interfaces 类的实现接口         * h(InvocationHandler)         */        Moveable m = (Moveable)Proxy.newProxyInstance(car.getClass().getClassLoader(),                car.getClass().getInterfaces(),h);        m.move();    }}</code></pre><p>2.cglib动态代理</p><p>下面的代码需引入cglib-nodep-2.2.jar包</p><pre><code class="java">package com.braincao.cglibproxy;​    import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @FileName: CglibProxy * @Author: braincao * @Date: 2018/11/23 17:45 * @Description: */public class CglibProxy implements MethodInterceptor {    private Enhancer enhancer = new Enhancer();    public Object getProxy(Class clazz){        //设置创建子类的类        enhancer.setSuperclass(clazz);        enhancer.setCallback(this);        return enhancer.create();    }    /*     *拦截所有目标类方法的调用     * 参数：     *  o 目标类的实例     *  method 目标方法     *  objects 方法的参数     *  methodProxy 代理类的实例     */    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;日志开始.....&quot;);        //代理类调用父类的方法        methodProxy.invokeSuper(o, objects);        System.out.println(&quot;日志结束.....&quot;);        return null;    }    public static void main(String[] args){        CglibProxy proxy = new CglibProxy();        Train train =(Train)proxy.getProxy(Train.class);        train.move();    }}</code></pre><p><strong>总结代理模式</strong>：日常项目中代理模式有很重要的作用，比如日志管理、事务处理、权限管理等，在不改变原有类的基础利用代理类增加额外功能，这个就是<strong>aop，面向切面编程</strong></p><p>动态代理的代理类是实现了一个InvocationHandler的接口，我们通过reflect.Proxy的类的newProxyInstance方法就可以得到这个接口的实例，然后再来作为参数传递进去，这里每一个在代理类上处理的东西也会被重定向到调用处理器上。</p><p>至于动态代理和静态代理的区别，即动态代理是动态的创建代理和动态的处理方法的，这也是反射的一个重要体现之处。<br>​    </p><h5 id="FileUtils类可以轻松对文件读写操作"><a href="#FileUtils类可以轻松对文件读写操作" class="headerlink" title="FileUtils类可以轻松对文件读写操作"></a>FileUtils类可以轻松对文件读写操作</h5><p>FileUtils.writeString(new File(filename), strData);</p><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>来源：</p><p><a href="https://www.imooc.com/video/3725" target="_blank" rel="noopener">反射专题视频</a></p><p><a href="https://www.cnblogs.com/haodawang/p/5967185.html" target="_blank" rel="noopener">Java动态代理与反射详解_博客</a></p><h5 id="1、反射–class类"><a href="#1、反射–class类" class="headerlink" title="1、反射–class类"></a>1、反射–class类</h5><p>任何一个类都是Class的实例对象，这个实例对象有三种表示方式。</p><p>1.Class c1 = Foo.class;</p><p>2.Class c2 = foo1.getClass();</p><p>3.</p><pre><code class="java">Class c3 = null;try{    try {        c3 = Class.forName(&quot;com.braincao.reflect.Foo&quot;);    } catch (ClassNotFoundException e) {        e.printStackTrace();    }}</code></pre><p>我们可以通过类的类类型创建该类的对象实例：</p><pre><code>Foo foo = (Foo) c1.newInstance();</code></pre><h5 id="2、反射–java动态加载类"><a href="#2、反射–java动态加载类" class="headerlink" title="2、反射–java动态加载类"></a>2、反射–java动态加载类</h5><p>编译时刻加载的类是静态加载类，运行时刻加载的类是动态加载类.</p><p>new创建对象是静态加载的类，在编译时刻就需要加载所有的可能使用到的类，即java代码中Word word=new Word();如果没有相关的Word类则编译不通过，找不到Word类，这就是静态加载的类</p><p>动态加载类：</p><pre><code class="java">package com.braincao.reflect;/** * @FileName: OfficeReflect * @Author: braincao * @Date: 2018/11/23 18:53 * @Description: */public class OfficeReflect {    public static void main(String[] args){        Class c1 = null;        try {            //动态加载类，在运行时刻加载            c1 = Class.forName(args[0]);//命令行输入想加载的类名(Word/Excel，他们都实现了接口Office)            Office office = (Office)c1.newInstance();//动态创建指定的对象            office.start();        } catch (ClassNotFoundException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InstantiationException e) {            e.printStackTrace();        }    }}</code></pre><h4 id="java方法的反射操作-重点"><a href="#java方法的反射操作-重点" class="headerlink" title="java方法的反射操作_重点"></a>java方法的反射操作_重点</h4><p>反射的操作是绕过编译，在运行时刻来操作的。</p><pre><code class="java">package com.braincao.reflect;import java.lang.invoke.MethodHandle;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @FileName: Reflect * @Author: braincao * @Date: 2018/11/23 20:36 * @Description: java的反射操作 */public class Reflect {    public static void main(String[] args){        //A a = new A();        //a.add(10, 20);        //java方法的反射操作        try {            Class c = A.class;            Method m = c.getMethod(&quot;add&quot;, new Class[]{int.class, int.class}); //获得方法对象            //Method m = c.getMethod(&quot;add&quot;, int.class, int.class); //这样写也行            m.invoke(c.newInstance(), 10, 20);//用方法对象进行反射操作        } catch (NoSuchMethodException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        } catch (InstantiationException e) {            e.printStackTrace();        } catch (InvocationTargetException e) {            e.printStackTrace();        }    }}class A{    public void add(int a, int b){        System.out.println(a + b);    }}</code></pre><h4 id="Mybatis-的接口式编程"><a href="#Mybatis-的接口式编程" class="headerlink" title="Mybatis 的接口式编程"></a>Mybatis 的接口式编程</h4><pre><code class="java">/** * @FileName: MessageDao * @Author: braincao * @Date: 2018/11/19 15:42 * @Description: 和command表相关的数据库操作 * 不用原始的jdbc了，用mybatis的sqlsession更方便的访问数据库，另外用了接口式编程，用反射来进行mapper.xml进行sql方法的调用 */public class CommandDao {    /**     * 根据查询条件查询指令列表。     * @param : 查询条件：command指令名称||description描述     * @return : 根据查询条件查询到的结果     */    public List&lt;Command&gt; queryCommandList(String commandData, String descriptionData) {        DBAccess dbAccess = new DBAccess();        List&lt;Command&gt; commandList = new ArrayList&lt;&gt;();//把查询出来的结果放在这里        SqlSession sqlSession = null;        try {            sqlSession = dbAccess.getSqlSession();//得到SqlSession            Command command = new Command();            command.setCommand(commandData);            command.setDescription(descriptionData);//把要传递的参数放在对象里，再把这个对象当成参数给SqlSession即可            //通过sqlSession执行sql语句,这里改成了接口式mybatis编程            //commandList = sqlSession.selectList(&quot;CommandMapper.queryListCommand&quot;, command);//xxx.Message是命名空间，queryListMessage是具体的sql语句            //用反射来操作:ICommandMapper是一个接口，里面有sql相关的方法，现在不创建ICommandMapper就调用其中的方法，用反射操作            ICommandMapper iCommandMapper = (ICommandMapper)sqlSession.getMapper(ICommandMapper.class);            commandList = iCommandMapper.queryListCommand(command);        } catch (IOException e) {            e.printStackTrace();        } finally {            if (sqlSession != null) {                sqlSession.close();            }        }        return commandList;    }</code></pre><p>总结接口式编程：</p><p>将：</p><pre><code>commandList = sqlSession.selectList(&quot;CommandMapper.queryListCommand&quot;, command);</code></pre><p>换成了：</p><pre><code>ICommandMapper iCommandMapper = sqlSession.getMapper(ICommandMapper.class);//反射操作，动态代理。getMapper方法返回时代理示例已经对目标示例进行强转，不需再(ICommandMapper)强转commandList = iCommandMapper.queryListCommand(command);</code></pre><h4 id="分页功能的实现1"><a href="#分页功能的实现1" class="headerlink" title="分页功能的实现1"></a>分页功能的实现1</h4><p>直接在加强版的项目上实现了，具体看代码实现</p><h4 id="分页功能的实现2–mybatis拦截器实现"><a href="#分页功能的实现2–mybatis拦截器实现" class="headerlink" title="分页功能的实现2–mybatis拦截器实现"></a>分页功能的实现2–mybatis拦截器实现</h4><p>为什么需要拦截器实现分页：上面虽然已经实现，但是实际项目中每一个页面都要重写一个分页功能，这样真成码农了，为了实现分页的共同处理，我们在不改变原来查询列表不分页显示的sql语句及相关逻辑基础上，用拦截器对需要分页的需求对象进行拦截，处理(在原来sql基础上拼接分页需要的limitsql语句，再返回查询结果即可)，实现共同处理。</p><p>视频来源: <a href="https://www.imooc.com/video/5929" target="_blank" rel="noopener">拦截器实现分页</a></p><p>mybatis拦截器是一个类似于log4j的能直接拿到配置文件中的sql参数的东西，有动态代理的思想。拦截器就是在不改变mybatis源码的情况下利用代理改变mybatis原本的一些逻辑行为便于我们更好的使用</p><p>拦截器要做的事：</p><ul><li>1.要拦截住</li><li>2.拦截下来做事(eg分页)</li><li>3.事情完成后要交回主权</li></ul><p>现将分页功能的实现1的实现去掉，恢复原来没有分页的功能的界面，现在要通过拦截器实现分页功能(即带byPage$结束符的sqlId进行拦截分页显示，不带byPage$结束符的sqlId的查询正常显示)</p><p>拦截器代码：(注意，写完拦截器需要在配置文件中注册拦截器)</p><pre><code class="java">package com.braincao.interceptor;import com.braincao.entity.Page;import org.apache.ibatis.executor.parameter.ParameterHandler;import org.apache.ibatis.executor.statement.StatementHandler;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.*;import org.apache.ibatis.reflection.DefaultReflectorFactory;import org.apache.ibatis.reflection.MetaObject;import org.apache.ibatis.reflection.SystemMetaObject;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.Map;import java.util.Properties;/** * @FileName: PageInterceptor * @Author: braincao * @Date: 2018/11/25 17:20 * @Description: 分页拦截器 * 实现mybatis的拦截器接口 *///下面的注解准确的描述了我们需要拦截的对象中的方法,本例中就是想获取mybatis中执行sql前能获取到sql语句的方法prepare@Intercepts({@Signature(type=StatementHandler.class, method=&quot;prepare&quot;, args={Connection.class})})public class PageInterceptor implements Interceptor {​        //invocation参数中就有被拦截下来的对象invocation.getTarget()，对拦截下来的对象处理    @Override    public Object intercept(Invocation invocation) throws Throwable {        //获取拦截下来的对象        StatementHandler statementHandler = (StatementHandler)invocation.getTarget();        //查看拦截下来的对象(查询需求)是否是想要实现分页的--即mapper.xml的查询id是否以&quot;byPage$&quot;结尾        //这里用mybatis已经封装好的MetaObject类来获取查询id        MetaObject metaObject = MetaObject.forObject(statementHandler,                SystemMetaObject.DEFAULT_OBJECT_FACTORY,                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,                new DefaultReflectorFactory());        MappedStatement mappedStatement =(MappedStatement) metaObject.getValue(&quot;delegate.mappedStatement&quot;);        String id = mappedStatement.getId();//拿到了mapper.xml该查询语句的id        if(id.matches(&quot;.+ByPage$&quot;)){//String.matches方法用来匹配            BoundSql boundSql = statementHandler.getBoundSql();            String sql = boundSql.getSql();//原来的sql查询语句            //原来的查询参数Map            Map&lt;?, ?&gt; parameter = (Map&lt;?, ?&gt;)boundSql.getParameterObject();            Page page = (Page) parameter.get(&quot;page&quot;);            //获取查询结果的总条数            String countSql = &quot;select count(*) from (&quot; + sql + &quot;)a&quot;; //a是别名            Connection connection = (Connection)invocation.getArgs()[0];            PreparedStatement countStatement = connection.prepareStatement(countSql);            ParameterHandler parameterHandler = (ParameterHandler)metaObject.getValue(&quot;delegate.parameterHandler&quot;);            parameterHandler.setParameters(countStatement);            ResultSet rs = countStatement.executeQuery();            if(rs.next()){                page.setTotalNumber(rs.getInt(1));//获取查询结果的总条数            }            //改造后的sql语句，拼接了分页需要的limit            String newSql = sql + &quot; limit &quot; + page.getDbIndex() + &quot;,&quot; + page.getDbNumber();            //将改造后的sql写入，偷天换日            metaObject.setValue(&quot;delegate.boundSql.sql&quot;, newSql);        }​            return invocation.proceed();//拦截下来对象，处理完成后，需要把拦截下来的对象主权返回，必须执行这步    }    //target就是被拦截下来的对象，返回的就是拦截下来动态代理的代理类对象    //this会根据上面的注解找到需要拦截对象和方法的class，用动态代理操作创建拦截对象的代理类target来进行处理    @Override    public Object plugin(Object target) {        return Plugin.wrap(target, this);    }    //这个是注册用的，如果已经在配置文件xml中注册了就不用在这里注册了    @Override    public void setProperties(Properties properties) {    }}</code></pre><p>总结拦截器的思路：</p><ul><li><p>1.创建拦截器类实现Interceptor接口，通过注解<code>@Intercepts({@Signature(type=StatementHandler.class, method=&quot;prepare&quot;, args={Connection.class})})</code>定位需要拦截的对象及方法</p></li><li><p>2.注册拦截器到配置文件中</p></li><li><p>3.逐步重写第一步中Interceptor接口的的方法，进行拦截、处理、返回</p></li></ul><h1 id="Java高并发秒杀API之业务分析与DAO层–开始学习"><a href="#Java高并发秒杀API之业务分析与DAO层–开始学习" class="headerlink" title="Java高并发秒杀API之业务分析与DAO层–开始学习"></a>Java高并发秒杀API之业务分析与DAO层–开始学习</h1><p>来源：<a href="https://www.imooc.com/learn/587" target="_blank" rel="noopener">Java高并发秒杀API之业务分析与DAO层</a> </p><p>本案例整合了上述的spring mvc + spring + mybatis，所以这个应该重点总结，重点回顾</p><h2 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h2><h4 id="需要的技术栈总结"><a href="#需要的技术栈总结" class="headerlink" title="需要的技术栈总结"></a>需要的技术栈总结</h4><p>mysql:</p><ul><li>表设计<br>​- sql技巧</li><li>事务和行级锁</li></ul><p>mybatis:</p><ul><li>dao层设计与开发</li><li>mybatis合理使用</li><li>mybatis与spring整合</li></ul><p>spring:</p><ul><li>spring IOC整合service</li><li>声明式事务运用</li></ul><p>spring MVC:</p><ul><li>Restful接口设计和使用</li><li>框架运作流程</li><li>Controller开发技巧</li></ul><p>前端:</p><ul><li>交互设计</li><li>bootstrap</li><li>jquery</li></ul><p>高并发:</p><ul><li>高并发点和高并发分析</li><li>优化思路并实现</li></ul><h4 id="秒杀业务分析"><a href="#秒杀业务分析" class="headerlink" title="秒杀业务分析"></a>秒杀业务分析</h4><p>1.秒杀业务流程分析–&gt;秒杀业务的核心：对库存的处理</p><p><img src="https://img.braincao.cn/blogimg/1583754258.jpg" alt="1583754258"></p><p>2.用户针对库存业务分析–&gt;减库存+记录购买明细</p><p>减库存+记录购买明细这两件事必须组成一个事务，否则将出现超卖/少卖情况。</p><p>关于数据落地的数据库选择：mysql vs nosql</p><p>mysql：关系型数据库。事务机制很好，本秒杀系统的案例采用mysql数据库</p><p>nosql：非关系型数据库。Redis、HBASE等，nosql创新很多，应用现在很挺多，追求性能，追求分布式，但是对事务的支持不是很好</p><p><img src="https://img.braincao.cn/blogimg/1583754304.jpg" alt="1583754304"></p><p>3.用户的购买行为：</p><p><img src="https://img.braincao.cn/blogimg/1583754294.jpg" alt="1583754294"></p><h4 id="mysql实现秒杀的难点分析–事务-行级锁"><a href="#mysql实现秒杀的难点分析–事务-行级锁" class="headerlink" title="mysql实现秒杀的难点分析–事务+行级锁"></a>mysql实现秒杀的难点分析–事务+行级锁</h4><p>事务：<br>​    </p><ul><li>1.start transaction</li><li>2.update 库存数量(这是重点，需要加行级锁)</li><li>3.insert 购买明细</li><li>4.commit</li></ul><p>上面第二步中的行级锁：当一个用户在update时其他用户等待</p><p><img src="https://img.braincao.cn/blogimg/1583754287.jpg" alt="1583754287"></p><h4 id="我们需要实现的秒杀功能–3个"><a href="#我们需要实现的秒杀功能–3个" class="headerlink" title="我们需要实现的秒杀功能–3个"></a>我们需要实现的秒杀功能–3个</h4><p>秒杀接口暴露</p><p>执行秒杀</p><p>相关查询</p><h4 id="完成上述功能的代码开发阶段"><a href="#完成上述功能的代码开发阶段" class="headerlink" title="完成上述功能的代码开发阶段"></a>完成上述功能的代码开发阶段</h4><p>DAO设计编码</p><p>Service设计编码</p><p>Web设计编码</p><h2 id="二、开始开发"><a href="#二、开始开发" class="headerlink" title="二、开始开发"></a>二、开始开发</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p>schema.sql:</p><pre><code class="sql">-- 创建数据库CREATE DATABASE seckill;-- 使用数据库USE seckill;-- 创建秒杀库存表CREATE TABLE seckill(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;商品库存id&#39;,`name` varchar(120) NOT NULL COMMENT &#39;商品名称&#39;,`number` int NOT NULL COMMENT &#39;库存数量&#39;,`start_time`timestamp NOT NULL COMMENT &#39;秒杀开启时间&#39;,`end_time` timestamp NOT NULL COMMENT &#39;秒杀结束时间&#39;,`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,PRIMARY KEY(seckill_id),key idx_start_time(start_time),key idx_end_time(end_time),key idx_create_time(create_time))ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT &#39;秒杀库存表&#39;;-- 初始化数据INSERT INTO seckill  (name,number,start_time,end_time) VALUES  (&#39;1000元秒杀iphoneX&#39;, 100, &#39;2018-12-01 00:00:00&#39;, &#39;2018-12-02 00:00:00&#39;),  (&#39;500元秒杀ipadPro&#39;, 200, &#39;2018-12-01 00:00:00&#39;, &#39;2018-12-02 00:00:00&#39;),  (&#39;300元秒杀小米Max&#39;, 300, &#39;2018-12-01 00:00:00&#39;, &#39;2018-12-02 00:00:00&#39;),  (&#39;200元秒杀华为mete20&#39;, 400, &#39;2018-12-01 00:00:00&#39;, &#39;2018-12-02 00:00:00&#39;);-- 秒杀成功明细表:包含用户登录认证相关的信息CREATE TABLE success_killed(`seckill_id` bigint NOT NULL AUTO_INCREMENT COMMENT &#39;秒杀商品id&#39;,`user_phone` bigint NOT NULL COMMENT &#39;用户手机号&#39;,`state` tinyint NOT NULL DEFAULT -1 COMMENT &#39;状态标示：-1无效 0成功 1已付款 2已发货&#39;,`create_time` timestamp NOT NULL COMMENT &#39;创建时间&#39;,PRIMARY KEY(seckill_id,user_phone), /*联合主键*/key idx_create_time(create_time))ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT &#39;秒杀成功明细表&#39;;</code></pre><h3 id="DAO层实体和接口开发"><a href="#DAO层实体和接口开发" class="headerlink" title="DAO层实体和接口开发"></a>DAO层实体和接口开发</h3><p>DAO层开发就是三件事：创建表、接口设计、sql编写。具体流程如下。</p><p>1.Seckill.java开发。首先开发entity包中的实体类：数据表table对应实体entity类，表中的列名对应实体类中的属性</p><p>2.SeckillDao.java开发(这是interface)。编写完实体类后，编码DAO包下的增删改查接口</p><p>3.Mapper.xml开发。对应实体类的dao层接口写完后，下面就是基于mybatis实现dao接口的开发。(mybatis只需要知道参数+sql语句就可以Mapper自动完成数据表与实体的映射)</p><p>4.spring-dao.xml编写。放在resources目录下，<strong>配置整合spring-mybatis</strong>。这个整合又省去了很多原生mybatis中mapper.xml的配置编码，比如类型Seckill不用再写包名而直接写类名、不用写参数类型parameterType和返回类型resultMap等,很多都不用再写了，另外在mybatis-config.xml也不用一个一个配置mapper.xml文件，而是<strong>自动扫描配置文件</strong>。</p><p>整合后做两件事：XML提供sql + DAO接口Mapper –&gt;就可以了</p><p>5.至此DAO部分基本写完了，现在进行DAO层单元测试和问题排查。直接在SeckillDao.java类名上右键go to test即可进行junit4测试，同时也自动在src/test/java包下创建对应目录的test类。</p><p>注:我们需要在test类中配置spring和junit整合(@RunWith等)，这样junit启动时会加载springIOC容器，拿到相应的bean。请左转参考SeckillDaoTest.java示例</p><p>至此，DAO层开发完毕</p><h3 id="Service层的设计和实现"><a href="#Service层的设计和实现" class="headerlink" title="Service层的设计和实现"></a>Service层的设计和实现</h3><p>基于Spring托管Service实现类，并使用了Spring声明式事务，具体流程如下。</p><p>1.service层的业务接口开发。service层的业务接口应站在”使用者”角度设计接口，三个方面考虑：方法定义粒度、参数、返回类型(return 类型/异常)，如下：</p><pre><code class="java">package com.braincao.service;import com.braincao.dto.Exposer;import com.braincao.dto.SeckillExecution;import com.braincao.entity.Seckill;import com.braincao.exception.RepeatKillException;import com.braincao.exception.SeckillCloseException;import com.braincao.exception.SeckillException;import java.util.List;/** * 业务接口：Service层接口应站在使用者角度设计接口 * */public interface SeckillService {    /**     * 查询所有秒杀商品     * @param void     * @return List&lt;Seckill&gt;     */    List&lt;Seckill&gt; getSeckillList();    /**     * 根据id查询一个秒杀商品     * @param seckillId     * @return Seckill     */    Seckill getById(long seckillId);    /**     * 用户根据id查询该秒杀商品的秒杀接口地址(点击即可秒杀)，如果秒杀未开启时输出系统时间和秒杀开启时间     * @param seckillId     * @return  秒杀接口地址。用dto传输层的实体来封装秒杀接口地址,dto方便web层拿到秒杀暴露接口相关数据     */    Exposer exportSeckillUrl(long seckillId);    /**     * 执行秒杀操作     * @param seckillId,userPhone,md5     *        md5用来验证是否是同一用户操作，如果md5变了，说明用户被篡改     * @return dto传输层的实体来封装秒杀操作的返回实体，包含成功、失败     * 当秒杀失败时输出自定义运行期异常RepeatKillException     */     SeckillExecution executeSeckill(long seckillId, long userPhone, String md5)        throws SeckillException, SeckillCloseException, RepeatKillException;}</code></pre><p>2.service层接口的实现开发。</p><p>略，出门左转参考示例。</p><p>3.基于spring管理service依赖。service层接口和实现都开发完后，就要进行spring-IOC注入。创建spring-service.xml + serviceImpl.java(service层的注解+类内部的spring注入依赖)，左转看参考示例</p><p><img src="https://img.braincao.cn/blogimg/1583754335.jpg" alt="1583754335"></p><p>4.spring声明式事务</p><p><img src="https://img.braincao.cn/blogimg/1583754342.jpg" alt="1583754342"></p><p><img src="https://img.braincao.cn/blogimg/1583754348.jpg" alt="1583754348"></p><p>什么时候回滚事务：抛出运行期异常(RunTimeException)时回滚事务</p><p>4.1配置使用spring声明式事务，采用注解方式。见spring-service.xml，在service层实现类的应用就是在需要声明事务的方法上@Transactional即可</p><p>使用注解控制事务方法的优点：</p><ul><li>1.开发团队达成一致的约定，明确标注事务方法的编程风格，不至于开发过程中忘了哪些需要事务控制，这样看到注解就好了知道这是事务方法</li><li>2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部</li><li>3.不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制</li></ul><p>5.还需要resources下配置logback.xml配置下日志管理。至此Service层基本写完了，现在进行service层单元测试和问题排查。</p><p>至此，Service层开发完毕</p><h3 id="Web层的设计和实现"><a href="#Web层的设计和实现" class="headerlink" title="Web层的设计和实现"></a>Web层的设计和实现</h3><p>秒杀业务Web层的设计和实现，使⽤SpringMVC整合spring,实现秒杀restful接⼝。</p><p>主要有：</p><ul><li>1.前端交互设计</li><li>2.Restful接口</li><li>3.SpringMVC</li><li>4.bootstrap + jquery</li></ul><p>1.前端交互设计</p><p>1.1前端页面流程：</p><p><img src="https://img.braincao.cn/blogimg/1583754373.jpg" alt="1583754373"></p><p>1.2 详情页的流程逻辑</p><p><img src="https://img.braincao.cn/blogimg/1583754380.jpg" alt="1583754380"></p><p>2.Restful接口的设计</p><p>什么是Restful?</p><p>兴起于Rails，一种优雅的URL表述方式，规范url的设计，理念就是：资源的状态和状态转移。</p><p>Restful规范：</p><ul><li>GET–&gt;查询操作</li><li>POST–&gt;添加/修改操作</li><li>PUT–&gt;修改操作</li><li>DELETE–&gt;删除操作</li></ul><p>Restful接口示例：<code>/模块/资源/{id标示}/名词1/名词2</code></p><ul><li>1./user/{uid}/friends–&gt;好友列表</li><li>2./user/{uid}/followers–&gt;关注者列表</li></ul><p>本案例的restful设计：<br>​<br><img src="https://img.braincao.cn/blogimg/1583754396.jpg" alt="1583754396"></p><p>3.SpringMVC整合spring。</p><p>springMVC运行流程：</p><p><img src="https://img.braincao.cn/blogimg/1583754415.jpg" alt="1583754415"></p><p>需要配置两个东西，具体请左转：</p><ul><li>1.resources包下的spring-web.xml</li><li>2.web.xml</li></ul><p>4.controller开发.</p><p>实现Restful接口的Controller层：接受请求与参数，跳转页面的控制，并且返回参数都是已经dto传输层封装好的类型</p><p>一个例子SeckillController.java请出门左转</p><p>springMVC开发技巧：DTO封装传递数据，便于controller与前端交互传递数据</p><p>5.采用bootstrap进行jsp主页面开发。</p><p>6.前端页面写完后，用jquery开发交互设计。</p><p>5、6两步请左转：依次看jsp主页面、.js文件</p><p>至此，dao、service、web层所有开发完毕，整个项目跑通，测试完毕，开发完毕。后续要做的就是高并发秒杀优化</p><h3 id="秒杀系统的高并发优化"><a href="#秒杀系统的高并发优化" class="headerlink" title="秒杀系统的高并发优化"></a>秒杀系统的高并发优化</h3><p>上述实现的秒杀系统实际上是扛不住多少并发量的，下面将进行高并发优化分析与实现。主要包括：前端CDN、后端redis缓存、mysql并发优化(减少行级锁持有时间+存储过程)</p><p>1.redis后端缓存优化编码。</p><p>秒杀接口地址可以放到<strong>redis服务器缓存</strong>中，而不用每次都访问数据库，redis可以定期同步更新一次数据库即可。</p><p>对应的redisDao,java:</p><pre><code class="java">package com.braincao.dao.cache;import com.braincao.entity.Seckill;import com.dyuproject.protostuff.LinkedBuffer;import com.dyuproject.protostuff.ProtostuffIOUtil;import com.dyuproject.protostuff.runtime.RuntimeSchema;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;/** * @FileName: RedisDao * @Author: braincao * @Date: 2018/11/30 10:27 * @Description: 高并发优化:读取/存取redis操作。这个dao就不做接口了，直接实现即可 */public class RedisDao {    private Logger logger = LoggerFactory.getLogger(this.getClass());    private final JedisPool jedisPool;    //java存取redis采用RuntimeSchema序列化工具类高效转化    private RuntimeSchema&lt;Seckill&gt; schema = RuntimeSchema.createFrom(Seckill.class);    public RedisDao(String ip, int port){        jedisPool = new JedisPool(ip, port);    }    //读取redis:根据id读取Seckill    public Seckill getSeckill(long seckillId){        //redis操作逻辑        try{            Jedis jedis = jedisPool.getResource();            try {                String key = &quot;seckill:&quot; + seckillId;                //redis并没有实现内部序列化操作                //get-&gt;byte[] -&gt;反序列化 -&gt;Object[Seckill]                //采用自定义序列化工具protostuff进行java存取redis                byte[] bytes = jedis.get(key.getBytes());                if (bytes != null) {                    Seckill seckill = schema.newMessage();                    ProtostuffIOUtil.mergeFrom(bytes, seckill, schema);                    //反序列化seckill                    return seckill;                }            }finally {                jedis.close();            }        }catch (Exception e){            logger.error(e.getMessage(),e);        }        return null;    }    //存取redis:将Seckill存储到redis中    public String putSeckill(Seckill seckill){        //set Onject[Seckill] -&gt; 序列化 -&gt; byte[]        //redis操作逻辑        try{            Jedis jedis = jedisPool.getResource();            try{                String key = &quot;seckill:&quot; + seckill.getSeckillId();                //redis并没有实现内部序列化操作                //get-&gt;byte[] -&gt;反序列化 -&gt;Object[Seckill]                //采用自定义序列化工具protostuff进行java存取redis                byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema,                        LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));                //超时缓存1h                int timeout = 60*60;                //redis存储，result是存储成功或失败的结果                String result = jedis.setex(key.getBytes(),timeout,bytes);                return result;            }finally {                jedis.close();            }        }catch (Exception e){            logger.error(e.getMessage(),e);        }        return null;    }}</code></pre><p>在service层的优化如下：</p><p>原来：<code>Seckill seckill = seckillDao.queryById(id);</code></p><p>优化：</p><pre><code class="java">//将这句话进行优化:1.先访问redisSeckill seckill = redisDao.getSeckill(seckillId);if(seckill == null){    //2.访问数据库    seckill = seckillDao.queryById(id);    if(seckill==null) {        return new Exposer(false, seckillId);    }else{        //3.放入redis        redisDao.putSeckill(seckill);    }}</code></pre><p>2.执行秒杀操作(减库存+记录购买明细)高并发优化。调整sql顺序：记录购买行为在前<br>，减库存在后。因为记录购买行为只是插入，而减库存需要行级锁，这样能减少行级锁持有时间</p><pre><code class="java">//执行秒杀逻辑:减库存 + 记录购买行为，对里面抛出的异常进行try/catch并记录到日志，汇总后向外只抛一个总异常就好Date date = new Date();try{    //优化高并发：记录购买行为在前    int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone);    if(insertCount&lt;=0){//重复秒杀        throw new RepeatKillException(&quot;Repeat seckill&quot;);    }else{        //优化高并发：减库存在后，热点商品竞争。因为减库存需要行级锁，这样能减少行级锁持有时间        int updateCount = seckillDao.reduceNumber(seckillId, date);        if(updateCount&lt;=0){//减库存失败，秒杀结束            throw new SeckillCloseException(&quot;seckill is closed&quot;);        }else{            //秒杀成功            SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId,userPhone);            return new SeckillExecution(seckillId, SeckillStateEnum.SUCCESS, successKilled);        }    }}catch(SeckillCloseException e1){    throw e1;}catch (RepeatKillException e2){    throw e2;}catch (Exception e){    logger.error(e.getMessage(), e);    //所有编译期异常转化为运行期异常，这样spring声明式事务会帮我们做roll back    throw new SeckillException(&quot;seckill inner error: &quot; + e.getMessage());}</code></pre><p>3.事务sql放在Mysql端执行(定义<strong>存储过程</strong>)。上面第2步的update减库存事务操作需要用户在客户端执行秒杀操作，现在将这个事务放在Mysql端执行(定义存储过程)，这样可以完全避免网络延迟和gc(垃圾回收)时间。</p><p><a href="https://www.cnblogs.com/mark-chan/p/5384139.html" target="_blank" rel="noopener">MySQL存储过程</a></p><p>SQL语句需要先编译然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。</p><p>利用存储过程将执行秒杀的一条事务逻辑放到mysql服务端去执行，减少了客户端和服务端之间的延迟和gc时间，客户端只需要传入参数执行存储过程并根据得到的返回结果做相应的逻辑处理。存储过程比较适合于简单的逻辑。</p><p>存储过程的优点：增强SQL语言的功能和灵活性、标准组件式编程、较快的执行速度、减少网络流量、作为一种安全机制来充分利用。</p><p>但存储过程 (只在银行被大量的时候,互联网公司用的很少,但是在秒杀中用)</p><ul><li>1.存储过程优化: 事务行级锁持有的时间（Mysql服务器执行sql十分快）</li><li>2.不要过渡依赖存储过程。</li><li>3.简单的逻辑可以应用存储过程</li><li>4.测试发现QPS:一个秒杀单6000/qps（不同秒杀单，不同行，不存在问题）</li></ul><p>下面就是sql包下的seckill.sql：(定义存储过程:insert+update)</p><pre><code class="sql">-- 执行秒杀的存储过程(插入购买明细+减库存)DELIMITER $$ -- 结束符 ; -&gt;$$-- 定义存储过程-- 参数:in输入参数;out输出参数-- row_count():返回上一条修改类型sql(delete\insert\update)的影响行数-- row_count: 0未修改数据; &gt;0影响修改的行数; &lt;0sql错误/未执行修改sqlCREATE PROCEDURE `seckill`.`execute_seckill`  (IN v_seckill_id BIGINT, IN v_phone BIGINT,   IN v_kill_time  TIMESTAMP, OUT r_result INT)  BEGIN    DECLARE insert_count INT DEFAULT 0;    START TRANSACTION;    INSERT IGNORE INTO success_killed    (seckill_id, user_phone, create_time)    VALUES (v_seckill_id, v_phone, v_kill_time);    SELECT row_count()    INTO insert_count;    IF (insert_count = 0)    THEN      ROLLBACK;      SET r_result = -1;    ELSEIF (insert_count &lt; 0)      THEN        ROLLBACK;        SET r_result = -2;    ELSE      UPDATE seckill      SET number = number - 1      WHERE seckill_id = v_seckill_id            AND end_time &gt; v_kill_time            AND start_time &lt; v_kill_time            AND number &gt; 0;      SELECT row_count()      INTO insert_count;      IF (insert_count = 0)      THEN        ROLLBACK;        SET r_result = 0;      ELSEIF (insert_count &lt; 0)        THEN          ROLLBACK;          SET r_result = -2;      ELSE        COMMIT;        SET r_result = 1;      END IF;    END IF;  END;$$-- 定义存储过程结束DELIMITER ;set @r_result = -3;-- 执行存储过程CALL execute_seckill(1003,15652965942,now(),@r_result);-- 获取结果</code></pre><p>至此，基于SSM框架的dao、service、web、并发优化四章的秒杀系统完结，收获颇多，再次热烈祝贺自己。</p>]]></content>
      
      
      <categories>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2018/03/21/dynamic-programming/"/>
      <url>/2018/03/21/dynamic-programming/</url>
      
        <content type="html"><![CDATA[<p>这个一篇关于动态规划的学习笔记</p><a id="more"></a><h1 id="动态规划核心"><a href="#动态规划核心" class="headerlink" title="动态规划核心"></a>动态规划核心</h1><ul><li>动态规划里非常重要的两个概念：<strong>状态和状态转移方程</strong>。<strong>状态怎么找：根据子问题定义状态</strong>。找到子问题，状态也就浮出水面了</li></ul><h1 id="常见的动态规划算法题"><a href="#常见的动态规划算法题" class="headerlink" title="常见的动态规划算法题"></a>常见的动态规划算法题</h1><ul><li>LIS（最长上升子序列）：DP解法、nlogn解法、排序+LCS解法</li></ul><h1 id="dp问题解决思路"><a href="#dp问题解决思路" class="headerlink" title="dp问题解决思路"></a>dp问题解决思路</h1><ul><li>当阅读一个题目并且开始尝试解决它时，首先看一下它的限制。 如果要求在多项式时间内解决，那么该问题就很可能要用DP来解。遇到这种情况， 最重要的就是找到问题的“状态”和“状态转移方程”。(状态不是随便定义的， 一般定义完状态，你要找到当前状态是如何从前面的状态得到的， 即找到状态转移方程)如果看起来是个DP问题，但你却无法定义出状态， 那么试着将问题规约到一个已知的DP问题</li></ul><h1 id="贪心算法与动态规划区别"><a href="#贪心算法与动态规划区别" class="headerlink" title="贪心算法与动态规划区别"></a>贪心算法与动态规划区别</h1><p>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题</p>]]></content>
      
      
      <categories>
          
          <category> 算法刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法刷题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客系统搭建过程</title>
      <link href="/2018/02/22/build-hexo/"/>
      <url>/2018/02/22/build-hexo/</url>
      
        <content type="html"><![CDATA[<p>搭建Hexo博客的经验贴，便于日后查看，也希望新手少走弯路</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说道技术博客，最开始在csdn上记录技术学习笔记较多，坚持时间较长。后来也迁移副本至博客园，可能先入为主的原因，并没有持续同步更新，不久便把博客园删了。后来入坑jekyll、Hexo等开源博客，后来因为考研的原因也都草草收场。博客系统虽搁置一边但笔记还在不断积累，懒出天际的我直接md文档保存在本地，待嫁的深闺文章越积越多。毕业前的新冠疫情来得突然，趁寒假闲来无事刚好把博客这个烂摊子理一理。</p><p>花了两周左右完成了gitee+hexo的博客系统，可一键发布并备份，随时随地无缝编辑博客。hexo好处多多，不用自己架服务器，同时主题样式可选种类较多，开源且稳定，最开始用的时候用github管理，后来由于各种原因墙内访问越来越慢（你懂），迁移至gitee托管，访问速度提升不少。</p><p>现将搭建过程记录如文，便于日后查看，也希望新手少走弯路。</p><p>这里附上我的博客，欢迎交流：<a href="https://braincao.cn/">https://braincao.cn/</a></p><h1 id="一、先搭建-建立博客系统"><a href="#一、先搭建-建立博客系统" class="headerlink" title="一、先搭建-建立博客系统"></a>一、先搭建-建立博客系统</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>到<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js</a>官网下载node.js并安装</p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>自行百度安装</p><h2 id="本地建立hexo系统"><a href="#本地建立hexo系统" class="headerlink" title="本地建立hexo系统"></a>本地建立hexo系统</h2><p>安装hexo：</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>本地创建自己的blog目录，如HexoBlog，在该目录下进行Hexo初始化：</p><pre><code>hexo init HexoBlogcd ~/HexoBlog/npm install</code></pre><h2 id="远程建立gitee上的hexo系统"><a href="#远程建立gitee上的hexo系统" class="headerlink" title="远程建立gitee上的hexo系统"></a>远程建立gitee上的hexo系统</h2><p>用Gitee Pages建立gitee远程博客仓库。</p><ol><li><p>码云注册并建立名为hexoblog的仓库（使用readme初始化项目）</p></li><li><p>通过 <code>hexoblog项目-&gt;Service-&gt;Gitee Pages服务</code> 建立博客仓库，它会自动生成博客地址，下文会介绍自定义域名绑定博客地址</p></li><li><p>添加ssh key：将本地的id_rsa.pub添加到gitee个人中心的ssh key中。为什么要添加ssh key？ 原因：后续想用git方式通过ssh与远程仓库连接，快捷一些，但为了安全起见，需要公密钥的方式来连接。本地设置gitglobal的user.name user.email，生成一个基于如user.email的ssh key，它是一对私钥和公钥，私钥自己保存别动它，把ssh key中的公钥添加到github官网自己账号中，这样就可以用自己设备很方便的连接至自己的github并享受其服务。如有多台设备，可以每台设备生成一对ssh key，并将多个公钥添加github账号中即可，这样就可以实现多台设备无缝连接，便于移动办公。</p></li><li><p>在_config.yml中配置博客url、远程Git：</p></li></ol><pre><code># 配置错误会出现主题样式展示错误url: https://braincao.cnroot: /# 发布deploy:  type: git  repo: git@gitee.com:username/repo.git  branch: master# 全局搜索search:  path: search.xml  field: post</code></pre><h2 id="发布博客到gitee"><a href="#发布博客到gitee" class="headerlink" title="发布博客到gitee"></a>发布博客到gitee</h2><p>安装Hexo必备插件：</p><pre><code>npm install hexo-deployer-git --save #hexo通过git发布npm install hexo-wordcount --save #文章统计字数npm install hexo-generator-search --save #全局搜索</code></pre><p>输入命令发布博客，首次发布需要在shell中输入账号和密码:</p><pre><code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p>github会发布后会自动更新博客页面，码云将此功能变为人民币玩家功能，因此发布后需要在码云仓库中手动update才能更新博客</p><h2 id="附常用hexo命令"><a href="#附常用hexo命令" class="headerlink" title="附常用hexo命令"></a>附常用hexo命令</h2><pre><code>hexo clean #清除public静态页面缓存（如果有）hexo new page &quot;pageName&quot; #新建页面hexo help  # 查看帮助hexo version  #查看Hexo的版本hexo new &quot;postName&quot; #新建文章简写:hexo n == hexo new #新建文章hexo g == hexo generate #生成静态页面至public目录hexo s == hexo server #本地服务，http://localhost:4000预览hexo d == hexo deploy #部署至github仓库完成博客发布hexo n page &#39;about&#39; #建立导航栏菜单，如about关于页面</code></pre><h1 id="二、后装修-个性化配置"><a href="#二、后装修-个性化配置" class="headerlink" title="二、后装修-个性化配置"></a>二、后装修-个性化配置</h1><p>个性化配置主要包括站点配置与主题配置，跟着<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官方文档</a>、每个主题的官方指导走就行。第三方功能包括但不限于：首页全文阅读、站内搜索、访问人数、字数统计、打赏功能、gitalk评论、404页面、RSS、sitemap</p><p>下面仅以3-hexo为例，罗列下我的个性化配置。</p><h2 id="主题下载"><a href="#主题下载" class="headerlink" title="主题下载"></a>主题下载</h2><p>Hexo系统有很多主题，较为主流的如Next主题，本文采用3-hexo主题。</p><pre><code>git clone https://github.com/yelog/hexo-theme-3-hexo.git themes/3-hexo</code></pre><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>在根目录的站点配置文件配置主题即可</p><pre><code>theme: 3-hexo</code></pre><p>这里注意3-hexo主题有个坑，配置时还需在主题配置文件中更改根目录：</p><pre><code>#如果博客放置位置不是根目录，则可以通过配置此路径解决静态文件路径错误问题#比如访问地址为 yelog.org/blog 那就需要配置为 blog_path: /blog 才能正常访问blog_path: /hexoblog #记得改这里，初始是/</code></pre><h2 id="主题-站点配置文件个性化修改"><a href="#主题-站点配置文件个性化修改" class="headerlink" title="主题/站点配置文件个性化修改"></a>主题/站点配置文件个性化修改</h2><p>先更改能看懂的，如作者、头像、github/邮箱地址、评论、友情链接、打赏二维码、置顶、评论(gitalk)等，看不懂的先别改。</p><p>这里有个点，3-hexo有自己的语法高亮，因此需把hexo站点高亮关了</p><pre><code>highlight:  enable: false  #true改成false</code></pre><h2 id="文章分类-amp-md头部"><a href="#文章分类-amp-md头部" class="headerlink" title="文章分类 &amp; md头部"></a>文章分类 &amp; md头部</h2><p>写md时直接分类即可，另外3-hexo原生支持多级分类（在主题配置文件中有详细介绍），具体的md头部如下：</p><pre><code>---title: 剑指offer刷题date: 2018-09-21 17:32:47updated: 2020-02-19 14:36:48categories:    - 算法刷题tags:    - 剑指offer刷题top: 1originUrl: https://zhuanlan.zhihu.com/p/28987530---</code></pre><p>如果博文中有图片，就在csdn上编辑，得到图片网链，导出md后同步至mac md上，最后再从mac md源进行全网同步</p><p>有的主题首页只显示文章的简介(全文阅读)：在md文章中的合适位置添加 &lt; !–more–&gt; 标签即可，之前的文字都会写在首页文章名称下面的简介里</p><h2 id="关于、相册等导航栏菜单建立"><a href="#关于、相册等导航栏菜单建立" class="headerlink" title="关于、相册等导航栏菜单建立"></a>关于、相册等导航栏菜单建立</h2><p>Hexo里，默认的导航菜单只有Home和Archives两项，还需自行添加其他导航栏菜单</p><pre><code>hexo n page &#39;about&#39;</code></pre><p>这样就建立了source/about文件夹，然后在主题配置文件中：</p><pre><code>menu:  Home: /  About: /about  #注意3-hexo主题这里需要改成hexoblog/about</code></pre><p>在menu中加了一项设置About: /about，前面部分是显示名称，后面部分是访问路径，即source/about中的index.md，就是想要访问About时的页面。同理，还可添加别的菜单，如  <code>Archives: /archives</code>、<code>Photo: /photo</code>等</p><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><p>gitee pages 会自动生成hexo博客地址，可正常访问，如果有自定义域名需要则要进行如下操作。</p><ol><li><p>阿里云购买域名、购买云解析dns服务，再购买免费的DVssl安全证书</p></li><li><p>在云解析dns服务中配置域名解析：添加CNAME，记录值为<code>gitee.gitee.io</code></p></li><li><p>在本地hexo根目录的source文件夹中新建CNAME文件，里面写自定义的域名<code>braincao.cn</code>，然后<code>hexo clean &amp; hexo g &amp; hexo d</code></p></li><li><p>在gitee的page service中添加自定义域名 braincao.cn，再把已买好的ssl证书上传，即可生成<code>https://braincao.cn</code>的博客地址</p></li></ol><p>这样就可以通过自定义域名访问博客地址了，自定义域名的好处可以不透漏gitee项目地址，通过阿里云有负载均衡等付费服务，访问延时更低</p><h2 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h2><p>Hexo博客是静态托管的，所有的原始md博文都保存在本地，本地md文件如果丢失的话就四大皆空了，因此需要每次发布博文的同时在托管仓库进行md文件备份。</p><p>备份的好处有两个。首先，防止本地md丢失，留一份在远程；其次，如果换台电脑，可以从远程仓库将博客系统与原始md文件都clone到本地，这样可以随时随地无缝地写博客。</p><p>具体的备份思路为：</p><ul><li>同一个hexo托管仓库，两个分支master、hexo</li><li>平时本地默认hexo分支，包含原始md博文、hexo系统</li><li>hexo站点配置中将deploy分支设置为master，将静态网页发布至origin/master</li><li>在本地bash中用配置alias：</li></ul><pre><code>function hexogdb() {hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m &quot;post new md&quot; &amp;&amp; git push &amp;&amp; git pull</code></pre><p>如此，当每次本地在hexo分支下写完md文件，直接 <code>hexogdb</code> 即可一键完成渲染、发布、备份。</p><p>其他备份方案：</p><ul><li>使用 <code>hexo-git-backup</code> 插件备份Hexo博客</li><li>自行新建repo专门对本地md文件、hexo博客系统进行备份</li></ul><h2 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>如果本地md丢了、主题配置文件改错或换个台电脑后想要恢复博客，则：</p><ul><li>本地安装git、node.js，安装hexo系统。能在cmd使用hexo即可</li><li>clone远程gitee中的hexo系统的repo，包含master与hexo两个分支</li><li>hexo分支包含主题配置与原始md文件，在该分支上继续写博客即可</li><li>配置git ssh key后正常发布博文即可</li></ul><h2 id="百度seo配置"><a href="#百度seo配置" class="headerlink" title="百度seo配置"></a>百度seo配置</h2><p>想通过在百度等搜索引擎上搜索到自己博客，操作如下：</p><ul><li>安装插件。npm install hexo-generator-sitemap –save</li><li>生成sitemap,xml。配置根目录_config.yml，配置后执行 hexo g，public目录中出现 sitemap.xml 文件则表明配置成功</li></ul><pre><code>#seo配置sitemap:  path: sitemap.xmlbaidusitemap:  path: baidusitemap.xml  </code></pre><ul><li>sitemap提交、js代码自动推送双重方式向百度推送。在 <a href="http://www.sousuoyinqingtijiao.com/baidu/tijiao/" target="_blank" rel="noopener">百度站点管理</a> 中链接提交界面中：上传sitemap、设置自动推送：</li></ul><pre><code>上传sitemap：百度定时抓取自动推送：在HexoBlog/themes/3-hexo/layout/_partial/footer.ejs中添加百度官方js代码，这样渲染md文件后每个页面中都有该js代码，一旦该页面被访问过就会自动推送给百度两种方式结合设置，这样博客不愁搜索不到了</code></pre><p>我个人对baidu、google搜索到博客有太大需求，因此尝试后随即关闭sitemap，目前也搜索不到</p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>至此，已基本完成Hexo博客系统搭建，剩下需要做的就是内容产出了。每次产出md博文后，<code>hexogdb</code> 一键完成发布与备份。</p><p>本人做博客的初衷是沉淀技术知识、记录成长轨迹同时及时分享反馈。同样，每当入门一个全新的领域如能看到同行前辈分享的完整学习贴也会感激万分，这种正向反馈给我坚持技术分享的动力。技术之路无穷尽，希望在这条充满挑战的路上，我们都会收获属于自己的那份成就感。</p>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="/2018/02/22/git-orders/"/>
      <url>/2018/02/22/git-orders/</url>
      
        <content type="html"><![CDATA[<h1 id="git命令总览"><a href="#git命令总览" class="headerlink" title="git命令总览"></a>git命令总览</h1><table><thead><tr><th align="center">序号</th><th align="center">目的操作</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="#1">多人协同github开发</a></td></tr><tr><td align="center">2</td><td align="center"><a href="#2">多人协同远程私人服务器开发</a></td></tr><tr><td align="center">3</td><td align="center"><a href="#3">指定远程仓库origin</a></td></tr><tr><td align="center">4</td><td align="center"><a href="#4">push</a></td></tr><tr><td align="center">5</td><td align="center"><a href="#5">分支操作</a></td></tr><tr><td align="center">6</td><td align="center"><a href="#6">本地与远程分支对应</a></td></tr><tr><td align="center">7</td><td align="center"><a href="#7">分支开发后merge到master</a></td></tr><tr><td align="center">8</td><td align="center"><a href="#8">修改本地以及远程分支名称</a></td></tr><tr><td align="center">9</td><td align="center"><a href="#9">新总结的git命令</a></td></tr></tbody></table><p><a name="1"></a></p><h2 id="1-多人协同github开发"><a href="#1-多人协同github开发" class="headerlink" title="1.多人协同github开发"></a>1.多人协同github开发</h2><p><strong>四步走原则</strong>：本地分支开发，本地主干拉取最新的远程主干+本地主干merge本地分支，本地主干向远程主干发布，切换并同步分支</p><p>具体操作如下：</p><pre><code>0.确保本地分支和远程分支一致(git checkout dev_braincao &amp;&amp; git pull)，开始在本地分支上开发(修改、写作、删除等)1.开发完成，本地切换到主干(git checkout master)，拉取最新的远程主干(git pull)，本地主干merge本地分支(git merge dev_braincao)，并解决冲突(即git add . &amp;&amp; git commit -m &#39;...&#39;)2.此时本地主干可以进行远程发布了，本地主干向远程主干发布(git push)3.最后一步将同步远程分支和本地分支，保证一致(git checkout dev_braincao &amp;&amp; git merge master &amp;&amp; git add . &amp;&amp; git commit(这里不用再写-m了) &amp;&amp; git push)。此时本地在dev_braincao分支上，刚好无缝接入步骤0</code></pre><p><a name="2"></a></p><h2 id="2-多人协同远程私人服务器开发"><a href="#2-多人协同远程私人服务器开发" class="headerlink" title="2.多人协同远程私人服务器开发"></a>2.多人协同远程私人服务器开发</h2><p>1.当本地的项目想git上传到远程仓库，但是远程仓库现在没有的话，需要以下操作：</p><pre><code>0.远程建项目同名文件夹，git init1.远程.git/config配置（这是由于git默认拒绝了push操作，需要进行设置）：[receive]denyCurrentBranch = ignore2.本地push到远程2.远程git reset --hard才能看到push后的内容</code></pre><p>2.然后本地和远程都是master分支，应该本地和远程都建立分支，按上面建分支的操作来就行</p><p>3.本地有分支，远程有分支，每次git push的时候push的分支必须不是远程所在分支(你想啊，这样的话你改了别人正在用怎么办)，所以正常来讲远程一直在master分支上，然后本地dev1分支push，远程merge即可。</p><p><a name="3"></a></p><h2 id="3-指定远程仓库origin"><a href="#3-指定远程仓库origin" class="headerlink" title="3.指定远程仓库origin"></a>3.指定远程仓库origin</h2><p><code>git remote add origin git@github.com:braincao/mmall.git</code> </p><p><a name="4"></a></p><h2 id="4-push"><a href="#4-push" class="headerlink" title="4.push"></a>4.push</h2><p><code>git push -u origin master</code> </p><p>但是push前有可能需要先pull，这里用–rebase操作:</p><p><code>git pull --rebase origin master</code></p><p>解决冲突后再push即可</p><p><a name="5"></a></p><h2 id="5-分支操作"><a href="#5-分支操作" class="headerlink" title="5.分支操作"></a>5.分支操作</h2><p>查看所有分支<code>git branch -a</code> </p><p>删除本地分支<code>git branch -d dev</code></p><p>删除远程分支<code>git push origin --delete dev</code></p><p><a name="6"></a></p><h2 id="6-本地与远程分支对应"><a href="#6-本地与远程分支对应" class="headerlink" title="6.本地与远程分支对应"></a>6.本地与远程分支对应</h2><p>一般情况是分支开发，主干发布，因此建立远程分支，在远程分支上开发push，在远程主干上发布push。</p><p>创建分支加切换分支的合并命令<code>git checkout -b &lt;new_branch&gt; [&lt;start point&gt;]</code></p><p>本地建立并切换到v1.0分支，初始start point基于master分支<code>git checkout -b v1.0 master</code></p><p>之后再把本地建立的分支推送到origin，即远程也建立了v1.0分支并与其对应<code>git push origin HEAD -u</code></p><p>查看分支与远程分支追踪状态<code>git branch -vv</code></p><p>设置远程跟踪。push的时候可以指定本地分支与远程的其他分支发生关系<code>git branch --set-upstream-to=origin/&lt;branch&gt; master</code>设置本地分支master跟踪origin/<branch>远程分支</p><p>删除远程仓库文件，但不删本地资源。有时本地push到远程仓库时，本地不存在但远程仓库存在的文件没法更新，也删不掉，这时需要把远程仓库的指定文件删除，用以下命令(这里删除远程仓库的/target文件夹)：<code>git rm -r --cached /target*</code></p><p><a name="7"></a></p><h2 id="7-分支开发后merge到master"><a href="#7-分支开发后merge到master" class="headerlink" title="7.分支开发后merge到master"></a>7.分支开发后merge到master</h2><p>merge前先<code>git diff branch1 branch2</code>查看两个分支的修改diff，看diff没问题后再merge</p><p>1.切换到<code>git checkout master</code></p><p>2.把本地的分支合并到master<code>git merge branchXXX</code>，这个地方需要解决conflicts，解决完git commit</p><p>3.把本地的master同步到远程<code>git push origin master</code></p><p><a name="8"></a></p><h2 id="8-修改本地以及远程分支名称"><a href="#8-修改本地以及远程分支名称" class="headerlink" title="8.修改本地以及远程分支名称"></a>8.修改本地以及远程分支名称</h2><p>修改分支名称总共分三步：</p><pre><code>git branch -m old_branch new_branch #修改本地分支名git push origin :old_branch #删除远程分支git push --set-upstream origin new_branch #新建远程分支</code></pre><p><a name="9"></a></p><h2 id="9-新总结的git命令"><a href="#9-新总结的git命令" class="headerlink" title="9.新总结的git命令"></a>9.新总结的git命令</h2><pre><code>切记:    dev上push前要经常rebase变基，养成好习惯    方法：git checkout dev &amp;&amp; git rebase master        自己总结的流程：            本地dev开发完成，            先在master上git pull更新            然后在dev上 git rebase master变基            然后dev上push，提交MR放弃修改：    git checkout -- file  回到最近一次git commit或git add时的状态放弃add：    git reset HEAD file放弃commit(版本回退)：    git reset --hard HEAD^/1g0a1merge（禁用fast-forword模式，留下合并历史）：    git merge --no-ff -m &quot;merged bug fix 101&quot; feature_namemerge后有冲突解决即可：git add + git merge --continue 不用再commit || git add + git commit -m &quot;&quot;创建远程分支(本地分支push到远程)并关联起来：    git push --set-upstream(-u) origin [name]删除远程分支：git push origin :[name]修复一个Bug，先保存现场，创建bug分支修复后，回到原dev分支开发:    git stash 保存现场    git stash list 查看现场    git stash pop 恢复的同时把stash内容也删了(git stash apply 恢复现场 + git stash drop 删除现场)    git stash apply stash@{0} 多次stash后指定恢复现场复制指定的一次/多次commit到当前分支，避免全部merge一个分支（有冲突解决即可git cherry-pick --continue）    git cherry-pick 9b47dd dd4e49tag标签：    git tag v1.0 59abc158b 给某个commit打tag，不指定commit号的话是当前最新一次commit    git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb //-a指定标签名，-m 指定说明文字    git show &lt;tagname&gt; 通过标签查commit信息    git push origin v1.0 将指定的几个tag提交到远程    git push origin –-tags 将本地所有标签一次性提交到远程    git tag -d v1.0 删除标签    git push origin :refs/tags/v0.9 删除远程标签    注：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。rebase变基：    基于master开发自己的dev分支时，dev要push，此时master已经更新了    笨的方法时，pull master后再在dev上merge master，再dev push--&gt;笨且提交历史线很多，前后顺序有时也要考虑，diff时也要三方对比    推荐：dev在push前进行rebase将master的基变成最新的，这时在dev push时就已经包含了团队更新后的master，且提交历史干净,两根线变一根线    原理：找到dev与master最新commit的最近公共祖先point，将dev上在point之后的所有commit全部移动到master分支的最新commit之后，即只有一根线了    方法：git checkout dev &amp;&amp; git rebase master    自己总结的流程：        本地dev开发完成，        先在master上git pull更新        然后在dev上 git rebase master变基        然后dev上push，提交MRgit fetch：    这将更新git remote 中所有的远程仓库所包含分支的最新commit-id, 将其记录到.git/FETCH_HEAD文件中git pull：    比对本地与远程的FETCH_HEAD记录fetch后并mergegit pull = git fetch + git mergegit pull --rebase = git fetch + git rebase详见（https://www.cnblogs.com/kevingrace/p/5896706.html）其他操作命令：    git config --global user.name &quot;John Doe&quot;    git config --global user.email johndoe@example.com    git remote add origin git@gitee.com:liaoxuefeng/learngit.git    git remote -v 看远程详细信息，可用于查看是否有fetch/push权限，也可用于指定同时开发多个远程库    git branch --set-upstream branch-name origin/branch-name  关联的操作push远程时要先pull    git checkout commitId/v0.21 此时会指向指定版本/tag时的代码状态（但现在处于一个空的分支上），用于查看指定版本状态关于github：    参加开源项目时先Fork到自己仓库，clone代码到本地开发后push到自己远程，之后推送pull request给官方仓库来贡献代码</code></pre>]]></content>
      
      
      <categories>
          
          <category> 综合技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研二java基础知识点</title>
      <link href="/2017/12/08/java-learning-road/"/>
      <url>/2017/12/08/java-learning-road/</url>
      
        <content type="html"><![CDATA[<p>10天恶补java的学习笔记</p><a id="more"></a><h2 id="java学习路线"><a href="#java学习路线" class="headerlink" title="java学习路线"></a>java学习路线</h2><ul><li><a href="http://bbs.itheima.com/thread-200600-1-1.html" target="_blank" rel="noopener">阳哥笔记】Java基础之笔记系列（全）</a></li></ul><p>用法：一共27章笔记，每章都很少，按顺序看完即可。有问题想深入的可以百度+b站视频，以下是看的过程中我另外加餐深入了解的：</p><ul><li><p><a href="https://www.cnblogs.com/xiaoxi/p/6036701.html" target="_blank" rel="noopener">博客_String相关</a></p></li><li><p><a href="https://www.bilibili.com/video/av29576265/?p=1" target="_blank" rel="noopener">b站_多线程</a></p></li><li><p><a href="https://www.bilibili.com/video/av28590247/?p=1" target="_blank" rel="noopener">b站_集合</a></p></li><li><p><a href="https://www.bilibili.com/video/av29576016/?p=1" target="_blank" rel="noopener">b站_IO</a></p></li></ul><p>JAVA 工程师技术路线参考：</p><ul><li>基础：Java 教程，JSP 教程</li><li>进阶：SQL 教程，MySQL 教程</li><li>高级：正则表达式教程，Mongodb教程， AJAX 教程，JSON 教程，XML 教程，</li><li>开发工具：Eclipse、IDEA</li></ul><p>总结：以阳哥笔记为主线往下看，附加string相关+三章的b站视频即可。(截止写完这篇博客时，阳哥笔记还剩网络编程、反射两章，估计还要配合b站视频看)</p><p>疯狂看的话，一周半应该能看完(符合学习一门语言10天的节奏，时间太长收益不大)。把阳哥看完，java基础应该差不多了</p><h2 id="java语法"><a href="#java语法" class="headerlink" title="java语法"></a>java语法</h2><p>java菜鸟教程过一遍</p><p><a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">java教程</a></p><h2 id="int与String转换"><a href="#int与String转换" class="headerlink" title="int与String转换"></a>int与String转换</h2><pre><code class="java">int a = 20;System.out.println(new Integer(a).toString()); //int to StringString ss = &quot;25&quot;;System.out.println(Integer.parseInt(ss)); //String to int</code></pre><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态方法中只能访问静态成员变量，静态方法中也只能调用静态方法</p><p>问：是否可以从一个static方法内部发出对非static方法的调用? 不可以<br>不可以。因为非static方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，故不可以</p><p>举例：</p><pre><code class="java">public class xix {    // 静态成员     public static String string=&quot;static成员&quot;;    // 普通成员    public String string2=&quot;非static成员&quot;;    // 静态方法    public static void method(){        string=&quot;sss&quot;;        //string2=&quot;sss&quot;;编译报错,因为静态方法里面只能调用静态方法或静态成员        //method2();        System.out.println(&quot;这是static方法,static方法与对象无关&quot;);    }    // 普通方法     public void method2(){        string =&quot;string1&quot;;        string2=&quot;string2&quot;;        method(); //非静态方法里面可以发出对static方法的调用        System.out.println(&quot;这是非static方法,此方法必须和指定的对象关联起来才起作用&quot;);    }    public static void main(String[] args) {        xix x=new xix();        x.method2();// 引用调用普通方法         x.method();// 引用调用静态方法    }}</code></pre><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final 修饰类中的属性或者变量</p><p>无论属性是基本类型还是引用类型，final 所起的作用都是变量里面存放的”值”不能变。</p><p>这个值，对于基本类型来说，变量里面放的就是实实在在的值，如 1，”abc” 等。</p><p>而引用类型变量里面放的是个地址，所以用 final 修饰引用类型变量指的是它里面的地址不能变，并不是说这个地址所指向的对象或数组的内容不可以变，这个一定要注意。</p><p>例如：类中有一个属性是 final Person p=new Person(“name”); 那么你不能对 p 进行重新赋值，但是可以改变 p 里面属性的值 p.setName(‘newName’);</p><p>final 修饰属性，声明变量时可以不赋值，而且一旦赋值就不能被修改了。对 final 属性可以在三个地方赋值：声明时、初始化块中、构造方法中，总之一定要赋值。</p><p>2、final修饰类中的方法</p><p>作用：可以被继承，但继承后不能被重写。</p><p>3、final修饰类</p><p>作用：类不可以被继承。</p><p>final 变量：</p><p>final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。</p><p>也就是说 final 对象的引用不能改变，但是里面的值可以改变。<br>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p><p>final 方法</p><p>类中的 final 方法可以被子类继承，但是不能被子类修改。<br>声明 final 方法的主要目的是防止该方法的内容被修改。</p><pre><code class="java">public class Test{    public final void changeName(){       // 方法体    }}final 类final 类不能被继承，没有类能够继承 final 类的任何特性。public final class Test {   // 类体}</code></pre><h2 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h2><p>抽象类：</p><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。<br>抽象类可以包含抽象方法和非抽象方法。</p><pre><code class="java">abstract class Caravan{   private double price;   private String model;   private String year;   public abstract void goFast(); //抽象方法   public abstract void changeColor();}</code></pre><p>抽象方法</p><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。<br>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p><p>抽象方法的声明以分号结尾，例如：<code>public abstract void sample();</code></p><pre><code class="java">public abstract class SuperClass{    abstract void m(); //抽象方法}class SubClass extends SuperClass{     //实现抽象方法      void m(){          .........      }}</code></pre><p>抽象类除了不能实例化对象之外，抽象类必须被继承，才能被使用</p><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用static修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><h2 id="synchronized-修饰符"><a href="#synchronized-修饰符" class="headerlink" title="synchronized 修饰符"></a>synchronized 修饰符</h2><p>synchronized 关键字声明的方法同一时间只能被一个线程访问。<br>synchronized 修饰符可以应用于四个访问修饰符。</p><pre><code class="java">public synchronized void showDetails(){.......}</code></pre><h2 id="transient-修饰符"><a href="#transient-修饰符" class="headerlink" title="transient 修饰符"></a>transient 修饰符</h2><p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p><pre><code class="java">public transient int limit = 55;   // 不会持久化public int b; // 持久化</code></pre><h2 id="volatile-修饰符"><a href="#volatile-修饰符" class="headerlink" title="volatile 修饰符"></a>volatile 修饰符</h2><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p><p>一个 volatile 对象引用可能是 null。</p><pre><code class="java">public class MyRunnable implements Runnable{    private volatile boolean active;    public void run()    {        active = true;        while (active) // 第一行        {            // 代码        }    }    public void stop()    {        active = false; // 第二行    }}</code></pre><p>通常情况下，在一个线程调用 run() 方法（在 Runnable 开启的线程），在另一个线程调用 stop() 方法。 如果 第一行 中缓冲区的 active 值被使用，那么在 第二行 的 active 值为 false 时循环不会停止。</p><p>但是以上代码中我们使用了 volatile 修饰 active，所以该循环会停止。</p><h2 id="子类与父类"><a href="#子类与父类" class="headerlink" title="子类与父类"></a>子类与父类</h2><p>子类是父类的类型，但父类不是子类的类型。</p><p>子类的实例可以声明为父类型，但父类的实例不能声明为子类型。</p><p><code>class Vehicle {}</code></p><pre><code class="java">public class Car extends Vehicle {    public static void main(String args[]){        Vehicle v1 = new Vehicle(); //父类型        Vehicle v2 = new Car(); //子类的实例可以声明为父类型        Car c1 = new Car();    // 子类型        Car c2 = new Vehicle(); //这句会报错，父类型的实例不能声明为子类型        //Car（子类）是Vehicle（父类）类型, Vehicle（父类）不是Car（子类）类型        boolean result1 =  c1 instanceof Vehicle;    // true        boolean result2 =  c1 instanceof Car;        // true        boolean result3 =  v1 instanceof Vehicle;    // true        boolean result4 =  v1 instanceof Car;          // false        boolean result5 =  v2 instanceof Vehicle;    // true        boolean result6 =  v2 instanceof Car;          // true        System.out.println(result1);        System.out.println(result2);        System.out.println(result3);        System.out.println(result4);        System.out.println(result5);        System.out.println(result6);   }}</code></pre><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</p><pre><code>output:bchaha</code></pre><h2 id="在控制台输入由-号组成的菱形"><a href="#在控制台输入由-号组成的菱形" class="headerlink" title="在控制台输入由*号组成的菱形"></a>在控制台输入由*号组成的菱形</h2><pre><code class="java">public class Test{    public static void main(String[] args)    {        int num = 11;  //打印一个一行最多num个*的菱形        int k = num; //通过数学计算，我们可知菱形的行数总数也为num        for(int i=0; i&lt;(k+1)/2; ++i)    //升序排序打印输出        {            int mid = (k-1)/2; //mid是每行的居中点下标            for(int j=0; j&lt;k; ++j)            {                int temp = j-mid;                if(java.lang.Math.abs(temp) &lt;= i)                {                    System.out.print(&quot;*&quot;);                }                else                {                    System.out.print(&quot; &quot;);                }            }            System.out.println();        }        for(int i=(k-1)/2-1; i&gt;=0; i--)    //降序排序打印输出        {            int mid = (k-1)/2; //mid是每行的居中点下标            for(int j=0; j&lt;k; ++j)            {                int temp = j-mid;                if(java.lang.Math.abs(temp) &lt;= i)                {                    System.out.print(&quot;*&quot;);                }                else                {                    System.out.print(&quot; &quot;);                }            }            System.out.println();        }    }}</code></pre><h2 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h2><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>注意：String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。</p><p>如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。</p><h2 id="StringBuffer-和-StringBuilder-类"><a href="#StringBuffer-和-StringBuilder-类" class="headerlink" title="StringBuffer 和 StringBuilder 类"></a>StringBuffer 和 StringBuilder 类</h2><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><p>Java 中 StringBuffer 和 String 是有一定的区别的，首先，String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的</p><p>concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象，而 StringBuffer 的长度是可变的，</p><p>调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！</p><p>String 长度大小不可变<br>StringBuffer 和 StringBuilder 长度可变<br>StringBuffer 线程安全 StringBuilder 线程不安全<br>StringBuilder 速度快</p><h2 id="length与size"><a href="#length与size" class="headerlink" title="length与size"></a>length与size</h2><p>length()方法，length属性和size()的方法的区别:</p><p>1.length()方法是针对字符串来说的，要求一个字符串的长度就要用到它的length()方法；</p><p>2.length属性是针对Java中的数组来说的，要求数组的长度可以用其length属性；</p><p>3.java中的size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</p><h2 id="数组与Arrays类"><a href="#数组与Arrays类" class="headerlink" title="数组与Arrays类"></a>数组与Arrays类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p><p>具有以下功能：</p><ul><li>给数组赋值：通过 fill 方法。</li><li>对数组排序：通过 sort 方法,按升序。</li><li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><p>String str = “helloworld”;</p><p>char[] data = str.toCharArray();// 将字符串转为数组</p><h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><ol><li>对整数进行格式化：%[index$][标识][最小宽度]转换方式<pre><code>     格式化字符串由4部分组成，特殊的格式常以%index$开头，index从1开始取值，表示将第index个参数拿进来进行格式化，[最小宽度]的含义也很好理解，就是最终该整数转化的字符串最少包含多少位数字。剩下2个部分的含义：</code></pre></li></ol><p>标识：</p><pre><code> &#39;-&#39; 在最小宽度内左对齐，不可以与&quot;用0填充&quot;同时使用 &#39;#&#39; 只适用于8进制和16进制，8进制时在结果前面增加一个0，16进制时在结果前面增加0x &#39;+&#39; 结果总是包括一个符号(一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制) &#39; &#39; 正值前加空格，负值前加负号(一般情况下只适用于10进制，若对象为BigInteger才可以用于8进制和16进制) &#39;0&#39; 结果将用零来填充 &#39;,&#39; 只适用于10进制，每3位数字之间用&quot;，&quot;分隔 &#39;(&#39; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(同&#39;+&#39;具有同样的限制)转换方式：d-十进制 o-八进制 x或X-十六进制上面的说明过于枯燥，我们来看几个具体的例子。需要特别注意的一点是：大部分标识字符可以同时使用。</code></pre><ol start="2"><li>对浮点数进行格式化：%[index$][标识][最少宽度][.精度]转换方式<br>我们可以看到，浮点数的转换多了一个”精度”选项，可以控制小数点后面的位数。<br>标识：</li></ol><pre><code>&#39;-&#39; 在最小宽度内左对齐，不可以与&quot;用0填充&quot;同时使用&#39;+&#39; 结果总是包括一个符号&#39; &#39; 正值前加空格，负值前加负号&#39;0&#39; 结果将用零来填充&#39;,&#39; 每3位数字之间用&quot;，&quot;分隔(只适用于fgG的转换)&#39;(&#39; 若参数是负数，则结果中不添加负号而是用圆括号把数字括起来(只适用于eEfgG的转换)转换方式：&#39;e&#39;, &#39;E&#39; -- 结果被格式化为用计算机科学记数法表示的十进制数&#39;f&#39; -- 结果被格式化为十进制普通表示方式&#39;g&#39;, &#39;G&#39; -- 根据具体情况，自动选择用普通表示方式还是科学计数法方式&#39;a&#39;, &#39;A&#39; -- 结果被格式化为带有效位数和指数的十六进制浮点数</code></pre><p>3.对字符进行格式化：</p><p>对字符进行格式化是非常简单的，c表示字符，标识中’-‘表示左对齐，其他就没什么了。</p><p>这个格式化没有太掌握，用的时候还需要进一步学习</p><h2 id="sleep休眠、测量时间"><a href="#sleep休眠、测量时间" class="headerlink" title="sleep休眠、测量时间"></a>sleep休眠、测量时间</h2><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p><p>你可以让程序休眠一毫秒的时间或者到您的计算机的寿命长的任意段时间。</p><p>例如，下面的程序会休眠3秒：</p><pre><code class="java">Thread.sleep(1000*3);   // 休眠3秒output:3001</code></pre><h2 id="Calendar类与Date类"><a href="#Calendar类与Date类" class="headerlink" title="Calendar类与Date类"></a>Calendar类与Date类</h2><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。</p><p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p><p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p><p>1.Calendar c = Calendar.getInstance();//默认是当前日期</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>java.util.regex包</p><p>java.util.regex 包主要包括以下三个类：</p><p>Pattern 类：pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p><p>Matcher 类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p><p>PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p><p>1.匹配一组</p><pre><code class="java">String content = &quot;I am noob &quot; + &quot;from runoob.com.&quot;;String pattern = &quot;.*runoob.*&quot;;boolean isMatch = Pattern.matches(pattern, content);System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch); //true</code></pre><ol start="2"><li>匹配多组</li></ol><pre><code class="java">// 按指定模式在字符串查找String line = &quot;This order was placed for QT3000! OK?&quot;;String pattern = &quot;(\\D*)(\\d+)(.*)&quot;;// 创建 Pattern 对象Pattern r = Pattern.compile(pattern);// 现在创建 matcher 对象Matcher m = r.matcher(line);if (m.find( )) { System.out.println(&quot;Found value: &quot; + m.group(0) ); System.out.println(&quot;Found value: &quot; + m.group(1) ); System.out.println(&quot;Found value: &quot; + m.group(2) ); System.out.println(&quot;Found value: &quot; + m.group(3) ); } else { System.out.println(&quot;NO MATCH&quot;);}</code></pre><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。<br>在方法声明中，在指定参数类型后加一个省略号(…) 。</p><p>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</p><h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h2><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p><p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。<br>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p><p>finalize() 一般格式是：</p><pre><code class="java">protected void finalize(){   // 在这里终结代码}</code></pre><p>关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。</p><p>当然，Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p><h2 id="java异常处理"><a href="#java异常处理" class="headerlink" title="java异常处理"></a>java异常处理</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p>从大体来分异常为两块：</p><p>1、error—错误 ： 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。</p><p>2、Exception — 异常 ：异常可分为运行时异常跟编译异常</p><ul><li>运行时异常：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。</li><li>编译异常：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。</li></ul><p>3、java处理异常的机制：抛出异常以及捕获异常 ，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</p><p>4、throw跟throws的区别:</p><pre><code class="java">public void test() throws Exception {    throw new Exception();}</code></pre><p>从上面这一段代码可以明显的看出两者的区别。throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个已定义的异常（可以是自定义需继承Exception，也可以是java自己给出的异常类）。</p><p>5、接下来看一下如何捕获异常：</p><p>1）首先java对于异常捕获使用的是try—catch或try — catch — finally 代码块，程序会捕获try代码块里面的代码，若捕获到异常则进行catch代码块处理。若有finally则在catch处理后执行finally里面的代码。然而存在这样两个问题：</p><p>a.看如下代码：</p><pre><code class="java">try{    //待捕获代码}catch（Exception e）{    System.out.println(&quot;catch is begin&quot;);    return 1 ；}finally{     System.out.println(&quot;finally is begin&quot;);}</code></pre><p>在catch里面有一个return，那么finally会不会被执行呢？答案是肯定的，上面代码的执行结果为：</p><pre><code>catch is beginfinally is begin </code></pre><p>也就是说会先执行catch里面的代码后执行finally里面的代码最后才return1 ；</p><p>b.看如下代码：</p><pre><code class="java">try{   //待捕获代码    }catch（Exception e）{    System.out.println(&quot;catch is begin&quot;);    return 1 ；}finally{     System.out.println(&quot;finally is begin&quot;);     return 2 ;}</code></pre><p>在b代码中输出结果跟a是一样的，然而返回的是return 2 ； 原因很明显，就是执行了finally后已经return了，所以catch里面的return不会被执行到。也就是说finally永远都会在catch的return前被执行。（这个是面试经常问到的问题哦！）</p><p>6、对于异常的捕获不应该觉得方便而将几个异常合成一个Exception进行捕获，比如有IO的异常跟SQL的异常，这样完全不同的两个异常应该分开处理！而且在catch里处理异常的时候不要简单的e.printStackTrace()，而是应该进行详细的处理。比如进行console打印详情或者进行日志记录。</p><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</p><h2 id="java继承"><a href="#java继承" class="headerlink" title="java继承"></a>java继承</h2><p>注意：super 语句必须是子类构造方法的第一条语句。不能在子类中使用父类构造方法名来调用父类构造方法。 父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用 super 关键字，如果子类中没显式调用，则编译器自动将 super(); 作为子类构造方法的第一条语句。这会形成一个构造方法链。</p><p>静态方法中不能使用 super 关键字。</p><ol><li>这个例子很重要，第三个输出注意看</li></ol><pre><code class="java">class SuperClass {  private int n;  SuperClass(){    System.out.println(&quot;SuperClass()&quot;);  }  SuperClass(int n) {    System.out.println(&quot;SuperClass(int n)&quot;);    this.n = n;  }}class SubClass extends SuperClass{  private int n;  SubClass(){    super(300);    System.out.println(&quot;SubClass&quot;);  }    public SubClass(int n){    System.out.println(&quot;SubClass(int n):&quot;+n);    this.n = n;  }}public class TestSuperSub{  public static void main (String args[]){    SubClass sc = new SubClass();    SubClass sc2 = new SubClass(200);   }}output:SuperClass(int n)SubClassSuperClass() //一定注意这一点，在子类构造方法之前，首先是调用父类的构造方法SubClass(int n):200</code></pre><p>2.又一个例子很重要</p><pre><code class="java">class Animal{   public void move(){      System.out.println(&quot;动物可以移动&quot;);   }}class Dog extends Animal{   public void move(){      System.out.println(&quot;狗可以跑和走&quot;);   }   public void bark(){      System.out.println(&quot;狗可以吠叫&quot;);   }}public class TestDog{   public static void main(String args[]){      Animal a = new Animal(); // Animal 对象      Animal b = new Dog(); // Dog 对象  //———如果改成Dog b = new Dog();就对了      a.move();// 执行 Animal 类的方法      b.move();//执行 Dog 类的方法      b.bark();   }}output:TestDog.java:30: cannot find symbolsymbol  : method bark()location: class Animal                b.bark();</code></pre><p>这是由于在编译阶段，只是检查参数的引用类型。如果编译通过，在运行时，Java虚拟机(JVM)指定对象的类型并且运行该对象的方法。</p><p>因此在上面的例子中，之所以能编译失败，是因为Animal类中不存在move方法，改成Dog b = new Dog();就对了</p><h2 id="java多态深入理解"><a href="#java多态深入理解" class="headerlink" title="java多态深入理解"></a>java多态深入理解</h2><p>强烈建议直接看菜鸟教程的多态和多态前一节(重载、重写)</p><p>多态存在的三个必要条件</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象</li></ul><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p><p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><p>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p><p>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p><p>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p><p>重载与重写的简明理解:</p><ul><li><p>重载反映的是”随机应变”. 同样一项功能, 根据数据类型的不同, 采用不同的处理方式. </p></li><li><p>重写反映的是”父子差异”. 你”继承”了父亲吃火锅的爱好, 但是吃同一份鸳鸯锅(注意, 数据类型相同) , 你喜欢涮红汤, 你父亲喜欢涮清汤.</p></li></ul><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p><h2 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h2><p>类的多继承是不合法，一个类只能继承一个类，可以实现多个接口，但接口允许多继承.</p><p>1.接口可以多继承</p><p>2.接口的方法声明必须是 public abstract 即便不写默认也是</p><p>3.接口里面不能包含方法具体实现</p><p>4.类实继承接口必须实现接口里申明的全部方法，除非该类是抽象类</p><p>5.类里面可以声明 public static final 修饰的变量</p><p>6.接口不能被实例化，但是可以被实现类创建</p><p>接口里面定义的成员变量都是  public static final修饰，抽象类中的变量是普通变量</p><p>抽象类和接口的区别:</p><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>什么时候使用抽象类和接口:</p><ul><li><p>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</p></li><li><p>如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</p></li><li><p>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</p></li></ul><h2 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h2><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><p>总结：Thread和Runnable的区别</p><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p><p>实现Runnable接口比继承Thread类所具有的优势：</p><p>1）适合多个相同的程序代码的线程去处理同一个资源</p><p>2）可以避免java中的单继承的限制</p><p>3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</p><p>4）线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。</p><p>Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：</p><pre><code class="java">static int MAX_PRIORITY          线程可以具有的最高优先级，取值为10。static int MIN_PRIORITY          线程可以具有的最低优先级，取值为1。static int NORM_PRIORITY          分配给线程的默认优先级，取值为5。</code></pre><p>Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。</p><p>每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。</p><p>线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。</p><p>JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。</p><p>2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p><p>3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。</p><p>4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。</p><p>5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p><p>6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。</p><p>注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p><h2 id="wait-相关详解"><a href="#wait-相关详解" class="headerlink" title="wait()相关详解"></a>wait()相关详解</h2><p>Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。</p><p>线程示例1（这个可以作为模板，请记住套路）</p><pre><code class="java">/** * 功能描述: 三个售票窗口同时出售20张票 * 程序分析：1.票数要使用同一个静态值            2.为保证不会出现卖出同一个票数，要java多线程同步锁。 *设计思路：            1.创建一个站台类Station，继承Thread，重写run方法，在run方法里面执行售票操作！                 售票要使用同步锁：即有一个站台卖这张票时，其他站台要等这张票卖完！            2.创建主方法调用类 @Author:braincao @Date: 2018/1/3 10:43 */public class Test{    public static void main(String[] args)    {        Station a = new Station(&quot;A&quot;);        Station b = new Station(&quot;B&quot;);        Station c = new Station(&quot;C&quot;);        a.start();        b.start();        c.start();    }}class Station extends Thread{    private String name;    private static int tickets = 20; //为了保持票数的一致，票数要静态    public Station(String name)    {        super(name);    }    static Object key = &quot;key&quot;; //创建一个静态钥匙    public void run()    {        while(tickets&gt;0)        {            synchronized(key) //这个很重要，必须使用一个锁，进去的人会把钥匙拿在手上，出来后才把钥匙让出来            {                if(tickets&gt;0)                {                    tickets--;                    System.out.println(getName() + &quot;窗口卖票一张 余票：&quot; + tickets);                }                else                {                    System.out.println(&quot;窗口无法买票，票买完了&quot;);                }            }            try            {                sleep(1000); //休息一秒，这里休息是必要的，否则很容易只让一个线程一直卖票，休息了给其他线程让出机会            }            catch(InterruptedException e)            {                e.printStackTrace();            }        }    }}</code></pre><p>线程示例2：建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决</p><pre><code class="java">/** * 功能描述:建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C， * 要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决 * @Author:braincao * @Date: 2018/1/3 14:44 */package com.multithread.wait;public class Test implements Runnable {    private String name;    private Object prev; //前一个对象锁    private Object self; //自身对象锁    private Test(String name, Object prev, Object self) {        this.name = name;        this.prev = prev;        this.self = self;    }    @Override    public void run() {        int count = 10;        while (count &gt; 0) {            synchronized (prev) {                synchronized (self) {                    System.out.print(name);                    count--;                    self.notify(); //释放自身对象锁                }                try {                    prev.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) throws Exception {        Object a = new Object();        Object b = new Object();        Object c = new Object();        Test pa = new Test(&quot;A&quot;, c, a);        Test pb = new Test(&quot;B&quot;, a, b);        Test pc = new Test(&quot;C&quot;, b, c);        new Thread(pa).start();        Thread.sleep(1000);  //确保按顺序A、B、C执行        new Thread(pb).start();        Thread.sleep(1000);        new Thread(pc).start();        Thread.sleep(1000);    }}    输出结果：ABCABCABCABCABCABCABCABCABCABC</code></pre><p>先来解释一下其整体思路，从大的方向上来讲，该问题为三线程间的同步唤醒操作，主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用self.notify()释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。</p><h2 id="socket网络通信"><a href="#socket网络通信" class="headerlink" title="socket网络通信"></a>socket网络通信</h2><p>三次握手</p><p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接</p><p>而下图是java socket网络通信的过程。定睛一看，服务器socket与客户端socket建立连接的部分其实就是大名鼎鼎的三次握手。</p><p>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入SYN_SEND状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p><h2 id="刷面经时别人总结的java知识点"><a href="#刷面经时别人总结的java知识点" class="headerlink" title="刷面经时别人总结的java知识点"></a>刷面经时别人总结的java知识点</h2><p>1.抽象方法只能定义在抽象类中，抽象方法和抽象类必须由abstract修饰，abstract关键字只能描述类和方法，不能描述变量。抽象方法只定义方法声明，不定义方法实现。抽象类不可以被实例化（创建对象），只有通过子类继承抽象类并覆盖抽象类中的所有抽象方法后，该子类才可以被实例化，否则该子类还是一个抽象类。抽象类中有构造函数用于给子类对象进行初始化，同时抽象类中可以含有非抽象方法。abstract关键字不可以与final，private,static关键字共存，因为被final修饰的方法不可以被重写，意味着子类不可以重写该方法，如果abstract和final共同修饰父类中的方法，子类要实现抽象方法（abstract的作用），而final又不让该方法重写，这相互矛盾。如果private和abstract共同修饰父类中的方法，private修饰则该方法不可以被子类访问，但是abstract修饰需要子类去实现，两者产生矛盾。如果static和abstract共同修饰父类中的方法，static表示是静态的方法，随着类的加载而加载，则该方法不需要在子类中去实现，这与abstract关键字矛盾。 </p><p>2.static用于修饰成员变量和成员函数，想要实现对象中的共性数据的对象共享，可以将这个数据进行静态修饰，被静态修饰的成员可以直接被类名调用，静态随着类的加载而加载，而且优先于对象存在。静态方法只能访问静态成员（静态方法和静态变量），不可以访问非静态成员，这是因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。静态方法中不能使用this和super关键字，因为this代表本类对象，super代表父类对象，而静态时，有可能没有对象存在，所以this和super无法使用。 </p><p>3.final关键字可以修饰类，方法，变量（成员变量内，局部变量，静态变量），被final修饰的类是一个最终类，不可以被继承，被final修饰的方法是一个最终方法，不可以被覆盖，但是可以被继承。被final修饰的变量只能是一个常量，只能赋值一次。内部类被定义在类中的局部位置上时，只能访问局部被final修饰的局部变量。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
